"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_pnpm_onnxruntime-web_1_21_0-dev_20250206-d981b153d3_node_modu-7672db"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm ***!
  \**********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort-wasm-simd-threaded.jsep.7aa09142.wasm";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?5923":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \***************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort.webgpu.bundle.min.e2f00bf6.mjs";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?bd86":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* binding */ Fp),\n/* harmony export */   TRACE: () => (/* binding */ _r),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* binding */ Ne),\n/* harmony export */   TRACE_FUNC_END: () => (/* binding */ Be),\n/* harmony export */   Tensor: () => (/* binding */ Fe),\n/* harmony export */   \"default\": () => (/* binding */ $1),\n/* harmony export */   env: () => (/* binding */ _e),\n/* harmony export */   registerBackend: () => (/* binding */ Tt)\n/* harmony export */ });\n/*!\n * ONNX Runtime Web v1.21.0-dev.20250206-d981b153d3\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar Rn=Object.defineProperty;var Vp=Object.getOwnPropertyDescriptor;var Wp=Object.getOwnPropertyNames;var Lp=Object.prototype.hasOwnProperty;var Un=(e=>typeof require<\"u\"?require:typeof Proxy<\"u\"?new Proxy(e,{get:(t,r)=>(typeof require<\"u\"?require:t)[r]}):e)(function(e){if(typeof require<\"u\")return require.apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var U=(e,t)=>()=>(e&&(t=e(e=0)),t);var Ht=(e,t)=>{for(var r in t)Rn(e,r,{get:t[r],enumerable:!0})},Gp=(e,t,r,n)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let o of Wp(t))!Lp.call(e,o)&&o!==r&&Rn(e,o,{get:()=>t[o],enumerable:!(n=Vp(t,o))||n.enumerable});return e};var gr=e=>Gp(Rn({},\"__esModule\",{value:!0}),e);var br,St,Tt,Hp,Xi,Nn=U(()=>{\"use strict\";br=new Map,St=[],Tt=(e,t,r)=>{if(t&&typeof t.init==\"function\"&&typeof t.createInferenceSessionHandler==\"function\"){let n=br.get(e);if(n===void 0)br.set(e,{backend:t,priority:r});else{if(n.priority>r)return;if(n.priority===r&&n.backend!==t)throw new Error(`cannot register backend \"${e}\" using priority ${r}`)}if(r>=0){let o=St.indexOf(e);o!==-1&&St.splice(o,1);for(let i=0;i<St.length;i++)if(br.get(St[i]).priority<=r){St.splice(i,0,e);return}St.push(e)}return}throw new TypeError(\"not a valid backend\")},Hp=async e=>{let t=br.get(e);if(!t)return\"backend not found.\";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(n){return r||(t.error=`${n}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Xi=async e=>{let t=e.executionProviders||[],r=t.map(l=>typeof l==\"string\"?l:l.name),n=r.length===0?St:r,o,i=[],a=new Set;for(let l of n){let p=await Hp(l);typeof p==\"string\"?i.push({name:l,err:p}):(o||(o=p),o===p&&a.add(l))}if(!o)throw new Error(`no available backend found. ERR: ${i.map(l=>`[${l.name}] ${l.err}`).join(\", \")}`);for(let{name:l,err:p}of i)r.includes(l)&&console.warn(`removing requested execution provider \"${l}\" from session options because it is not available: ${p}`);let d=t.filter(l=>a.has(typeof l==\"string\"?l:l.name));return[o,new Proxy(e,{get:(l,p)=>p===\"executionProviders\"?d:Reflect.get(l,p)})]}});var Ji=U(()=>{\"use strict\";Nn()});var ea,ta=U(()=>{\"use strict\";ea=\"1.21.0-dev.20250206-d981b153d3\"});var ra,Ue,Vn=U(()=>{\"use strict\";ta();ra=\"warning\",Ue={wasm:{},webgl:{},webgpu:{},versions:{common:ea},set logLevel(e){if(e!==void 0){if(typeof e!=\"string\"||[\"verbose\",\"info\",\"warning\",\"error\",\"fatal\"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);ra=e}},get logLevel(){return ra}};Object.defineProperty(Ue,\"logLevel\",{enumerable:!0})});var _e,na=U(()=>{\"use strict\";Vn();_e=Ue});var oa,ia,aa=U(()=>{\"use strict\";oa=(e,t)=>{let r=typeof document<\"u\"?document.createElement(\"canvas\"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let n=r.getContext(\"2d\");if(n!=null){let o,i;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],i=e.dims[3]):(o=e.dims[3],i=e.dims[2]);let a=t?.format!==void 0?t.format:\"RGB\",d=t?.norm,l,p;d===void 0||d.mean===void 0?l=[255,255,255,255]:typeof d.mean==\"number\"?l=[d.mean,d.mean,d.mean,d.mean]:(l=[d.mean[0],d.mean[1],d.mean[2],0],d.mean[3]!==void 0&&(l[3]=d.mean[3])),d===void 0||d.bias===void 0?p=[0,0,0,0]:typeof d.bias==\"number\"?p=[d.bias,d.bias,d.bias,d.bias]:(p=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(p[3]=d.bias[3]));let m=i*o,u=0,h=m,_=m*2,y=-1;a===\"RGBA\"?(u=0,h=m,_=m*2,y=m*3):a===\"RGB\"?(u=0,h=m,_=m*2):a===\"RBG\"&&(u=0,_=m,h=m*2);for(let g=0;g<i;g++)for(let x=0;x<o;x++){let $=(e.data[u++]-p[0])*l[0],v=(e.data[h++]-p[1])*l[1],S=(e.data[_++]-p[2])*l[2],T=y===-1?255:(e.data[y++]-p[3])*l[3];n.fillStyle=\"rgba(\"+$+\",\"+v+\",\"+S+\",\"+T+\")\",n.fillRect(x,g,1,1)}if(\"toDataURL\"in r)return r.toDataURL();throw new Error(\"toDataURL is not supported\")}else throw new Error(\"Can not access image data\")},ia=(e,t)=>{let r=typeof document<\"u\"?document.createElement(\"canvas\").getContext(\"2d\"):new OffscreenCanvas(1,1).getContext(\"2d\"),n;if(r!=null){let o,i,a;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],i=e.dims[1],a=e.dims[3]):(o=e.dims[3],i=e.dims[2],a=e.dims[1]);let d=t!==void 0&&t.format!==void 0?t.format:\"RGB\",l=t?.norm,p,m;l===void 0||l.mean===void 0?p=[255,255,255,255]:typeof l.mean==\"number\"?p=[l.mean,l.mean,l.mean,l.mean]:(p=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(p[3]=l.mean[3])),l===void 0||l.bias===void 0?m=[0,0,0,0]:typeof l.bias==\"number\"?m=[l.bias,l.bias,l.bias,l.bias]:(m=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(m[3]=l.bias[3]));let u=i*o;if(t!==void 0&&(t.format!==void 0&&a===4&&t.format!==\"RGBA\"||a===3&&t.format!==\"RGB\"&&t.format!==\"BGR\"))throw new Error(\"Tensor format doesn't match input tensor dims\");let h=4,_=0,y=1,g=2,x=3,$=0,v=u,S=u*2,T=-1;d===\"RGBA\"?($=0,v=u,S=u*2,T=u*3):d===\"RGB\"?($=0,v=u,S=u*2):d===\"RBG\"&&($=0,S=u,v=u*2),n=r.createImageData(o,i);for(let A=0;A<i*o;_+=h,y+=h,g+=h,x+=h,A++)n.data[_]=(e.data[$++]-m[0])*p[0],n.data[y]=(e.data[v++]-m[1])*p[1],n.data[g]=(e.data[S++]-m[2])*p[2],n.data[x]=T===-1?255:(e.data[T++]-m[3])*p[3]}else throw new Error(\"Can not access image data\");return n}});var Wn,sa,ua,da,la,ca,pa=U(()=>{\"use strict\";yr();Wn=(e,t)=>{if(e===void 0)throw new Error(\"Image buffer must be defined\");if(t.height===void 0||t.width===void 0)throw new Error(\"Image height and width must be defined\");if(t.tensorLayout===\"NHWC\")throw new Error(\"NHWC Tensor layout is not supported yet\");let{height:r,width:n}=t,o=t.norm??{mean:255,bias:0},i,a;typeof o.mean==\"number\"?i=[o.mean,o.mean,o.mean,o.mean]:i=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias==\"number\"?a=[o.bias,o.bias,o.bias,o.bias]:a=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let d=t.format!==void 0?t.format:\"RGBA\",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:\"RGB\",p=r*n,m=l===\"RGBA\"?new Float32Array(p*4):new Float32Array(p*3),u=4,h=0,_=1,y=2,g=3,x=0,$=p,v=p*2,S=-1;d===\"RGB\"&&(u=3,h=0,_=1,y=2,g=-1),l===\"RGBA\"?S=p*3:l===\"RBG\"?(x=0,v=p,$=p*2):l===\"BGR\"&&(v=0,$=p,x=p*2);for(let A=0;A<p;A++,h+=u,y+=u,_+=u,g+=u)m[x++]=(e[h]+a[0])/i[0],m[$++]=(e[_]+a[1])/i[1],m[v++]=(e[y]+a[2])/i[2],S!==-1&&g!==-1&&(m[S++]=(e[g]+a[3])/i[3]);return l===\"RGBA\"?new ze(\"float32\",m,[1,4,r,n]):new ze(\"float32\",m,[1,3,r,n])},sa=async(e,t)=>{let r=typeof HTMLImageElement<\"u\"&&e instanceof HTMLImageElement,n=typeof ImageData<\"u\"&&e instanceof ImageData,o=typeof ImageBitmap<\"u\"&&e instanceof ImageBitmap,i=typeof e==\"string\",a,d=t??{},l=()=>{if(typeof document<\"u\")return document.createElement(\"canvas\");if(typeof OffscreenCanvas<\"u\")return new OffscreenCanvas(1,1);throw new Error(\"Canvas is not supported\")},p=m=>typeof HTMLCanvasElement<\"u\"&&m instanceof HTMLCanvasElement||m instanceof OffscreenCanvas?m.getContext(\"2d\"):null;if(r){let m=l();m.width=e.width,m.height=e.height;let u=p(m);if(u!=null){let h=e.height,_=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(h=t.resizedHeight,_=t.resizedWidth),t!==void 0){if(d=t,t.tensorFormat!==void 0)throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");d.tensorFormat=\"RGBA\",d.height=h,d.width=_}else d.tensorFormat=\"RGBA\",d.height=h,d.width=_;u.drawImage(e,0,0),a=u.getImageData(0,0,_,h).data}else throw new Error(\"Can not access image data\")}else if(n){let m,u;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(m=t.resizedHeight,u=t.resizedWidth):(m=e.height,u=e.width),t!==void 0&&(d=t),d.format=\"RGBA\",d.height=m,d.width=u,t!==void 0){let h=l();h.width=u,h.height=m;let _=p(h);if(_!=null)_.putImageData(e,0,0),a=_.getImageData(0,0,u,m).data;else throw new Error(\"Can not access image data\")}else a=e.data}else if(o){if(t===void 0)throw new Error(\"Please provide image config with format for Imagebitmap\");let m=l();m.width=e.width,m.height=e.height;let u=p(m);if(u!=null){let h=e.height,_=e.width;return u.drawImage(e,0,0,_,h),a=u.getImageData(0,0,_,h).data,d.height=h,d.width=_,Wn(a,d)}else throw new Error(\"Can not access image data\")}else{if(i)return new Promise((m,u)=>{let h=l(),_=p(h);if(!e||!_)return u();let y=new Image;y.crossOrigin=\"Anonymous\",y.src=e,y.onload=()=>{h.width=y.width,h.height=y.height,_.drawImage(y,0,0,h.width,h.height);let g=_.getImageData(0,0,h.width,h.height);d.height=h.height,d.width=h.width,m(Wn(g.data,d))}});throw new Error(\"Input data provided is not supported - aborted tensor creation\")}if(a!==void 0)return Wn(a,d);throw new Error(\"Input data provided is not supported - aborted tensor creation\")},ua=(e,t)=>{let{width:r,height:n,download:o,dispose:i}=t,a=[1,n,r,4];return new ze({location:\"texture\",type:\"float32\",texture:e,dims:a,download:o,dispose:i})},da=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:i}=t;return new ze({location:\"gpu-buffer\",type:r??\"float32\",gpuBuffer:e,dims:n,download:o,dispose:i})},la=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:i}=t;return new ze({location:\"ml-tensor\",type:r??\"float32\",mlTensor:e,dims:n,download:o,dispose:i})},ca=(e,t,r)=>new ze({location:\"cpu-pinned\",type:e,data:t,dims:r??[t.length]})});var It,Ft,ma,fa,ha=U(()=>{\"use strict\";It=new Map([[\"float32\",Float32Array],[\"uint8\",Uint8Array],[\"int8\",Int8Array],[\"uint16\",Uint16Array],[\"int16\",Int16Array],[\"int32\",Int32Array],[\"bool\",Uint8Array],[\"float64\",Float64Array],[\"uint32\",Uint32Array],[\"int4\",Uint8Array],[\"uint4\",Uint8Array]]),Ft=new Map([[Float32Array,\"float32\"],[Uint8Array,\"uint8\"],[Int8Array,\"int8\"],[Uint16Array,\"uint16\"],[Int16Array,\"int16\"],[Int32Array,\"int32\"],[Float64Array,\"float64\"],[Uint32Array,\"uint32\"]]),ma=!1,fa=()=>{if(!ma){ma=!0;let e=typeof BigInt64Array<\"u\"&&BigInt64Array.from,t=typeof BigUint64Array<\"u\"&&BigUint64Array.from,r=typeof Float16Array<\"u\"&&Float16Array.from;e&&(It.set(\"int64\",BigInt64Array),Ft.set(BigInt64Array,\"int64\")),t&&(It.set(\"uint64\",BigUint64Array),Ft.set(BigUint64Array,\"uint64\")),r?(It.set(\"float16\",Float16Array),Ft.set(Float16Array,\"float16\")):It.set(\"float16\",Uint16Array)}}});var ga,ba,ya=U(()=>{\"use strict\";yr();ga=e=>{let t=1;for(let r=0;r<e.length;r++){let n=e[r];if(typeof n!=\"number\"||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},ba=(e,t)=>{switch(e.location){case\"cpu\":return new ze(e.type,e.data,t);case\"cpu-pinned\":return new ze({location:\"cpu-pinned\",data:e.data,type:e.type,dims:t});case\"texture\":return new ze({location:\"texture\",texture:e.texture,type:e.type,dims:t});case\"gpu-buffer\":return new ze({location:\"gpu-buffer\",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case\"ml-tensor\":return new ze({location:\"ml-tensor\",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var ze,yr=U(()=>{\"use strict\";aa();pa();ha();ya();ze=class{constructor(t,r,n){fa();let o,i;if(typeof t==\"object\"&&\"location\"in t)switch(this.dataLocation=t.location,o=t.type,i=t.dims,t.location){case\"cpu-pinned\":{let d=It.get(o);if(!d)throw new TypeError(`unsupported type \"${o}\" to create tensor from pinned buffer`);if(!(t.data instanceof d))throw new TypeError(`buffer should be of type ${d.name}`);this.cpuData=t.data;break}case\"texture\":{if(o!==\"float32\")throw new TypeError(`unsupported type \"${o}\" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case\"gpu-buffer\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case\"ml-tensor\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint64\"&&o!==\"int8\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let d,l;if(typeof t==\"string\")if(o=t,l=n,t===\"string\"){if(!Array.isArray(r))throw new TypeError(\"A string tensor's data must be a string array.\");d=r}else{let p=It.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t===\"float16\"&&p===Uint16Array||t===\"uint4\"||t===\"int4\")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${p.name} as data.`);t===\"uint64\"||t===\"int64\"?d=p.from(r,BigInt):d=p.from(r)}else if(r instanceof p)d=r;else if(r instanceof Uint8ClampedArray)if(t===\"uint8\")d=Uint8Array.from(r);else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");else throw new TypeError(`A ${o} tensor's data must be type of ${p}`)}else if(l=r,Array.isArray(t)){if(t.length===0)throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");let p=typeof t[0];if(p===\"string\")o=\"string\",d=t;else if(p===\"boolean\")o=\"bool\",d=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else if(t instanceof Uint8ClampedArray)o=\"uint8\",d=Uint8Array.from(t);else{let p=Ft.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=p,d=t}if(l===void 0)l=[d.length];else if(!Array.isArray(l))throw new TypeError(\"A tensor's dims must be a number array\");i=l,this.cpuData=d,this.dataLocation=\"cpu\"}let a=ga(i);if(this.cpuData&&a!==this.cpuData.length&&!((o===\"uint4\"||o===\"int4\")&&Math.ceil(a/2)===this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=i,this.size=a}static async fromImage(t,r){return sa(t,r)}static fromTexture(t,r){return ua(t,r)}static fromGpuBuffer(t,r){return da(t,r)}static fromMLTensor(t,r){return la(t,r)}static fromPinnedBuffer(t,r,n){return ca(t,r,n)}toDataURL(t){return oa(this,t)}toImageData(t){return ia(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error(\"The data is not stored as a WebGL texture.\");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error(\"The data is not stored as a WebGPU buffer.\");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error(\"The data is not stored as a WebNN MLTensor.\");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case\"cpu\":case\"cpu-pinned\":return this.data;case\"texture\":case\"gpu-buffer\":case\"ml-tensor\":{if(!this.downloader)throw new Error(\"The current tensor is not created with a specified data downloader.\");if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation=\"cpu\",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation=\"none\"}ensureValid(){if(this.dataLocation===\"none\")throw new Error(\"The tensor is disposed.\")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");return ba(this,t)}}});var Fe,Ln=U(()=>{\"use strict\";yr();Fe=ze});var _r,_a,Ne,Be,Gn=U(()=>{\"use strict\";Vn();_r=(e,t)=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||console.timeStamp(`${e}::ORT::${t}`)},_a=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],n=!1;for(let o=0;o<r.length;o++){if(n&&!r[o].includes(\"TRACE_FUNC\")){let i=`FUNC_${e}::${r[o].trim().split(\" \")[1]}`;t&&(i+=`::${t}`),_r(\"CPU\",i);return}r[o].includes(\"TRACE_FUNC\")&&(n=!0)}},Ne=e=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||_a(\"BEGIN\",e)},Be=e=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||_a(\"END\",e)}});var wr,wa=U(()=>{\"use strict\";Nn();Ln();Gn();wr=class e{constructor(t){this.handler=t}async run(t,r,n){Ne();let o={},i={};if(typeof t!=\"object\"||t===null||t instanceof Fe||Array.isArray(t))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let a=!0;if(typeof r==\"object\"){if(r===null)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(r instanceof Fe)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(r)){if(r.length===0)throw new TypeError(\"'fetches' cannot be an empty array.\");a=!1;for(let p of r){if(typeof p!=\"string\")throw new TypeError(\"'fetches' must be a string array or an object.\");if(this.outputNames.indexOf(p)===-1)throw new RangeError(`'fetches' contains invalid output name: ${p}.`);o[p]=null}if(typeof n==\"object\"&&n!==null)i=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else{let p=!1,m=Object.getOwnPropertyNames(r);for(let u of this.outputNames)if(m.indexOf(u)!==-1){let h=r[u];(h===null||h instanceof Fe)&&(p=!0,a=!1,o[u]=h)}if(p){if(typeof n==\"object\"&&n!==null)i=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else i=r}}else if(typeof r<\"u\")throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(let p of this.inputNames)if(typeof t[p]>\"u\")throw new Error(`input '${p}' is missing in 'feeds'.`);if(a)for(let p of this.outputNames)o[p]=null;let d=await this.handler.run(t,o,i),l={};for(let p in d)if(Object.hasOwnProperty.call(d,p)){let m=d[p];m instanceof Fe?l[p]=m:l[p]=new Fe(m.type,m.data,m.dims)}return Be(),l}async release(){return this.handler.dispose()}static async create(t,r,n,o){Ne();let i,a={};if(typeof t==\"string\"){if(i=t,typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof Uint8Array){if(i=t,typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<\"u\"&&t instanceof SharedArrayBuffer){let m=t,u=0,h=t.byteLength;if(typeof r==\"object\"&&r!==null)a=r;else if(typeof r==\"number\"){if(u=r,!Number.isSafeInteger(u))throw new RangeError(\"'byteOffset' must be an integer.\");if(u<0||u>=m.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${m.byteLength}).`);if(h=t.byteLength-u,typeof n==\"number\"){if(h=n,!Number.isSafeInteger(h))throw new RangeError(\"'byteLength' must be an integer.\");if(h<=0||u+h>m.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${m.byteLength-u}].`);if(typeof o==\"object\"&&o!==null)a=o;else if(typeof o<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(typeof n<\"u\")throw new TypeError(\"'byteLength' must be a number.\")}else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\");i=new Uint8Array(m,u,h)}else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");let[d,l]=await Xi(a),p=await d.createInferenceSessionHandler(i,l);return Be(),new e(p)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Fp,va=U(()=>{\"use strict\";wa();Fp=wr});var $a=U(()=>{\"use strict\"});var xa=U(()=>{\"use strict\"});var Sa=U(()=>{\"use strict\"});var Ta=U(()=>{\"use strict\"});var Hn={};Ht(Hn,{InferenceSession:()=>Fp,TRACE:()=>_r,TRACE_FUNC_BEGIN:()=>Ne,TRACE_FUNC_END:()=>Be,Tensor:()=>Fe,env:()=>_e,registerBackend:()=>Tt});var Le=U(()=>{\"use strict\";Ji();na();va();Ln();$a();xa();Gn();Sa();Ta()});var vr=U(()=>{\"use strict\"});var ka={};Ht(ka,{default:()=>qp});var Ca,Aa,qp,Ea=U(()=>{\"use strict\";Fn();gt();$r();Ca=\"ort-wasm-proxy-worker\",Aa=globalThis.self?.name===Ca;Aa&&(self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case\"init-wasm\":xr(r.wasm).then(()=>{Sr(r).then(()=>{postMessage({type:t})},n=>{postMessage({type:t,err:n})})},n=>{postMessage({type:t,err:n})});break;case\"init-ep\":{let{epName:n,env:o}=r;Tr(o,n).then(()=>{postMessage({type:t})},i=>{postMessage({type:t,err:i})});break}case\"copy-from\":{let{buffer:n}=r,o=qt(n);postMessage({type:t,out:o});break}case\"create\":{let{model:n,options:o}=r;Ir(n,o).then(i=>{postMessage({type:t,out:i})},i=>{postMessage({type:t,err:i})});break}case\"release\":Cr(r),postMessage({type:t});break;case\"run\":{let{sessionId:n,inputIndices:o,inputs:i,outputIndices:a,options:d}=r;Ar(n,o,i,a,new Array(a.length).fill(null),d).then(l=>{l.some(p=>p[3]!==\"cpu\")?postMessage({type:t,err:\"Proxy does not support non-cpu tensor location.\"}):postMessage({type:t,out:l},Er([...i,...l]))},l=>{postMessage({type:t,err:l})});break}case\"end-profiling\":kr(r),postMessage({type:t});break;default:}}catch(n){postMessage({type:t,err:n})}});qp=Aa?null:e=>new Worker(e??Ve,{type:\"module\",name:Ca})});var za={};Ht(za,{default:()=>Kp});var qn,Pa,Kp,Oa=U(()=>{\"use strict\";Pa=(qn=\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\",async function(e={}){function t(){return K.buffer!=Q.buffer&&pe(),Q}function r(){return K.buffer!=Q.buffer&&pe(),ie}function n(){return K.buffer!=Q.buffer&&pe(),te}function o(){return K.buffer!=Q.buffer&&pe(),be}function i(){return K.buffer!=Q.buffer&&pe(),Oe}function a(){return K.buffer!=Q.buffer&&pe(),ve}function d(){return K.buffer!=Q.buffer&&pe(),de}function l(){return K.buffer!=Q.buffer&&pe(),he}var p,m,u=Object.assign({},e),h=new Promise((s,c)=>{p=s,m=c}),_=typeof window==\"object\",y=typeof importScripts==\"function\",g=y&&self.name==\"em-pthread\";u.mountExternalData=(s,c)=>{s.startsWith(\"./\")&&(s=s.substring(2)),(u.Fb||(u.Fb=new Map)).set(s,c)},u.unmountExternalData=()=>{delete u.Fb};var x=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let $=()=>{let s=(f,b,w)=>(...I)=>{let O=Xe,B=b?.();I=f(...I);let G=b?.();return B!==G&&(f=G,w(B),b=w=null),Xe!=O?new Promise((F,X)=>{kn={resolve:F,reject:X}}):I},c=f=>async(...b)=>{try{if(u.Gb)throw Error(\"Session already started\");let w=u.Gb={hc:b[0],errors:[]},I=await f(...b);if(u.Gb!==w)throw Error(\"Session mismatch\");u.Hb?.flush();let O=w.errors;if(0<O.length){let B=await Promise.all(O);if(B=B.filter(G=>G),0<B.length)throw Error(B.join(`\n`))}return I}finally{u.Gb=null}};u._OrtCreateSession=s(u._OrtCreateSession,()=>u._OrtCreateSession,f=>u._OrtCreateSession=f),u._OrtRun=c(s(u._OrtRun,()=>u._OrtRun,f=>u._OrtRun=f)),u._OrtRunWithBinding=c(s(u._OrtRunWithBinding,()=>u._OrtRunWithBinding,f=>u._OrtRunWithBinding=f)),u._OrtBindInput=s(u._OrtBindInput,()=>u._OrtBindInput,f=>u._OrtBindInput=f),$=void 0};u.jsepInit=(s,c)=>{if($?.(),s===\"webgpu\"){[u.Hb,u.Vb,u.Zb,u.Ob,u.Yb,u.kb,u.$b,u.cc,u.Wb,u.Xb,u.ac]=c;let f=u.Hb;u.jsepRegisterBuffer=(b,w,I,O)=>f.registerBuffer(b,w,I,O),u.jsepGetBuffer=b=>f.getBuffer(b),u.jsepCreateDownloader=(b,w,I)=>f.createDownloader(b,w,I),u.jsepOnCreateSession=b=>{f.onCreateSession(b)},u.jsepOnReleaseSession=b=>{f.onReleaseSession(b)},u.jsepOnRunStart=b=>f.onRunStart(b),u.dc=(b,w)=>{f.upload(b,w)}}else if(s===\"webnn\"){[u.Hb,u.bc,u.Pb,u.jsepEnsureTensor,u.ec,u.jsepDownloadTensor]=c,u.jsepReleaseTensorId=u.Pb;let f=u.Hb;u.jsepOnRunStart=b=>f.onRunStart(b),u.jsepRegisterMLContext=(b,w)=>{f.registerMLContext(b,w)},u.jsepOnReleaseSession=b=>{f.onReleaseSession(b)},u.jsepCreateMLTensorDownloader=(b,w)=>f.createMLTensorDownloader(b,w),u.jsepRegisterMLTensor=(b,w,I)=>f.registerMLTensor(b,w,I),u.jsepCreateMLContext=b=>f.createMLContext(b),u.jsepRegisterMLConstant=(b,w,I,O,B)=>f.registerMLConstant(b,w,I,O,B,u.Fb)}};var v,S,T=Object.assign({},u),A=(s,c)=>{throw c},C=\"\";(_||y)&&(y?C=self.location.href:typeof document<\"u\"&&document.currentScript&&(C=document.currentScript.src),qn&&(C=qn),C=C.startsWith(\"blob:\")?\"\":C.substr(0,C.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1),y&&(S=s=>{var c=new XMLHttpRequest;return c.open(\"GET\",s,!1),c.responseType=\"arraybuffer\",c.send(null),new Uint8Array(c.response)}),v=(s,c,f)=>{var b=new XMLHttpRequest;b.open(\"GET\",s,!0),b.responseType=\"arraybuffer\",b.onload=()=>{b.status==200||b.status==0&&b.response?c(b.response):f()},b.onerror=f,b.send(null)});var P,D=console.log.bind(console),R=console.error.bind(console),H=D,L=R;if(Object.assign(u,T),T=null,g){let s=function(c){try{var f=c.data,b=f.cmd;if(b===\"load\"){let w=[];self.onmessage=I=>w.push(I),self.startWorker=()=>{postMessage({cmd:\"loaded\"});for(let I of w)s(I);self.onmessage=s};for(let I of f.handlers)u[I]&&!u[I].proxy||(u[I]=(...O)=>{postMessage({Nb:\"callHandler\",pc:I,args:O})},I==\"print\"&&(H=u[I]),I==\"printErr\"&&(L=u[I]));K=f.wasmMemory,pe(),re(f.wasmModule)}else if(b===\"run\"){On(f.pthread_ptr,0,0,1,0,0),Cn(f.pthread_ptr),xc(),Go(),V||(Vi(),V=!0);try{Sc(f.start_routine,f.arg)}catch(w){if(w!=\"unwind\")throw w}}else b===\"cancel\"?Rt()&&fr(-1):f.target!==\"setimmediate\"&&(b===\"checkMailbox\"?V&&or():b&&(L(`worker: received unknown command ${b}`),L(f)))}catch(w){throw Wi(),w}};var wg=s,re,V=!1;L=function(...c){c=c.join(\" \"),console.error(c)},self.alert=function(...c){postMessage({Nb:\"alert\",text:c.join(\" \"),rc:Rt()})},u.instantiateWasm=(c,f)=>new Promise(b=>{re=w=>{w=new WebAssembly.Instance(w,Uo()),f(w),b()}}),self.onunhandledrejection=c=>{throw c.reason||c},self.onmessage=s}u.wasmBinary&&(P=u.wasmBinary);var K,we,j,Q,ie,te,be,Oe,ve,de,W,Y,he,De=!1;function pe(){var s=K.buffer;u.HEAP8=Q=new Int8Array(s),u.HEAP16=te=new Int16Array(s),u.HEAPU8=ie=new Uint8Array(s),u.HEAPU16=be=new Uint16Array(s),u.HEAP32=Oe=new Int32Array(s),u.HEAPU32=ve=new Uint32Array(s),u.HEAPF32=de=new Float32Array(s),u.HEAPF64=he=new Float64Array(s),u.HEAP64=W=new BigInt64Array(s),u.HEAPU64=Y=new BigUint64Array(s)}if(!g){if(!((K=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof x))throw L(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),Error(\"bad memory\");pe()}var Ie=[],He=[],mn=[],wt=0,fn=null,Gt=null;function Oo(){if(--wt==0&&(fn!==null&&(clearInterval(fn),fn=null),Gt)){var s=Gt;Gt=null,s()}}function ct(s){throw L(s=\"Aborted(\"+s+\")\"),De=!0,j=1,s=new WebAssembly.RuntimeError(s+\". Build with -sASSERTIONS for more info.\"),m(s),s}var hn,Do=s=>s.startsWith(\"data:application/octet-stream;base64,\"),Bo=s=>s.startsWith(\"file://\");function Mo(s){if(s==hn&&P)return new Uint8Array(P);if(S)return S(s);throw\"both async and sync fetching of the wasm failed\"}function Ro(s,c,f){return function(b){if(!P&&(_||y)){if(typeof fetch==\"function\"&&!Bo(b))return fetch(b,{credentials:\"same-origin\"}).then(w=>{if(!w.ok)throw`failed to load wasm binary file at '${b}'`;return w.arrayBuffer()}).catch(()=>Mo(b));if(v)return new Promise((w,I)=>{v(b,O=>w(new Uint8Array(O)),I)})}return Promise.resolve().then(()=>Mo(b))}(s).then(b=>WebAssembly.instantiate(b,c)).then(f,b=>{L(`failed to asynchronously prepare wasm: ${b}`),ct(b)})}function Uo(){return{a:{O:$c,Aa:vc,b:Ic,aa:Ko,B:Zo,qa:Qo,Y:Jo,_:ei,ra:ti,oa:ri,ha:ni,na:oi,L:ii,Z:ai,W:si,pa:ui,X:di,va:Cc,F:kc,Q:Ec,P:zc,E:Dc,u:Bc,q:Mc,G:Rc,A:Hc,R:Fc,ua:qc,ka:Kc,U:jc,ba:Yc,H:Zc,ja:Cn,ta:Qc,t:Xc,Ba:Jc,x:rp,o:np,m:ip,c:Tn,n:ap,k:dp,w:lp,p:cp,f:pp,s:mp,l:fp,e:hp,j:gp,i:bp,g:yp,d:_p,ea:wp,fa:vp,ga:$p,ca:xi,da:Si,T:xp,h:Sp,D:Tp,I:Ip,M:Cp,y:Ap,sa:kp,V:Ep,v:Ii,z:Pp,N:zp,S:Op,za:Dp,ya:Bp,la:ki,ma:Ei,$:wn,C:Pi,K:zi,ia:Oi,J:Di,a:K,xa:_n,wa:Ri,r:Up}}}var gn={916868:(s,c,f,b,w)=>{if(u===void 0||!u.Fb)return 1;if((s=Ce(Number(s>>>0))).startsWith(\"./\")&&(s=s.substring(2)),!(s=u.Fb.get(s)))return 2;if(c=Number(c>>>0),f=Number(f>>>0),b=Number(b>>>0),c+f>s.byteLength)return 3;try{let I=s.subarray(c,c+f);switch(w){case 0:r().set(I,b>>>0);break;case 1:u.dc(b,I);break;default:return 4}return 0}catch{return 4}},917583:(s,c,f)=>{u.ec(s,r().subarray(c>>>0,c+f>>>0))},917646:()=>u.bc(),917687:s=>{u.Pb(s)},917723:()=>{u.Wb()},917754:()=>{u.Xb()},917783:()=>{u.ac()},917808:s=>u.Vb(s),917841:s=>u.Zb(s),917873:(s,c,f)=>{u.Ob(Number(s),Number(c),Number(f),!0)},917936:(s,c,f)=>{u.Ob(Number(s),Number(c),Number(f))},917993:()=>typeof wasmOffsetConverter<\"u\",918050:s=>{u.kb(\"Abs\",s,void 0)},918101:s=>{u.kb(\"Neg\",s,void 0)},918152:s=>{u.kb(\"Floor\",s,void 0)},918205:s=>{u.kb(\"Ceil\",s,void 0)},918257:s=>{u.kb(\"Reciprocal\",s,void 0)},918315:s=>{u.kb(\"Sqrt\",s,void 0)},918367:s=>{u.kb(\"Exp\",s,void 0)},918418:s=>{u.kb(\"Erf\",s,void 0)},918469:s=>{u.kb(\"Sigmoid\",s,void 0)},918524:(s,c,f)=>{u.kb(\"HardSigmoid\",s,{alpha:c,beta:f})},918603:s=>{u.kb(\"Log\",s,void 0)},918654:s=>{u.kb(\"Sin\",s,void 0)},918705:s=>{u.kb(\"Cos\",s,void 0)},918756:s=>{u.kb(\"Tan\",s,void 0)},918807:s=>{u.kb(\"Asin\",s,void 0)},918859:s=>{u.kb(\"Acos\",s,void 0)},918911:s=>{u.kb(\"Atan\",s,void 0)},918963:s=>{u.kb(\"Sinh\",s,void 0)},919015:s=>{u.kb(\"Cosh\",s,void 0)},919067:s=>{u.kb(\"Asinh\",s,void 0)},919120:s=>{u.kb(\"Acosh\",s,void 0)},919173:s=>{u.kb(\"Atanh\",s,void 0)},919226:s=>{u.kb(\"Tanh\",s,void 0)},919278:s=>{u.kb(\"Not\",s,void 0)},919329:(s,c,f)=>{u.kb(\"Clip\",s,{min:c,max:f})},919398:s=>{u.kb(\"Clip\",s,void 0)},919450:(s,c)=>{u.kb(\"Elu\",s,{alpha:c})},919508:s=>{u.kb(\"Gelu\",s,void 0)},919560:s=>{u.kb(\"Relu\",s,void 0)},919612:(s,c)=>{u.kb(\"LeakyRelu\",s,{alpha:c})},919676:(s,c)=>{u.kb(\"ThresholdedRelu\",s,{alpha:c})},919746:(s,c)=>{u.kb(\"Cast\",s,{to:c})},919804:s=>{u.kb(\"Add\",s,void 0)},919855:s=>{u.kb(\"Sub\",s,void 0)},919906:s=>{u.kb(\"Mul\",s,void 0)},919957:s=>{u.kb(\"Div\",s,void 0)},920008:s=>{u.kb(\"Pow\",s,void 0)},920059:s=>{u.kb(\"Equal\",s,void 0)},920112:s=>{u.kb(\"Greater\",s,void 0)},920167:s=>{u.kb(\"GreaterOrEqual\",s,void 0)},920229:s=>{u.kb(\"Less\",s,void 0)},920281:s=>{u.kb(\"LessOrEqual\",s,void 0)},920340:(s,c,f,b,w)=>{u.kb(\"ReduceMean\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},920515:(s,c,f,b,w)=>{u.kb(\"ReduceMax\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},920689:(s,c,f,b,w)=>{u.kb(\"ReduceMin\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},920863:(s,c,f,b,w)=>{u.kb(\"ReduceProd\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921038:(s,c,f,b,w)=>{u.kb(\"ReduceSum\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921212:(s,c,f,b,w)=>{u.kb(\"ReduceL1\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921385:(s,c,f,b,w)=>{u.kb(\"ReduceL2\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921558:(s,c,f,b,w)=>{u.kb(\"ReduceLogSum\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921735:(s,c,f,b,w)=>{u.kb(\"ReduceSumSquare\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921915:(s,c,f,b,w)=>{u.kb(\"ReduceLogSumExp\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},922095:s=>{u.kb(\"Where\",s,void 0)},922148:(s,c,f)=>{u.kb(\"Transpose\",s,{perm:c?Array.from(i().subarray(Number(c)>>>0,Number(f)>>>0)):[]})},922272:(s,c,f,b)=>{u.kb(\"DepthToSpace\",s,{blocksize:c,mode:Ce(f),format:b?\"NHWC\":\"NCHW\"})},922405:(s,c,f,b)=>{u.kb(\"DepthToSpace\",s,{blocksize:c,mode:Ce(f),format:b?\"NHWC\":\"NCHW\"})},922538:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z,ue)=>{u.kb(\"ConvTranspose\",s,{format:G?\"NHWC\":\"NCHW\",autoPad:c,dilations:[f],group:b,kernelShape:[w],pads:[I,O],strides:[B],wIsConst:()=>!!t()[F>>>0],outputPadding:X?Array.from(i().subarray(Number(X)>>>0,Number(le)>>>0)):[],outputShape:ge?Array.from(i().subarray(Number(ge)>>>0,Number(z)>>>0)):[],activation:Ce(ue)})},922971:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"ConvTranspose\",s,{format:B?\"NHWC\":\"NCHW\",autoPad:c,dilations:Array.from(i().subarray(Number(f)>>>0,2+(Number(f)>>>0)>>>0)),group:b,kernelShape:Array.from(i().subarray(Number(w)>>>0,2+(Number(w)>>>0)>>>0)),pads:Array.from(i().subarray(Number(I)>>>0,4+(Number(I)>>>0)>>>0)),strides:Array.from(i().subarray(Number(O)>>>0,2+(Number(O)>>>0)>>>0)),wIsConst:()=>!!t()[G>>>0],outputPadding:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],outputShape:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[],activation:Ce(z)})},923632:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z,ue)=>{u.kb(\"ConvTranspose\",s,{format:G?\"NHWC\":\"NCHW\",autoPad:c,dilations:[f],group:b,kernelShape:[w],pads:[I,O],strides:[B],wIsConst:()=>!!t()[F>>>0],outputPadding:X?Array.from(i().subarray(Number(X)>>>0,Number(le)>>>0)):[],outputShape:ge?Array.from(i().subarray(Number(ge)>>>0,Number(z)>>>0)):[],activation:Ce(ue)})},924065:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"ConvTranspose\",s,{format:B?\"NHWC\":\"NCHW\",autoPad:c,dilations:Array.from(i().subarray(Number(f)>>>0,2+(Number(f)>>>0)>>>0)),group:b,kernelShape:Array.from(i().subarray(Number(w)>>>0,2+(Number(w)>>>0)>>>0)),pads:Array.from(i().subarray(Number(I)>>>0,4+(Number(I)>>>0)>>>0)),strides:Array.from(i().subarray(Number(O)>>>0,2+(Number(O)>>>0)>>>0)),wIsConst:()=>!!t()[G>>>0],outputPadding:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],outputShape:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[],activation:Ce(z)})},924726:(s,c)=>{u.kb(\"GlobalAveragePool\",s,{format:c?\"NHWC\":\"NCHW\"})},924817:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"AveragePool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(G)>>>0)):[],pads:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],strides:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[]})},925296:(s,c)=>{u.kb(\"GlobalAveragePool\",s,{format:c?\"NHWC\":\"NCHW\"})},925387:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"AveragePool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(G)>>>0)):[],pads:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],strides:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[]})},925866:(s,c)=>{u.kb(\"GlobalMaxPool\",s,{format:c?\"NHWC\":\"NCHW\"})},925953:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"MaxPool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(G)>>>0)):[],pads:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],strides:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[]})},926428:(s,c)=>{u.kb(\"GlobalMaxPool\",s,{format:c?\"NHWC\":\"NCHW\"})},926515:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"MaxPool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(G)>>>0)):[],pads:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],strides:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[]})},926990:(s,c,f,b,w)=>{u.kb(\"Gemm\",s,{alpha:c,beta:f,transA:b,transB:w})},927094:s=>{u.kb(\"MatMul\",s,void 0)},927148:(s,c,f,b)=>{u.kb(\"ArgMax\",s,{keepDims:!!c,selectLastIndex:!!f,axis:b})},927256:(s,c,f,b)=>{u.kb(\"ArgMin\",s,{keepDims:!!c,selectLastIndex:!!f,axis:b})},927364:(s,c)=>{u.kb(\"Softmax\",s,{axis:c})},927427:(s,c)=>{u.kb(\"Concat\",s,{axis:c})},927487:(s,c,f,b,w)=>{u.kb(\"Split\",s,{axis:c,numOutputs:f,splitSizes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},927643:s=>{u.kb(\"Expand\",s,void 0)},927697:(s,c)=>{u.kb(\"Gather\",s,{axis:Number(c)})},927768:(s,c)=>{u.kb(\"GatherElements\",s,{axis:Number(c)})},927847:(s,c)=>{u.kb(\"GatherND\",s,{batch_dims:Number(c)})},927926:(s,c,f,b,w,I,O,B,G,F,X)=>{u.kb(\"Resize\",s,{antialias:c,axes:f?Array.from(i().subarray(Number(f)>>>0,Number(b)>>>0)):[],coordinateTransformMode:Ce(w),cubicCoeffA:I,excludeOutside:O,extrapolationValue:B,keepAspectRatioPolicy:Ce(G),mode:Ce(F),nearestMode:Ce(X)})},928288:(s,c,f,b,w,I,O)=>{u.kb(\"Slice\",s,{starts:c?Array.from(i().subarray(Number(c)>>>0,Number(f)>>>0)):[],ends:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[],axes:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[]})},928552:s=>{u.kb(\"Tile\",s,void 0)},928604:(s,c,f)=>{u.kb(\"InstanceNormalization\",s,{epsilon:c,format:f?\"NHWC\":\"NCHW\"})},928718:(s,c,f)=>{u.kb(\"InstanceNormalization\",s,{epsilon:c,format:f?\"NHWC\":\"NCHW\"})},928832:s=>{u.kb(\"Range\",s,void 0)},928885:(s,c)=>{u.kb(\"Einsum\",s,{equation:Ce(c)})},928966:(s,c,f,b,w)=>{u.kb(\"Pad\",s,{mode:c,value:f,pads:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},929109:(s,c,f,b,w,I)=>{u.kb(\"BatchNormalization\",s,{epsilon:c,momentum:f,spatial:!!w,trainingMode:!!b,format:I?\"NHWC\":\"NCHW\"})},929278:(s,c,f,b,w,I)=>{u.kb(\"BatchNormalization\",s,{epsilon:c,momentum:f,spatial:!!w,trainingMode:!!b,format:I?\"NHWC\":\"NCHW\"})},929447:(s,c,f)=>{u.kb(\"CumSum\",s,{exclusive:Number(c),reverse:Number(f)})},929544:(s,c,f)=>{u.kb(\"DequantizeLinear\",s,{axis:c,blockSize:f})},929634:(s,c,f,b,w)=>{u.kb(\"GridSample\",s,{align_corners:c,mode:Ce(f),padding_mode:Ce(b),format:w?\"NHWC\":\"NCHW\"})},929804:(s,c,f,b,w)=>{u.kb(\"GridSample\",s,{align_corners:c,mode:Ce(f),padding_mode:Ce(b),format:w?\"NHWC\":\"NCHW\"})},929974:(s,c,f,b,w,I,O,B,G)=>{u.kb(\"Attention\",s,{numHeads:c,isUnidirectional:f,maskFilterValue:b,scale:w,doRotary:I,qkvHiddenSizes:O?Array.from(i().subarray(Number(B)>>>0,Number(B)+O>>>0)):[],pastPresentShareBuffer:!!G})},930246:s=>{u.kb(\"BiasAdd\",s,void 0)},930301:s=>{u.kb(\"BiasSplitGelu\",s,void 0)},930362:s=>{u.kb(\"FastGelu\",s,void 0)},930418:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z,ue,Se)=>{u.kb(\"Conv\",s,{format:le?\"NHWC\":\"NCHW\",auto_pad:c,dilations:f?Array.from(i().subarray(Number(f)>>>0,Number(b)>>>0)):[],group:w,kernel_shape:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],pads:B?Array.from(i().subarray(Number(B)>>>0,Number(G)>>>0)):[],strides:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],w_is_const:()=>!!t()[Number(ge)>>>0],activation:Ce(z),activation_params:ue?Array.from(d().subarray(Number(ue)>>>0,Number(Se)>>>0)):[]})},931002:s=>{u.kb(\"Gelu\",s,void 0)},931054:(s,c,f,b,w,I,O,B,G)=>{u.kb(\"GroupQueryAttention\",s,{numHeads:c,kvNumHeads:f,scale:b,softcap:w,doRotary:I,rotaryInterleaved:O,smoothSoftmax:B,localWindowSize:G})},931271:(s,c,f,b)=>{u.kb(\"LayerNormalization\",s,{axis:c,epsilon:f,simplified:!!b})},931382:(s,c,f,b)=>{u.kb(\"LayerNormalization\",s,{axis:c,epsilon:f,simplified:!!b})},931493:(s,c,f,b,w,I)=>{u.kb(\"MatMulNBits\",s,{k:c,n:f,accuracyLevel:b,bits:w,blockSize:I})},931620:(s,c,f,b,w,I)=>{u.kb(\"MultiHeadAttention\",s,{numHeads:c,isUnidirectional:f,maskFilterValue:b,scale:w,doRotary:I})},931779:(s,c)=>{u.kb(\"QuickGelu\",s,{alpha:c})},931843:(s,c,f,b,w)=>{u.kb(\"RotaryEmbedding\",s,{interleaved:!!c,numHeads:f,rotaryEmbeddingDim:b,scale:w})},931982:(s,c,f)=>{u.kb(\"SkipLayerNormalization\",s,{epsilon:c,simplified:!!f})},932084:(s,c,f)=>{u.kb(\"SkipLayerNormalization\",s,{epsilon:c,simplified:!!f})},932186:(s,c,f,b)=>{u.kb(\"GatherBlockQuantized\",s,{gatherAxis:c,quantizeAxis:f,blockSize:b})},932307:s=>{u.$b(s)},932341:(s,c)=>u.cc(Number(s),Number(c),u.Gb.hc,u.Gb.errors)};function vc(s,c,f){return yi(async()=>{await u.Yb(Number(s),Number(c),Number(f))})}function $c(){return typeof wasmOffsetConverter<\"u\"}function bn(s){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${s})`,this.status=s}var yn=s=>{s.terminate(),s.onmessage=()=>{}},No=s=>{pt.length==0&&(Fo(),Ho(pt[0]));var c=pt.pop();if(!c)return 6;$t.push(c),Ze[s.Bb]=c,c.Bb=s.Bb;var f={cmd:\"run\",start_routine:s.ic,arg:s.Rb,pthread_ptr:s.Bb};return c.postMessage(f,s.nc),0},vt=0,$e=(s,c,...f)=>{for(var b=2*f.length,w=Mn(),I=Bn(8*b),O=I>>>3,B=0;B<f.length;B++){var G=f[B];typeof G==\"bigint\"?(W[O+2*B]=1n,W[O+2*B+1]=G):(W[O+2*B]=0n,l()[O+2*B+1>>>0]=G)}return s=Li(s,0,b,I,c),hr(w),s};function _n(s){if(g)return $e(0,1,s);if(j=s,!(0<vt)){for(var c of $t)yn(c);for(c of pt)yn(c);pt=[],$t=[],Ze=[],De=!0}A(0,new bn(s))}function Vo(s){if(g)return $e(1,0,s);wn(s)}var wn=s=>{if(j=s,g)throw Vo(s),\"unwind\";_n(s)},pt=[],$t=[],Wo=[],Ze={},Lo=s=>{var c=s.Bb;delete Ze[c],pt.push(s),$t.splice($t.indexOf(s),1),s.Bb=0,Dn(c)};function Go(){Wo.forEach(s=>s())}var Ho=s=>new Promise(c=>{s.onmessage=w=>{var I=(w=w.data).cmd;if(w.targetThread&&w.targetThread!=Rt()){var O=Ze[w.targetThread];O?O.postMessage(w,w.transferList):L(`Internal error! Worker sent a message \"${I}\" to target pthread ${w.targetThread}, but that thread no longer exists!`)}else I===\"checkMailbox\"?or():I===\"spawnThread\"?No(w):I===\"cleanupThread\"?Lo(Ze[w.thread]):I===\"killThread\"?(w=w.thread,I=Ze[w],delete Ze[w],yn(I),Dn(w),$t.splice($t.indexOf(I),1),I.Bb=0):I===\"cancelThread\"?Ze[w.thread].postMessage({cmd:\"cancel\"}):I===\"loaded\"?(s.loaded=!0,c(s)):I===\"alert\"?alert(`Thread ${w.threadId}: ${w.text}`):w.target===\"setimmediate\"?s.postMessage(w):I===\"callHandler\"?u[w.handler](...w.args):I&&L(`worker sent an unknown command ${I}`)},s.onerror=w=>{throw L(`worker sent an error! ${w.filename}:${w.lineno}: ${w.message}`),w};var f,b=[];for(f of[])u.hasOwnProperty(f)&&b.push(f);s.postMessage({cmd:\"load\",handlers:b,wasmMemory:K,wasmModule:we})});function Fo(){var s=new Worker(\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\".startsWith(\"file:\")?/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?5923\")):new URL(\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"),{type:\"module\",workerData:\"em-pthread\",name:\"em-pthread\"});pt.push(s)}var nr=s=>{for(;0<s.length;)s.shift()(u)},xc=()=>{var s=Rt(),c=a()[s+52>>>2>>>0];s=a()[s+56>>>2>>>0],Hi(c,c-s),hr(c)},Sc=(s,c)=>{vt=0,s=Fi(s,c),0<vt?j=s:fr(s)};class Tc{constructor(c){this.Kb=c-24}}function Ic(s,c,f){var b=new Tc(s>>>=0);throw c>>>=0,f>>>=0,a()[b.Kb+16>>>2>>>0]=0,a()[b.Kb+4>>>2>>>0]=c,a()[b.Kb+8>>>2>>>0]=f,s}function qo(s,c,f,b){return g?$e(2,1,s,c,f,b):Ko(s,c,f,b)}function Ko(s,c,f,b){if(s>>>=0,c>>>=0,f>>>=0,b>>>=0,x===void 0)return L(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var w=[];return g&&w.length===0?qo(s,c,f,b):(s={ic:f,Bb:s,Rb:b,nc:w},g?(s.Nb=\"spawnThread\",postMessage(s,w),0):No(s))}var jo=typeof TextDecoder<\"u\"?new TextDecoder(\"utf8\"):void 0,Yo=(s,c,f)=>{var b=(c>>>=0)+f;for(f=c;s[f]&&!(f>=b);)++f;if(16<f-c&&s.buffer&&jo)return jo.decode(s.buffer instanceof x?s.slice(c,f):s.subarray(c,f));for(b=\"\";c<f;){var w=s[c++];if(128&w){var I=63&s[c++];if((224&w)==192)b+=String.fromCharCode((31&w)<<6|I);else{var O=63&s[c++];65536>(w=(240&w)==224?(15&w)<<12|I<<6|O:(7&w)<<18|I<<12|O<<6|63&s[c++])?b+=String.fromCharCode(w):(w-=65536,b+=String.fromCharCode(55296|w>>10,56320|1023&w))}}else b+=String.fromCharCode(w)}return b},Ce=(s,c)=>(s>>>=0)?Yo(r(),s,c):\"\";function Zo(s,c,f){return g?$e(3,1,s,c,f):0}function Qo(s,c){if(g)return $e(4,1,s,c)}var vn=s=>{for(var c=0,f=0;f<s.length;++f){var b=s.charCodeAt(f);127>=b?c++:2047>=b?c+=2:55296<=b&&57343>=b?(c+=4,++f):c+=3}return c},Xo=(s,c,f,b)=>{if(!(0<b))return 0;var w=f>>>=0;b=f+b-1;for(var I=0;I<s.length;++I){var O=s.charCodeAt(I);if(55296<=O&&57343>=O&&(O=65536+((1023&O)<<10)|1023&s.charCodeAt(++I)),127>=O){if(f>=b)break;c[f++>>>0]=O}else{if(2047>=O){if(f+1>=b)break;c[f++>>>0]=192|O>>6}else{if(65535>=O){if(f+2>=b)break;c[f++>>>0]=224|O>>12}else{if(f+3>=b)break;c[f++>>>0]=240|O>>18,c[f++>>>0]=128|O>>12&63}c[f++>>>0]=128|O>>6&63}c[f++>>>0]=128|63&O}}return c[f>>>0]=0,f-w},Dt=(s,c,f)=>Xo(s,r(),c,f);function Jo(s,c){if(g)return $e(5,1,s,c)}function ei(s,c,f){if(g)return $e(6,1,s,c,f)}function ti(s,c,f){return g?$e(7,1,s,c,f):0}function ri(s,c){if(g)return $e(8,1,s,c)}function ni(s,c,f){if(g)return $e(9,1,s,c,f)}function oi(s,c,f,b){if(g)return $e(10,1,s,c,f,b)}function ii(s,c,f,b){if(g)return $e(11,1,s,c,f,b)}function ai(s,c,f,b){if(g)return $e(12,1,s,c,f,b)}function si(s){if(g)return $e(13,1,s)}function ui(s,c){if(g)return $e(14,1,s,c)}function di(s,c,f){if(g)return $e(15,1,s,c,f)}var li,mt,Cc=()=>{ct(\"\")},Qe=s=>{for(var c=\"\";r()[s>>>0];)c+=li[r()[s++>>>0]];return c},$n={},xn={},Ac={};function st(s,c,f={}){if(!(\"argPackAdvance\"in c))throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");return function(b,w,I={}){var O=w.name;if(!b)throw new mt(`type \"${O}\" must have a positive integer typeid pointer`);if(xn.hasOwnProperty(b)){if(I.Tb)return;throw new mt(`Cannot register type '${O}' twice`)}xn[b]=w,delete Ac[b],$n.hasOwnProperty(b)&&(w=$n[b],delete $n[b],w.forEach(B=>B()))}(s,c,f)}var ci=(s,c,f)=>{switch(c){case 1:return f?b=>t()[b>>>0]:b=>r()[b>>>0];case 2:return f?b=>n()[b>>>1>>>0]:b=>o()[b>>>1>>>0];case 4:return f?b=>i()[b>>>2>>>0]:b=>a()[b>>>2>>>0];case 8:return f?b=>W[b>>>3]:b=>Y[b>>>3];default:throw new TypeError(`invalid integer width (${c}): ${s}`)}};function kc(s,c,f){f>>>=0,st(s>>>=0,{name:c=Qe(c>>>0),fromWireType:b=>b,toWireType:function(b,w){if(typeof w!=\"bigint\"&&typeof w!=\"number\")throw w=w===null?\"null\":(b=typeof w)==\"object\"||b===\"array\"||b===\"function\"?w.toString():\"\"+w,new TypeError(`Cannot convert \"${w}\" to ${this.name}`);return typeof w==\"number\"&&(w=BigInt(w)),w},argPackAdvance:ft,readValueFromPointer:ci(c,f,c.indexOf(\"u\")==-1),Eb:null})}var ft=8;function Ec(s,c,f,b){st(s>>>=0,{name:c=Qe(c>>>0),fromWireType:function(w){return!!w},toWireType:function(w,I){return I?f:b},argPackAdvance:ft,readValueFromPointer:function(w){return this.fromWireType(r()[w>>>0])},Eb:null})}var Sn=[],ut=[];function Tn(s){9<(s>>>=0)&&--ut[s+1]==0&&(ut[s]=void 0,Sn.push(s))}var Re=s=>{if(!s)throw new mt(\"Cannot use deleted val. handle = \"+s);return ut[s]},We=s=>{switch(s){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let c=Sn.pop()||ut.length;return ut[c]=s,ut[c+1]=1,c}};function In(s){return this.fromWireType(a()[s>>>2>>>0])}var Pc={name:\"emscripten::val\",fromWireType:s=>{var c=Re(s);return Tn(s),c},toWireType:(s,c)=>We(c),argPackAdvance:ft,readValueFromPointer:In,Eb:null};function zc(s){return st(s>>>0,Pc)}var Oc=(s,c)=>{switch(c){case 4:return function(f){return this.fromWireType(d()[f>>>2>>>0])};case 8:return function(f){return this.fromWireType(l()[f>>>3>>>0])};default:throw new TypeError(`invalid float width (${c}): ${s}`)}};function Dc(s,c,f){f>>>=0,st(s>>>=0,{name:c=Qe(c>>>0),fromWireType:b=>b,toWireType:(b,w)=>w,argPackAdvance:ft,readValueFromPointer:Oc(c,f),Eb:null})}function Bc(s,c,f,b,w){if(s>>>=0,f>>>=0,c=Qe(c>>>0),w===-1&&(w=4294967295),w=B=>B,b===0){var I=32-8*f;w=B=>B<<I>>>I}var O=c.includes(\"unsigned\")?function(B,G){return G>>>0}:function(B,G){return G};st(s,{name:c,fromWireType:w,toWireType:O,argPackAdvance:ft,readValueFromPointer:ci(c,f,b!==0),Eb:null})}function Mc(s,c,f){function b(I){var O=a()[I>>>2>>>0];return I=a()[I+4>>>2>>>0],new w(t().buffer,I,O)}var w=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][c];st(s>>>=0,{name:f=Qe(f>>>0),fromWireType:b,argPackAdvance:ft,readValueFromPointer:b},{Tb:!0})}function Rc(s,c){s>>>=0;var f=(c=Qe(c>>>0))===\"std::string\";st(s,{name:c,fromWireType:function(b){var w=a()[b>>>2>>>0],I=b+4;if(f)for(var O=I,B=0;B<=w;++B){var G=I+B;if(B==w||r()[G>>>0]==0){if(O=Ce(O,G-O),F===void 0)var F=O;else F+=String.fromCharCode(0),F+=O;O=G+1}}else{for(F=Array(w),B=0;B<w;++B)F[B]=String.fromCharCode(r()[I+B>>>0]);F=F.join(\"\")}return Je(b),F},toWireType:function(b,w){w instanceof ArrayBuffer&&(w=new Uint8Array(w));var I=typeof w==\"string\";if(!(I||w instanceof Uint8Array||w instanceof Uint8ClampedArray||w instanceof Int8Array))throw new mt(\"Cannot pass non-string to std::string\");var O=f&&I?vn(w):w.length,B=mr(4+O+1),G=B+4;if(a()[B>>>2>>>0]=O,f&&I)Dt(w,G,O+1);else if(I)for(I=0;I<O;++I){var F=w.charCodeAt(I);if(255<F)throw Je(G),new mt(\"String has UTF-16 code units that do not fit in 8 bits\");r()[G+I>>>0]=F}else for(I=0;I<O;++I)r()[G+I>>>0]=w[I];return b!==null&&b.push(Je,B),B},argPackAdvance:ft,readValueFromPointer:In,Eb(b){Je(b)}})}var pi=typeof TextDecoder<\"u\"?new TextDecoder(\"utf-16le\"):void 0,Uc=(s,c)=>{for(var f=s>>1,b=f+c/2;!(f>=b)&&o()[f>>>0];)++f;if(32<(f<<=1)-s&&pi)return pi.decode(r().slice(s,f));for(f=\"\",b=0;!(b>=c/2);++b){var w=n()[s+2*b>>>1>>>0];if(w==0)break;f+=String.fromCharCode(w)}return f},Nc=(s,c,f)=>{if(f??=2147483647,2>f)return 0;var b=c;f=(f-=2)<2*s.length?f/2:s.length;for(var w=0;w<f;++w){var I=s.charCodeAt(w);n()[c>>>1>>>0]=I,c+=2}return n()[c>>>1>>>0]=0,c-b},Vc=s=>2*s.length,Wc=(s,c)=>{for(var f=0,b=\"\";!(f>=c/4);){var w=i()[s+4*f>>>2>>>0];if(w==0)break;++f,65536<=w?(w-=65536,b+=String.fromCharCode(55296|w>>10,56320|1023&w)):b+=String.fromCharCode(w)}return b},Lc=(s,c,f)=>{if(c>>>=0,f??=2147483647,4>f)return 0;var b=c;f=b+f-4;for(var w=0;w<s.length;++w){var I=s.charCodeAt(w);if(55296<=I&&57343>=I&&(I=65536+((1023&I)<<10)|1023&s.charCodeAt(++w)),i()[c>>>2>>>0]=I,(c+=4)+4>f)break}return i()[c>>>2>>>0]=0,c-b},Gc=s=>{for(var c=0,f=0;f<s.length;++f){var b=s.charCodeAt(f);55296<=b&&57343>=b&&++f,c+=4}return c};function Hc(s,c,f){if(s>>>=0,c>>>=0,f=Qe(f>>>=0),c===2)var b=Uc,w=Nc,I=Vc,O=B=>o()[B>>>1>>>0];else c===4&&(b=Wc,w=Lc,I=Gc,O=B=>a()[B>>>2>>>0]);st(s,{name:f,fromWireType:B=>{for(var G,F=a()[B>>>2>>>0],X=B+4,le=0;le<=F;++le){var ge=B+4+le*c;le!=F&&O(ge)!=0||(X=b(X,ge-X),G===void 0?G=X:(G+=String.fromCharCode(0),G+=X),X=ge+c)}return Je(B),G},toWireType:(B,G)=>{if(typeof G!=\"string\")throw new mt(`Cannot pass non-string to C++ string type ${f}`);var F=I(G),X=mr(4+F+c);return a()[X>>>2>>>0]=F/c,w(G,X+4,F+c),B!==null&&B.push(Je,X),X},argPackAdvance:ft,readValueFromPointer:In,Eb(B){Je(B)}})}function Fc(s,c){st(s>>>=0,{Ub:!0,name:c=Qe(c>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var qc=()=>1;function Kc(s){On(s>>>0,!y,1,!_,131072,!1),Go()}var mi=s=>{if(!De)try{if(s(),!(0<vt))try{g?fr(j):wn(j)}catch(c){c instanceof bn||c==\"unwind\"||A(0,c)}}catch(c){c instanceof bn||c==\"unwind\"||A(0,c)}};function Cn(s){s>>>=0,typeof Atomics.oc==\"function\"&&(Atomics.oc(i(),s>>>2,s).value.then(or),s+=128,Atomics.store(i(),s>>>2,1))}var or=()=>{var s=Rt();s&&(Cn(s),mi(Gi))};function jc(s,c){(s>>>=0)==c>>>0?setTimeout(or):g?postMessage({targetThread:s,cmd:\"checkMailbox\"}):(s=Ze[s])&&s.postMessage({cmd:\"checkMailbox\"})}var An=[];function Yc(s,c,f,b,w){for(c>>>=0,b/=2,An.length=b,f=w>>>0>>>3,w=0;w<b;w++)An[w]=W[f+2*w]?W[f+2*w+1]:l()[f+2*w+1>>>0];return(c?gn[c]:Np[s])(...An)}function Zc(s){s>>>=0,g?postMessage({cmd:\"cleanupThread\",thread:s}):Lo(Ze[s])}function Qc(s){}var ir=(s,c)=>{var f=xn[s];if(f===void 0)throw s=Ni(s),f=Qe(s),Je(s),new mt(`${c} has unknown type ${f}`);return f},fi=(s,c,f)=>{var b=[];return s=s.toWireType(b,f),b.length&&(a()[c>>>2>>>0]=We(b)),s};function Xc(s,c,f){return c>>>=0,f>>>=0,s=Re(s>>>0),c=ir(c,\"emval::as\"),fi(c,f,s)}function Jc(s,c){return c>>>=0,s=Re(s>>>0),(c=ir(c,\"emval::as\")).toWireType(null,s)}var ar=s=>{try{s()}catch(c){ct(c)}},ht=0,Xe=null,hi=0,sr=[],gi={},bi={},ep=0,kn=null,tp=[];function yi(s){return function(c){if(!De){if(ht===0){var f=!1,b=!1;c((w=0)=>{if(!De&&(hi=w,f=!0,b)){ht=2,ar(()=>ji(Xe)),typeof Browser<\"u\"&&Browser.Lb.Sb&&Browser.Lb.resume(),w=!1;try{var I=function(){var G=i()[Xe+8>>>2>>>0];return G=Z[bi[G]],--vt,G()}()}catch(G){I=G,w=!0}var O=!1;if(!Xe){var B=kn;B&&(kn=null,(w?B.reject:B.resolve)(I),O=!0)}if(w&&!O)throw I}}),b=!0,f||(ht=1,Xe=function(){var w=mr(65548),I=w+12;a()[w>>>2>>>0]=I,a()[w+4>>>2>>>0]=I+65536,I=sr[0];var O=gi[I];return O===void 0&&(O=ep++,gi[I]=O,bi[O]=I),I=O,i()[w+8>>>2>>>0]=I,w}(),typeof Browser<\"u\"&&Browser.Lb.Sb&&Browser.Lb.pause(),ar(()=>qi(Xe)))}else ht===2?(ht=0,ar(Yi),Je(Xe),Xe=null,tp.forEach(mi)):ct(`invalid state: ${ht}`);return hi}}(c=>{s().then(c)})}function rp(s){return s>>>=0,yi(()=>(s=Re(s)).then(We))}var ur=[];function np(s,c,f,b){return f>>>=0,b>>>=0,(s=ur[s>>>0])(null,c=Re(c>>>0),f,b)}var op={},dr=s=>{var c=op[s];return c===void 0?Qe(s):c};function ip(s,c,f,b,w){return f>>>=0,b>>>=0,w>>>=0,(s=ur[s>>>0])(c=Re(c>>>0),c[f=dr(f)],b,w)}var _i=()=>typeof globalThis==\"object\"?globalThis:Function(\"return this\")();function ap(s){return(s>>>=0)==0?We(_i()):(s=dr(s),We(_i()[s]))}var sp=s=>{var c=ur.length;return ur.push(s),c},up=(s,c)=>{for(var f=Array(s),b=0;b<s;++b)f[b]=ir(a()[c+4*b>>>2>>>0],\"parameter \"+b);return f},wi=(s,c)=>Object.defineProperty(c,\"name\",{value:s});function dp(s,c,f){var b=(c=up(s,c>>>0)).shift();s--;var w=`return function (obj, func, destructorsRef, args) {\n`,I=0,O=[];f===0&&O.push(\"obj\");for(var B=[\"retType\"],G=[b],F=0;F<s;++F)O.push(\"arg\"+F),B.push(\"argType\"+F),G.push(c[F]),w+=`  var arg${F} = argType${F}.readValueFromPointer(args${I?\"+\"+I:\"\"});\n`,I+=c[F].argPackAdvance;return w+=`  var rv = ${f===1?\"new func\":\"func.call\"}(${O.join(\", \")});\n`,b.Ub||(B.push(\"emval_returnValue\"),G.push(fi),w+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),B.push(w+`};\n`),s=function(X){var le=Function;if(!(le instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof le} which is not a function`);var ge=wi(le.name||\"unknownFunctionName\",function(){});return ge.prototype=le.prototype,ge=new ge,(X=le.apply(ge,X))instanceof Object?X:ge}(B)(...G),f=`methodCaller<(${c.map(X=>X.name).join(\", \")}) => ${b.name}>`,sp(wi(f,s))}function lp(s){return s=dr(s>>>0),We(u[s])}function cp(s,c){return c>>>=0,s=Re(s>>>0),c=Re(c),We(s[c])}function pp(s){9<(s>>>=0)&&(ut[s+1]+=1)}function mp(){return We([])}function fp(s){s=Re(s>>>0);for(var c=Array(s.length),f=0;f<s.length;f++)c[f]=s[f];return We(c)}function hp(s){return We(dr(s>>>0))}function gp(){return We({})}function bp(s){for(var c=Re(s>>>=0);c.length;){var f=c.pop();c.pop()(f)}Tn(s)}function yp(s,c,f){c>>>=0,f>>>=0,s=Re(s>>>0),c=Re(c),f=Re(f),s[c]=f}function _p(s,c){return c>>>=0,s=(s=ir(s>>>0,\"_emval_take_value\")).readValueFromPointer(c),We(s)}function wp(s,c){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),c>>>=0,s=new Date(1e3*s),i()[c>>>2>>>0]=s.getUTCSeconds(),i()[c+4>>>2>>>0]=s.getUTCMinutes(),i()[c+8>>>2>>>0]=s.getUTCHours(),i()[c+12>>>2>>>0]=s.getUTCDate(),i()[c+16>>>2>>>0]=s.getUTCMonth(),i()[c+20>>>2>>>0]=s.getUTCFullYear()-1900,i()[c+24>>>2>>>0]=s.getUTCDay(),s=(s.getTime()-Date.UTC(s.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[c+28>>>2>>>0]=s}var Bt=s=>s%4==0&&(s%100!=0||s%400==0),vi=[0,31,60,91,121,152,182,213,244,274,305,335],$i=[0,31,59,90,120,151,181,212,243,273,304,334];function vp(s,c){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),c>>>=0,s=new Date(1e3*s),i()[c>>>2>>>0]=s.getSeconds(),i()[c+4>>>2>>>0]=s.getMinutes(),i()[c+8>>>2>>>0]=s.getHours(),i()[c+12>>>2>>>0]=s.getDate(),i()[c+16>>>2>>>0]=s.getMonth(),i()[c+20>>>2>>>0]=s.getFullYear()-1900,i()[c+24>>>2>>>0]=s.getDay();var f=(Bt(s.getFullYear())?vi:$i)[s.getMonth()]+s.getDate()-1|0;i()[c+28>>>2>>>0]=f,i()[c+36>>>2>>>0]=-60*s.getTimezoneOffset(),f=new Date(s.getFullYear(),6,1).getTimezoneOffset();var b=new Date(s.getFullYear(),0,1).getTimezoneOffset();s=0|(f!=b&&s.getTimezoneOffset()==Math.min(b,f)),i()[c+32>>>2>>>0]=s}function $p(s){s>>>=0;var c=new Date(i()[s+20>>>2>>>0]+1900,i()[s+16>>>2>>>0],i()[s+12>>>2>>>0],i()[s+8>>>2>>>0],i()[s+4>>>2>>>0],i()[s>>>2>>>0],0),f=i()[s+32>>>2>>>0],b=c.getTimezoneOffset(),w=new Date(c.getFullYear(),6,1).getTimezoneOffset(),I=new Date(c.getFullYear(),0,1).getTimezoneOffset(),O=Math.min(I,w);return 0>f?i()[s+32>>>2>>>0]=+(w!=I&&O==b):0<f!=(O==b)&&(w=Math.max(I,w),c.setTime(c.getTime()+6e4*((0<f?O:w)-b))),i()[s+24>>>2>>>0]=c.getDay(),f=(Bt(c.getFullYear())?vi:$i)[c.getMonth()]+c.getDate()-1|0,i()[s+28>>>2>>>0]=f,i()[s>>>2>>>0]=c.getSeconds(),i()[s+4>>>2>>>0]=c.getMinutes(),i()[s+8>>>2>>>0]=c.getHours(),i()[s+12>>>2>>>0]=c.getDate(),i()[s+16>>>2>>>0]=c.getMonth(),i()[s+20>>>2>>>0]=c.getYear(),s=c.getTime(),BigInt(isNaN(s)?-1:s/1e3)}function xi(s,c,f,b,w,I,O){return g?$e(16,1,s,c,f,b,w,I,O):-52}function Si(s,c,f,b,w,I){if(g)return $e(17,1,s,c,f,b,w,I)}function xp(s,c,f,b){s>>>=0,c>>>=0,f>>>=0,b>>>=0;var w=new Date().getFullYear(),I=new Date(w,0,1),O=new Date(w,6,1);w=I.getTimezoneOffset();var B=O.getTimezoneOffset(),G=Math.max(w,B);a()[s>>>2>>>0]=60*G,i()[c>>>2>>>0]=+(w!=B),I=(s=F=>F.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:\"short\"}).split(\" \")[1])(I),O=s(O),B<w?(Dt(I,f,17),Dt(O,b,17)):(Dt(I,b,17),Dt(O,f,17))}var En=[],Ti=(s,c)=>{En.length=0;for(var f;f=r()[s++>>>0];){var b=f!=105;c+=(b&=f!=112)&&c%8?4:0,En.push(f==112?a()[c>>>2>>>0]:f==106?W[c>>>3]:f==105?i()[c>>>2>>>0]:l()[c>>>3>>>0]),c+=b?8:4}return En};function Sp(s,c,f){return s>>>=0,c=Ti(c>>>0,f>>>0),gn[s](...c)}function Tp(s,c,f){return s>>>=0,c=Ti(c>>>0,f>>>0),gn[s](...c)}var Ip=()=>{},Cp=()=>Date.now();function Ap(s,c){return L(Ce(s>>>0,c>>>0))}var Ii,kp=()=>{throw vt+=1,\"unwind\"};function Ep(){return 4294901760}Ii=()=>performance.timeOrigin+performance.now();var Pp=()=>navigator.hardwareConcurrency;function zp(){return ct(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"),0}function Op(s){s>>>=0;var c=r().length;if(s<=c||4294901760<s)return!1;for(var f=1;4>=f;f*=2){var b=c*(1+.2/f);b=Math.min(b,s+100663296);var w=Math;b=Math.max(s,b);e:{w=(w.min.call(w,4294901760,b+(65536-b%65536)%65536)-K.buffer.byteLength+65535)/65536;try{K.grow(w),pe();var I=1;break e}catch{}I=void 0}if(I)return!0}return!1}var lr=()=>(ct(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"),0),Mt={},Ci=s=>{s.forEach(c=>{var f=lr();f&&(Mt[f]=c)})};function Dp(){var s=Error().stack.toString().split(`\n`);return s[0]==\"Error\"&&s.shift(),Ci(s),Mt.Qb=lr(),Mt.fc=s,Mt.Qb}function Bp(s,c,f){if(s>>>=0,c>>>=0,Mt.Qb==s)var b=Mt.fc;else(b=Error().stack.toString().split(`\n`))[0]==\"Error\"&&b.shift(),Ci(b);for(var w=3;b[w]&&lr()!=s;)++w;for(s=0;s<f&&b[s+w];++s)i()[c+4*s>>>2>>>0]=lr();return s}var Pn,zn={},Ai=()=>{if(!Pn){var s,c={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:\"./this.program\"};for(s in zn)zn[s]===void 0?delete c[s]:c[s]=zn[s];var f=[];for(s in c)f.push(`${s}=${c[s]}`);Pn=f}return Pn};function ki(s,c){if(g)return $e(18,1,s,c);s>>>=0,c>>>=0;var f=0;return Ai().forEach((b,w)=>{var I=c+f;for(w=a()[s+4*w>>>2>>>0]=I,I=0;I<b.length;++I)t()[w++>>>0]=b.charCodeAt(I);t()[w>>>0]=0,f+=b.length+1}),0}function Ei(s,c){if(g)return $e(19,1,s,c);s>>>=0,c>>>=0;var f=Ai();a()[s>>>2>>>0]=f.length;var b=0;return f.forEach(w=>b+=w.length+1),a()[c>>>2>>>0]=b,0}function Pi(s){return g?$e(20,1,s):52}function zi(s,c,f,b){return g?$e(21,1,s,c,f,b):52}function Oi(s,c,f,b){return g?$e(22,1,s,c,f,b):70}var Mp=[null,[],[]];function Di(s,c,f,b){if(g)return $e(23,1,s,c,f,b);c>>>=0,f>>>=0,b>>>=0;for(var w=0,I=0;I<f;I++){var O=a()[c>>>2>>>0],B=a()[c+4>>>2>>>0];c+=8;for(var G=0;G<B;G++){var F=r()[O+G>>>0],X=Mp[s];F===0||F===10?((s===1?H:L)(Yo(X,0)),X.length=0):X.push(F)}w+=B}return a()[b>>>2>>>0]=w,0}var Bi=[31,29,31,30,31,30,31,31,30,31,30,31],Mi=[31,28,31,30,31,30,31,31,30,31,30,31],Rp=(s,c)=>{t().set(s,c>>>0)};function Ri(s,c,f,b){function w(z,ue,Se){for(z=typeof z==\"number\"?z.toString():z||\"\";z.length<ue;)z=Se[0]+z;return z}function I(z,ue){return w(z,ue,\"0\")}function O(z,ue){function Se(Qi){return 0>Qi?-1:0<Qi?1:0}var xt;return(xt=Se(z.getFullYear()-ue.getFullYear()))===0&&(xt=Se(z.getMonth()-ue.getMonth()))===0&&(xt=Se(z.getDate()-ue.getDate())),xt}function B(z){switch(z.getDay()){case 0:return new Date(z.getFullYear()-1,11,29);case 1:return z;case 2:return new Date(z.getFullYear(),0,3);case 3:return new Date(z.getFullYear(),0,2);case 4:return new Date(z.getFullYear(),0,1);case 5:return new Date(z.getFullYear()-1,11,31);case 6:return new Date(z.getFullYear()-1,11,30)}}function G(z){var ue=z.Cb;for(z=new Date(new Date(z.Db+1900,0,1).getTime());0<ue;){var Se=z.getMonth(),xt=(Bt(z.getFullYear())?Bi:Mi)[Se];if(!(ue>xt-z.getDate())){z.setDate(z.getDate()+ue);break}ue-=xt-z.getDate()+1,z.setDate(1),11>Se?z.setMonth(Se+1):(z.setMonth(0),z.setFullYear(z.getFullYear()+1))}return Se=new Date(z.getFullYear()+1,0,4),ue=B(new Date(z.getFullYear(),0,4)),Se=B(Se),0>=O(ue,z)?0>=O(Se,z)?z.getFullYear()+1:z.getFullYear():z.getFullYear()-1}s>>>=0,c>>>=0,f>>>=0,b>>>=0;var F=a()[b+40>>>2>>>0];for(var X in b={lc:i()[b>>>2>>>0],kc:i()[b+4>>>2>>>0],Ib:i()[b+8>>>2>>>0],Mb:i()[b+12>>>2>>>0],Jb:i()[b+16>>>2>>>0],Db:i()[b+20>>>2>>>0],vb:i()[b+24>>>2>>>0],Cb:i()[b+28>>>2>>>0],sc:i()[b+32>>>2>>>0],jc:i()[b+36>>>2>>>0],mc:F?Ce(F):\"\"},f=Ce(f),F={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})f=f.replace(new RegExp(X,\"g\"),F[X]);var le=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),ge=\"January February March April May June July August September October November December\".split(\" \");for(X in F={\"%a\":z=>le[z.vb].substring(0,3),\"%A\":z=>le[z.vb],\"%b\":z=>ge[z.Jb].substring(0,3),\"%B\":z=>ge[z.Jb],\"%C\":z=>I((z.Db+1900)/100|0,2),\"%d\":z=>I(z.Mb,2),\"%e\":z=>w(z.Mb,2,\" \"),\"%g\":z=>G(z).toString().substring(2),\"%G\":G,\"%H\":z=>I(z.Ib,2),\"%I\":z=>((z=z.Ib)==0?z=12:12<z&&(z-=12),I(z,2)),\"%j\":z=>{for(var ue=0,Se=0;Se<=z.Jb-1;ue+=(Bt(z.Db+1900)?Bi:Mi)[Se++]);return I(z.Mb+ue,3)},\"%m\":z=>I(z.Jb+1,2),\"%M\":z=>I(z.kc,2),\"%n\":()=>`\n`,\"%p\":z=>0<=z.Ib&&12>z.Ib?\"AM\":\"PM\",\"%S\":z=>I(z.lc,2),\"%t\":()=>\"\t\",\"%u\":z=>z.vb||7,\"%U\":z=>I(Math.floor((z.Cb+7-z.vb)/7),2),\"%V\":z=>{var ue=Math.floor((z.Cb+7-(z.vb+6)%7)/7);if(2>=(z.vb+371-z.Cb-2)%7&&ue++,ue)ue==53&&((Se=(z.vb+371-z.Cb)%7)==4||Se==3&&Bt(z.Db)||(ue=1));else{ue=52;var Se=(z.vb+7-z.Cb-1)%7;(Se==4||Se==5&&Bt(z.Db%400-1))&&ue++}return I(ue,2)},\"%w\":z=>z.vb,\"%W\":z=>I(Math.floor((z.Cb+7-(z.vb+6)%7)/7),2),\"%y\":z=>(z.Db+1900).toString().substring(2),\"%Y\":z=>z.Db+1900,\"%z\":z=>{var ue=0<=(z=z.jc);return z=Math.abs(z)/60,(ue?\"+\":\"-\")+(\"0000\"+(z/60*100+z%60)).slice(-4)},\"%Z\":z=>z.mc,\"%%\":()=>\"%\"},f=f.replace(/%%/g,\"\\0\\0\"),F)f.includes(X)&&(f=f.replace(new RegExp(X,\"g\"),F[X](b)));return X=function(z){var ue=Array(vn(z)+1);return Xo(z,ue,0,ue.length),ue}(f=f.replace(/\\0\\0/g,\"%\")),X.length>c?0:(Rp(X,s),X.length-1)}function Up(s,c,f,b){return Ri(s>>>0,c>>>0,f>>>0,b>>>0)}g||function(){for(var s=u.numThreads-1;s--;)Fo();Ie.unshift(()=>{wt++,function(c){g?c():Promise.all(pt.map(Ho)).then(c)}(()=>Oo())})}();for(var Ui=Array(256),cr=0;256>cr;++cr)Ui[cr]=String.fromCharCode(cr);li=Ui,mt=u.BindingError=class extends Error{constructor(s){super(s),this.name=\"BindingError\"}},u.InternalError=class extends Error{constructor(s){super(s),this.name=\"InternalError\"}},ut.push(0,1,void 0,1,null,1,!0,1,!1,1),u.count_emval_handles=()=>ut.length/2-5-Sn.length;var Np=[_n,Vo,qo,Zo,Qo,Jo,ei,ti,ri,ni,oi,ii,ai,si,ui,di,xi,Si,ki,Ei,Pi,zi,Oi,Di],Z=function(){function s(f,b){return Z=f.exports,Z=function(){var w=Z,I={};for(let[O,B]of Object.entries(w))I[O]=typeof B==\"function\"?(...G)=>{sr.push(O);try{return B(...G)}finally{De||(sr.pop(),Xe&&ht===1&&sr.length===0&&(ht=0,vt+=1,ar(Ki),typeof Fibers<\"u\"&&Fibers.tc()))}}:B;return I}(),Z=function(){var w=Z,I=B=>G=>B(G)>>>0,O=B=>()=>B()>>>0;return(w=Object.assign({},w)).Da=I(w.Da),w.gb=O(w.gb),w.ib=I(w.ib),w.emscripten_main_runtime_thread_id=O(w.emscripten_main_runtime_thread_id),w.tb=I(w.tb),w.ub=O(w.ub),w}(),Wo.push(Z.jb),He.unshift(Z.Ca),we=b,Oo(),Z}var c=Uo();if(wt++,u.instantiateWasm)try{return u.instantiateWasm(c,s)}catch(f){L(`Module.instantiateWasm callback failed with error: ${f}`),m(f)}return hn||=u.locateFile?Do(\"ort-wasm-simd-threaded.jsep.wasm\")?\"ort-wasm-simd-threaded.jsep.wasm\":u.locateFile?u.locateFile(\"ort-wasm-simd-threaded.jsep.wasm\",C):C+\"ort-wasm-simd-threaded.jsep.wasm\":/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(app-pages-browser)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href,function(f,b){var w=hn;return P||typeof WebAssembly.instantiateStreaming!=\"function\"||Do(w)||Bo(w)||typeof fetch!=\"function\"?Ro(w,f,b):fetch(w,{credentials:\"same-origin\"}).then(I=>WebAssembly.instantiateStreaming(I,f).then(b,function(O){return L(`wasm streaming compile failed: ${O}`),L(\"falling back to ArrayBuffer instantiation\"),Ro(w,f,b)}))}(c,function(f){s(f.instance,f.module)}).catch(m),{}}(),Ni=s=>(Ni=Z.Da)(s),Vi=()=>(Vi=Z.Ea)();u._OrtInit=(s,c)=>(u._OrtInit=Z.Fa)(s,c),u._OrtGetLastError=(s,c)=>(u._OrtGetLastError=Z.Ga)(s,c),u._OrtCreateSessionOptions=(s,c,f,b,w,I,O,B,G,F)=>(u._OrtCreateSessionOptions=Z.Ha)(s,c,f,b,w,I,O,B,G,F),u._OrtAppendExecutionProvider=(s,c)=>(u._OrtAppendExecutionProvider=Z.Ia)(s,c),u._OrtAddFreeDimensionOverride=(s,c,f)=>(u._OrtAddFreeDimensionOverride=Z.Ja)(s,c,f),u._OrtAddSessionConfigEntry=(s,c,f)=>(u._OrtAddSessionConfigEntry=Z.Ka)(s,c,f),u._OrtReleaseSessionOptions=s=>(u._OrtReleaseSessionOptions=Z.La)(s),u._OrtCreateSession=(s,c,f)=>(u._OrtCreateSession=Z.Ma)(s,c,f),u._OrtReleaseSession=s=>(u._OrtReleaseSession=Z.Na)(s),u._OrtGetInputOutputCount=(s,c,f)=>(u._OrtGetInputOutputCount=Z.Oa)(s,c,f),u._OrtGetInputName=(s,c)=>(u._OrtGetInputName=Z.Pa)(s,c),u._OrtGetOutputName=(s,c)=>(u._OrtGetOutputName=Z.Qa)(s,c),u._OrtFree=s=>(u._OrtFree=Z.Ra)(s),u._OrtCreateTensor=(s,c,f,b,w,I)=>(u._OrtCreateTensor=Z.Sa)(s,c,f,b,w,I),u._OrtGetTensorData=(s,c,f,b,w)=>(u._OrtGetTensorData=Z.Ta)(s,c,f,b,w),u._OrtReleaseTensor=s=>(u._OrtReleaseTensor=Z.Ua)(s),u._OrtCreateRunOptions=(s,c,f,b)=>(u._OrtCreateRunOptions=Z.Va)(s,c,f,b),u._OrtAddRunConfigEntry=(s,c,f)=>(u._OrtAddRunConfigEntry=Z.Wa)(s,c,f),u._OrtReleaseRunOptions=s=>(u._OrtReleaseRunOptions=Z.Xa)(s),u._OrtCreateBinding=s=>(u._OrtCreateBinding=Z.Ya)(s),u._OrtBindInput=(s,c,f)=>(u._OrtBindInput=Z.Za)(s,c,f),u._OrtBindOutput=(s,c,f,b)=>(u._OrtBindOutput=Z._a)(s,c,f,b),u._OrtClearBoundOutputs=s=>(u._OrtClearBoundOutputs=Z.$a)(s),u._OrtReleaseBinding=s=>(u._OrtReleaseBinding=Z.ab)(s),u._OrtRunWithBinding=(s,c,f,b,w)=>(u._OrtRunWithBinding=Z.bb)(s,c,f,b,w),u._OrtRun=(s,c,f,b,w,I,O,B)=>(u._OrtRun=Z.cb)(s,c,f,b,w,I,O,B),u._OrtEndProfiling=s=>(u._OrtEndProfiling=Z.db)(s),u._JsepOutput=(s,c,f)=>(u._JsepOutput=Z.eb)(s,c,f),u._JsepGetNodeName=s=>(u._JsepGetNodeName=Z.fb)(s);var pr,Rt=()=>(Rt=Z.gb)(),Je=u._free=s=>(Je=u._free=Z.hb)(s),mr=u._malloc=s=>(mr=u._malloc=Z.ib)(s),On=(s,c,f,b,w,I)=>(On=Z.lb)(s,c,f,b,w,I),Wi=()=>(Wi=Z.mb)(),Li=(s,c,f,b,w)=>(Li=Z.nb)(s,c,f,b,w),Dn=s=>(Dn=Z.ob)(s),fr=s=>(fr=Z.pb)(s),Gi=()=>(Gi=Z.qb)(),Hi=(s,c)=>(Hi=Z.rb)(s,c),hr=s=>(hr=Z.sb)(s),Bn=s=>(Bn=Z.tb)(s),Mn=()=>(Mn=Z.ub)(),Fi=u.dynCall_ii=(s,c)=>(Fi=u.dynCall_ii=Z.wb)(s,c),qi=s=>(qi=Z.xb)(s),Ki=()=>(Ki=Z.yb)(),ji=s=>(ji=Z.zb)(s),Yi=()=>(Yi=Z.Ab)();function Zi(){0<wt||(g?(p(u),g||nr(He),startWorker(u)):(nr(Ie),0<wt||pr||(pr=!0,u.calledRun=!0,De||(g||nr(He),p(u),g||nr(mn)))))}return u.___start_em_js=932469,u.___stop_em_js=932715,u.stackSave=()=>Mn(),u.stackRestore=s=>hr(s),u.stackAlloc=s=>Bn(s),u.setValue=function(s,c,f=\"i8\"){switch(f.endsWith(\"*\")&&(f=\"*\"),f){case\"i1\":case\"i8\":t()[s>>>0]=c;break;case\"i16\":n()[s>>>1>>>0]=c;break;case\"i32\":i()[s>>>2>>>0]=c;break;case\"i64\":W[s>>>3]=BigInt(c);break;case\"float\":d()[s>>>2>>>0]=c;break;case\"double\":l()[s>>>3>>>0]=c;break;case\"*\":a()[s>>>2>>>0]=c;break;default:ct(`invalid type for setValue: ${f}`)}},u.getValue=function(s,c=\"i8\"){switch(c.endsWith(\"*\")&&(c=\"*\"),c){case\"i1\":case\"i8\":return t()[s>>>0];case\"i16\":return n()[s>>>1>>>0];case\"i32\":return i()[s>>>2>>>0];case\"i64\":return W[s>>>3];case\"float\":return d()[s>>>2>>>0];case\"double\":return l()[s>>>3>>>0];case\"*\":return a()[s>>>2>>>0];default:ct(`invalid type for getValue: ${c}`)}},u.UTF8ToString=Ce,u.stringToUTF8=Dt,u.lengthBytesUTF8=vn,Gt=function s(){pr||Zi(),pr||(Gt=s)},Zi(),u.PTR_SIZE=4,h}),Kp=Pa;globalThis.self?.name===\"em-pthread\"&&Pa()});var Ma,jp,Ve,Ra,Kn,Yp,Zp,Ua,Qp,Da,Na,Ba,Va,$r=U(()=>{\"use strict\";vr();Ma= false||typeof location>\"u\"?void 0:location.origin,jp=()=>{if(true)return \"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\")?new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?5923\")).href,Ma).href:\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"},Ve=jp(),Ra=()=>{if(Ve&&!Ve.startsWith(\"blob:\"))return Ve.substring(0,Ve.lastIndexOf(\"/\")+1)},Kn=(e,t)=>{try{let r=t??Ve;return(r?new URL(e,r):new URL(e)).origin===Ma}catch{return!1}},Yp=(e,t)=>{let r=t??Ve;try{return(r?new URL(e,r):new URL(e)).href}catch{return}},Zp=(e,t)=>`${t??\"./\"}${e}`,Ua=async e=>{let r=await(await fetch(e,{credentials:\"same-origin\"})).blob();return URL.createObjectURL(r)},Qp=async e=>(await import(/*webpackIgnore:true*/e)).default,Da=(Ea(),gr(ka)).default,Na=async()=>{if(!Ve)throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");if(Kn(Ve))return[void 0,Da()];let e=await Ua(Ve);return[e,Da(e)]},Ba=(Oa(),gr(za)).default,Va=async(e,t,r)=>{if(!e&&!t&&Ba&&Ve&&Kn(Ve))return[void 0,Ba];{let n=\"ort-wasm-simd-threaded.jsep.mjs\",o=e??Yp(n,t),i= true&&r&&o&&!Kn(o,t),a=i?await Ua(o):o??Zp(n,t);return[i?a:void 0,await Qp(a)]}}});var jn,Yn,Pr,Wa,Xp,Jp,xr,Te,gt=U(()=>{\"use strict\";$r();Yn=!1,Pr=!1,Wa=!1,Xp=()=>{if(typeof SharedArrayBuffer>\"u\")return!1;try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Jp=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},xr=async e=>{if(Yn)return Promise.resolve();if(Pr)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(Wa)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");Pr=!0;let t=e.initTimeout,r=e.numThreads;if(!Jp())throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");let n=Xp();r>1&&!n&&(typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+r+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"),e.numThreads=r=1);let o=e.wasmPaths,i=typeof o==\"string\"?o:void 0,a=o?.mjs,d=a?.href??a,l=o?.wasm,p=l?.href??l,m=e.wasmBinary,[u,h]=await Va(d,i,r>1),_=!1,y=[];if(t>0&&y.push(new Promise(g=>{setTimeout(()=>{_=!0,g()},t)})),y.push(new Promise((g,x)=>{let $={numThreads:r};if(m)$.wasmBinary=m;else if(p||i)$.locateFile=v=>p??i+v;else if(d&&d.indexOf(\"blob:\")!==0)$.locateFile=v=>new URL(v,d).href;else if(u){let v=Ra();v&&($.locateFile=S=>v+S)}h($).then(v=>{Pr=!1,Yn=!0,jn=v,g(),u&&URL.revokeObjectURL(u)},v=>{Pr=!1,Wa=!0,x(v)})})),await Promise.race(y),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Te=()=>{if(Yn&&jn)return jn;throw new Error(\"WebAssembly is not initialized yet.\")}});var ke,Kt,ce,zr=U(()=>{\"use strict\";gt();ke=(e,t)=>{let r=Te(),n=r.lengthBytesUTF8(e)+1,o=r._malloc(n);return r.stringToUTF8(e,o,n),t.push(o),o},Kt=(e,t,r,n)=>{if(typeof e==\"object\"&&e!==null){if(r.has(e))throw new Error(\"Circular reference in options\");r.add(e)}Object.entries(e).forEach(([o,i])=>{let a=t?t+o:o;if(typeof i==\"object\")Kt(i,a+\".\",r,n);else if(typeof i==\"string\"||typeof i==\"number\")n(a,i.toString());else if(typeof i==\"boolean\")n(a,i?\"1\":\"0\");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},ce=e=>{let t=Te(),r=t.stackSave();try{let n=t.PTR_SIZE,o=t.stackAlloc(2*n);t._OrtGetLastError(o,o+n);let i=Number(t.getValue(o,n===4?\"i32\":\"i64\")),a=t.getValue(o+n,\"*\"),d=a?t.UTF8ToString(a):\"\";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${d}`)}finally{t.stackRestore(r)}}});var La,Ga=U(()=>{\"use strict\";gt();zr();La=e=>{let t=Te(),r=0,n=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof e.logSeverityLevel!=\"number\"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!=\"number\"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let i=0;return e?.tag!==void 0&&(i=ke(e.tag,n)),r=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,i),r===0&&ce(\"Can't create run options.\"),e?.extra!==void 0&&Kt(e.extra,\"\",new WeakSet,(a,d)=>{let l=ke(a,n),p=ke(d,n);t._OrtAddRunConfigEntry(r,l,p)!==0&&ce(`Can't set a run config entry: ${a} - ${d}.`)}),[r,n]}catch(i){throw r!==0&&t._OrtReleaseRunOptions(r),n.forEach(a=>t._free(a)),i}}});var em,tm,rm,nm,Ha,Fa=U(()=>{\"use strict\";gt();zr();em=e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},tm=e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},rm=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some(r=>(typeof r==\"string\"?r:r.name)===\"webgpu\")&&(e.enableMemPattern=!1)},nm=(e,t,r)=>{for(let n of t){let o=typeof n==\"string\"?n:n.name;switch(o){case\"webnn\":if(o=\"WEBNN\",typeof n!=\"string\"){let d=n?.deviceType;if(d){let l=ke(\"deviceType\",r),p=ke(d,r);Te()._OrtAddSessionConfigEntry(e,l,p)!==0&&ce(`Can't set a session config entry: 'deviceType' - ${d}.`)}}break;case\"webgpu\":if(o=\"JS\",typeof n!=\"string\"){let a=n;if(a?.preferredLayout){if(a.preferredLayout!==\"NCHW\"&&a.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${a.preferredLayout}`);let d=ke(\"preferredLayout\",r),l=ke(a.preferredLayout,r);Te()._OrtAddSessionConfigEntry(e,d,l)!==0&&ce(`Can't set a session config entry: 'preferredLayout' - ${a.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${o}`)}let i=ke(o,r);Te()._OrtAppendExecutionProvider(e,i)!==0&&ce(`Can't append execution provider: ${o}.`)}},Ha=e=>{let t=Te(),r=0,n=[],o=e||{};rm(o);try{let i=em(o.graphOptimizationLevel??\"all\"),a=tm(o.executionMode??\"sequential\"),d=typeof o.logId==\"string\"?ke(o.logId,n):0,l=o.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let p=o.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let m=typeof o.optimizedModelFilePath==\"string\"?ke(o.optimizedModelFilePath,n):0;if(r=t._OrtCreateSessionOptions(i,!!o.enableCpuMemArena,!!o.enableMemPattern,a,!!o.enableProfiling,0,d,l,p,m),r===0&&ce(\"Can't create session options.\"),o.executionProviders&&nm(r,o.executionProviders,n),o.enableGraphCapture!==void 0){if(typeof o.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);let u=ke(\"enableGraphCapture\",n),h=ke(o.enableGraphCapture.toString(),n);t._OrtAddSessionConfigEntry(r,u,h)!==0&&ce(`Can't set a session config entry: 'enableGraphCapture' - ${o.enableGraphCapture}.`)}if(o.freeDimensionOverrides)for(let[u,h]of Object.entries(o.freeDimensionOverrides)){if(typeof u!=\"string\")throw new Error(`free dimension override name must be a string: ${u}`);if(typeof h!=\"number\"||!Number.isInteger(h)||h<0)throw new Error(`free dimension override value must be a non-negative integer: ${h}`);let _=ke(u,n);t._OrtAddFreeDimensionOverride(r,_,h)!==0&&ce(`Can't set a free dimension override: ${u} - ${h}.`)}return o.extra!==void 0&&Kt(o.extra,\"\",new WeakSet,(u,h)=>{let _=ke(u,n),y=ke(h,n);t._OrtAddSessionConfigEntry(r,_,y)!==0&&ce(`Can't set a session config entry: ${u} - ${h}.`)}),[r,n]}catch(i){throw r!==0&&t._OrtReleaseSessionOptions(r)!==0&&ce(\"Can't release session options.\"),n.forEach(a=>t._free(a)),i}}});var jt,bt,At,Or,Yt,Dr,Br,Zn,J=U(()=>{\"use strict\";jt=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;case\"int4\":return 22;case\"uint4\":return 21;default:throw new Error(`unsupported data type: ${e}`)}},bt=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";case 22:return\"int4\";case 21:return\"uint4\";default:throw new Error(`unsupported data type: ${e}`)}},At=(e,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],n=typeof t==\"number\"?t:t.reduce((o,i)=>o*i,1);return r>0?Math.ceil(n*r):void 0},Or=e=>{switch(e){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Yt=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Dr=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Br=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint64\"||e===\"int8\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Zn=e=>{switch(e){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;case\"ml-tensor\":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var Zt,Qn=U(()=>{\"use strict\";vr();Zt=async e=>{if(typeof e==\"string\")if(false){}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get(\"Content-Length\"),n=r?parseInt(r,10):0;if(n<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let o=t.body.getReader(),i;try{i=new ArrayBuffer(n)}catch(d){if(d instanceof RangeError){let l=Math.ceil(n/65536);i=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw d}let a=0;for(;;){let{done:d,value:l}=await o.read();if(d)break;let p=l.byteLength;new Uint8Array(i,a,p).set(l),a+=p}return new Uint8Array(i,0,n)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var om,im,qa,Ka,Mr,am,se,et=U(()=>{\"use strict\";J();om=[\"V\",\"I\",\"W\",\"E\",\"F\"],im=(e,t)=>{console.log(`[${om[e]},${new Date().toISOString()}]${t}`)},Mr=(e,t)=>{qa=e,Ka=t},am=(e,t)=>{let r=Yt(e),n=Yt(qa);r>=n&&im(r,typeof t==\"function\"?t():t)},se=(...e)=>{Ka&&am(...e)}});var Rr,Xn=U(()=>{\"use strict\";J();Rr=(e,t)=>new(Or(t))(e)});var Ur=U(()=>{\"use strict\"});var ja,Jn,eo,sm,um,Ya,ro,to,Qa,Xa=U(()=>{\"use strict\";et();Ur();ja=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Jn=[],eo=e=>Math.ceil(Number(e)/16)*16,sm=e=>{for(let t=0;t<Jn.length;t++){let r=Jn[t];if(e<=r)return r}return Math.ceil(e/16)*16},um=1,Ya=()=>um++,ro=async(e,t,r,n)=>{let o=eo(r),i=e.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,i,0,o),e.flush(),await i.mapAsync(GPUMapMode.READ);let d=i.getMappedRange();if(n){let l=n();return l.set(new Uint8Array(d,0,r)),l}else return new Uint8Array(d.slice(0,r))}finally{i.destroy()}},to=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[r]of ja)Jn.push(r),this.freeBuffers.set(r,[]),this.freeUniformBuffers.set(r,[]);this.sessionCount=0}upload(t,r){let n=r.buffer,o=r.byteOffset,i=r.byteLength,a=eo(i),d=this.storageCache.get(t);if(!d)throw new Error(\"gpu data for uploading does not exist\");if(Number(d.originalSize)!==i)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${i}`);let l=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=l.getMappedRange();new Uint8Array(p).set(new Uint8Array(n,o,i)),l.unmap();let m=this.backend.device.createCommandEncoder();m.copyBufferToBuffer(l,0,d.gpuData.buffer,0,a),this.backend.device.queue.submit([m.finish()]),l.destroy(),se(\"verbose\",()=>`[WebGPU] GpuDataManager.upload(id=${t})`)}memcpy(t,r){let n=this.storageCache.get(t);if(!n)throw new Error(\"source gpu data for memcpy does not exist\");let o=this.storageCache.get(r);if(!o)throw new Error(\"destination gpu data for memcpy does not exist\");if(n.originalSize!==o.originalSize)throw new Error(\"inconsistent source and destination gpu data size\");let i=eo(n.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(n.gpuData.buffer,0,o.gpuData.buffer,0,i)}registerExternalBuffer(t,r,n){let o;if(n){if(o=n[0],t===n[1])return se(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, buffer is the same, skip.`),o;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`)}else o=Ya();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:t},originalSize:r}),se(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, registered.`),o}unregisterExternalBuffer(t){t!==void 0&&(this.storageCache.delete(t),se(\"verbose\",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=sm(t),o,i=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||a){let p=(i?this.freeBuffers:this.freeUniformBuffers).get(n);p?p.length>0?o=p.pop():o=this.backend.device.createBuffer({size:n,usage:r}):o=this.backend.device.createBuffer({size:n,usage:r})}else o=this.backend.device.createBuffer({size:n,usage:r});let d={id:Ya(),type:0,buffer:o};return this.storageCache.set(d.id,{gpuData:d,originalSize:Number(t)}),se(\"verbose\",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=typeof t==\"bigint\"?Number(t):t,n=this.storageCache.get(r);if(!n){if(this.storageCache.size===0)return 0;throw new Error(\"releasing data does not exist\")}return se(\"verbose\",()=>`[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(r),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(t,r){let n=this.storageCache.get(Number(t));if(!n)throw new Error(\"data does not exist\");await ro(this.backend,n.gpuData.buffer,n.originalSize,r)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus===\"default\"){for(let t of this.buffersPending){let r=ja.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(t.size)||[];r===void 0||n.length>=r?t.destroy():n.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(t.size)||[];r===void 0||n.length>=r?t.destroy():n.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let r of this.buffersPending)t.push(r);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(t){let r=this.capturedPendingBuffers.get(t);r&&(r.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(t)),this.sessionCount-=1,this.sessionCount===0&&(se(\"warning\",()=>\"[WebGPU] Clearing webgpu buffer cache\"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Qa=(...e)=>new to(...e)});var no,ee,xe=U(()=>{\"use strict\";no=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(\";\")),this.key}},ee=e=>new no(e)});var oo,tt,k,kt,Nr,Ja,es,ne=U(()=>{\"use strict\";oo=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},tt=class{static calcShape(t,r,n=!1){let o=t.length,i=r.length;if(o===0)return r;if(i===0)return t;let a=Math.max(t.length,r.length),d=new Array(a);if(n){if(o<2||i<2)return;let l=oo.calcMatMulShape([t[o-2],t[o-1]],[r[i-2],r[i-1]]);if(l===void 0)return;[d[a-2],d[a-1]]=l}for(let l=n?3:1;l<=a;l++){let p=o-l<0?1:t[o-l],m=i-l<0?1:r[i-l];if(p!==m&&p>1&&m>1)return;let u=Math.max(p,m);if(p&&m)d[a-l]=Math.max(p,m);else{if(u>1)return;d[a-l]=0}}return d}static isValidBroadcast(t,r){let n=t.length,o=r.length;if(n>o)return!1;for(let i=1;i<=n;i++)if(t[n-i]!==1&&t[n-i]!==r[o-i])return!1;return!0}},k=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,r=4){let n=t.length;if(n===0)return[];let o=new Array(n),i=n-1;for(;i>=0;){if(t[i]%r===0){o[i]=t[i]/r;break}if(r%t[i]!==0)throw new Error(\"cannot convert shape\");o[i]=1,r/=t[i],i--}for(i--;i>=0;i--)o[i]=t[i];return o}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,n){let o=1;for(let i=r;i<n;i++){if(t[i]<0)throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains negative values in them.\");o*=Number(t[i])}return o}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let n=new Array(r);n[r-1]=1,n[r-2]=t[r-1];for(let o=r-3;o>=0;--o)n[o]=n[o+1]*t[o+1];return n}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error(\"unsupported axis for this operation.\");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(n=>this.normalizeAxis(n,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(n=>t[n]):t.slice().reverse()}static padShape(t,r){let n=t.length;return t.map((o,i)=>o+r[i]+r[i+n])}static areEqual(t,r){return t.length!==r.length?!1:t.every((n,o)=>n===r[o])}},kt=class e{static adjustPoolAttributes(t,r,n,o,i,a){if(!t&&n.length!==r.length-2)throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");if(t)for(let d=0;d<r.length-2;d++)d>=n.length?n.push(r[d+2]):n[d]=r[d+2];for(let d=0;d<n.length;d++)if(d<o.length){if(o[d]<0)throw new Error(\"strides should be greater than or equal to 1\")}else o.push(1);for(let d=0;d<n.length;d++)if(d<i.length){if(i[d]<0)throw new Error(\"dilations should be greater than or equal to 1\")}else i.push(1);for(let d=0;d<n.length*2;d++)if(d<a.length){if(a[d]<0)throw new Error(\"pad should be greater than or equal to 1\")}else a.push(0);for(let d=0;d<n.length;d++){if(n[d]<=0)throw new Error(\"kernel shapes need to be greater than 0\");if(a[d]>=n[d]||a[d+n.length]>=n[d])throw new Error(\"pads should be smaller than kernel\")}}static adjustPadsBasedOnAutoPad(t,r,n,o,i,a,d){if(d){if(i.length!==2*(t.length-2))throw new Error(\"length of pads should be twice the length of data dimensions\");if(r.length!==t.length-2)throw new Error(\"length of strides should be the length of data dimensions\");if(o.length!==t.length-2)throw new Error(\"length of kernel shapes should be the length of data dimensions\");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(a?1:2)],r[l],n[l],o[l],i,l,l+t.length-2,d)}}static computePoolOutputShape(t,r,n,o,i,a,d){if(r.length<=0)throw new Error(\"input shape must be of size greater than 0\");let l=[r[0],r[1]];return e.computeShapeHelper(t,r,l,n,o,i,a,d),l}static computeConvOutputShape(t,r,n,o,i,a,d){if(t.length<=0||r.length<=0)throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");let l=[t[0],r[0]];return e.computeShapeHelper(!1,t,l,n,o,i,a,d),l}static computeShapeHelper(t,r,n,o,i,a,d,l){if(t)for(let p=0;p<r.length-2;p++)n.push(1);else for(let p=0;p<r.length-2;p++)n.push(e.adjustPadAndReturnShape(r[p+2],o[p],i[p],a[p],d,p,p+r.length-2,l))}static adjustPadAndReturnShape(t,r,n,o,i,a,d,l){let p=n*(o-1)+1;if(l&&l!==\"NOTSET\")switch(l){case\"VALID\":return i[a]=0,i[d]=0,Math.floor((t-p)/r+1);case\"SAME_LOWER\":case\"SAME_UPPER\":if(n!==1)throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");{let u=((t+r-1)/r-1)*r+o-t;return i[a]=Math.floor(l===\"SAME_LOWER\"?(u+1)/2:u/2),i[d]=u-i[a],Math.floor((t+u-o)/r+1)}default:throw new Error(\"Unsupported AutoPad type\")}else return Math.floor((t+i[a]+i[d]-p)/r+1)}},Nr=class{static getShapeOfGemmResult(t,r,n,o,i){if(t.length!==2||n.length!==2)throw new Error(\"shape need to be of size 2\");let a,d,l;r?(a=t[1],d=t[0]):(a=t[0],d=t[1]);let p=-1;if(o?(l=n[0],p=1):(l=n[1],p=0),n[p]!==d)throw new Error(\"dimension mismatch\");if(a<=0||l<=0||d<=0)throw new Error(\"invalid shape specified\");if(i&&!tt.isValidBroadcast(i,[a,l]))throw new Error(\"gemm: invalid bias shape for broadcast\");return[a,l,d]}},Ja=-34028234663852886e22,es=34028234663852886e22});var Et,ao,ye,Ee,N,me,so,Pt,qe,q,Vr,E,M,ts,Wr,io,rs,ae=U(()=>{\"use strict\";J();ne();Et=64,ao=(e,t)=>{if(t===3)throw new Error(\"vec3 has same alignment as vec4, use vec4 instead\");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:\"f16\";case 1:return t>1?`vec${t}<f32>`:\"f32\";case 6:return t>1?`vec${t}<i32>`:\"i32\";case 12:return t>1?`vec${t}<u32>`:\"u32\";case 7:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"i32\"];case 13:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"u32\"];case 9:if(t!==4)throw new Error(\"bool must be vec4\");return[\"u32\",\"vec4<bool>\"];case 22:return\"i32\";case 21:return\"u32\";default:throw new Error(`Unknown data type: ${e}`)}},ye=(e,t=1)=>{let r=ao(e,t);return typeof r==\"string\"?r:r[0]},Ee=(e,t=1)=>{let r=ao(e,t);return typeof r==\"string\"?r:r[1]},N=(...e)=>{let t=[];return e.forEach(r=>{r.length!==0&&t.push({type:12,data:r},{type:12,data:k.computeStrides(r)})}),t},me=e=>e%4===0?4:e%2===0?2:1,so=(e=\"f32\",t,r=\"0\")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,Pt=(e,t,r)=>e===\"f32\"?r:t===1?`f32(${r})`:`vec${t}<f32>(${r})`,qe=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,q=(e,t,r,n)=>e.startsWith(\"uniforms.\")&&r>4?typeof t==\"string\"?n===\"f16\"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:n===\"f16\"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,Vr=(e,t,r,n,o)=>{let i=typeof r==\"number\",a=i?r:r.length,d=[...new Array(a).keys()],l=a<2?\"u32\":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,p=ao(t,o),m=typeof p==\"string\"?p:p[1],u=typeof p==\"string\"?p:p[0],h={indices:l,value:m,storage:u,tensor:t},_=W=>typeof W==\"string\"?W:`${W}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},g=i?\"uniforms.\":\"\",x=`${g}${e}_shape`,$=`${g}${e}_strides`,v=\"\";for(let W=0;W<a-1;W++)v+=`\n    let dim${W} = current / ${q($,W,a)};\n    let rest${W} = current % ${q($,W,a)};\n    indices[${W}] = dim${W};\n    current = rest${W};\n    `;v+=`indices[${a-1}] = current;`;let S=a<2?\"\":`\n  fn o2i_${e}(offset: u32) -> ${h.indices} {\n    var indices: ${h.indices};\n    var current = offset;\n    ${v}\n    return indices;\n  }`,T=W=>(y.offsetToIndices=!0,a<2?W:`o2i_${e}(${W})`),A=[];if(a>=2)for(let W=a-1;W>=0;W--)A.push(`${q($,W,a)} * (indices[${W}])`);let C=a<2?\"\":`\n  fn i2o_${e}(indices: ${h.indices}) -> u32 {\n    return ${A.join(\"+\")};\n  }`,P=W=>(y.indicesToOffset=!0,a<2?W:`i2o_${e}(${W})`),D=(...W)=>a===0?\"0u\":`${h.indices}(${W.map(_).join(\",\")})`,R=(W,Y)=>a<2?`${W}`:`${q(W,Y,a)}`,H=(W,Y,he)=>a<2?`${W}=${he};`:`${q(W,Y,a)}=${he};`,L={},re=(W,Y)=>{y.broadcastedIndicesToOffset=!0;let he=`${Y.name}broadcastedIndicesTo${e}Offset`;if(he in L)return`${he}(${W})`;let De=[];for(let pe=a-1;pe>=0;pe--){let Ie=Y.indicesGet(\"outputIndices\",pe+Y.rank-a);De.push(`${R($,pe)} * (${Ie} % ${R(x,pe)})`)}return L[he]=`fn ${he}(outputIndices: ${Y.type.indices}) -> u32 {\n             return ${De.length>0?De.join(\"+\"):\"0u\"};\n           }`,`${he}(${W})`},V=(W,Y)=>(()=>{if(h.storage===h.value)return`${e}[${W}]=${Y};`;if(h.storage===\"vec2<u32>\"&&h.value===\"i32\")return`${e}[${W}]=vec2<u32>(u32(${Y}), select(0u, 0xFFFFFFFFu, ${Y} < 0));`;if(h.storage===\"vec2<u32>\"&&h.value===\"u32\")return`${e}[${W}]=vec2<u32>(u32(${Y}), 0u);`;if(h.storage===\"u32\"&&h.value===\"vec4<bool>\")return`${e}[${W}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Y}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),K=W=>(()=>{if(h.storage===h.value)return`${e}[${W}]`;if(h.storage===\"vec2<u32>\"&&h.value===\"i32\")return`i32(${e}[${W}].x)`;if(h.storage===\"vec2<u32>\"&&h.value===\"u32\")return`u32(${e}[${W}].x)`;if(h.storage===\"u32\"&&h.value===\"vec4<bool>\")return`vec4<bool>(bool(${e}[${W}] & 0xFFu), bool(${e}[${W}] & 0xFF00u), bool(${e}[${W}] & 0xFF0000u), bool(${e}[${W}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),we=a<2?\"\":`\n  fn get_${e}ByIndices(indices: ${h.indices}) -> ${m} {\n    return ${K(`i2o_${e}(indices)`)};\n  }`,j=a<2?\"\":(()=>{let W=d.map(he=>`d${he}: u32`).join(\", \"),Y=d.map(he=>`d${he}`).join(\", \");return`\n  fn get_${e}(${W}) -> ${m} {\n    return get_${e}ByIndices(${D(Y)});\n  }`})(),Q=(...W)=>{if(W.length!==a)throw new Error(`indices length must be ${a}`);let Y=W.map(_).join(\",\");return a===0?K(\"0u\"):a===1?K(Y[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}(${Y})`)},ie=W=>a<2?K(W):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}ByIndices(${W})`),te=a<2?\"\":`\n  fn set_${e}ByIndices(indices: ${h.indices}, value: ${m}) {\n    ${V(`i2o_${e}(indices)`,\"value\")}\n  }`,be=a<2?\"\":(()=>{let W=d.map(he=>`d${he}: u32`).join(\", \"),Y=d.map(he=>`d${he}`).join(\", \");return`\n  fn set_${e}(${W}, value: ${m}) {\n    set_${e}ByIndices(${D(Y)}, value);\n  }`})();return{impl:()=>{let W=[],Y=!1;return y.offsetToIndices&&(W.push(S),Y=!0),y.indicesToOffset&&(W.push(C),Y=!0),y.broadcastedIndicesToOffset&&(Object.values(L).forEach(he=>W.push(he)),Y=!0),y.set&&(W.push(be),Y=!0),y.setByIndices&&(W.push(te),Y=!0),y.get&&(W.push(j),Y=!0),y.getByIndices&&(W.push(we),Y=!0),!i&&Y&&W.unshift(`const ${x} = ${h.indices}(${r.join(\",\")});`,`const ${$} = ${h.indices}(${k.computeStrides(r).join(\",\")});`),W.join(`\n`)},type:h,offsetToIndices:T,indicesToOffset:P,broadcastedIndicesToOffset:re,indices:D,indicesGet:R,indicesSet:H,set:(...W)=>{if(W.length!==a+1)throw new Error(`indices length must be ${a}`);let Y=W[a];if(typeof Y!=\"string\")throw new Error(\"value must be string\");let he=W.slice(0,a).map(_).join(\",\");return a===0?V(\"0u\",Y):a===1?V(he[0],Y):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}(${he}, ${Y})`)},setByOffset:V,setByIndices:(W,Y)=>a<2?V(W,Y):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}ByIndices(${W}, ${Y});`),get:Q,getByOffset:K,getByIndices:ie,usage:n,name:e,strides:$,shape:x,rank:a}},E=(e,t,r,n=1)=>Vr(e,t,r,\"input\",n),M=(e,t,r,n=1)=>Vr(e,t,r,\"output\",n),ts=(e,t,r)=>Vr(e,t,r,\"atomicOutput\",1),Wr=(e,t,r,n=1)=>Vr(e,t,r,\"internal\",n),io=class{constructor(t,r){this.normalizedDispatchGroup=t;this.limits=r;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t==\"number\"?`${t}u`:t}) { return; }`}mainStart(t=Et){let r=typeof t==\"number\"?t:t[0],n=typeof t==\"number\"?1:t[1],o=typeof t==\"number\"?1:t[2];if(r>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||o>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(r*n*o>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,a=i?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=i?`let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${r*n*o}u + local_idx;`;return`@compute @workgroup_size(${r}, ${n}, ${o})\n  fn main(${a}) {\n    ${d}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.shape.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}),t.strides.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.strides.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}))}declareVariable(t,r){if(t.usage===\"internal\")throw new Error(\"cannot use internal variable with declareVariable(). use registerInternalVariables() instead.\");this.variables.push(t),this.appendVariableUniforms(t);let n=t.usage===\"input\"?\"read\":\"read_write\",o=t.usage===\"atomicOutput\"?\"atomic<i32>\":t.type.storage;return`@group(0) @binding(${r}) var<storage, ${n}> ${t.name}: array<${o}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!==\"internal\")throw new Error(\"cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.\");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,n=1){return this.uniforms.push({name:t,type:r,length:n}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return\"\";let t=[];for(let{name:r,type:n,length:o}of this.uniforms)if(o&&o>4)n===\"f16\"?t.push(`@align(16) ${r}:array<mat2x4<${n}>, ${Math.ceil(o/8)}>`):t.push(`${r}:array<vec4<${n}>, ${Math.ceil(o/4)}>`);else{let i=o==null||o===1?n:`vec${o}<${n}>`;t.push(`${r}:${i}`)}return`\n      struct Uniforms { ${t.join(\", \")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=r=>[12,10,1,6][[\"u32\",\"f16\",\"f32\",\"i32\"].indexOf(r)];return this.uniforms.map(r=>[t(r.type),r.length??1])}},rs=(e,t)=>new io(e,t)});var dm,ns,lm,cm,pm,mm,Pe,os,is,dt=U(()=>{\"use strict\";J();ne();xe();ae();dm=(e,t)=>{if(!e||e.length!==1)throw new Error(\"Transpose requires 1 input.\");if(t.length!==0&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},ns=(e,t)=>t.length!==0?t:[...new Array(e).keys()].reverse(),lm=(e,t)=>k.sortBasedOnPerm(e,ns(e.length,t)),cm=(e,t,r,n)=>{let o=`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`;for(let i=0;i<t;++i)o+=`a[${e[i]}]=i[${i}];`;return o+=\"return a;}\"},pm=(e,t)=>{let r=[],n=[];for(let o=0;o<e.length;++o)e[o]!==1&&r.push(e[o]),e[t[o]]!==1&&n.push(t[o]);return{newShape:r,newPerm:n}},mm=(e,t)=>{let r=0;for(let n=0;n<e.length;++n)if(t[e[n]]!==1){if(e[n]<r)return!1;r=e[n]}return!0},Pe=(e,t)=>{let r=e.dataType,n=e.dims.length,o=ns(n,t),i=lm(e.dims,o),a=e.dims,d=i,l=n<2||mm(o,e.dims),p;if(l)return p=g=>{let x=E(\"input\",r,a,4),$=M(\"output\",r,d,4);return`\n  ${g.registerUniform(\"output_size\",\"u32\").declareVariables(x,$)}\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    output[global_idx] = input[global_idx];\n  }`},{name:\"TransposeCopy\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let g=k.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64/4)},programUniforms:[{type:12,data:Math.ceil(g/4)}]}},getShaderSource:p};let{newShape:m,newPerm:u}=pm(e.dims,o),h=k.areEqual(u,[2,3,1]),_=k.areEqual(u,[3,1,2]);if(m.length===2||h||_){a=h?[m[0],m[1]*m[2]]:_?[m[0]*m[1],m[2]]:m,d=[a[1],a[0]];let g=16;return p=x=>{let $=E(\"a\",r,a.length),v=M(\"output\",r,d.length);return`\n  ${x.registerUniform(\"output_size\",\"u32\").declareVariables($,v)}\n  var<workgroup> tile : array<array<${v.type.value}, ${g+1}>, ${g}>;\n  ${x.mainStart([g,g,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${g} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${g}u + local_id.x;\n    let input_row = workgroup_id_x * ${g}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${$.getByIndices(`${$.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${g}u + local_id.x;\n    let output_row = workgroup_id_y * ${g}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${v.setByIndices(`${v.type.indices}(output_row, output_col)`,\"tile[local_id.x][local_id.y]\")}\n    }\n  }`},{name:\"TransposeShared\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let x=k.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d[1]/g),y:Math.ceil(d[0]/g)},programUniforms:[{type:12,data:x},...N(a,d)]}},getShaderSource:p}}return p=g=>{let x=E(\"a\",r,a.length),$=M(\"output\",r,d.length);return`\n  ${g.registerUniform(\"output_size\",\"u32\").declareVariables(x,$)}\n\n  ${cm(o,n,x,$)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${$.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${$.setByOffset(\"global_idx\",x.getByIndices(\"aIndices\"))}\n  }`},{name:\"Transpose\",shaderCache:{hint:`${t}`,inputDependencies:[\"rank\"]},getRunData:()=>{let g=k.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:12,data:g},...N(a,d)]}},getShaderSource:p}},os=(e,t)=>{dm(e.inputs,t.perm),e.compute(Pe(e.inputs[0],t.perm))},is=e=>ee({perm:e.perm})});var fm,hm,gm,bm,ym,_m,wm,vm,$m,xm,rt,as,ss,us,ds,ls,cs,ps,ms,fs,hs,gs=U(()=>{\"use strict\";J();ne();ae();Lr();dt();fm={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate * candidate\",logSumExp:\"bestValue + exp(candidate)\",l1:\"bestValue + abs(candidate)\",l2:\"bestValue + candidate * candidate\",logSum:\"bestValue + candidate\"},hm={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate\",logSumExp:\"bestValue + candidate\",l1:\"bestValue + candidate\",l2:\"bestValue + candidate\",logSum:\"bestValue + candidate\"},gm={max:\"_A[offset]\",min:\"_A[offset]\",mean:\"0\",sum:\"0\",prod:\"1\",sumSquare:\"0\",logSumExp:\"0\",l1:\"0\",l2:\"0\",logSum:\"0\"},bm={max:\"bestValue\",min:\"bestValue\",sum:\"bestValue\",prod:\"bestValue\",sumSquare:\"bestValue\",logSumExp:\"log(bestValue)\",l1:\"bestValue\",l2:\"sqrt(bestValue)\",logSum:\"log(bestValue)\"},ym=(e,t)=>{let r=[];for(let n=t-e;n<t;++n)r.push(n);return r},_m=(e,t)=>{let r=[],n=e.length;for(let i=0;i<n;i++)t.indexOf(i)===-1&&r.push(e[i]);let o=t.map(i=>e[i]);return[r,o]},wm=(e,t)=>{let r=e.length+t.length,n=[],o=0;for(let i=0;i<r;i++)t.indexOf(i)===-1?n.push(e[o++]):n.push(1);return n},vm=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},$m=(e,t)=>{let r=[];if(!vm(e,t)){for(let n=0;n<t;++n)e.indexOf(n)===-1&&r.push(n);e.forEach(n=>r.push(n))}return r},xm=(e,t,r,n,o,i,a)=>{let d=r[0].dims,l=k.size(i),p=k.size(a),m=E(\"_A\",r[0].dataType,d),u=M(\"output\",o,i),h=64;l===1&&(h=256);let _=`\n          var<workgroup> aBestValues : array<f32, ${h}>;\n       `,y=g=>`\n        ${g.registerUniform(\"reduceSize\",\"u32\").declareVariables(m,u)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${g.mainStart(h)}\n\n          let outputIndex = global_idx / ${h};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${gm[n]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${h}) {\n           let candidate = f32(${m.getByOffset(\"offset + k\")});\n           bestValue = ${fm[n]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${h}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${hm[n]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${u.setByOffset(\"outputIndex\",`${n===\"mean\"?`${u.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${u.type.storage}(${bm[n]})`}`)};\n         }\n        }`;return{name:e,shaderCache:{hint:`${t};${h}`,inputDependencies:[\"type\"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:i,dataType:o}],dispatchGroup:{x:l},programUniforms:[{type:12,data:p}]})}},rt=(e,t,r,n)=>{let o=e.inputs.length===1?r:uo(e.inputs,r),i=o.axes;i.length===0&&!o.noopWithEmptyAxes&&(i=e.inputs[0].dims.map((_,y)=>y));let a=k.normalizeAxes(i,e.inputs[0].dims.length),d=a,l=e.inputs[0],p=$m(d,e.inputs[0].dims.length);p.length>0&&(l=e.compute(Pe(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],d=ym(d.length,l.dims.length));let[m,u]=_m(l.dims,d),h=m;o.keepDims&&(h=wm(m,a)),e.compute(xm(t,o.cacheKey,[l],n,e.inputs[0].dataType,h,u),{inputs:[l]})},as=(e,t)=>{rt(e,\"ReduceMeanShared\",t,\"mean\")},ss=(e,t)=>{rt(e,\"ReduceL1Shared\",t,\"l1\")},us=(e,t)=>{rt(e,\"ReduceL2Shared\",t,\"l2\")},ds=(e,t)=>{rt(e,\"ReduceLogSumExpShared\",t,\"logSumExp\")},ls=(e,t)=>{rt(e,\"ReduceMaxShared\",t,\"max\")},cs=(e,t)=>{rt(e,\"ReduceMinShared\",t,\"min\")},ps=(e,t)=>{rt(e,\"ReduceProdShared\",t,\"prod\")},ms=(e,t)=>{rt(e,\"ReduceSumShared\",t,\"sum\")},fs=(e,t)=>{rt(e,\"ReduceSumSquareShared\",t,\"sumSquare\")},hs=(e,t)=>{rt(e,\"ReduceLogSumShared\",t,\"logSum\")}});var nt,Sm,Gr,uo,ot,Tm,Im,Cm,Am,km,Em,Pm,zm,Om,Dm,it,bs,ys,_s,ws,vs,$s,xs,Ss,Ts,Is,Lr=U(()=>{\"use strict\";J();ne();xe();ae();gs();nt=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"Reduce op requires 1 or 2 inputs.\");if(e.length===2&&e[1].dims.length!==1)throw new Error(\"Invalid axes input dims.\")},Sm=e=>[\"\",\"\",`var value = ${e.getByIndices(\"input_indices\")};`,\"\"],Gr=(e,t,r,n,o,i,a=!1,d=!1)=>{let l=[],p=r[0].dims,m=p.length,u=k.normalizeAxes(o,m),h=!d&&u.length===0;p.forEach((x,$)=>{h||u.indexOf($)>=0?a&&l.push(1):l.push(x)});let _=l.length,y=k.size(l);return{name:e,shaderCache:t,getShaderSource:x=>{let $=[],v=E(\"_A\",r[0].dataType,m),S=M(\"output\",i,_),T=n(v,S,u),A=T[2];for(let C=0,P=0;C<m;C++)h||u.indexOf(C)>=0?(a&&P++,A=`for(var j${C}: u32 = 0; j${C} < ${p[C]}; j${C}++) {\n                  ${T[2].includes(\"last_index\")?`let last_index = j${C};`:\"\"}\n                  ${v.indicesSet(\"input_indices\",C,`j${C}`)}\n                  ${A}\n                }`):($.push(`${v.indicesSet(\"input_indices\",C,S.indicesGet(\"output_indices\",P))};`),P++);return`\n\n        ${x.registerUniform(\"output_size\",\"u32\").declareVariables(v,S)}\n\n        ${x.mainStart()}\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          var input_indices: ${v.type.indices};\n          let output_indices = ${S.offsetToIndices(\"global_idx\")};\n\n          ${$.join(`\n`)}\n          ${T[0]}       // init ops for reduce max/min\n          ${T[1]}\n          ${A}\n          ${T[3]}\n          ${T.length===4?S.setByOffset(\"global_idx\",\"value\"):T.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:i}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...N(p,l)]})}},uo=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),ee({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},ot=(e,t,r,n)=>{let o=e.inputs,i=o.length===1?r:uo(o,r);e.compute(Gr(t,{hint:i.cacheKey,inputDependencies:[\"rank\"]},[o[0]],i.noopWithEmptyAxes&&i.axes.length===0?Sm:n,i.axes,o[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},Tm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceLogSum\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${n.getByIndices(\"input_indices\")};`,\"value = log(value);\"])},Im=(e,t)=>{nt(e.inputs),ot(e,\"ReduceL1\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += abs(${n.getByIndices(\"input_indices\")});`,\"\"])},Cm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceL2\",t,(n,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${n.getByIndices(\"input_indices\")}; value += (t * t);`,\"value = sqrt(value);\"])},Am=(e,t)=>{nt(e.inputs),ot(e,\"ReduceLogSumExp\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += exp(${n.getByIndices(\"input_indices\")});`,\"value = log(value);\"])},km=(e,t)=>{nt(e.inputs),ot(e,\"ReduceMax\",t,(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(n.indicesSet(\"input_indices\",d,0));return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};`,`value = max(value, ${n.getByIndices(\"input_indices\")});`,\"\"]})},Em=(e,t)=>{nt(e.inputs),ot(e,\"ReduceMean\",t,(n,o,i)=>{let a=1;for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&(a*=e.inputs[0].dims[d]);return[\"var sum = f32(0);\",\"\",`sum += f32(${n.getByIndices(\"input_indices\")});`,`let value = ${o.type.value}(sum / ${a});`]})},Pm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceMin\",t,(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(`input_indices[${d}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};`,`value = min(value, ${n.getByIndices(\"input_indices\")});`,\"\"]})},zm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceProd\",t,(n,o)=>[`var value = ${o.type.storage}(1);`,\"\",`value *= ${n.getByIndices(\"input_indices\")};`,\"\"])},Om=(e,t)=>{nt(e.inputs),ot(e,\"ReduceSum\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${n.getByIndices(\"input_indices\")};`,\"\"])},Dm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceSumSquare\",t,(n,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${n.getByIndices(\"input_indices\")}; value += t * t;`,\"\"])},it=(e,t,r)=>{if(t.length===0)return r;let n=1,o=1;for(let i=0;i<t.length;i++)t.indexOf(i)===-1?n*=e[i]:o*=e[i];return o<32&&n>1024},bs=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Em(e,t):as(e,t)},ys=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Im(e,t):ss(e,t)},_s=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Cm(e,t):us(e,t)},ws=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Am(e,t):ds(e,t)},vs=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?km(e,t):ls(e,t)},$s=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Pm(e,t):cs(e,t)},xs=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?zm(e,t):ps(e,t)},Ss=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Om(e,t):ms(e,t)},Ts=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Dm(e,t):fs(e,t)},Is=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Tm(e,t):hs(e,t)}});var Cs,As,ks,lo,Es=U(()=>{\"use strict\";J();xe();Lr();Cs=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"ArgMinMaxOp op requires 1 or 2 inputs.\");if(e[0].dataType!==1)throw new Error(\"Invalid input type.\")},As=(e,t)=>{Cs(e.inputs);let r=(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(`input_indices[${d}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${n.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\"<=\":\"<\"} value) {\n         value = ${n.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Gr(\"ArgMin\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ks=(e,t)=>{Cs(e.inputs);let r=(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(`input_indices[${d}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${n.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\">=\":\">\"} value) {\n         value = ${n.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Gr(\"argMax\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},lo=e=>ee(e)});var Bm,co,Mm,Rm,Um,Ut,Nm,Ps,Hr=U(()=>{\"use strict\";J();ne();Ur();ae();Bm=(e,t)=>{let r=e[0],n=e[1],o=e[2],i=e[3],a=e[4],d=e[5];if(a&&d)throw new Error(\"Attention cannot have both past and attention_bias\");if(r.dims.length!==3)throw new Error('Input \"input\" must have 3 dimensions');let l=r.dims[0],p=r.dims[1],m=r.dims[2];if(o.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimensions');if(n.dims.length!==2)throw new Error('Input \"weights\" is expected to have 2 dimensions');if(n.dims[0]!==m)throw new Error(\"Input 1 dimension 0 should have same length as dimension 2 of input 0\");if(o.dims[0]!==n.dims[1])throw new Error('Input \"bias\" dimension 0 should have same length as dimension 1 of input \"weights\"');let u=o.dims[0]/3,h=u,_=h;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error(\"qkv_hidden_sizes attribute should have 3 elements\");for(let S of t.qkvHiddenSizes)if(S%t.numHeads!==0)throw new Error(\"qkv_hidden_sizes should be divisible by num_heads\");u=t.qkvHiddenSizes[0],h=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let y=p;if(u!==h)throw new Error(\"qkv_hidden_sizes first element should be same as the second\");if(o.dims[0]!==u+h+_)throw new Error('Input \"bias\" dimension 0 should have same length as sum of Q/K/V hidden sizes');let g=0;if(a){if(h!==_)throw new Error('Input \"past\" expect k_hidden_size == v_hidden_size');if(a.dims.length!==5)throw new Error('Input \"past\" must have 5 dimensions');if(a.dims[0]!==2)throw new Error('Input \"past\" first dimension must be 2');if(a.dims[1]!==l)throw new Error('Input \"past\" second dimension must be batch_size');if(a.dims[2]!==t.numHeads)throw new Error('Input \"past\" third dimension must be num_heads');if(a.dims[4]!==h/t.numHeads)throw new Error('Input \"past\" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(g=a.dims[3])}let x=y+g,$=-1,v=0;if(i)throw new Error(\"Mask not supported\");if(a)throw new Error(\"past is not supported\");if(d){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" must have 4 dimensions');if(d.dims[0]!==l||d.dims[1]!==t.numHeads||d.dims[2]!==p||d.dims[3]!==x)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:p,pastSequenceLength:g,kvSequenceLength:y,totalSequenceLength:x,maxSequenceLength:$,inputHiddenSize:m,hiddenSize:u,vHiddenSize:_,headSize:Math.floor(u/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:v,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},co=(e,t,r)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset(\"0\")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset(\"batchIdx\")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${r?\"let past_sequence_length = uniforms.past_sequence_length\":\"\"};\n    let present_sequence_length = total_sequence_length;\n    `,Mm=(e,t,r,n,o,i,a,d)=>{let l=me(a?1:i),p=64,m=i/l;m<p&&(p=32);let u=Math.ceil(i/l/p),h=[{type:12,data:t},{type:12,data:r},{type:12,data:n},{type:12,data:o},{type:12,data:m},{type:12,data:u}],_=ye(e.dataType,l),y=Ee(1,l),g=[\"type\"];a&&g.push(\"type\"),d&&g.push(\"type\");let x=$=>{let v=M(\"x\",e.dataType,e.dims,l),S=[v],T=a?E(\"seq_lens\",a.dataType,a.dims):void 0;T&&S.push(T);let A=d?E(\"total_sequence_length_input\",d.dataType,d.dims):void 0;A&&S.push(A);let C=Ee(e.dataType),P=[{name:\"batch_size\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"sequence_length\",type:\"u32\"},{name:\"total_sequence_length\",type:\"u32\"},{name:\"elements_per_thread\",type:\"u32\"}];return`\n  var<workgroup> thread_max: array<f32, ${p}>;\n  var<workgroup> thread_sum: array<f32, ${p}>;\n  ${$.registerUniforms(P).declareVariables(...S)}\n  ${$.mainStart([p,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${co(T,A,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${p}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${a?\"u32(past_sequence_length + workgroup_id.y + 1)\":\"total_sequence_length\"};\n    var thread_max_vector = ${y}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${y}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return\"thread_max_vector\";case 2:return\"max(thread_max_vector.x, thread_max_vector.y)\";case 4:return\"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${p}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${y}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${y}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return\"sum_vector\";case 2:return\"sum_vector.x + sum_vector.y\";case 4:return\"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${p}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${v.type.value}(${C}(1.0) / ${C}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${y}(x[offset + i]);\n        x[offset + i] = ${v.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${a?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${v.type.value}(${C}(0));\n        }`:\"\"};\n  }`};return{name:\"AttentionProbsSoftmax\",shaderCache:{hint:`${p};${_};${l}`,inputDependencies:g},getShaderSource:x,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(i/p),y:o,z:t*r},programUniforms:h})}},Rm=(e,t,r,n,o,i,a,d,l)=>{let p=a+i.kvSequenceLength,m=[i.batchSize,i.numHeads,i.sequenceLength,p],u=e>1&&n,h=i.kvNumHeads?i.kvNumHeads:i.numHeads,_=u?[i.batchSize,h,p,i.headSize]:void 0,y=i.nReps?i.nReps:1,g=i.scale===0?1/Math.sqrt(i.headSize):i.scale,x=me(i.headSize),$=i.headSize/x,v=12,S={x:Math.ceil(p/v),y:Math.ceil(i.sequenceLength/v),z:i.batchSize*i.numHeads},T=[{type:12,data:i.sequenceLength},{type:12,data:$},{type:12,data:p},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:1,data:g},{type:12,data:a},{type:12,data:i.kvSequenceLength},{type:12,data:y}],A=u&&n&&k.size(n.dims)>0,C=[\"type\",\"type\"];A&&C.push(\"type\"),o&&C.push(\"type\"),d&&C.push(\"type\"),l&&C.push(\"type\");let P=[{dims:m,dataType:t.dataType,gpuDataType:0}];u&&P.push({dims:_,dataType:t.dataType,gpuDataType:0});let D=R=>{let H=E(\"q\",t.dataType,t.dims,x),L=E(\"key\",r.dataType,r.dims,x),re=[H,L];if(A){let te=E(\"past_key\",n.dataType,n.dims,x);re.push(te)}o&&re.push(E(\"attention_bias\",o.dataType,o.dims));let V=d?E(\"seq_lens\",d.dataType,d.dims):void 0;V&&re.push(V);let K=l?E(\"total_sequence_length_input\",l.dataType,l.dims):void 0;K&&re.push(K);let we=M(\"output\",t.dataType,m),j=[we];u&&j.push(M(\"present_key\",t.dataType,_,x));let Q=Ee(1,x),ie=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${v}u;\n\n  var<workgroup> tileQ: array<${H.type.storage}, ${v*v}>;\n  var<workgroup> tileK: array<${H.type.storage}, ${v*v}>;\n  ${R.registerUniforms(ie).declareVariables(...re,...j)}\n  ${R.mainStart([v,v,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${y===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n    let kv_num_heads = ${y===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${co(V,K,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${A&&u?\"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;\":\"\"};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${u?\"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;\":\"\"}\n    var value = ${Q}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${(()=>A&&u?`\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }`:`\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }`)()}\n      ${u?`if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }`:\"\"}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${Q}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(x){case 1:return\"value\";case 2:return\"value.x + value.y\";case 4:return\"value.x + value.y + value.z + value.w\";default:throw new Error(`Unsupported components: ${x}`)}})()};\n        output[outputIdx] = ${we.type.value} (sum * uniforms.alpha) + ${o?\"attention_bias[outputIdx]\":\"0.0\"};\n    }\n  }`};return{name:\"AttentionProbs\",shaderCache:{hint:`${x};${o!==void 0};${n!==void 0};${e}`,inputDependencies:C},getRunData:()=>({outputs:P,dispatchGroup:S,programUniforms:T}),getShaderSource:D}},Um=(e,t,r,n,o,i,a=void 0,d=void 0)=>{let l=i+o.kvSequenceLength,p=o.nReps?o.nReps:1,m=o.vHiddenSize*p,u=e>1&&n,h=o.kvNumHeads?o.kvNumHeads:o.numHeads,_=u?[o.batchSize,h,l,o.headSize]:void 0,y=[o.batchSize,o.sequenceLength,m],g=12,x={x:Math.ceil(o.vHeadSize/g),y:Math.ceil(o.sequenceLength/g),z:o.batchSize*o.numHeads},$=[{type:12,data:o.sequenceLength},{type:12,data:l},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:o.headSize},{type:12,data:m},{type:12,data:i},{type:12,data:o.kvSequenceLength},{type:12,data:p}],v=u&&n&&k.size(n.dims)>0,S=[\"type\",\"type\"];v&&S.push(\"type\"),a&&S.push(\"type\"),d&&S.push(\"type\");let T=[{dims:y,dataType:t.dataType,gpuDataType:0}];u&&T.push({dims:_,dataType:t.dataType,gpuDataType:0});let A=C=>{let P=E(\"probs\",t.dataType,t.dims),D=E(\"v\",r.dataType,r.dims),R=[P,D];v&&R.push(E(\"past_value\",n.dataType,n.dims));let H=a?E(\"seq_lens\",a.dataType,a.dims):void 0;a&&R.push(H);let L=d?E(\"total_sequence_length_input\",d.dataType,d.dims):void 0;d&&R.push(L);let V=[M(\"output\",t.dataType,y)];u&&V.push(M(\"present_value\",t.dataType,_));let K=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"v_hidden_size\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${g}u;\n  var<workgroup> tileQ: array<${P.type.value}, ${g*g}>;\n  var<workgroup> tileV: array<${P.type.value}, ${g*g}>;\n  ${C.registerUniforms(K).declareVariables(...R,...V)}\n  ${C.mainStart([g,g,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${p===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n   let kv_num_heads = ${p===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${co(H,L,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${v&&u?\"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;\":\"\"};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${u?\"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;\":\"\"}\n   var value = ${P.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${(()=>v&&u?`\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      `:`\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }`)()}\n        ${u?`\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }`:\"\"}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`};return{name:\"AttentionScore\",shaderCache:{hint:`${n!==void 0};${e}`,inputDependencies:S},getRunData:()=>({outputs:T,dispatchGroup:x,programUniforms:$}),getShaderSource:A}},Ut=(e,t,r,n,o,i,a,d,l,p,m=void 0,u=void 0)=>{let h=Math.min(e.outputCount,1+(a?1:0)+(d?1:0)),_=h>1?p.pastSequenceLength:0,y=_+p.kvSequenceLength,g=l&&k.size(l.dims)>0?l:void 0,x=[t,r];h>1&&a&&k.size(a.dims)>0&&x.push(a),g&&x.push(g),m&&x.push(m),u&&x.push(u);let $=e.compute(Rm(h,t,r,a,g,p,_,m,u),{inputs:x,outputs:h>1?[-1,1]:[-1]})[0];e.compute(Mm($,p.batchSize,p.numHeads,_,p.sequenceLength,y,m,u),{inputs:m&&u?[$,m,u]:[$],outputs:[]});let v=[$,n];h>1&&d&&k.size(d.dims)>0&&v.push(d),m&&v.push(m),u&&v.push(u),e.compute(Um(h,$,n,d,p,_,m,u),{inputs:v,outputs:h>1?[0,2]:[0]})},Nm=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],n=t.sequenceLength,o=t.inputHiddenSize,i=t.headSize,a=12,d={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],p=[{type:12,data:n},{type:12,data:o},{type:12,data:i},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],m=u=>{let h=M(\"output_q\",l[0].dataType,r),_=M(\"output_k\",l[0].dataType,r),y=M(\"output_v\",l[0].dataType,r),g=E(\"input\",l[0].dataType,l[0].dims),x=E(\"weight\",l[1].dataType,l[1].dims),$=E(\"bias\",l[2].dataType,l[2].dims),v=g.type.storage,S=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"ldb\",type:\"u32\"}];return`\n  const TILE_SIZE = ${a}u;\n  var<workgroup> tileInput: array<${v}, ${a*a}>;\n  var<workgroup> tileWeightQ: array<${v}, ${a*a}>;\n  var<workgroup> tileWeightK: array<${v}, ${a*a}>;\n  var<workgroup> tileWeightV: array<${v}, ${a*a}>;\n  ${u.registerUniforms(S).declareVariables(g,x,$,h,_,y)}\n  ${u.mainStart([a,a,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${v}(0);\n    var valueK = ${v}(0);\n    var valueV = ${v}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:\"AttentionPrepare\",shaderCache:{inputDependencies:[\"type\",\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:d,programUniforms:p}),getShaderSource:m},{inputs:l,outputs:[-1,-1,-1]})},Ps=(e,t)=>{let r=Bm(e.inputs,t),[n,o,i]=Nm(e,r);return Ut(e,n,o,i,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r)}});var Vm,Wm,Lm,zs,Os=U(()=>{\"use strict\";Le();J();ne();xe();ae();Vm=(e,t)=>{if(!e||e.length!==5)throw new Error(\"BatchNormalization requires 5 inputs\");let r=(n,o,i)=>{let a=o.length;if(a!==n.length)throw new Error(`${i}: num dimensions != ${a}`);o.forEach((d,l)=>{if(d!==n[l])throw new Error(`${i}: dim[${l}] do not match`)})};if(e[0].dims.length>1){let n=t.format===\"NHWC\"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,n,\"Invalid input scale\"),r(e[2].dims,n,\"Invalid input B\"),r(e[3].dims,n,\"Invalid input mean\"),r(e[4].dims,n,\"Invalid input var\")}else r(e[1].dims,[1],\"Invalid input scale\"),r(e[2].dims,[1],\"Invalid input B\"),r(e[3].dims,[1],\"Invalid input mean\"),r(e[4].dims,[1],\"Invalid input var\")},Wm=(e,t)=>{let{epsilon:r,spatial:n,format:o}=t,i=e[0].dims,a=n?me(i[i.length-1]):1,d=o===\"NHWC\"&&i.length>1?a:1,l=k.size(i)/a,p=n,m=p?i.length:i,u=E(\"x\",e[0].dataType,e[0].dims,a),h=E(\"scale\",e[1].dataType,e[1].dims,d),_=E(\"bias\",e[2].dataType,e[2].dims,d),y=E(\"inputMean\",e[3].dataType,e[3].dims,d),g=E(\"inputVar\",e[4].dataType,e[4].dims,d),x=M(\"y\",e[0].dataType,m,a),$=()=>{let S=\"\";if(n)S=`let cOffset = ${i.length===1?\"0u\":o===\"NHWC\"?`outputIndices[${i.length-1}] / ${a}`:\"outputIndices[1]\"};`;else if(o===\"NCHW\")S=`\n            ${x.indicesSet(\"outputIndices\",\"0\",\"0\")}\n            let cOffset = ${x.indicesToOffset(\"outputIndices\")};`;else{S=`var cIndices = ${h.type.indices}(0);\n                       cIndices[0] = outputIndices[${i.length-1}];`;for(let T=1;T<h.rank;T++)S+=`cIndices[${T}] = outputIndices[${T}];`;S+=`let cOffset = ${h.indicesToOffset(\"cIndices\")};`}return S},v=S=>`\n  const epsilon = ${r};\n  ${S.registerUniform(\"outputSize\",\"u32\").declareVariables(u,h,_,y,g,x)}\n  ${S.mainStart()}\n  ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n    var outputIndices = ${x.offsetToIndices(`global_idx * ${a}`)};\n    ${$()}\n    let scale = ${h.getByOffset(\"cOffset\")};\n    let bias = ${_.getByOffset(\"cOffset\")};\n    let inputMean = ${y.getByOffset(\"cOffset\")};\n    let inputVar = ${g.getByOffset(\"cOffset\")};\n    let x = ${u.getByOffset(\"global_idx\")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${x.setByOffset(\"global_idx\",\"value\")}\n  }`;return{name:\"BatchNormalization\",shaderCache:{hint:`${t.epsilon}_${t.format}_${n}_${a}`,inputDependencies:p?[\"rank\",\"type\",\"type\",\"type\",\"type\"]:void 0},getShaderSource:v,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p?[{type:12,data:l},...N(i)]:[{type:12,data:l}]})}},Lm=e=>ee(e),zs=(e,t)=>{let{inputs:r,outputCount:n}=e,o=Lm({...t,outputCount:n});if(_e.webgpu.validateInputContent&&Vm(r,o),t.trainingMode)throw new Error(\"BatchNormalization trainingMode is not supported yet.\");e.compute(Wm(r,o))}});var Gm,Hm,Ds,Bs=U(()=>{\"use strict\";ne();ae();Gm=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![320,640,1280].includes(e[0].dims[2]))throw new Error(\"number of channels should be 320, 640 or 1280\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Hm=e=>{let t=e[0].dims,r=e[0].dims[2],n=k.size(t)/4,o=e[0].dataType,i=E(\"input\",o,t,4),a=E(\"bias\",o,[r],4),d=E(\"residual\",o,t,4),l=M(\"output\",o,t,4);return{name:\"BiasAdd\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:m=>`\n  const channels = ${r}u / 4;\n  ${m.declareVariables(i,a,d,l)}\n\n  ${m.mainStart()}\n    ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let value = ${i.getByOffset(\"global_idx\")}\n      + ${a.getByOffset(\"global_idx % channels\")} + ${d.getByOffset(\"global_idx\")};\n    ${l.setByOffset(\"global_idx\",\"value\")}\n  }`}},Ds=e=>{Gm(e.inputs),e.compute(Hm(e.inputs))}});var Fm,fe,Ms,Rs,Us,Ns,Vs,Ws,Ls,Gs,Hs,qm,Fs,qs,Ks,js,Qt,Ys,Fr,Zs,Qs,Xs,Js,eu,tu,ru,nu,ou,iu,au,su,uu,du,lu,cu,pu,mu,po,mo,fu,hu,gu,Km,jm,bu,qr=U(()=>{\"use strict\";J();ne();xe();ae();Fm=(e,t,r,n,o,i,a)=>{let d=Math.ceil(t/4),l=\"\";typeof o==\"string\"?l=`${o}(a)`:l=o(\"a\");let p=E(\"inputData\",r,[d],4),m=M(\"outputData\",n,[d],4),u=[{name:\"vec_size\",type:\"u32\"}];return a&&u.push(...a),`\n      ${e.registerUniforms(u).declareVariables(p,m)}\n\n  ${i??\"\"}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n\n    let a = ${p.getByOffset(\"global_idx\")};\n    ${m.setByOffset(\"global_idx\",l)}\n  }`},fe=(e,t,r,n,o,i=e.dataType,a,d)=>{let l=[{type:12,data:Math.ceil(k.size(e.dims)/4)}];return a&&l.push(...a),{name:t,shaderCache:{hint:o,inputDependencies:[\"type\"]},getShaderSource:p=>Fm(p,k.size(e.dims),e.dataType,i,r,n,d),getRunData:p=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(k.size(p[0].dims)/64/4)},programUniforms:l})}},Ms=e=>{e.compute(fe(e.inputs[0],\"Abs\",\"abs\"))},Rs=e=>{e.compute(fe(e.inputs[0],\"Acos\",\"acos\"))},Us=e=>{e.compute(fe(e.inputs[0],\"Acosh\",\"acosh\"))},Ns=e=>{e.compute(fe(e.inputs[0],\"Asin\",\"asin\"))},Vs=e=>{e.compute(fe(e.inputs[0],\"Asinh\",\"asinh\"))},Ws=e=>{e.compute(fe(e.inputs[0],\"Atan\",\"atan\"))},Ls=e=>{e.compute(fe(e.inputs[0],\"Atanh\",\"atanh\"))},Gs=e=>ee(e),Hs=(e,t)=>{let r;switch(t.to){case 10:r=\"vec4<f16>\";break;case 1:r=\"vec4<f32>\";break;case 12:r=\"vec4<u32>\";break;case 6:r=\"vec4<i32>\";break;case 9:r=\"vec4<bool>\";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(fe(e.inputs[0],\"Cast\",r,void 0,t.cacheKey,t.to))},qm=e=>{let t,r,n=e.length>=2&&e[1].data!==0,o=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=n?e[1].getFloat32Array()[0]:-34028234663852886e22,r=o?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=n?e[1].getUint16Array()[0]:64511,r=o?e[2].getUint16Array()[0]:31743;break;default:throw new Error(\"Unsupport data type\")}return ee({min:t,max:r})},Fs=(e,t)=>{let r=t||qm(e.inputs),n=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Clip\",o=>`clamp(${o}, vec4<${n}>(uniforms.min), vec4<${n}>(uniforms.max))`,void 0,r.cacheKey,void 0,[{type:e.inputs[0].dataType,data:r.min},{type:e.inputs[0].dataType,data:r.max}],[{name:\"min\",type:n},{name:\"max\",type:n}]),{inputs:[0]})},qs=e=>{e.compute(fe(e.inputs[0],\"Ceil\",\"ceil\"))},Ks=e=>{e.compute(fe(e.inputs[0],\"Cos\",\"cos\"))},js=e=>{e.compute(fe(e.inputs[0],\"Cosh\",\"cosh\"))},Qt=e=>ee(e),Ys=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Elu\",n=>`elu_vf32(${n})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Fr=(e=\"f32\")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Zs=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Erf\",r=>`erf_vf32(${r})`,Fr(t)))},Qs=e=>{e.compute(fe(e.inputs[0],\"Exp\",\"exp\"))},Xs=e=>{e.compute(fe(e.inputs[0],\"Floor\",\"floor\"))},Js=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Gelu\",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Fr(t)))},eu=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"LeakyRelu\",n=>`select(leaky_relu_alpha_ * ${n}, ${n}, ${n} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},tu=e=>{e.compute(fe(e.inputs[0],\"Not\",t=>`!${t}`))},ru=e=>{e.compute(fe(e.inputs[0],\"Neg\",t=>`-${t}`))},nu=e=>{e.compute(fe(e.inputs[0],\"Reciprocal\",t=>`1.0/${t}`))},ou=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Relu\",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},iu=e=>{e.compute(fe(e.inputs[0],\"Sigmoid\",t=>`(1.0 / (1.0 + exp(-${t})))`))},au=e=>ee(e),su=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"HardSigmoid\",n=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${n} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},uu=e=>{e.compute(fe(e.inputs[0],\"Sin\",\"sin\"))},du=e=>{e.compute(fe(e.inputs[0],\"Sinh\",\"sinh\"))},lu=e=>{e.compute(fe(e.inputs[0],\"Sqrt\",\"sqrt\"))},cu=e=>{e.compute(fe(e.inputs[0],\"Tan\",\"tan\"))},pu=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,mu=e=>{e.compute(fe(e.inputs[0],\"Tanh\",pu))},po=(e=\"f32\")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${pu(\"v\")};\n}\n`,mo=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,fu=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"FastGelu\",mo,po(t),void 0,e.inputs[0].dataType))},hu=(e,t)=>{let r=Ee(e.inputs[0].dataType);return e.compute(fe(e.inputs[0],\"ThresholdedRelu\",n=>`select(vec4<${r}>(0.0), ${n}, ${n} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},gu=e=>{e.compute(fe(e.inputs[0],\"Log\",\"log\"))},Km=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,jm=e=>`quick_gelu_impl(${e})`,bu=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"QuickGelu\",jm,Km(r,t.alpha),t.cacheKey,e.inputs[0].dataType))}});var Ym,Zm,_u,wu=U(()=>{\"use strict\";ne();ae();qr();Ym=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error(\"hidden state should be 2560, 5120 or 10240\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Zm=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=E(\"input\",e[0].dataType,e[0].dims,4),n=E(\"bias\",e[0].dataType,[e[0].dims[2]],4),o=M(\"output\",e[0].dataType,t,4),i=k.size(t)/4,a=ye(e[0].dataType);return{name:\"BiasSplitGelu\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:l=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${l.declareVariables(r,n,o)}\n\n  ${Fr(a)}\n\n  ${l.mainStart()}\n    ${l.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${o.setByOffset(\"global_idx\",\"valueLeft * geluRight\")}\n  }`}},_u=e=>{Ym(e.inputs),e.compute(Zm(e.inputs))}});var Qm,Xm,at,vu,$u,xu,Su,Tu,Iu,Cu,Au,ku,Eu,Pu=U(()=>{\"use strict\";J();ne();ae();Qm=(e,t,r,n,o,i,a,d,l,p,m,u)=>{let h,_;typeof d==\"string\"?h=_=(v,S)=>`${d}((${v}),(${S}))`:typeof d==\"function\"?h=_=d:(h=d.scalar,_=d.vector);let y=M(\"outputData\",m,n.length,4),g=E(\"aData\",l,t.length,4),x=E(\"bData\",p,r.length,4),$;if(o)if(i){let v=k.size(t)===1,S=k.size(r)===1,T=t.length>0&&t[t.length-1]%4===0,A=r.length>0&&r[r.length-1]%4===0;v||S?$=y.setByOffset(\"global_idx\",_(v?`${g.type.value}(${g.getByOffset(\"0\")}.x)`:g.getByOffset(\"global_idx\"),S?`${x.type.value}(${x.getByOffset(\"0\")}.x)`:x.getByOffset(\"global_idx\"))):$=`\n            let outputIndices = ${y.offsetToIndices(\"global_idx * 4u\")};\n            let offsetA = ${g.broadcastedIndicesToOffset(\"outputIndices\",y)};\n            let offsetB = ${x.broadcastedIndicesToOffset(\"outputIndices\",y)};\n            ${y.setByOffset(\"global_idx\",_(a||T?g.getByOffset(\"offsetA / 4u\"):`${g.type.value}(${g.getByOffset(\"offsetA / 4u\")}[offsetA % 4u])`,a||A?x.getByOffset(\"offsetB / 4u\"):`${x.type.value}(${x.getByOffset(\"offsetB / 4u\")}[offsetB % 4u])`))}\n          `}else $=y.setByOffset(\"global_idx\",_(g.getByOffset(\"global_idx\"),x.getByOffset(\"global_idx\")));else{if(!i)throw new Error(\"no necessary to use scalar implementation for element-wise binary op implementation.\");let v=(S,T,A=\"\")=>{let C=`aData[indexA${T}][componentA${T}]`,P=`bData[indexB${T}][componentB${T}]`;return`\n            let outputIndices${T} = ${y.offsetToIndices(`global_idx * 4u + ${T}u`)};\n            let offsetA${T} = ${g.broadcastedIndicesToOffset(`outputIndices${T}`,y)};\n            let offsetB${T} = ${x.broadcastedIndicesToOffset(`outputIndices${T}`,y)};\n            let indexA${T} = offsetA${T} / 4u;\n            let indexB${T} = offsetB${T} / 4u;\n            let componentA${T} = offsetA${T} % 4u;\n            let componentB${T} = offsetB${T} % 4u;\n            ${S}[${T}] = ${A}(${h(C,P)});\n          `};m===9?$=`\n            var data = vec4<u32>(0);\n            ${v(\"data\",0,\"u32\")}\n            ${v(\"data\",1,\"u32\")}\n            ${v(\"data\",2,\"u32\")}\n            ${v(\"data\",3,\"u32\")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:$=`\n            ${v(\"outputData[global_idx]\",0)}\n            ${v(\"outputData[global_idx]\",1)}\n            ${v(\"outputData[global_idx]\",2)}\n            ${v(\"outputData[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(g,x,y)}\n\n        ${u??\"\"}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${$}\n      }`},Xm=(e,t,r,n,o,i,a=r.dataType)=>{let d=r.dims.map(g=>Number(g)??1),l=n.dims.map(g=>Number(g)??1),p=!k.areEqual(d,l),m=d,u=k.size(d),h=!1,_=!1,y=[p];if(p){let g=tt.calcShape(d,l,!1);if(!g)throw new Error(\"Can't perform binary op on the given tensors\");m=g.slice(),u=k.size(m);let x=k.size(d)===1,$=k.size(l)===1,v=d.length>0&&d[d.length-1]%4===0,S=l.length>0&&l[l.length-1]%4===0;y.push(x),y.push($),y.push(v),y.push(S);let T=1;for(let A=1;A<m.length;A++){let C=d[d.length-A],P=l[l.length-A];if(C===P)T*=C;else break}T%4===0?(_=!0,h=!0):(x||$||v||S)&&(h=!0)}else h=!0;return y.push(h),{name:e,shaderCache:{hint:t+y.map(g=>g.toString()).join(\"_\"),inputDependencies:[\"rank\",\"rank\"]},getShaderSource:g=>Qm(g,d,l,m,h,p,_,o,r.dataType,n.dataType,a,i),getRunData:()=>({outputs:[{dims:m,dataType:a}],dispatchGroup:{x:Math.ceil(u/64/4)},programUniforms:[{type:12,data:Math.ceil(k.size(m)/4)},...N(d,l,m)]})}},at=(e,t,r,n,o,i)=>{e.compute(Xm(t,o??\"\",e.inputs[0],e.inputs[1],r,n,i))},vu=e=>{at(e,\"Add\",(t,r)=>`${t}+${r}`)},$u=e=>{at(e,\"Div\",(t,r)=>`${t}/${r}`)},xu=e=>{at(e,\"Equal\",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Su=e=>{at(e,\"Mul\",(t,r)=>`${t}*${r}`)},Tu=e=>{let t=E(\"input\",e.inputs[0].dataType,e.inputs[0].dims).type.value;at(e,\"Pow\",{scalar:(n,o)=>`pow_custom(${n},${o})`,vector:(n,o)=>`pow_vector_custom(${n},${o})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t===\"i32\"?\"round\":\"\"}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Iu=e=>{at(e,\"Sub\",(t,r)=>`${t}-${r}`)},Cu=e=>{at(e,\"Greater\",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Au=e=>{at(e,\"Less\",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},ku=e=>{at(e,\"GreaterOrEqual\",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Eu=e=>{at(e,\"LessOrEqual\",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var ef,tf,rf,nf,zu,Ou,Du=U(()=>{\"use strict\";J();ne();xe();ae();ef=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");let r=0,n=e[r],o=n.dataType,i=n.dims.length;e.forEach((a,d)=>{if(d!==r){if(a.dataType!==o)throw new Error(\"input tensors should be one type\");if(a.dims.length!==i)throw new Error(\"input tensors should have the same shape\");a.dims.forEach((l,p)=>{if(p!==t&&l!==n.dims[p])throw new Error(\"non concat dimensions must match\")})}})},tf=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,rf=(e,t)=>{let r=e.length,n=[];for(let o=0;o<r;++o){let i=t.setByOffset(\"global_idx\",e[o].getByIndices(\"indices\"));r===1?n.push(i):o===0?n.push(`if (inputIndex == ${o}u) { ${i} }`):o===r-1?n.push(`else { ${i} }`):n.push(`else if (inputIndex == ${o}) { ${i} }`)}return n.join(`\n`)},nf=(e,t,r,n)=>{let o=k.size(r),i=new Array(e.length),a=new Array(e.length),d=0,l=[],p=[],m=[{type:12,data:o}];for(let g=0;g<e.length;++g)d+=e[g].dims[t],i[g]=d,p.push(e[g].dims.length),a[g]=E(`input${g}`,n,p[g]),l.push(\"rank\"),m.push({type:12,data:i[g]});for(let g=0;g<e.length;++g)m.push(...N(e[g].dims));m.push(...N(r));let u=M(\"output\",n,r.length),h=u.indicesGet(\"indices\",t),_=Array.from(Array(i.length).keys()).map(g=>`uniforms.sizeInConcatAxis${g}`).join(\",\"),y=g=>`\n\n  ${(()=>{g.registerUniform(\"outputSize\",\"u32\");for(let x=0;x<e.length;x++)g.registerUniform(`sizeInConcatAxis${x}`,\"u32\");return g.declareVariables(...a,u)})()}\n\n  ${tf(i.length,_)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n    var indices = ${u.offsetToIndices(\"global_idx\")};\n\n    let inputIndex = calculateInputIndex(${h});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${i.length}u>(${_});\n      ${h} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${rf(a,u)}\n  }`;return{name:\"Concat\",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:r,dataType:n}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:m}),getShaderSource:y}},zu=(e,t)=>{let r=e.inputs,n=r[0].dims,o=k.normalizeAxis(t.axis,n.length);ef(r,o);let i=n.slice();i[o]=r.reduce((d,l)=>d+(l.dims.length>o?l.dims[o]:0),0);let a=r.filter(d=>k.size(d.dims)>0);e.compute(nf(a,o,i,r[0].dataType),{inputs:a})},Ou=e=>ee({axis:e.axis})});var Ke,je,Ye,Kr,yt=U(()=>{\"use strict\";J();ne();Ke=(e,t,r=\"f32\")=>{switch(e.activation){case\"Relu\":return`value = max(value, ${t}(0.0));`;case\"Sigmoid\":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case\"Clip\":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case\"HardSigmoid\":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case\"LeakyRelu\":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case\"Tanh\":return`let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        `;case\"\":return\"\";default:throw new Error(`Unsupported activation ${e.activation}`)}},je=(e,t)=>{e.activation===\"Clip\"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation===\"HardSigmoid\"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation===\"LeakyRelu\"&&t.push({type:1,data:e.alpha})},Ye=(e,t)=>{e.activation===\"Clip\"?t.push({name:\"clip_max\",type:\"f32\"},{name:\"clip_min\",type:\"f32\"}):e.activation===\"HardSigmoid\"?t.push({name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}):e.activation===\"LeakyRelu\"&&t.push({name:\"alpha\",type:\"f32\"})},Kr=e=>{let t=e?.activation||\"\";if(t===\"HardSigmoid\"){let[r,n]=e?.activation_params||[.2,.5];return{activation:t,alpha:r,beta:n}}else if(t===\"Clip\"){let[r,n]=e?.activation_params||[Ja,es];return{activation:t,clipMax:n,clipMin:r}}else if(t===\"LeakyRelu\"){let[r]=e?.activation_params||[.01];return{activation:t,alpha:r}}return{activation:t}}});var Ae,Bu,jr=U(()=>{\"use strict\";Ae=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Bu=e=>`\n      ${e?\"value = value + getBiasByOutputCoords(coords);\":\"\"}\n      `});var Mu,Ru=U(()=>{\"use strict\";Mu=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var Xt,Yr,Zr=U(()=>{\"use strict\";J();ne();ae();yt();Xt=(e,t,r,n,o)=>{let i=n-r;return`\n      ${Array.from({length:r}).map((a,d)=>`\n      if (${q(t.shape,d,t.rank)} != 1) {\n        ${t.indicesSet(e,d,q(o,d+i,n))}\n      } else {\n        ${t.indicesSet(e,d,0)}\n      }`).join(\"\")}\n`},Yr=(e,t,r,n,o=!1,i)=>{let a=e[0].dims,d=e[1].dims,l=a[a.length-2],p=d[d.length-1],m=a[a.length-1],u=me(p),h=me(m),_=me(l),y=k.size(r)/u/_,g=e.length>2,x=n?n.slice(0,-2):r.slice(0,-2),v=[k.size(x),l,p],S=[{type:12,data:y},{type:12,data:l},{type:12,data:p},{type:12,data:m}];je(t,S),S.push(...N(x,a,d)),g&&S.push(...N(e[2].dims)),S.push(...N(v));let T=A=>{let C=Wr(\"batch_dims\",e[0].dataType,x.length),P=E(\"a\",e[0].dataType,a.length,h),D=E(\"b\",e[1].dataType,d.length,u),R=M(\"output\",e[0].dataType,v.length,u),H=ye(R.type.tensor),L=Ke(t,R.type.value,H),re=[P,D],V=\"\";if(g){let j=o?u:1;re.push(E(\"bias\",e[2].dataType,e[2].dims.length,j)),V=`${o?`value += bias[col / ${j}];`:`value += ${R.type.value}(bias[row + i]);`}`}let K=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"}];Ye(t,K);let we=()=>{let j=`var a_data: ${P.type.value};`;for(let Q=0;Q<h;Q++)j+=`\n              let b_data${Q} = b[(b_offset + (k + ${Q}) * uniforms.N + col) / ${u}];`;for(let Q=0;Q<_;Q++){j+=`a_data = a[(a_offset + (row + ${Q}) * uniforms.K + k) / ${h}];`;for(let ie=0;ie<h;ie++)j+=`\n            values[${Q}] = fma(${D.type.value}(a_data${h===1?\"\":`[${ie}]`}), b_data${ie}, values[${Q}]);\n`}return j};return`\n  ${A.registerUniforms(K).registerInternalVariables(C).declareVariables(...re,R)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let col = (global_idx % (uniforms.N / ${u})) * ${u};\n    var index1 = global_idx / (uniforms.N / ${u});\n    let stride1 = uniforms.M / ${_};\n    let row = (index1 % stride1) * ${_};\n    let batch = index1 / stride1;\n\n    ${r.length===2?\"\":`let batch_indices = ${C.offsetToIndices(\"batch\")};`}\n\n    var a_indices: ${P.type.indices};\n    ${Xt(\"a_indices\",P,P.rank-2,C.rank,\"batch_indices\")}\n    ${P.indicesSet(\"a_indices\",P.rank-2,0)}\n    ${P.indicesSet(\"a_indices\",P.rank-1,0)}\n    let a_offset = ${P.indicesToOffset(\"a_indices\")};\n\n    var b_indices: ${D.type.indices};\n    ${Xt(\"b_indices\",D,D.rank-2,C.rank,\"batch_indices\")}\n    ${D.indicesSet(\"b_indices\",D.rank-2,0)}\n    ${D.indicesSet(\"b_indices\",D.rank-1,0)}\n    let b_offset = ${D.indicesToOffset(\"b_indices\")};\n    var values: array<${R.type.value}, ${_}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {\n      ${we()}\n    }\n    for (var i = 0u; i < ${_}u; i++) {\n      var value = values[i];\n      ${V}\n      ${L}\n      let cur_indices = ${R.type.indices}(batch, row + i, col);\n      let offset = ${R.indicesToOffset(\"cur_indices\")};\n      ${R.setByOffset(`offset / ${u}`,\"value\")};\n    }\n  }\n  `};return{name:\"MatMulNaive\",shaderCache:{hint:`${t.activation};${u};${h};${_};${o}`,inputDependencies:g?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:i?i(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:S}),getShaderSource:T}}});var of,af,fo,Uu,sf,ho,uf,Jt,Qr=U(()=>{\"use strict\";J();ne();ae();yt();Zr();jr();of=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `,af=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?\"\":\"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];\"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached3[i] + acc[i];\"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached.w + acc[i];\"}\n        }`,fo=(e,t,r=\"f32\",n,o=!1,i=32,a=!1,d=32)=>{let l=t[1]*e[1],p=t[0]*e[0],m=o?l:i,u=o?i:l,h=m/t[0],_=i/t[1];if(!((o&&h===4&&e[1]===4||!o&&(h===3||h===4))&&m%t[0]===0&&i%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${h} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${h} must be 3 or 4.\n  tileAWidth ${m} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${h}<${r}>, ${m/h}>, ${u}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${i}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${h};\nconst tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${a?\"0\":\"i32(globalId.z)\"};\n  ${n?`let batchIndices = ${n.offsetToIndices(\"u32(batch)\")};`:\"\"}\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let num_tiles = ${a?`${Math.ceil(d/i)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n  var kStart = ${a?`i32(globalId.z) * ${d}`:\"0\"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${of(o,n)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${n?\", batchIndices\":\"\"});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${h===3?\"\":\"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];\"}\n\n          ${af(o,h)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Uu=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?\", batchIndices\":\"\"});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?\", batchIndices\":\"\"});\n            `,sf=e=>e?\"let ACached = mm_Asub[k][tileRow + innerRow];\":\"let ACached = mm_Asub[tileRow + innerRow][k];\",ho=(e,t,r=\"f32\",n,o=!1,i=32,a=!1,d=32,l=!1)=>{let p=e[1]*t[1],m=e[0]*t[0],u=o?p:i,h=o?i:p;if(!(h%t[1]===0&&u%t[0]===0&&i%t[1]===0))throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let _=h/t[1],y=u/t[0],g=i/t[1],x=l?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${m};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${t[0]}) {\n          ${Uu(o,n)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${m}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${n?\", batchIndices\":\"\"});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${y};\nlet tileRowB = i32(localId.y) * ${g};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Uu(o,n)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${n?\", batchIndices\":\"\"});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${sf(o)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${u}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${m}>, ${i}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${a?\"0\":\"i32(globalId.z)\"};\n    ${n?`let batchIndices = ${n.offsetToIndices(\"u32(batch)\")};`:\"\"}\n    let num_tiles = ${a?`${Math.ceil(d/i)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n    var kStart = ${a?`i32(globalId.z) * ${d}`:\"0\"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n    ${x}\n  }\n`},uf=(e,t,r,n,o=!1)=>{let[i,a,d,l]=n,p=ye(n[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ae(e,p)} {\n      var value = ${Ae(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${a.type.indices};\n        ${Xt(\"aIndices\",a,a.rank-2,i.rank,\"batchIndices\")}\n        ${a.indicesSet(\"aIndices\",a.rank-2,\"u32(row)\")}\n        ${a.indicesSet(\"aIndices\",a.rank-1,\"u32(colIn)\")}\n        value = ${a.getByIndices(\"aIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ae(e,p)} {\n      var value = ${Ae(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${d.type.indices};\n        ${Xt(\"bIndices\",d,d.rank-2,i.rank,\"batchIndices\")}\n        ${d.indicesSet(\"bIndices\",d.rank-2,\"u32(row)\")}\n        ${d.indicesSet(\"bIndices\",d.rank-1,\"u32(colIn)\")}\n        value = ${d.getByIndices(\"bIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ae(e,p)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${o?\"bias[colIn]\":`${Ae(e,p)}(bias[row])`};`:\"\"}\n        ${r}\n        ${l.setByIndices(\"vec3<u32>(coords)\",\"value\")}\n      }\n    }\n    `},Jt=(e,t,r,n,o=!1,i)=>{let a=e[0].dims,d=e[1].dims,l=a.slice(0,-2),p=d.slice(0,-2),m=n?n.slice(0,-2):r.slice(0,-2),u=k.size(m),h=a[a.length-2],_=a[a.length-1],y=d[d.length-1],g=_%4===0&&y%4===0,x=h<=8?[4,1,1]:[4,4,1],$=[8,8,1],v=[Math.ceil(y/$[0]/x[0]),Math.ceil(h/$[1]/x[1]),Math.ceil(u/$[2]/x[2])],S=g?4:1,T=[...l,h,_/S],A=T.length,C=[...p,_,y/S],P=C.length,D=[u,h,y/S],R=[{type:6,data:h},{type:6,data:y},{type:6,data:_}];je(t,R),R.push(...N(m,T,C));let H=[\"rank\",\"rank\"],L=e.length>2;L&&(R.push(...N(e[2].dims)),H.push(\"rank\")),R.push(...N(D));let re=V=>{let K=m.length,we=Wr(\"batchDims\",e[0].dataType,K,1),j=ye(e[0].dataType),Q=E(\"a\",e[0].dataType,A,S),ie=E(\"b\",e[1].dataType,P,S),te=M(\"result\",e[0].dataType,D.length,S),be=[Q,ie];if(L){let Y=o?S:1;be.push(E(\"bias\",e[2].dataType,e[2].dims.length,Y))}let Oe=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"}];Ye(t,Oe);let ve=ye(te.type.tensor),de=Ke(t,te.type.value,ve),W=uf(S,L,de,[we,Q,ie,te],o);return`\n  ${V.registerUniforms(Oe).registerInternalVariables(we).declareVariables(...be,te)}\n  ${W}\n  ${g?fo(x,$,j,we):ho(x,$,j,we)}\n                   `};return{name:\"MatMul\",shaderCache:{hint:`${x};${t.activation};${g};${o}`,inputDependencies:H},getRunData:()=>({outputs:[{dims:i?i(r):r,dataType:e[0].dataType}],dispatchGroup:{x:v[0],y:v[1],z:v[2]},programUniforms:R}),getShaderSource:re}}});var df,Nu,Vu=U(()=>{\"use strict\";J();et();ae();yt();jr();Ru();Qr();df=(e,t,r,n,o=!1,i,a=4,d=4,l=4,p=\"f32\")=>{let m=H=>{switch(H){case 1:return\"resData = x[xIndex];\";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return\"resData = x[xIndex / 4];\";default:throw new Error(`innerElementSize ${H} is not supported.`)}},u=H=>{switch(H){case 1:return\"return w[row * i32(uniforms.w_shape[3]) + colIn];\";case 4:return\"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];\";default:throw new Error(`innerElementSize ${H} is not supported.`)}},h=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?\"i32(uniforms.x_shape[1])\":\"i32(uniforms.x_shape[2])\",g=e?\"i32(uniforms.x_shape[2])\":\"i32(uniforms.x_shape[3])\",x=e?\"row\":\"col\",$=e?\"col\":\"row\",v=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n    let outRow = ${x} / outWidth;\n    let outCol = ${x} % outWidth;\n\n    let WRow = ${$} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${$} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${$} % inChannels;\n    var resData = ${Ae(a,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${g}) {\n      ${h}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${m(a)}\n    }\n    return resData;`,S=e?t&&n?`\n    let col = colIn * ${a};\n    ${v}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${v}\n    }\n    return ${Ae(a,p)}(0.0);`:n&&r?`\n    let col = colIn * ${a};\n    ${v}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${v}\n    }\n    return ${Ae(a,p)}(0.0);`,T=e?n&&r?u(d):`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${u(d)}\n    }\n    return ${Ae(d,p)}(0.0);`:`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${u(d)}\n    }\n    return ${Ae(d,p)}(0.0);`,A=Ae(l,p),C=e?Ae(a,p):Ae(d,p),P=e?Ae(d,p):Ae(a,p),D=Ke(i,A,p);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${C} {\n      ${e?S:T}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${P} {\n      ${e?T:S}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${A}) {\n      let col = colIn * ${l};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n      ${_}\n      ${Bu(o)}\n      ${D}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Nu=(e,t,r,n,o,i,a,d,l)=>{let p=t.format===\"NHWC\",m=p?e[0].dims[3]:e[0].dims[1],u=r[0],h=p?r[2]:r[3],_=p?r[1]:r[2],y=p?r[3]:r[1],g=p&&(m%4===0||m%3===0)&&y%4===0,x=p?y:h*_,$=p?h*_:y,v=[8,8,1],S=n<=8?[4,1,1]:[4,4,1],T=[Math.ceil(x/v[0]/S[0]),Math.ceil($/v[1]/S[1]),Math.ceil(u/v[2]/S[2])];se(\"verbose\",()=>`[conv2d_mm_webgpu] dispatch = ${T}`);let A=g?p&&m%4!==0?3:4:1,C=v[1]*S[1],P=v[0]*S[0],D=Math.max(v[0]*A,v[1]),R=n%C===0,H=o%P===0,L=i%D===0,re=g?[A,4,4]:[1,1,1],V=[{type:6,data:n},{type:6,data:o},{type:6,data:i},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];je(t,V),V.push(...N(e[0].dims,e[1].dims));let K=[\"rank\",\"rank\"];a&&(V.push(...N(e[2].dims)),K.push(\"rank\")),V.push(...N(r));let we=j=>{let Q=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"},{name:\"pad\",type:\"i32\",length:2},{name:\"stride\",type:\"i32\",length:2},{name:\"dilation\",type:\"i32\",length:2}];Ye(t,Q);let ie=g?4:1,te=ye(e[0].dataType),be=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${g?`vec4<${te}>`:te}) {\n        result[flatIndex] = ${g?`vec4<${te}>`:te}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${g?`vec4<${te}>`:te}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${g?\"/ 4\":\"\"}, value);\n      }`,Oe=E(\"x\",e[0].dataType,e[0].dims.length,A===3?1:A),ve=E(\"w\",e[1].dataType,e[1].dims.length,ie),de=[Oe,ve],W=M(\"result\",e[0].dataType,r.length,ie);if(a){let Y=E(\"bias\",e[2].dataType,e[2].dims.length,ie);de.push(Y),be+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${g?`vec4<${te}>`:te} {\n          return bias[coords.${p?\"w\":\"y\"}${g?\"/ 4\":\"\"}];\n        }`}return`\n        ${Mu(\"uniforms.result_strides\")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${j.registerUniforms(Q).declareVariables(...de,W)}\n        ${be}\n        ${df(p,R,H,L,a,t,re[0],re[1],re[2],te)}\n        ${g?fo(S,v,te,void 0,!p,D):ho(S,v,te,void 0,!p,D,!1,void 0,d)}`};return{name:\"Conv2DMatMul\",shaderCache:{hint:`${t.cacheKey};${A};${g};${R};${H};${L};${C};${P};${D}`,inputDependencies:K},getRunData:()=>({outputs:[{dims:l?l(r):r,dataType:e[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]},programUniforms:V}),getShaderSource:we}}});var lf,Wu,Xr,cf,Lu,pf,Gu,Hu,Fu=U(()=>{\"use strict\";J();et();ne();ae();yt();jr();lf=e=>{let t=1;for(let r=0;r<e.length;r++)t*=e[r];return t},Wu=e=>typeof e==\"number\"?[e,e,e]:e,Xr=(e,t)=>t<=1?e:e+(e-1)*(t-1),cf=(e,t,r,n=1)=>{let o=Xr(t,n);return Math.floor((e[0]*(r-1)-r+o)/2)},Lu=(e,t,r,n,o)=>{o==null&&(o=cf(e,t[0],n[0]));let i=[0,0,0,r];for(let a=0;a<3;a++)e[a]+2*o>=t[a]&&(i[a]=Math.trunc((e[a]-t[a]+2*o)/n[a]+1));return i},pf=(e,t,r,n,o,i,a,d,l,p)=>{let m,u,h,_;if(e===\"VALID\"&&(e=0),typeof e==\"number\"){m={top:e,bottom:e,left:e,right:e,front:e,back:e};let y=Lu([t,r,n,1],[d,l,p],1,[o,i,a],e);u=y[0],h=y[1],_=y[2]}else if(Array.isArray(e)){if(!e.every((g,x,$)=>g===$[0]))throw Error(`Unsupported padding parameter: ${e}`);m={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let y=Lu([t,r,n,1],[d,l,p],1,[o,i,a],e[0]);u=y[0],h=y[1],_=y[2]}else if(e===\"SAME_UPPER\"){u=Math.ceil(t/o),h=Math.ceil(r/i),_=Math.ceil(n/a);let y=(u-1)*o+d-t,g=(h-1)*i+l-r,x=(_-1)*a+p-n,$=Math.floor(y/2),v=y-$,S=Math.floor(g/2),T=g-S,A=Math.floor(x/2),C=x-A;m={top:S,bottom:T,left:A,right:C,front:$,back:v}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:m,outDepth:u,outHeight:h,outWidth:_}},Gu=(e,t,r,n,o,i=!1,a=\"channelsLast\")=>{let d,l,p,m,u;if(a===\"channelsLast\")[d,l,p,m,u]=e;else if(a===\"channelsFirst\")[d,u,l,p,m]=e;else throw new Error(`Unknown dataFormat ${a}`);let[h,,_,y,g]=t,[x,$,v]=Wu(r),[S,T,A]=Wu(n),C=Xr(_,S),P=Xr(y,T),D=Xr(g,A),{padInfo:R,outDepth:H,outHeight:L,outWidth:re}=pf(o,l,p,m,x,$,v,C,P,D),V=i?h*u:h,K=[0,0,0,0,0];return a===\"channelsFirst\"?K=[d,V,H,L,re]:a===\"channelsLast\"&&(K=[d,H,L,re,V]),{batchSize:d,dataFormat:a,inDepth:l,inHeight:p,inWidth:m,inChannels:u,outDepth:H,outHeight:L,outWidth:re,outChannels:V,padInfo:R,strideDepth:x,strideHeight:$,strideWidth:v,filterDepth:_,filterHeight:y,filterWidth:g,effectiveFilterDepth:C,effectiveFilterHeight:P,effectiveFilterWidth:D,dilationDepth:S,dilationHeight:T,dilationWidth:A,inShape:e,outShape:K,filterShape:t}},Hu=(e,t,r,n,o,i)=>{let a=i===\"channelsLast\",d=a?e[0].dims[3]:e[0].dims[1],l=!1,p=[64,1,1],m={x:r.map((v,S)=>S)},u=[Math.ceil(lf(m.x.map(v=>r[v]))/p[0]),1,1];se(\"verbose\",()=>`[conv3d_naive_webgpu] dispatch = ${u}`);let h=l?a&&d%4!==0?3:4:1,_=k.size(r),y=[{type:12,data:_},{type:12,data:n},{type:12,data:o},{type:12,data:t.strides},{type:12,data:t.dilations}];je(t,y),y.push(...N(e[0].dims,e[1].dims));let g=[\"rank\",\"rank\"],x=e.length===3;x&&(y.push(...N(e[2].dims)),g.push(\"rank\")),y.push(...N(r));let $=v=>{let S=[{name:\"output_size\",type:\"u32\"},{name:\"filter_dims\",type:\"u32\",length:n.length},{name:\"pads\",type:\"u32\",length:o.length},{name:\"strides\",type:\"u32\",length:t.strides.length},{name:\"dilations\",type:\"u32\",length:t.dilations.length}];Ye(t,S);let T=l?4:1,A=ye(e[0].dataType),C=E(\"x\",e[0].dataType,e[0].dims.length,h===3?1:h),P=E(\"W\",e[1].dataType,e[1].dims.length,T),D=[C,P],R=M(\"result\",e[0].dataType,r.length,T),H=\"\";if(x){let V=E(\"bias\",e[2].dataType,e[2].dims.length,T);D.push(V),H+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l?`vec4<${A}>`:A} {\n          return bias[${a?q(\"coords\",4,5):q(\"coords\",1,5)}${l?\"/ 4\":\"\"}];\n        }`}let L=Ae(h,A),re=Ke(t,L,A);return`\n            ${H}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${C.getByIndices(\"aIndices\")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${P.getByIndices(\"aIndices\")};\n            }\n          ${v.registerUniforms(S).declareVariables(...D,R)}\n          ${v.mainStart()}\n          ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n              let coords = ${R.offsetToIndices(\"global_idx\")};\n              let batch = ${q(\"coords\",0,C.rank)};\n              let d2 = ${a?q(\"coords\",C.rank-1,C.rank):q(\"coords\",1,C.rank)};\n              let xFRCCorner = vec3<u32>(${a?q(\"coords\",1,C.rank):q(\"coords\",2,C.rank)},\n              ${a?q(\"coords\",2,C.rank):q(\"coords\",3,C.rank)},\n              ${a?q(\"coords\",3,C.rank):q(\"coords\",4,C.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${a?q(\"uniforms.x_shape\",1,C.rank):q(\"uniforms.x_shape\",2,C.rank)};\n              let xShapeZ = ${a?q(\"uniforms.x_shape\",2,C.rank):q(\"uniforms.x_shape\",3,C.rank)};\n              let xShapeW = ${a?q(\"uniforms.x_shape\",3,C.rank):q(\"uniforms.x_shape\",4,C.rank)};\n              let xShapeU = ${a?q(\"uniforms.x_shape\",4,C.rank):q(\"uniforms.x_shape\",1,C.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${a?`let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            `:`let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            `}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${a?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${a?`let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      `:`let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    `}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${a?`let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      `:`let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    `}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${x?\"value = value + getBiasByOutputCoords(coords)\":\"\"};\n              ${re}\n              result[global_idx] = f32(value);\n          }`};return{name:\"Conv3DNaive\",shaderCache:{hint:`${t.cacheKey};${a};${h};${x}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:u[0],y:u[1],z:u[2]},programUniforms:y}),getShaderSource:$}}});var qu,Ku,ju=U(()=>{\"use strict\";J();ne();ae();yt();qu=(e,t,r,n)=>{let o=e.length>2,i=o?\"value += b[output_channel];\":\"\",a=e[0].dims,d=e[1].dims,l=t.format===\"NHWC\",p=l?r[3]:r[1],m=p/t.group,u=l&&m>=4?me(p):1,h=k.size(r)/u,_=[{type:12,data:h},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:m}];je(t,_),_.push(...N(a,[d[0],d[1],d[2],d[3]/u]));let y=o?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"];_.push(...N([r[0],r[1],r[2],r[3]/u]));let g=x=>{let $=M(\"output\",e[0].dataType,r.length,u),v=ye($.type.tensor),S=Ke(t,$.type.value,v),T=E(\"x\",e[0].dataType,a.length),A=E(\"w\",e[1].dataType,d.length,u),C=[T,A];o&&C.push(E(\"b\",e[2].dataType,e[2].dims,u));let P=[{name:\"output_size\",type:\"u32\"},{name:\"dilations\",type:\"u32\",length:t.dilations.length},{name:\"strides\",type:\"u32\",length:2},{name:\"pads\",type:\"u32\",length:2},{name:\"output_channels_per_group\",type:\"u32\"}];Ye(t,P);let D=l?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${T.get(\"batch\",\"xHeight\",\"xWidth\",\"input_channel\")};\n            let wVal = ${A.get(\"wHeight\",\"wWidth\",\"wInChannel\",\"output_channel\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${T.get(\"batch\",\"input_channel\",\"xHeight\",\"xWidth\")};\n            let wVal = ${A.get(\"output_channel\",\"wInChannel\",\"wHeight\",\"wWidth\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${x.registerUniforms(P).declareVariables(...C,$)}\n\n  ${x.mainStart()}\n    ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let outputIndices = ${$.offsetToIndices(\"global_idx\")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${l?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${u} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\n\n    var value: ${$.type.value} = ${$.type.value}(0);\n    ${D}\n    ${i}\n    ${S}\n    ${$.setByOffset(\"global_idx\",\"value\")}\n  }`};return{name:\"GroupedConv\",shaderCache:{hint:`${t.cacheKey}_${u}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:_}),getShaderSource:g}},Ku=(e,t,r,n)=>{let o=e.length>2,i=me(r[3]),a=me(r[2]),d=k.size(r)/i/a,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/i],p=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/i],m=[r[0],r[1],r[2],r[3]/i],u=[{type:12,data:d},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];je(t,u),u.push(...N(l,p,m));let h=(a-1)*t.strides[1]+p[1],_=y=>{let g=M(\"output\",e[0].dataType,m.length,i),x=ye(g.type.tensor),$=Ke(t,g.type.value,x),v=E(\"x\",e[0].dataType,l.length,i),S=E(\"w\",e[1].dataType,p.length,i),T=[v,S];o&&T.push(E(\"b\",e[2].dataType,e[2].dims,i));let A=o?\"value += b[output_channel];\":\"\",C=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"i32\",length:2},{name:\"pads\",type:\"i32\",length:2}];return Ye(t,C),`\n  ${y.registerUniforms(C).declareVariables(...T,g)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${a}u;\n    let col = (index1 % width1) * ${a}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${v.type.value}, ${h}>;\n    var values: array<${g.type.value}, ${a}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${p[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${h}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${v.get(\"batch\",\"u32(x_height)\",\"u32(x_width)\",\"input_channel\")};\n          } else {\n            x_vals[i] = ${v.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${p[1]}; w_width++) {\n          let w_val = ${S.get(\"w_height\",\"w_width\",\"0\",\"output_channel\")};\n          for (var i = 0u; i < ${a}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${a}u; i++) {\n      var value = values[i];\n      ${A}\n      ${$}\n      ${g.set(\"batch\",\"row\",\"col + i\",\"output_channel\",\"value\")};\n    }\n  }`};return{name:\"GroupedConv-Vectorize\",shaderCache:{hint:`${t.cacheKey};${i};${a};${h};${p[0]};${p[1]}`,inputDependencies:o?[\"rank\",\"rank\",\"type\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}),getShaderSource:_}}});var mf,go,ff,bo,yo,Yu,hf,gf,_o,Zu=U(()=>{\"use strict\";ne();Vu();Fu();Qr();ju();yt();Zr();dt();mf=(e,t,r,n,o,i)=>{let a=e[0],d=e.slice(i?1:2,i?3:4),l=d.length,p=t[0],u=t.slice(2).map((y,g)=>y+(y-1)*(r[g]-1)),_=d.map((y,g)=>y+n[g]+n[g+l]).map((y,g)=>Math.floor((y-u[g]+o[g])/o[g]));return _.splice(0,0,a),_.splice(i?3:1,0,p),_},go=[2,3,1,0],ff=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length>5)throw new Error(\"greater than 5D is not supported\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let r=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],n=e[1].dims[1]*t.group;if(r!==n)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error(\"invalid bias\");let o=e[0].dims.length-2;if(t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\")},bo=(e,t)=>{let r=e.kernelShape.slice();r.length<t[1].dims.length-2&&r.push(...Array(t[1].dims.length-2-r.length).fill(0));for(let i=2;i<t[1].dims.length;++i)r[i-2]===0&&(r[i-2]=t[1].dims[i]);let n=e.pads.slice();kt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,n,e.format===\"NHWC\",e.autoPad);let o=Object.assign({},e);return Object.assign(o,{kernelShape:r,pads:n}),o},yo=e=>{let t=Kr(e),r=e.format,n=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],o=e.dilations,i=e.group,a=e.kernel_shape,d=e.pads,l=e.strides,p=e.w_is_const();return{autoPad:n,format:r,dilations:o,group:i,kernelShape:a,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},Yu=(e,t,r,n)=>{let o=r.format===\"NHWC\",i=mf(t[0].dims,t[1].dims,r.dilations,r.pads,r.strides,o);if(r.group!==1){let C=[t[0]];if(o){let D=e.kernelCustomData.wT??e.compute(Pe(t[1],go),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=D),C.push(D)}else C.push(t[1]);t.length===3&&C.push(t[2]),!e.adapterInfo.isArchitecture(\"ampere\")&&o&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1?e.compute(Ku(C,r,i,n),{inputs:C}):e.compute(qu(C,r,i,n),{inputs:C});return}let a=t.length===3,d=t[0].dims[o?1:2],l=t[0].dims[o?2:3],p=t[0].dims[o?3:1],m=t[1].dims[2],u=t[1].dims[3],h=i[o?1:2],_=i[o?2:3],y=i[o?3:1],g=o&&m===d&&u===l&&r.pads[0]===0&&r.pads[1]===0;if(g||m===1&&u===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let C=i[0],P,D,R,H=[];if(o){let V=e.kernelCustomData.wT??e.compute(Pe(t[1],go),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=V),g){let K=d*l*p;P=t[0].reshape([1,C,K]),D=V.reshape([1,K,y]),R=[1,C,y]}else P=t[0].reshape([C,d*l,p]),D=V.reshape([1,p,y]),R=[C,h*_,y];H.push(P),H.push(D)}else P=t[0].reshape([C,p,d*l]),D=t[1].reshape([1,y,p]),R=[C,y,h*_],H.push(D),H.push(P);a&&H.push(t[2]);let L=R[2],re=H[0].dims[H[0].dims.length-1];L<8&&re<8?e.compute(Yr(H,r,i,R,o,n),{inputs:H}):e.compute(Jt(H,r,i,R,o,n),{inputs:H});return}let x=!0,$=e.kernelCustomData.wT??e.compute(Pe(t[1],go),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=$);let v=[t[0],$];a&&v.push(t[2]);let S=o?h*_:y,T=o?y:h*_,A=m*u*p;e.compute(Nu(v,r,i,S,T,A,a,x,n),{inputs:v})},hf=(e,t)=>{let r=t.format===\"NHWC\",n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&n.push(e.inputs[2]);let o=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),a=[1].concat(t.dilations),d=[1].concat(t.kernelShape),l=bo({...t,pads:o,strides:i,dilations:a,kernelShape:d},n);Yu(e,n,l,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]])},gf=(e,t,r)=>{let n=r.format===\"NHWC\"?\"channelsLast\":\"channelsFirst\",o=bo(r,t),i=r.autoPad===\"NOTSET\"?r.pads:r.autoPad,a=Gu(t[0].dims,t[1].dims,r.strides,r.dilations,i,!1,n);e.compute(Hu(t,o,a.outShape,[a.filterDepth,a.filterHeight,a.filterWidth],[a.padInfo.front,a.padInfo.top,a.padInfo.left],n))},_o=(e,t)=>{if(ff(e.inputs,t),e.inputs[0].dims.length===3)hf(e,t);else if(e.inputs[0].dims.length===5)gf(e,e.inputs,t);else{let r=bo(t,e.inputs);Yu(e,e.inputs,r)}}});var Qu,Xu=U(()=>{\"use strict\";J();et();ne();ae();Qu=(e,t,r)=>{let n=e.length>2,o=t.outputShape,i=t.format===\"NHWC\",a=t.group,d=e[1].dims,l=d[2]/a,p=d[3],m=i?me(l):1,u=i?me(p):1,h=i?p===1?m:u:1,_=k.size(o)/u,y=[Math.ceil(_/64),1,1];se(\"verbose\",()=>`[conv2d_backprop_webgpu] dispatch = ${y}`);let g=[\"rank\",\"rank\"],x=[t.strides[0],t.strides[1]],$=[t.kernelShape[i?1:2],t.kernelShape[i?2:3]],v=[t.dilations[0],t.dilations[1]],S=[$[0]+(t.dilations[0]<=1?0:(t.kernelShape[i?1:2]-1)*(t.dilations[0]-1)),$[1]+(t.dilations[1]<=1?0:(t.kernelShape[i?2:3]-1)*(t.dilations[1]-1))],T=[S[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),S[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],A=[{type:12,data:_},{type:12,data:x},{type:12,data:$},{type:12,data:v},{type:12,data:S},{type:6,data:T},{type:12,data:l},{type:12,data:p},...N(e[0].dims,e[1].dims)];n&&(A.push(...N(e[2].dims)),g.push(\"rank\")),A.push(...N(o));let C=P=>{let D=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"u32\",length:x.length},{name:\"filter_dims\",type:\"u32\",length:$.length},{name:\"dilations\",type:\"u32\",length:$.length},{name:\"effective_filter_dims\",type:\"u32\",length:S.length},{name:\"pads\",type:\"i32\",length:T.length},{name:\"input_channels_per_group\",type:\"u32\"},{name:\"output_channels_per_group\",type:\"u32\"}],R=ye(e[0].dataType),H=i?1:2,L=i?2:3,re=i?3:1,V=E(\"W\",e[1].dataType,e[1].dims.length,h),K=E(\"Dy\",e[0].dataType,e[0].dims.length,m),we=[K,V];n&&we.push(E(\"bias\",e[2].dataType,[o[re]].length,u));let j=M(\"result\",e[0].dataType,o.length,u),Q=()=>{let te=\"\";if(m===1)te+=`\n        let w_offset = ${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n        let wValue = ${V.getByOffset(`w_offset / ${h}`)};\n        dotProd = dotProd + xValue * wValue;`;else if(p===1)te+=`\n          let wValue = ${V.getByOffset(`${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${h}`)};\n          dotProd = dotProd + dot(xValue, wValue);`;else for(let be=0;be<m;be++)te+=`\n            let wValue${be} = ${V.getByOffset(`${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${be}, wOutChannel)`)} / ${h}`)};\n            dotProd = dotProd + xValue[${be}] * wValue${be};`;return te},ie=`\n            let outputIndices = ${j.offsetToIndices(`global_idx * ${u}`)};\n            let batch = ${j.indicesGet(\"outputIndices\",0)};\n            let d1 = ${j.indicesGet(\"outputIndices\",re)};\n            let r = ${j.indicesGet(\"outputIndices\",H)};\n            let c = ${j.indicesGet(\"outputIndices\",L)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${j.type.value}(0.0);\n            var wR: u32 = 0;\n            if (uniforms.dilations.x == 1) {\n              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0\n              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);\n            }\n            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${R}(dyRCorner) + ${R}(wR)) / ${R}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${R}(uniforms.Dy_shape[${H}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              let idyR: u32 = u32(dyR);\n              var wC: u32 = 0;\n              if (uniforms.dilations.y == 1) {\n                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0\n                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);\n              }\n\n              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${R}(dyCCorner) + ${R}(wC)) / ${R}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${R}(uniforms.Dy_shape[${L}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${m}) {\n                  let xValue = ${i?K.getByOffset(`${K.indicesToOffset(`${K.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${m}`):K.get(\"batch\",\"inputChannel\",\"idyR\",\"idyC\")};\n                  ${Q()}\n                  inputChannel = inputChannel + ${m};\n                }\n                wC = wC + uniforms.strides.y - 1;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n            }\n            let value = dotProd${n?` + bias[d1 / ${u}]`:\"\"};\n            ${j.setByOffset(\"global_idx\",\"value\")};\n          `;return`\n    ${P.registerUniforms(D).declareVariables(...we,j)}\n      ${P.mainStart()}\n      ${P.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")};\n    ${ie}}`};return{name:\"ConvTranspose2D\",shaderCache:{hint:`${t.cacheKey};${m}${h}${u}${p===1}`,inputDependencies:g},getRunData:()=>({dispatchGroup:{x:y[0],y:y[1],z:y[2]},outputs:[{dims:r?r(o):o,dataType:e[0].dataType}],programUniforms:A}),getShaderSource:C}}});var bf,yf,_f,Ju,ed,wf,td,vf,rd,nd=U(()=>{\"use strict\";Xu();yt();dt();bf=(e,t,r,n,o,i)=>(e-1)*t+r+(n-1)*o+1-i,yf=(e,t,r,n,o)=>{let i=Math.floor(e/2);t===\"SAME_UPPER\"?(r[n]=i,r[o]=e-i):t===\"SAME_LOWER\"&&(r[n]=e-i,r[o]=i)},_f=(e,t,r,n,o,i,a,d,l,p)=>{let m=e.length-2,u=p.length===0;l.length<m&&l.push(...Array(m-l.length).fill(0));let h=e[0],_=t[d?3:1]*o;for(let y=0,g=e.length-m-(d?1:0);y<m;++y,++g){let x=e[g],$=u?x*a[y]:p[y],v=bf(x,a[y],i[y],t[g],r[y],$);yf(v,n,i,y,y+m),u&&p.push(a[y]*(x-1)+l[y]+(t[g]-1)*r[y]+1-i[y]-i[y+m])}p.splice(0,0,h),p.splice(d?3:1,0,_)},Ju=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((u,h)=>u*h,1)===0){r.length=0;for(let u=2;u<t[1].dims.length;++u)r.push(t[1].dims[u])}let n=e.format===\"NHWC\";r.splice(0,0,t[1].dims[0]),r.splice(n?3:1,0,t[1].dims[1]);let o=e.pads.slice(),i=e.outputShape.slice(),a=e.outputPadding.slice(),d=t[0].dims,l=e.dilations.slice();if(l.reduce((u,h)=>u+h,0)===0){let u=t[0].dims.length-2;l=new Array(u).fill(1)}let p=e.strides.slice();if(p.reduce((u,h)=>u+h,0)===0){let u=t[0].dims.length-2;p=new Array(u).fill(1)}_f(d,r,l,e.autoPad,e.group,o,p,n,a,i);let m=Object.assign({},e);return Object.assign(m,{kernelShape:r,pads:o,outputPadding:a,outputShape:i,dilations:l,strides:p}),m},ed=e=>{let t=Kr(e),r=e.format,n=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][typeof e.autoPad>\"u\"?0:e.autoPad],o=e.dilations,i=e.group,a=e.kernelShape,d=e.pads,l=e.strides,p=e.wIsConst(),m=e.outputPadding,u=e.outputShape;return{autoPad:n,format:r,dilations:o,group:i,kernelShape:a,outputPadding:m,outputShape:u,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},wf=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error(\"currently only support 2-dimensional conv\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let r=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],n=e[1].dims[0];if(r!==n)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");let o=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==o))throw new Error(\"invalid bias\");let i=e[0].dims.length-2;if(t.dilations.reduce((m,u)=>m+u,0)>0&&t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.reduce((m,u)=>m+u,0)>0&&t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.reduce((m,u)=>m+u,0)>0&&t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.outputPadding.length!==i&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${i}D`);if(t.kernelShape.reduce((m,u)=>m+u,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error(\"invalid output shape\")},td=(e,t,r,n)=>{let o=e.kernelCustomData.wT??e.compute(Pe(t[1],[2,3,0,1]),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=o);let i=[t[0],o];t.length===3&&i.push(t[2]),e.compute(Qu(i,r,n),{inputs:i})},vf=(e,t)=>{let r=t.format===\"NHWC\",n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&n.push(e.inputs[2]);let o=t.kernelShape;(o.length===0||o[0]===0)&&(o=[e.inputs[1].dims[2]]);let i=t.dilations;(i.length===0||i[0]===0)&&(i=[1]);let a=t.strides;(a.length===0||a[0]===0)&&(a=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],a=[1].concat(a),i=[1].concat(i),o=[1].concat(o);let l=t.outputPadding;l=[0].concat(l);let p=Ju({...t,pads:d,strides:a,dilations:i,kernelShape:o,outputPadding:l},n);td(e,n,p,m=>r?[m[0],m[2],m[3]]:[m[0],m[1],m[3]])},rd=(e,t)=>{if(wf(e.inputs,t),e.inputs[0].dims.length===3)vf(e,t);else{let r=Ju(t,e.inputs);td(e,e.inputs,r)}}});var $f,od,id,ad=U(()=>{\"use strict\";J();ne();xe();ae();$f=(e,t,r,n)=>{let o=k.size(t),i=t.length,a=E(\"input\",e,i),d=M(\"output\",e,i),l=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),p=k.normalizeAxis(l,i),m=u=>{let h=` i32(${a.indicesGet(\"inputIndices\",\"uniforms.axis\")}) `,_=q(\"uniforms.input_shape\",\"uniforms.axis\",i),y=n.reverse?h+(n.exclusive?\" + 1\":\"\"):\"0\",g=n.reverse?_:h+(n.exclusive?\"\":\" + 1\");return`\n                ${u.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axis\",\"u32\").declareVariables(a,d)}\n                ${u.mainStart()}\n                  ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n                  var inputIndices = ${d.offsetToIndices(\"global_idx\")};\n                  var sum = ${d.type.value}(0);\n                  let first : i32 = ${y};\n                  let last : i32 = ${g};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${a.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(i)\")};\n                    sum = sum + ${a.getByIndices(\"inputIndices\")};\n                  }\n                  ${d.setByOffset(\"global_idx\",\"sum\")};\n                }`};return{name:\"CumSum\",shaderCache:{hint:n.cacheKey,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:12,data:o},{type:12,data:p},...N(t,t)]}),getShaderSource:m}},od=(e,t)=>{let r=e.inputs[0].dims,n=e.inputs[0].dataType,o=e.inputs[1];e.compute($f(n,r,o,t),{inputs:[0]})},id=e=>{let t=e.exclusive===1,r=e.reverse===1;return ee({exclusive:t,reverse:r})}});var xf,Sf,Tf,sd,ud,dd=U(()=>{\"use strict\";J();ne();xe();ae();xf=e=>{if(!e||e.length!==1)throw new Error(\"DepthToSpace requires 1 input.\");if(e[0].dims.length!==4)throw new Error(\"DepthToSpace requires 4D input.\")},Sf=(e,t,r,n)=>{let o=[];o.push(`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let i=0;i<t;++i)o.push(r.indicesSet(\"a\",e[i],`i[${i}]`));return o.push(\"return a;}\"),o.join(`\n`)},Tf=(e,t)=>{let r,n,o,i,a,d,l=t.format===\"NHWC\",p=t.blocksize,m=t.mode===\"DCR\";l?([r,n,o,i]=e.dims,a=m?[r,n,o,p,p,i/p**2]:[r,n,o,i/p**2,p,p],d=m?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([r,n,o,i]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=m?[r,p,p,i/p**2,n,o]:[r,i/p**2,p,p,n,o],d=m?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let u=e.reshape(a),h=u.dims.length,_=e.dataType,y=E(\"a\",_,h),g=M(\"output\",_,h),x=$=>`\n  ${$.registerUniform(\"output_size\",\"u32\").declareVariables(y,g)}\n\n  ${Sf(d,h,y,g)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${g.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${g.setByOffset(\"global_idx\",y.getByIndices(\"aIndices\"))}\n  }`;return{name:\"DepthToSpace\",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:[\"rank\"]},getRunData:$=>{let v=l?[r,n*p,o*p,i/p**2]:[r,i/p**2,n*p,o*p],S=k.size(v),T=u.dims,A=k.sortBasedOnPerm(T,d);return{outputs:[{dims:v,dataType:$[0].dataType}],dispatchGroup:{x:Math.ceil(S/64)},programUniforms:[{type:12,data:S},...N(T,A)]}},getShaderSource:x}},sd=(e,t)=>{xf(e.inputs),e.compute(Tf(e.inputs[0],t))},ud=e=>ee({blocksize:e.blocksize,mode:e.mode,format:e.format})});var wo,Jr,ld,If,Cf,vo,$o,cd,Af,pd,md,fd=U(()=>{\"use strict\";J();ne();xe();ae();wo=\"[a-zA-Z]|\\\\.\\\\.\\\\.\",Jr=\"(\"+wo+\")+\",ld=\"^\"+Jr+\"$\",If=\"(\"+Jr+\",)*\"+Jr,Cf=\"^\"+If+\"$\",vo=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let n=this.symbolToIndices.get(t);n===void 0?n=[r]:n.push(r),this.symbolToIndices.set(t,n)}},$o=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,o]=r.includes(\"->\")?r.split(\"->\",2):[r,\"\"];if(!n.match(RegExp(Cf)))throw new Error(\"Invalid LHS term\");if(n.split(\",\").forEach((d,l)=>{let p=t[l].dims.slice();if(!d.match(RegExp(ld)))throw new Error(\"Invalid LHS term\");let m=this.processTerm(d,!0,p,l);this.lhs.push(m)}),o===\"\")o+=[...this.symbolToInfo.entries()].filter(([d,l])=>l.count===1||d===\"...\").map(([d])=>d).join(\"\");else if(!o.match(RegExp(Jr)))throw new Error(\"Invalid RHS\");o.match(RegExp(wo,\"g\"))?.forEach(d=>{if(d===\"...\")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let l=this.symbolToInfo.get(d);if(l===void 0)throw new Error(\"Invalid RHS symbol\");this.outputDims.push(l.dimValue)}}),this.rhs=this.processTerm(o,!1,this.outputDims)}addSymbol(t,r,n){let o=this.symbolToInfo.get(t);if(o!==void 0){if(o.dimValue!==r&&o.count!==1)throw new Error(\"Dimension mismatch\");o.count++,o.inputIndices.push(n)}else o={count:1,dimValue:r,inputIndices:[n]};this.symbolToInfo.set(t,o)}processTerm(t,r,n,o=-1){let i=n.length,a=!1,d=[],l=0;if(!t.match(RegExp(ld))&&!r&&t!==\"\")throw new Error(\"Invalid LHS term\");let p=t.match(RegExp(wo,\"g\")),m=new vo(o);return p?.forEach((u,h)=>{if(u===\"...\"){if(a)throw new Error(\"Only one ellipsis is allowed per input term\");a=!0;let _=i-p.length+1;if(_<0)throw new Error(\"Ellipsis out of bounds\");if(d=n.slice(l,l+_),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error(\"Ellipsis dimensions mismatch\")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error(\"Ellipsis must be specified in the LHS\");for(let y=0;y<d.length;y++){let g=String.fromCharCode(\"0\".charCodeAt(0)+y);m.addSymbol(g,h+y),this.addSymbol(g,n[l++],o)}}else m.addSymbol(u,h+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(u,n[l++],o)}),m}},cd=e=>e+\"_max\",Af=(e,t,r,n)=>{let i=e.map(m=>m.length).map((m,u)=>E(`input${u}`,t,m)),a=k.size(n),d=M(\"output\",t,n.length),l=[...r.symbolToInfo.keys()].filter(m=>!r.rhs.symbolToIndices.has(m)),p=m=>{let u=[],h=\"var prod = 1.0;\",_=\"var sum = 0.0;\",y=\"sum += prod;\",g=[],x=[],$=[],v=[],S=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((A,C)=>{if(r.rhs.symbolToIndices.has(C)){let P=r.rhs.symbolToIndices.get(C)?.[0];P!==void 0&&r.lhs.forEach((D,R)=>{if(A.inputIndices.includes(R)){let H=D.symbolToIndices.get(C);if(H===void 0)throw new Error(\"Invalid symbol error\");H.forEach(L=>{u.push(`${i[R].indicesSet(`input${R}Indices`,L,d.indicesGet(\"outputIndices\",P))}`)})}})}else r.lhs.forEach((P,D)=>{if(A.inputIndices.includes(D)){let R=P.symbolToIndices.get(C);if(R===void 0)throw new Error(\"Invalid symbol error\");R.forEach(H=>{g.push(`${i[D].indicesSet(`input${D}Indices`,H,`${C}`)}`)}),v.push(`prod *= ${i[D].getByIndices(`input${D}Indices`)};`)}}),x.push(`for(var ${C}: u32 = 0; ${C} < uniforms.${cd(C)}; ${C}++) {`),$.push(\"}\")});let T=S?[...u,`let sum = ${i.map((A,C)=>A.getByIndices(`input${C}Indices`)).join(\" * \")};`]:[...u,_,...x,...g,h,...v,y,...$];return`\n            ${m.registerUniforms(l.map(A=>({name:`${cd(A)}`,type:\"u32\"}))).registerUniform(\"outputSize\",\"u32\").declareVariables(...i,d)}\n\n            ${m.mainStart()}\n            ${m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n            var outputIndices = ${d.offsetToIndices(\"global_idx\")};\n            ${i.map((A,C)=>`var input${C}Indices: ${i[C].type.indices};`).join(`\n`)}\n            ${T.join(`\n`)};\n            ${d.setByOffset(\"global_idx\",\"sum\")};\n          }`};return{name:\"Einsum\",shaderCache:{hint:r.equation,inputDependencies:e.map(()=>\"rank\")},getRunData:()=>{let m=l.filter(h=>r.symbolToInfo.has(h)).map(h=>({type:12,data:r.symbolToInfo.get(h)?.dimValue||0}));m.push({type:12,data:a});let u=e.map((h,_)=>[...N(h)]).reduce((h,_)=>h.concat(_),m);return u.push(...N(n)),{outputs:[{dims:n,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:u}},getShaderSource:p}},pd=(e,t)=>{let r=new $o(e.inputs,t.equation),n=r.outputDims,o=e.inputs.map((i,a)=>i.dims);e.compute(Af(o,e.inputs[0].dataType,r,n))},md=e=>{let t=e.equation.replace(/\\s+/g,\"\");return ee({equation:t})}});var kf,hd,Ef,Pf,gd,bd=U(()=>{\"use strict\";J();ne();ae();kf=e=>{if(!e||e.length!==2)throw new Error(\"Expand requires 2 input.\");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=r.length<t.length?0:r.length-t.length,o=t.length<r.length?0:t.length-r.length;for(;n<r.length&&o<t.length;++n,++o)if(r[n]!==t[o]&&r[n]!==1&&t[o]!==1)throw new Error(\"Expand requires shape to be broadcastable to input\")},hd=(e,t)=>{let r=e.length-t.length,n=[];for(let o=0;o<r;++o)n.push(e[o]);for(let o=0;o<t.length;++o)n.push(t[o]===1?e[o+r]:t[o]);return n},Ef=(e,t)=>e.length>t.length?hd(e,t):hd(t,e),Pf=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=Ef(t,r),o=e[0].dataType,i=o===9||k.size(t)===1,a=o===9||t.length>0&&t[t.length-1]%4===0?4:1,d=i||n.length>0&&n[n.length-1]%4===0?4:1,l=Math.ceil(k.size(n)/d),p=u=>{let h=E(\"input\",o,t.length,a),_=M(\"output\",o,n.length,d),y;if(o===9){let g=(x,$,v=\"\")=>`\n          let outputIndices${$} = ${_.offsetToIndices(`outputOffset + ${$}u`)};\n          let offset${$} = ${h.broadcastedIndicesToOffset(`outputIndices${$}`,_)};\n          let index${$} = offset${$} / 4u;\n          let component${$} = offset${$} % 4u;\n          ${x}[${$}] = ${v}(${h.getByOffset(`index${$}`)}[component${$}]);\n        `;y=`\n        let outputOffset = global_idx * ${d};\n        var data = vec4<u32>(0);\n        ${g(\"data\",0,\"u32\")}\n        ${g(\"data\",1,\"u32\")}\n        ${g(\"data\",2,\"u32\")}\n        ${g(\"data\",3,\"u32\")}\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`}else y=`\n        let outputIndices = ${_.offsetToIndices(`global_idx * ${d}`)};\n        let inputOffset = ${h.broadcastedIndicesToOffset(\"outputIndices\",_)};\n        let data = ${_.type.value}(${h.getByOffset(`inputOffset / ${a}`)});\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`;return`\n    ${u.registerUniform(\"vec_size\",\"u32\").declareVariables(h,_)}\n    ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n    ${y}`},m=[{type:12,data:l},...N(t,n)];return{name:\"Expand\",shaderCache:{hint:`${n.length};${a}${d}`,inputDependencies:[\"rank\"]},getShaderSource:p,getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:m})}},gd=e=>{kf(e.inputs),e.compute(Pf(e.inputs),{inputs:[0]})}});var zf,yd,_d=U(()=>{\"use strict\";J();ne();ae();qr();zf=e=>{let t=e[0].dataType,r=k.size(e[0].dims),n=k.size(e[1].dims),o=n%4===0,i=a=>{let d=E(\"x\",t,[1],4),l=E(\"bias\",t,[1],4),p=M(\"y\",t,[1],4),m=[{name:\"output_vec_size\",type:\"u32\"},{name:\"bias_size\",type:\"u32\"}],u=_=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${l.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,h=o?`\n      let bias = ${l.getByOffset(\"global_idx % (uniforms.bias_size / 4)\")};`:`${u(0)}${u(1)}${u(2)}${u(3)}\n      let bias = ${d.type.value}(bias0, bias1, bias2, bias3);`;return`${a.registerUniforms(m).declareVariables(d,l,p)}\n\n    ${po(Ee(t))}\n\n    ${a.mainStart(Et)}\n      ${a.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_vec_size\")}\n\n      let x = ${d.getByOffset(\"global_idx\")};\n      ${h}\n      let x_in = x + bias;\n      ${p.setByOffset(\"global_idx\",mo(\"x_in\"))}\n    }`};return{name:\"FastGeluWithBias\",shaderCache:{hint:`${o}`,inputDependencies:[\"type\",\"type\"]},getShaderSource:i,getRunData:a=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:n}],dispatchGroup:{x:Math.ceil(r/Et/4)}})}},yd=e=>{e.inputs.length<2||k.size(e.inputs[1].dims)===0?fu(e):e.compute(zf(e.inputs))}});var Of,Df,wd,vd,$d=U(()=>{\"use strict\";J();ne();xe();ae();Of=e=>{if(!e||e.length!==2)throw new Error(\"Gather requires 2 inputs.\")},Df=(e,t)=>{let r=e[0].dims,n=e[1].dims,o=r.length,i=k.normalizeAxis(t.axis,o),a=r.slice(0);a.splice(i,1,...n);let d=r[i],l=e[0].dataType===9?4:1,p=Math.ceil(k.size(a)/l),m=[{type:12,data:p},{type:6,data:d},{type:12,data:i},...N(e[0].dims,e[1].dims,a)],u=h=>{let _=E(\"data\",e[0].dataType,e[0].dims.length,l),y=E(\"inputIndices\",e[1].dataType,e[1].dims.length),g=M(\"output\",e[0].dataType,a.length,l),x=v=>{let S=n.length,T=`var indicesIndices${v}  = ${y.type.indices}(0);`;for(let A=0;A<S;A++)T+=`${S>1?`indicesIndices${v}[${A}]`:`indicesIndices${v}`} = ${a.length>1?`outputIndices${v}[uniforms.axis + ${A}]`:`outputIndices${v}`};`;T+=`\n          var idx${v} = ${y.getByIndices(`indicesIndices${v}`)};\n          if (idx${v} < 0) {\n            idx${v} = idx${v} + uniforms.axisDimLimit;\n          }\n          var dataIndices${v} : ${_.type.indices};\n        `;for(let A=0,C=0;A<o;A++)A===i?(T+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = u32(idx${v});`,C+=S):(T+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = ${a.length>1?`outputIndices${v}[${C}]`:`outputIndices${v}`};`,C++);return T},$;if(e[0].dataType===9){let v=(S,T,A=\"\")=>`\n          let outputIndices${T} = ${g.offsetToIndices(`outputOffset + ${T}u`)};\n          ${x(T)};\n          let offset${T} = ${_.indicesToOffset(`dataIndices${T}`)};\n          let index${T} = offset${T} / 4u;\n          let component${T} = offset${T} % 4u;\n          ${S}[${T}] = ${A}(${_.getByOffset(`index${T}`)}[component${T}]);\n        `;$=`\n        let outputOffset = global_idx * ${l};\n        var value = vec4<u32>(0);\n        ${v(\"value\",0,\"u32\")}\n        ${v(\"value\",1,\"u32\")}\n        ${v(\"value\",2,\"u32\")}\n        ${v(\"value\",3,\"u32\")}\n        ${g.setByOffset(\"global_idx\",\"value\")}\n      `}else $=`\n      let outputIndices = ${g.offsetToIndices(\"global_idx\")};\n      ${x(\"\")};\n      let value = ${_.getByIndices(\"dataIndices\")};\n      ${g.setByOffset(\"global_idx\",\"value\")};\n      `;return`\n      ${h.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(_,y,g)}\n      ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        ${$}\n      }`};return{name:\"Gather\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:m}),getShaderSource:u}},wd=e=>ee({axis:e.axis}),vd=(e,t)=>{let r=e.inputs;Of(r),e.compute(Df(e.inputs,t))}});var Bf,xd,Sd,Td=U(()=>{\"use strict\";J();ne();ae();Bf=(e,t,r,n,o,i,a,d,l)=>{let p=[{type:12,data:i},{type:12,data:n},{type:12,data:o},{type:12,data:r},{type:12,data:a},{type:12,data:d},{type:12,data:l}],m=[i];p.push(...N(t.dims,m));let u=h=>{let _=E(\"indices_data\",t.dataType,t.dims.length),y=M(\"input_slice_offsets_data\",12,1,1),g=[_,y],x=[{name:\"output_size\",type:\"u32\"},{name:\"batch_dims\",type:\"u32\"},{name:\"input_dims\",type:\"u32\",length:o.length},{name:\"sizes_from_slice_dims_data\",type:\"u32\",length:r.length},{name:\"num_slices_per_batch\",type:\"u32\"},{name:\"input_batch_stride\",type:\"u32\"},{name:\"num_slice_dims\",type:\"u32\"}];return`\n  ${h.registerUniforms(x).declareVariables(...g)}\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${o.length===1?\"index += i32(uniforms.input_dims);\":\"index += i32(uniforms.input_dims[input_dim_idx]);\"}\n      }\n      ${r.length===1?\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);\":\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);\"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`};return e.compute({name:\"computeSliceOffsets\",shaderCache:{hint:`${o.length}_${r.length}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:m,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:p}),getShaderSource:u},{inputs:[t],outputs:[-1]})[0]},xd=(e,t)=>{let r=e.inputs,n=r[0].dims,o=r[0].dataType,i=r[1].dims,a=i[i.length-1],d=k.sizeToDimension(i,i.length-1),l=k.sizeFromDimension(n,t.batchDims+a),p=k.sizeToDimension(n,t.batchDims),m=k.sizeFromDimension(n,t.batchDims),u=d/p,h=new Array(a),_=l;for(let T=0;T<a;++T)h[a-1-T]=_,_*=n[t.batchDims+a-1-T];let y=Bf(e,r[1],h,t.batchDims,n,d,u,m,a),g=t.batchDims+a;if(g>n.length)throw new Error(\"last dimension of indices must not be larger than rank of input tensor\");let x=i.slice(0,-1).concat(n.slice(g)),$=k.size(x),v=[{type:12,data:$},{type:12,data:l},...N(r[0].dims,y.dims,x)],S=T=>{let A=E(\"data\",r[0].dataType,r[0].dims.length),C=E(\"slice_offsets\",12,y.dims.length),P=M(\"output\",r[0].dataType,x.length);return`\n          ${T.registerUniform(\"output_size\",\"u32\").registerUniform(\"slice_size\",\"u32\").declareVariables(A,C,P)}\n            ${T.mainStart()}\n            ${T.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`};e.compute({name:\"GatherND\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:x,dataType:o}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:v}),getShaderSource:S},{inputs:[r[0],y]})},Sd=e=>({batchDims:e.batch_dims,cacheKey:\"\"})});var Mf,Rf,Id,Cd,Ad=U(()=>{\"use strict\";J();ne();xe();ae();Mf=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"GatherBlockQuantized requires 3 or 4 inputs.\");let r=k.normalizeAxis(t.quantizeAxis,e[0].dims.length),n=t.blockSize,o=e[0],i=e[2],a=e.length===4?e[3]:void 0;if(i.dims.length!==o.dims.length||!o.dims.map((d,l)=>l===r?Math.ceil(d/n)===i.dims[l]:d===i.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.\");if(a){if(a.dataType!==o.dataType)throw new Error(\"Zero point must have the same data type as the input tensor.\");if(a.dims.length!==i.dims.length||!a.dims.map((d,l)=>d===i.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.\")}},Rf=(e,t)=>{let r=e[0].dims,n=e[1].dims,o=r.length,i=k.normalizeAxis(t.gatherAxis,o),a=k.normalizeAxis(t.quantizeAxis,o),d=r.slice(0);d.splice(i,1,...n);let l=k.size(d),p=e[2].dataType,u=e[0].dataType===22,h=[{type:12,data:l},{type:12,data:a},{type:12,data:i},{type:12,data:t.blockSize},...N(...e.map((y,g)=>y.dims),d)],_=y=>{let g=E(\"data\",e[0].dataType,e[0].dims.length),x=E(\"inputIndices\",e[1].dataType,e[1].dims.length),$=E(\"scales\",e[2].dataType,e[2].dims.length),v=e.length>3?E(\"zeroPoint\",e[3].dataType,e[3].dims.length):void 0,S=M(\"output\",p,d.length),T=[g,x,$];v&&T.push(v);let A=[{name:\"output_size\",type:\"u32\"},{name:\"quantize_axis\",type:\"u32\"},{name:\"gather_axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n        ${y.registerUniforms(A).declareVariables(...T,S)}\n        ${y.mainStart()}\n        let output_indices = ${S.offsetToIndices(\"global_idx\")};\n        var indices_indices = ${x.type.indices}(0);\n        ${(()=>n.length>1?`\n          for (var i: u32 = 0; i < ${n.length}; i++) {\n            let index = ${S.indicesGet(\"output_indices\",\"uniforms.gather_axis + i\")};\n            ${x.indicesSet(\"indices_indices\",\"i\",\"index\")};\n          }`:`indices_indices = ${S.indicesGet(\"output_indices\",\"uniforms.gather_axis\")};`)()};\n        var data_indices = ${g.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${S.indicesGet(\"output_indices\",\"i\")};\n          ${g.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        var index_from_indices = ${x.getByIndices(\"indices_indices\")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${r[i]};\n        }\n        ${g.indicesSet(\"data_indices\",\"uniforms.gather_axis\",\"u32(index_from_indices)\")};\n        for (var i = uniforms.gather_axis + 1; i < ${d.length}; i++) {\n          let index = ${S.indicesGet(\"output_indices\",`i + ${n.length} - 1`)};\n          ${g.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        let data_offset = ${g.indicesToOffset(\"data_indices\")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${g.getByOffset(\"data_offset / 8\")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${u?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${$.indicesGet(\"data_indices\",\"uniforms.quantize_axis\")} / uniforms.block_size;\n        ${$.indicesSet(\"scale_indices\",\"uniforms.quantize_axis\",\"quantize_axis_index\")};\n        var scale = ${$.getByIndices(\"scale_indices\")};\n        ${(()=>v?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${v.indicesToOffset(\"zero_point_indices\")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${v.getByOffset(\"zero_point_offset / 8\")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${u?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:\"var zero_point = 0\")()};\n        let dequantized_data = ${Ee(p)}(quantized_data - zero_point) * scale;\n        ${S.setByOffset(\"global_idx\",\"dequantized_data\")};\n    }`};return{name:\"GatherBlockQuantized\",shaderCache:{hint:`${t.cacheKey};${e.filter((y,g)=>g!==1).map(y=>y.dims.join(\"_\")).join(\";\")}`,inputDependencies:Array.from({length:e.length},(y,g)=>\"rank\")},getRunData:()=>({outputs:[{dims:d,dataType:p}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:h}),getShaderSource:_}},Id=(e,t)=>{let r=e.inputs;Mf(r,t),e.compute(Rf(e.inputs,t))},Cd=e=>ee({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})});var Uf,Nf,kd,Ed,Pd=U(()=>{\"use strict\";J();ne();xe();ae();Uf=e=>{if(!e||e.length!==2)throw new Error(\"GatherElements requires 2 inputs.\");if(e[0].dims.length<1)throw new Error(\"GatherElements requires that the data input be rank >= 1.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Nf=(e,t)=>{let r=e[0].dims,n=e[0].dataType,o=r.length,i=e[1].dims,a=e[1].dataType,d=k.normalizeAxis(t.axis,o),l=r[d],p=i.slice(0),m=k.size(p),u=E(\"input\",n,o),h=E(\"indicesInput\",a,i.length),_=M(\"output\",n,p.length),y=[{type:12,data:m},{type:6,data:l},{type:12,data:d}];return y.push(...N(r,i,p)),{name:\"GatherElements\",shaderCache:{inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:y}),getShaderSource:$=>`\n      ${$.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(u,h,_)}\n      ${$.mainStart()}\n      ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n      let outputIndices = ${_.offsetToIndices(\"global_idx\")};\n\n      var idx = ${h.getByOffset(\"global_idx\")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${u.type.indices}(outputIndices);\n      ${u.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(idx)\")};\n      let value = ${u.getByIndices(\"inputIndices\")};\n\n      ${_.setByOffset(\"global_idx\",\"value\")};\n  }`}},kd=e=>ee({axis:e.axis}),Ed=(e,t)=>{let r=e.inputs;Uf(r),e.compute(Nf(e.inputs,t))}});var Vf,Wf,zd,Od,Dd=U(()=>{\"use strict\";J();ne();ae();Vf=e=>{if(!e)throw new Error(\"Input is missing\");if(e.length<2||e.length>3)throw new Error(\"Invaid input number.\");if(e.length===3&&e[2].dims.length>2)throw new Error(\"Invalid input shape of C\");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"Input types are mismatched\")},Wf=(e,t)=>{let r=e[0].dims.slice(),n=e[1].dims.slice(),[o,i,a]=Nr.getShapeOfGemmResult(r,t.transA,n,t.transB,e.length===3?e[2].dims:void 0),d=[o,i];if(!d)throw new Error(\"Can't use gemm on the given tensors\");let l=16,p=Math.ceil(i/l),m=Math.ceil(o/l),u=!0,h=k.size(d),_=[{type:12,data:u?p:h},{type:12,data:o},{type:12,data:i},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}],y=[\"type\",\"type\"];e.length===3&&(_.push(...N(e[2].dims)),y.push(\"rank\")),_.push(...N(d));let g=$=>{let v=\"\";t.transA&&t.transB?v=\"value += a[k * uniforms.M + m] * b[n * uniforms.K + k];\":t.transA&&!t.transB?v=\"value += a[k * uniforms.M + m] * b[k * uniforms.N + n];\":!t.transA&&t.transB?v=\"value += a[m * uniforms.K + k] * b[n * uniforms.K + k];\":!t.transA&&!t.transB&&(v=\"value += a[m * uniforms.K + k] * b[k * uniforms.N + n];\");let S=t.alpha===1?\"\":\"value *= uniforms.alpha;\",T=E(\"a\",e[0].dataType,e[0].dims),A=E(\"b\",e[1].dataType,e[1].dims),C=T.type.value,P=null,D=[T,A];e.length===3&&(P=E(\"c\",e[2].dataType,e[2].dims.length),D.push(P));let R=M(\"output\",e[0].dataType,d.length);D.push(R);let H=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}];return`\n  ${$.registerUniforms(H).declareVariables(...D)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${C}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${v}\n    }\n\n    ${S}\n    ${(()=>P!=null?`let cOffset = ${P.broadcastedIndicesToOffset(\"vec2(m, n)\",R)}; value += ${C}(uniforms.beta) * ${P.getByOffset(\"cOffset\")};`:\"\")()}\n    output[global_idx] = value;\n  }`},x=$=>{let v=E(\"a\",e[0].dataType,e[0].dims),S=E(\"b\",e[1].dataType,e[1].dims),T=null,A=[v,S];e.length===3&&(T=E(\"c\",e[2].dataType,e[2].dims.length),A.push(T));let C=M(\"output\",e[0].dataType,d.length);A.push(C);let P=[{name:\"num_tile_n\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}],D=\"\",R=\"\";t.transA&&t.transB?(R=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[k][local_id.y] * tile_b[local_id.x][k];\"):t.transA&&!t.transB?(R=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[k][local_id.y] * tile_b[k][local_id.x];\"):!t.transA&&t.transB?(R=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[local_id.y][k] * tile_b[local_id.x][k];\"):!t.transA&&!t.transB&&(R=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[local_id.y][k] * tile_b[k][local_id.x];\");let H=t.alpha===1?\"\":\"value *= uniforms.alpha;\";return`\n  ${$.registerUniforms(P).declareVariables(...A)}\n  var<workgroup> tile_a: array<array<${v.type.storage}, ${l}>, ${l}>;\n  var<workgroup> tile_b: array<array<${S.type.storage}, ${l}>, ${l}>;\n  ${$.mainStart([l,l,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};\n    let num_tiles = (uniforms.K - 1) / ${l} + 1;\n    var k_start = 0u;\n    var value = ${C.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${R}\n      k_start = k_start + ${l};\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < ${l}; k++) {\n        ${D}\n      }\n      workgroupBarrier();\n    }\n\n    ${H}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${(()=>T!=null?`let cOffset = ${T.broadcastedIndicesToOffset(\"vec2(m, n)\",C)}; value += ${C.type.value}(uniforms.beta) * ${T.getByOffset(\"cOffset\")};`:\"\")()}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`};return u?{name:\"GemmShared\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:p*m},programUniforms:_}),getShaderSource:x}:{name:\"Gemm\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:_}),getShaderSource:g}},zd=e=>{let t=e.transA,r=e.transB,n=e.alpha,o=e.beta;return{transA:t,transB:r,alpha:n,beta:o,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},Od=(e,t)=>{Vf(e.inputs),e.compute(Wf(e.inputs,t))}});var lt,_t,Nt,Vt,Lf,Gf,Hf,Ff,qf,Kf,jf,Yf,Bd,Md,Rd=U(()=>{\"use strict\";J();ne();xe();ae();[lt,_t,Nt,Vt]=[0,1,2,3],Lf=e=>{if(e[0].dims.length!==4)throw new Error(\"only 4-D tensor is supported.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"input dimensions must be equal to grid dimensions\");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error(\"grid batch size must match input batch size\")},Gf=`\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n`,Hf=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,Ff=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${e.alignCorners===0?`\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    `:`\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    `}\n  }\n`,qf=e=>`\n  ${e.paddingMode===\"reflection\"?`\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }`:\"\"}\n`,Kf=(e,t,r)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${lt}] = batch;\n     indices[${_t}] = channel;`+(()=>{switch(r.paddingMode){case\"zeros\":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${Nt}] = u32(r);\n            indices[${Vt}] = u32(c);\n          }\n        `;case\"border\":return`\n          indices[${Nt}] = u32(clamp(r, 0, H - 1));\n          indices[${Vt}] = u32(clamp(c, 0, W - 1));\n        `;case\"reflection\":return`\n          indices[${Nt}] = gs_reflect(r, border[1], border[3]);\n          indices[${Vt}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${r.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices(\"indices\")};\n  }\n`,jf=(e,t,r)=>(()=>{switch(r.mode){case\"nearest\":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${lt}], indices[${_t}], border);\n        `;case\"bilinear\":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${lt}], indices[${_t}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case\"bicubic\":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${lt}], indices[${_t}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${r.mode} is not supported`)}})()+`${e.setByOffset(\"global_idx\",\"result\")}`,Yf=(e,t)=>{let r=E(\"x\",e[0].dataType,e[0].dims.length),n=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],o=E(\"grid\",e[1].dataType,n.length,2),i=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];t.format===\"NHWC\"&&(i=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[lt,_t,Nt,Vt]=[0,3,1,2]);let a=M(\"output\",e[0].dataType,i.length),d=r.type.value,l=k.size(i),p=[{type:12,data:l},...N(e[0].dims,n,i)],m=u=>`\n  ${u.registerUniform(\"output_size\",\"u32\").declareVariables(r,o,a)}\n  ${Gf}\n  ${Hf(d)}\n  ${Ff(t)}\n  ${qf(t)}\n  ${Kf(r,d,t)}\n\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let H_in = i32(uniforms.x_shape[${Nt}]);\n      let W_in = i32(uniforms.x_shape[${Vt}]);\n\n      ${t.alignCorners===0?`\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      `:`\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      `};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${a.offsetToIndices(\"global_idx\")};\n      var grid_indices = vec3<u32>(indices[${lt}], indices[${Nt}], indices[${Vt}]);\n      let nxy = ${o.getByIndices(\"grid_indices\")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${jf(a,d,t)}\n  }`;return{name:\"GridSample\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:[\"type\",\"type\"]},getRunData:u=>{let h=k.size(i);return{outputs:[{dims:i,dataType:u[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:p}},getShaderSource:m}},Bd=(e,t)=>{Lf(e.inputs),e.compute(Yf(e.inputs,t))},Md=e=>ee({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})});var Me,Xf,Nd,Ud,Jf,er,Vd,xo=U(()=>{\"use strict\";J();ne();xe();Ur();Hr();ae();dt();Me=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,Xf=(e,t)=>{let r=e[0],n=Me(e,1),o=Me(e,2),i=Me(e,3),a=Me(e,4),d=Me(e,5),l=Me(e,6),p=Me(e,7);if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let m=r.dims[0],u=r.dims[1],h=r.dims.length===3?r.dims[2]:t.numHeads*r.dims[4],_=u,y=0,g=0,x=Math.floor(h/t.numHeads);if(l&&p&&k.size(l.dims)&&k.size(p.dims)){if(l.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(l.dims[0]!==m||l.dims[1]!==t.numHeads||l.dims[3]!==x)throw new Error('Input \"past_key\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(p.dims[0]!==m||p.dims[1]!==t.numHeads||p.dims[3]!==x)throw new Error('Input \"past_value\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==p.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have same dim 2 (past_sequence_length)');if(p.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');y=l.dims[2],g=l.dims[2]}else if(l&&k.size(l.dims)||p&&k.size(p.dims))throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let $;if(n&&k.size(n.dims)>0){if(r.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(n.dims.length===3){if(n.dims[2]!==r.dims[2])throw new Error('Input \"query\" and \"key\" shall have same dim 2 (hidden_size)');$=2,_=n.dims[1]}else if(n.dims.length===5){if(n.dims[2]!==t.numHeads||n.dims[3]!==2||n.dims[4]!==x)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');$=5,_=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==x)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');$=0,_=n.dims[2]}}else{if(r.dims.length!==5)throw new Error('Input \"query\" is expected to have 5 dimensions when key is empty');if(r.dims[2]!==t.numHeads||r.dims[3]!==3)throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');$=3}if(i&&k.size(i.dims)>0){if(i.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimension');if(n&&n.dims.length===5&&n.dims[3]===2)throw new Error(\"bias is not allowed for packed kv.\")}let v=y+_,S=0;if(a&&k.size(a.dims)>0){S=8;let P=a.dims;throw P.length===1?P[0]===m?S=1:P[0]===3*m+2&&(S=3):P.length===2&&P[0]===m&&P[1]===v&&(S=5),S===8?new Error('Input \"key_padding_mask\" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error(\"Mask not supported\")}let T=!1,A=h;if(o&&k.size(o.dims)>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(r.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(_!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(_!==o.dims[2])throw new Error('Input \"key\" and \"value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],T=!0}}let C=!1;if(a&&k.size(a.dims)>0)throw new Error(\"Key padding mask is not supported\");if(d&&k.size(d.dims)>0){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" is expected to have 4 dimensions');if(d.dims[0]!==m||d.dims[1]!==t.numHeads||d.dims[2]!==u||d.dims[3]!==v)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:m,sequenceLength:u,pastSequenceLength:y,kvSequenceLength:_,totalSequenceLength:v,maxSequenceLength:g,inputHiddenSize:0,hiddenSize:h,vHiddenSize:A,headSize:x,vHeadSize:Math.floor(A/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:S,scale:t.scale,broadcastResPosBias:C,passPastInKv:T,qkvFormat:$}},Nd=e=>ee({...e}),Ud=ee({perm:[0,2,1,3]}),Jf=(e,t,r,n,o,i,a)=>{let d=[n,o,i],l=k.size(d),p=[{type:12,data:l},{type:12,data:a},{type:12,data:i}],m=u=>{let h=M(\"qkv_with_bias\",t.dataType,d),_=E(\"qkv\",t.dataType,d),y=E(\"bias\",r.dataType,d),g=[{name:\"output_size\",type:\"u32\"},{name:\"bias_offset\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"}];return`\n  ${u.registerUniforms(g).declareVariables(_,y,h)}\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:\"MultiHeadAttentionAddBias\",shaderCache:{inputDependencies:[\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:d,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p}),getShaderSource:m},{inputs:[t,r],outputs:[-1]})[0]},er=(e,t,r,n,o,i,a,d)=>{let l=i;if(a&&k.size(a.dims)>0){if(n===1)throw new Error(\"AddBiasReshape is not implemented. Please export your model with packed QKV or KV\");return l=Jf(e,i,a,t,n,r*o,d),l=l.reshape([t,n,r,o]),r===1||n===1?l:e.compute(Pe(l,Ud.perm),{inputs:[l],outputs:[-1]})[0]}else return i.dims.length===3&&(l=i.reshape([t,n,r,o])),r===1||n===1?l:e.compute(Pe(l,Ud.perm),{inputs:[l],outputs:[-1]})[0]},Vd=(e,t)=>{let r=Xf(e.inputs,t),n=e.inputs[0],o=Me(e.inputs,1),i=Me(e.inputs,2),a=Me(e.inputs,3),d=Me(e.inputs,4),l=Me(e.inputs,5),p=Me(e.inputs,6),m=Me(e.inputs,7);if(n.dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(o?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let u=o&&i&&o.dims.length===4&&i.dims.length===4,h=er(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,n,a,0);if(u)return Ut(e,h,o,i,d,void 0,p,m,l,r);if(!o||!i)throw new Error(\"key and value must be provided\");let _=er(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,o,a,r.hiddenSize),y=er(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,i,a,2*r.hiddenSize);Ut(e,h,_,y,d,void 0,p,m,l,r)}});var eh,th,rh,nh,So,Wd,Ld,To=U(()=>{\"use strict\";J();ne();xe();ae();eh=e=>{if(!e||e.length<1)throw new Error(\"too few inputs\")},th=(e,t)=>{let r=[],n=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),n=r.length),ee({numOutputs:n,axis:t.axis,splitSizes:r})},rh=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${q(\"uniforms.size_in_split_axis\",\"i\",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,nh=e=>{let t=e.length,r=[];for(let n=0;n<t;++n){let o=e[n].setByIndices(\"indices\",\"input[global_idx]\");t===1?r.push(o):n===0?r.push(`if (output_number == ${n}u) { ${o} }`):n===t-1?r.push(`else { ${o} }`):r.push(`else if (output_number == ${n}) { ${o} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},So=(e,t)=>{let r=e[0].dims,n=k.size(r),o=e[0].dataType,i=k.normalizeAxis(t.axis,r.length),a=new Array(t.numOutputs),d=E(\"input\",o,r.length),l=new Array(t.numOutputs),p=[],m=[],u=0,h=[{type:12,data:n}];for(let y=0;y<t.numOutputs;y++){u+=t.splitSizes[y],l[y]=u;let g=r.slice();g[i]=t.splitSizes[y],m.push(g),a[y]=M(`output${y}`,o,g.length),p.push({dims:m[y],dataType:e[0].dataType})}h.push({type:12,data:l},...N(r,...m));let _=y=>`\n  ${y.registerUniform(\"input_size\",\"u32\").registerUniform(\"size_in_split_axis\",\"u32\",l.length).declareVariables(d,...a)}\n  ${rh(l.length)}\n  ${nh(a)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.input_size\")}\n\n    var indices = ${d.offsetToIndices(\"global_idx\")};\n    var index = ${d.indicesGet(\"indices\",i)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${q(\"uniforms.size_in_split_axis\",\"output_number - 1u\",l.length)};\n      ${d.indicesSet(\"indices\",i,\"index\")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:\"Split\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\"]},getShaderSource:_,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(n/64)},programUniforms:h})}},Wd=(e,t)=>{eh(e.inputs);let r=e.inputs.length===1?t:th(e.inputs,t);e.compute(So(e.inputs,r),{inputs:[0]})},Ld=e=>{let t=e.axis,r=e.splitSizes,n=e.numOutputs<0?r.length:e.numOutputs;if(n!==r.length)throw new Error(\"numOutputs and splitSizes lengh must be equal\");return ee({axis:t,numOutputs:n,splitSizes:r})}});var oh,ih,Gd,Hd,Fd=U(()=>{\"use strict\";xe();Hr();xo();To();dt();oh=(e,t)=>{if(t.doRotary)throw new Error(\"GroupQuerryAttention do_rotary attribute is not supported\");if(t.doRotary&&e.length<=7)throw new Error(\"cos_cache and sin_cache inputs are required if do_rotary is specified\");let r=e[0],n=e[1],o=e[2],i=e[3],a=e[4];if(t.localWindowSize!==-1)throw new Error(\"Local attention is not supported\");if(t.softcap!==0)throw new Error(\"Softcap is not supported\");if(t.rotaryInterleaved!==0)throw new Error(\"Rotary interleaved is not supported\");if(t.smoothSoftmax)throw new Error(\"Smooth softmax is not supported\");if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let d=!1,l=r.dims[0],p=r.dims[1],m=r.dims.length===3?d?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],u=p,h=0,_=!n||n.dims.length===0,y=Math.floor(_?m/(t.numHeads+2*t.kvNumHeads):m/t.numHeads);_&&(m=y*t.numHeads);let g=i&&i.dims.length!==0,x=a&&a.dims.length!==0;if(g&&i.dims.length===4&&i.dims[0]===l&&i.dims[1]!==t.kvNumHeads&&i.dims[2]===t.kvNumHeads&&i.dims[3]===y)throw new Error(\"BSNH pastKey/pastValue is not supported\");if(g&&x){if(i.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(a.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');h=i.dims[2]}else if(g||x)throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let v=1;if(n&&n.dims.length>0){if(r.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(n.dims.length===3){if(r.dims[2]%n.dims[2]!==0)throw new Error('Dimension 2 of \"query\" should be a multiple of \"key\"');u=n.dims[1]}else if(n.dims.length===5){if(n.dims[2]!==t.numHeads||n.dims[3]!==2||n.dims[4]!==y)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');u=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==y)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');u=n.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');v=3}let S=0,T=!1,A=t.kvNumHeads?y*t.kvNumHeads:m;if(o&&o.dims.length>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(r.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(u!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(u!==o.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],T=!0}}let C=e.length>4?e[5]:void 0;if(C&&C.dims.length!==1&&C.dims[0]!==l)throw new Error('Input \"seqlens\" is expected to have 1 dimension and the same dim 0 as batch_size');let P=-1,D=-1,R=!1;return{batchSize:l,sequenceLength:p,pastSequenceLength:h,kvSequenceLength:u,totalSequenceLength:P,maxSequenceLength:D,inputHiddenSize:0,hiddenSize:m,vHiddenSize:A,headSize:y,vHeadSize:Math.floor(A/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:S,scale:t.scale,broadcastResPosBias:R,passPastInKv:T,qkvFormat:v}},ih=ee({perm:[0,2,1,3]}),Gd=(e,t,r)=>{let n=t,o=r.kvNumHeads;return t.dims.length===3&&r.kvSequenceLength!==0&&(n=t.reshape([r.batchSize,r.kvSequenceLength,o,r.headSize]),n=e.compute(Pe(n,ih.perm),{inputs:[n],outputs:[-1]})[0]),n},Hd=(e,t)=>{let r=oh(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(e.inputs[1]?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let n=e.inputs[0],o=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,i=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,a=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,d=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,p=e.inputs.length>5?e.inputs[6]:void 0,m=r.kvNumHeads?r.kvNumHeads:r.numHeads,u=ee({axis:2,numOutputs:3,splitSizes:[r.numHeads*r.headSize,m*r.headSize,m*r.headSize]}),[h,_,y]=!o&&!i?e.compute(So([n],u),{inputs:[n],outputs:[-1,-1,-1]}):[n,o,i],g=er(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,h,void 0,0);Ut(e,g,Gd(e,_,r),Gd(e,y,r),void 0,void 0,a,d,void 0,r,l,p)}});var qd,ah,sh,Kd,jd=U(()=>{\"use strict\";J();ne();dt();ae();qd=(e,t,r,n,o,i,a,d)=>{let l=me(i),p=l===1?\"f32\":`vec${l}f`,m=l===1?\"vec2f\":`mat2x${l}f`,u=o*a,h=64;u===1&&(h=256);let _=[o,a,i/l],y=[o,a,2],g=[\"rank\",\"type\",\"type\"],x=[];x.push(...N(_,y));let $=v=>{let S=E(\"x\",t.dataType,3,l),T=E(\"scale\",r.dataType,r.dims),A=E(\"bias\",n.dataType,n.dims),C=M(\"output\",1,3,2),P=[S,T,A,C];return`\n  var<workgroup> workgroup_shared : array<${m}, ${h}>;\n  const workgroup_size = ${h}u;\n  ${v.declareVariables(...P)}\n  ${v.mainStart(h)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${p}(0);\n    var squared_sum = ${p}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${p}(${S.get(\"batch\",\"channel\",\"h\")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${m}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${qe(\"workgroup_shared[0][0]\",l)} / f32(hight * ${l});\n      let squared_sum_final = ${qe(\"workgroup_shared[0][1]\",l)} / f32(hight * ${l});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${d}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`};return e.compute({name:\"InstanceNormComputeChannelScaleShift\",shaderCache:{hint:`${l};${d};${h}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:y,dataType:1}],dispatchGroup:{x:u},programUniforms:x}),getShaderSource:$},{inputs:[t,r,n],outputs:[-1]})[0]},ah=(e,t,r)=>{let n=t[0].dims,o=n,i=2,a=n[0],d=n[1],l=k.sizeFromDimension(n,i),p=me(l),m=k.size(o)/p,u=qd(e,t[0],t[1],t[2],a,l,d,r.epsilon),h=[a,d,l/p],_=[a,d],y=[\"type\",\"none\"],g=x=>{let $=E(\"x\",t[0].dataType,h.length,p),v=E(\"scale_shift\",1,_.length,2),S=M(\"output\",t[0].dataType,h.length,p),T=[$,v,S];return`\n  ${x.registerUniform(\"output_size\",\"u32\").declareVariables(...T)}\n  ${x.mainStart()}\n  ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let outputIndices = ${S.offsetToIndices(\"global_idx\")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${v.getByIndices(\"vec2<u32>(batch, channel)\")};\n      let value = ${$.getByOffset(\"global_idx\")} * ${S.type.value}(scale_shift.x) + ${S.type.value}(scale_shift.y);\n      ${S.setByOffset(\"global_idx\",\"value\")};\n  }`};e.compute({name:\"InstanceNormalization\",shaderCache:{hint:`${p}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...N(h,_,h)]}),getShaderSource:g},{inputs:[t[0],u]})},sh=(e,t,r)=>{let n=t[0].dims,o=n,i=n[0],a=n[n.length-1],d=k.sizeFromDimension(n,1)/a,l=me(a),p=k.size(o)/l,m=[{type:12,data:d},{type:12,data:Math.floor(a/l)}],u=[\"type\",\"type\"],h=!1,_=[0,n.length-1];for(let $=0;$<n.length-2;$++)h=h||n[$+1]!==1,_.push($+1);h=h&&n[n.length-1]!==1;let y=h?e.compute(Pe(e.inputs[0],_),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:n.length},($,v)=>n[_[v]])),g=qd(e,y,t[1],t[2],i,d,a,r.epsilon),x=$=>{let v=ye(t[0].dataType),S=l===1?\"vec2f\":`mat${l}x2f`,T=P=>{let D=P===0?\"x\":\"y\",R=l===1?\"f32\":`vec${l}f`;switch(l){case 1:return`${v}(${R}(scale.${D}))`;case 2:return`vec2<${v}>(${R}(scale[0].${D}, scale[1].${D}))`;case 4:return`vec4<${v}>(${R}(scale[0].${D}, scale[1].${D}, scale[2].${D}, scale[3].${D}))`;default:throw new Error(`Not supported compoents ${l}`)}},A=E(\"input\",t[0].dataType,t[0].dims,l),C=M(\"output\",t[0].dataType,o,l);return`\n  @group(0) @binding(0) var<storage, read> input : array<${A.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${S}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${C.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${$.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${T(0)}, ${T(1)});\n  }`};e.compute({name:\"InstanceNormalizationNHWC\",shaderCache:{hint:`${l}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:m}),getShaderSource:x},{inputs:[t[0],g]})},Kd=(e,t)=>{t.format===\"NHWC\"?sh(e,e.inputs,t):ah(e,e.inputs,t)}});var uh,dh,Yd,Zd=U(()=>{\"use strict\";J();ne();ae();uh=e=>{if(!e||e.length<2)throw new Error(\"layerNorm requires at least 2 inputs.\")},dh=(e,t,r)=>{let n=t.simplified,o=e[0].dims,i=e[1],a=!n&&e[2],d=o,l=k.normalizeAxis(t.axis,o.length),p=k.sizeToDimension(o,l),m=k.sizeFromDimension(o,l),u=k.size(i.dims),h=a?k.size(a.dims):0;if(u!==m||a&&h!==m)throw new Error(`Size of X.shape()[axis:] == ${m}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${u} and bias size of ${h}`);let _=[];for(let A=0;A<o.length;++A)A<l?_.push(o[A]):_.push(1);let y=me(m),g=[\"type\",\"type\"],x=[{type:12,data:p},{type:1,data:m},{type:12,data:Math.floor(m/y)},{type:1,data:t.epsilon}];a&&g.push(\"type\");let $=r>1,v=r>2,S=A=>{let C=ye(e[0].dataType),P=[E(\"x\",e[0].dataType,e[0].dims,y),E(\"scale\",i.dataType,i.dims,y)];a&&P.push(E(\"bias\",a.dataType,a.dims,y)),P.push(M(\"output\",e[0].dataType,d,y)),$&&P.push(M(\"mean_data_output\",1,_)),v&&P.push(M(\"inv_std_output\",1,_));let D=[{name:\"norm_count\",type:\"u32\"},{name:\"norm_size\",type:\"f32\"},{name:\"norm_size_vectorized\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}];return`\n  ${A.registerUniforms(D).declareVariables(...P)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.norm_count\")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${so(\"f32\",y)};\n    var mean_square_vector = ${so(\"f32\",y)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Pt(C,y,\"x[h + offset]\")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${qe(\"mean_vector\",y)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${qe(\"mean_square_vector\",y)} / uniforms.norm_size ${n?\"\":\"- mean * mean\"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Pt(C,y,\"x[j + offset]\")};\n      let f32scale = ${Pt(C,y,\"scale[j]\")};\n      output[j + offset] = ${P[0].type.value}((f32input ${n?\"\":\"- mean\"}) * inv_std_dev * f32scale\n        ${a?`+ ${Pt(C,y,\"bias[j]\")}`:\"\"}\n      );\n    }\n\n    ${$?\"mean_data_output[global_idx] = mean\":\"\"};\n    ${v?\"inv_std_output[global_idx] = inv_std_dev\":\"\"};\n  }`},T=[{dims:d,dataType:e[0].dataType}];return $&&T.push({dims:_,dataType:1}),v&&T.push({dims:_,dataType:1}),{name:\"LayerNormalization\",shaderCache:{hint:`${y};${r};${n}`,inputDependencies:g},getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(p/64)},programUniforms:x}),getShaderSource:S}},Yd=(e,t)=>{uh(e.inputs),e.compute(dh(e.inputs,t,e.outputCount))}});var lh,Qd,Xd=U(()=>{\"use strict\";ne();Zr();Qr();lh=e=>{if(!e||e.length!==2)throw new Error(\"MatMul requires 2 inputs.\");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error(\"shared dimension does not match.\")},Qd=e=>{lh(e.inputs);let t=tt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error(\"Can't use matmul on the given tensors\");let r=t[t.length-1],n=e.inputs[0].dims[e.inputs[0].dims.length-1];if(r<8&&n<8)e.compute(Yr(e.inputs,{activation:\"\"},t));else{let o=t[t.length-2],i=k.size(e.inputs[0].dims.slice(0,-2)),a=k.size(e.inputs[1].dims.slice(0,-2));if(i!==1&&o===1&&a===1){let d=e.inputs[0].reshape([1,i,n]),l=e.inputs[1].reshape([1,n,r]),p=[1,i,r],m=[d,l];e.compute(Jt(m,{activation:\"\"},t,p),{inputs:m})}else e.compute(Jt(e.inputs,{activation:\"\"},t))}}});var ch,ph,mh,Jd,el,tl=U(()=>{\"use strict\";J();ne();xe();ae();ch=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"MatMulNBits requires 3 or 4 inputs\");let r=e[0],n=r.dims.length;if(r.dims[n-1]!==t.k)throw new Error(\"The last dim of input shape does not match the k value\");let o=Math.floor((t.k+t.blockSize-1)/t.blockSize),i=t.blockSize/8*t.bits,a=e[1];if(!k.areEqual(a.dims,[t.n,o,i]))throw new Error(\"The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize\");let l=e[2].dims;if(k.size(l)!==t.n*o)throw new Error(\"scales input size error.\");if(e.length===4){let m=e[3].dims,u=t.bits>4?t.n*o:t.n*Math.floor((o+1)/2);if(k.size(m)!==u)throw new Error(\"zeroPoints input size error.\")}},ph=(e,t)=>{let r=e[0].dims,n=r.length,o=r[n-2],i=t.k,a=t.n,d=r.slice(0,n-2),l=k.size(d),m=e[1].dims[2]/4,u=e[0].dataType,h=me(t.k),_=me(m),y=me(a),g=d.concat([o,a]),x=o>1&&a/y%2===0?2:1,$=k.size(g)/y/x,v=64,S=[],T=[l,o,i/h],A=k.convertShape(e[1].dims).slice();A.splice(-1,1,m/_),S.push(...N(T)),S.push(...N(A)),S.push(...N(e[2].dims)),e.length===4&&S.push(...N(k.convertShape(e[3].dims)));let C=[l,o,a/y];S.push(...N(C));let P=D=>{let R=T.length,H=E(\"a\",e[0].dataType,R,h),L=E(\"b\",12,A.length,_),re=E(\"scales\",e[2].dataType,e[2].dims.length),V=[H,L,re],K=e.length===4?E(\"zero_points\",12,e[3].dims.length):void 0;K&&V.push(K);let we=C.length,j=M(\"output\",e[0].dataType,we,y),Q=ye(e[0].dataType),ie=(()=>{switch(h){case 1:return`array<${Q}, 8>`;case 2:return`mat4x2<${Q}>`;case 4:return`mat2x4<${Q}>`;default:throw new Error(`${h}-component is not supported.`)}})(),te=()=>{let ve=`\n          // reuse a data\n            var input_offset = ${H.indicesToOffset(`${H.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${ie};\n            for (var j: u32 = 0; j < ${8/h}; j++) {\n              a_data[j] = ${H.getByOffset(\"input_offset\")};\n              input_offset++;\n            }\n          `;for(let de=0;de<y*x;de++)ve+=`\n            b_value = ${_===1?`b${de}_data`:`b${de}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${ie}(${Array.from({length:4},(W,Y)=>`${Q}(b_value_lower[${Y}]), ${Q}(b_value_upper[${Y}])`).join(\", \")});\n            b_dequantized_values = ${(()=>h===1?`${ie}(${Array.from({length:8},(W,Y)=>`(b_quantized_values[${Y}] - ${K?`zero_point${de}`:\"zero_point\"}) * scale${de}`).join(\", \")});`:`(b_quantized_values - ${ie}(${Array(8).fill(`${K?`zero_point${de}`:\"zero_point\"}`).join(\",\")})) * scale${de};`)()};\n            workgroup_shared[local_id.x * ${x} + ${Math.floor(de/y)}]${y>1?`[${de%y}]`:\"\"} += ${Array.from({length:8/h},(W,Y)=>`${h===1?`a_data[${Y}] * b_dequantized_values[${Y}]`:`dot(a_data[${Y}], b_dequantized_values[${Y}])`}`).join(\" + \")};\n          `;return ve},be=()=>{let ve=`\n            var col_index = col * ${y};\n            ${K?`\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${Q}(8);`}\n            `;for(let de=0;de<y*x;de++)ve+=`\n            let scale${de} = ${re.getByOffset(\"col_index * nBlocksPerCol + block\")};\n            ${K?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${K.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point${de} = ${Q}((zero_point_word) & 0xFu);`:\"\"}\n            col_index += 1;`;return ve},Oe=()=>{let ve=`col_index = col * ${y};`;for(let de=0;de<y*x;de++)ve+=`\n            let b${de}_data = ${L.getByIndices(`${L.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return ve+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${ie};\n            var b_dequantized_values: ${ie};`,ve};return`\n        var<workgroup> workgroup_shared: array<${j.type.value}, ${x*v}>;\n        ${D.declareVariables(...V,j)}\n        ${D.mainStart([v,1,1])}\n          let output_indices = ${j.offsetToIndices(`(global_idx / ${v}) * ${x}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += ${v}) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/h};\n            ${be()}\n            for (var word: u32 = 0; word < ${m}; word += ${_}) {\n              ${Oe()}\n              for (var i: u32 = 0; i < ${_}; i++) {\n                ${te()}\n                word_offset += ${8/h};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${x}) {\n            var output_value: ${j.type.value} = ${j.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < ${v}u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${x};\n            }\n            ${j.setByIndices(`${j.type.indices}(batch, row, col + local_id.x)`,\"output_value\")};\n          }\n        }`};return{name:\"MatMulNBits\",shaderCache:{hint:`${t.blockSize};${t.bits};${h};${_};${y};${x};${v}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:g,dataType:u}],dispatchGroup:{x:$},programUniforms:S}),getShaderSource:P}},mh=(e,t)=>{let r=e[0].dims,n=r.length,o=r[n-2],i=t.k,a=t.n,d=r.slice(0,n-2),l=k.size(d),m=e[1].dims[2]/4,u=e[0].dataType,h=me(t.k),_=me(m),y=d.concat([o,a]),g=128,x=a%8===0?8:a%4===0?4:1,$=g/x,v=$*_*8,S=v/h,T=v/t.blockSize,A=k.size(y)/x,C=[],P=[l,o,i/h],D=k.convertShape(e[1].dims).slice();D.splice(-1,1,m/_),C.push(...N(P)),C.push(...N(D)),C.push(...N(e[2].dims)),e.length===4&&C.push(...N(k.convertShape(e[3].dims)));let R=[l,o,a];C.push(...N(R));let H=L=>{let re=P.length,V=E(\"a\",e[0].dataType,re,h),K=E(\"b\",12,D.length,_),we=E(\"scales\",e[2].dataType,e[2].dims.length),j=[V,K,we],Q=e.length===4?E(\"zero_points\",12,e[3].dims.length):void 0;Q&&j.push(Q);let ie=R.length,te=M(\"output\",e[0].dataType,ie),be=ye(e[0].dataType),Oe=()=>{switch(h){case 1:return`\n          let a_data0 = vec4<${be}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${be}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${be}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${be}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${h}-component is not supported.`)}};return`\n        var<workgroup> sub_a: array<${V.type.value}, ${S}>;\n        var<workgroup> inter_results: array<array<${te.type.value}, ${$}>, ${x}>;\n        ${L.declareVariables(...j,te)}\n        ${L.mainStart([$,x,1])}\n          let output_indices = ${te.offsetToIndices(`workgroup_index * ${x}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${T} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${S};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${S}; a_offset += ${g})\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${V.getByIndices(`${V.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${V.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${T} + local_id.x;\n            ${Q?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${Q.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point = ${be}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${be}(8);`}\n            let scale = ${we.getByOffset(\"b_row * n_blocks_per_col + block\")};\n            let b_data = ${K.getByIndices(`${K.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/h};\n            for (var i: u32 = 0; i < ${_}; i++) {\n              ${Oe()}\n              let b_value = ${_===1?\"b_data\":\"b_data[i]\"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${be}>(${Array.from({length:4},(ve,de)=>`${be}(b_value_lower[${de}]), ${be}(b_value_upper[${de}])`).join(\", \")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${be}>(${Array(8).fill(\"zero_point\").join(\",\")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(ve,de)=>`${`dot(a_data${de}, b_dequantized_values[${de}])`}`).join(\" + \")};\n              word_offset += ${8/h};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${x}) {\n            var output_value: ${te.type.value} = ${te.type.value}(0);\n            for (var b = 0u; b < ${$}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${te.setByIndices(`${te.type.indices}(batch, row, col + local_idx)`,\"output_value\")}\n            }\n          }\n        }`};return{name:\"BlockwiseMatMulNBits32\",shaderCache:{hint:`${t.blockSize};${h};${_};${$};${x}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:y,dataType:u}],dispatchGroup:{x:A},programUniforms:C}),getShaderSource:H}},Jd=(e,t)=>{ch(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor(\"intel\")&&e.adapterInfo.isArchitecture(\"gen-12lp\")?e.compute(mh(e.inputs,t)):e.compute(ph(e.inputs,t))},el=e=>ee(e)});var fh,hh,gh,bh,yh,_h,wh,vh,rl,nl=U(()=>{\"use strict\";J();ne();ae();fh=e=>{if(!e||e.length<1)throw new Error(\"Too few inputs\");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error(\"Input type must be float or float16.\");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error(\"The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].\")}},hh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n            k = i32(${e.indicesGet(\"indices\",o)}) - ${q(\"uniforms.pads\",o,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${q(\"uniforms.x_shape\",o,t)})) {\n              break;\n            }\n            offset += k * i32(${q(\"uniforms.x_strides\",o,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${n}\n            value = x[offset];\n          }\n      `},gh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${q(\"uniforms.pads\",o,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${q(\"uniforms.x_shape\",o,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${q(\"uniforms.x_shape\",o,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${q(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},bh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${q(\"uniforms.pads\",o,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${q(\"uniforms.x_shape\",o,t)})) {\n                  k = i32(${q(\"uniforms.x_shape\",o,t)}) - 1;\n                }\n                offset += k * i32(${q(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},yh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${q(\"uniforms.pads\",o,r)};\n                if (k < 0)  {\n                  k += i32(${q(\"uniforms.x_shape\",o,t)}]);\n                }\n                if (k >= i32(${q(\"uniforms.x_shape\",o,t)})) {\n                  k -= i32(${q(\"uniforms.x_shape\",o,t)});\n                }\n                offset += k * i32(${q(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},_h=(e,t,r)=>{switch(r.mode){case 0:return hh(e,t,r.pads.length);case 1:return gh(e,t,r.pads.length);case 2:return bh(e,t,r.pads.length);case 3:return yh(e,t,r.pads.length);default:throw new Error(\"Invalid mode\")}},wh=(e,t)=>{let r=k.padShape(e[0].dims.slice(),t.pads),n=e[0].dims,o=k.size(r),i=[{type:12,data:o},{type:6,data:t.pads}],a=e.length>=3&&e[2].data;t.mode===0&&i.push({type:a?e[2].dataType:1,data:t.value}),i.push(...N(e[0].dims,r));let d=[\"rank\"],l=p=>{let m=M(\"output\",e[0].dataType,r.length),u=E(\"x\",e[0].dataType,n.length),h=u.type.value,_=_h(m,n.length,t),y=[{name:\"output_size\",type:\"u32\"},{name:\"pads\",type:\"i32\",length:t.pads.length}];return t.mode===0&&y.push({name:\"constant_value\",type:a?h:\"f32\"}),`\n            ${p.registerUniforms(y).declareVariables(u,m)}\n            ${p.mainStart()}\n            ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n            let indices = ${m.offsetToIndices(\"global_idx\")};\n\n            var value = ${h}(0);\n            ${_}\n            output[global_idx] = value;\n        }`};return{name:\"Pad\",shaderCache:{hint:`${t.mode}${a}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(r)/64)},programUniforms:i}),getShaderSource:l}},vh=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),n=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,o=e[0].dims.length,i=new Int32Array(2*o).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let l=0;l<d.length;l++)i[Number(d[l])]=Number(r[l]),i[Number(d[l])+o]=Number(r[l+d.length])}else r.forEach((d,l)=>i[Number(l)]=Number(d));let a=[];return i.forEach(d=>a.push(d)),{mode:t.mode,value:n,pads:a}}else return t},rl=(e,t)=>{fh(e.inputs);let r=vh(e.inputs,t);e.compute(wh(e.inputs,r),{inputs:[0]})}});var en,ol,il,al,sl,$h,xh,ul,dl,ll,cl,pl,ml,fl,hl,gl,bl,yl,_l,wl=U(()=>{\"use strict\";Le();J();ne();ae();en=e=>{if(_e.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error(\"Pool ops requires 1 input.\")},ol=(e,t,r)=>{let n=t.format===\"NHWC\",o=e.dims.slice();n&&o.splice(1,0,o.pop());let i=Object.hasOwnProperty.call(t,\"dilations\"),a=t.kernelShape.slice(),d=t.strides.slice(),l=i?t.dilations.slice():[],p=t.pads.slice();kt.adjustPoolAttributes(r,o,a,d,l,p);let m=kt.computePoolOutputShape(r,o,d,l,a,p,t.autoPad),u=Object.assign({},t);i?Object.assign(u,{kernelShape:a,strides:d,pads:p,dilations:l,cacheKey:t.cacheKey}):Object.assign(u,{kernelShape:a,strides:d,pads:p,cacheKey:t.cacheKey});let h=m.slice();return h.push(h.splice(1,1)[0]),[u,n?h:m]},il=(e,t)=>{let r=t.format===\"NHWC\",n=k.size(e),o=k.size(t.kernelShape),i=[{type:12,data:n},{type:12,data:o}],a=[{name:\"outputSize\",type:\"u32\"},{name:\"kernelSize\",type:\"u32\"}];if(t.kernelShape.length<=2){let d=t.kernelShape[t.kernelShape.length-1],l=t.strides[t.strides.length-1],p=t.pads[t.pads.length/2-1],m=t.pads[t.pads.length-1],u=!!(p+m);i.push({type:12,data:d},{type:12,data:l},{type:12,data:p},{type:12,data:m}),a.push({name:\"kw\",type:\"u32\"},{name:\"sw\",type:\"u32\"},{name:\"pwStart\",type:\"u32\"},{name:\"pwEnd\",type:\"u32\"});let h=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],y=t.strides[t.strides.length-2],g=t.pads[t.pads.length/2-2],x=t.pads[t.pads.length-2];h=!!(g+x),i.push({type:12,data:_},{type:12,data:y},{type:12,data:g},{type:12,data:x}),a.push({name:\"kh\",type:\"u32\"},{name:\"sh\",type:\"u32\"},{name:\"phStart\",type:\"u32\"},{name:\"phEnd\",type:\"u32\"})}return[i,a,!0,u,h]}else{if(r)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let d=k.computeStrides(t.kernelShape);i.push({type:12,data:d},{type:12,data:t.pads},{type:12,data:t.strides}),a.push({name:\"kernelStrides\",type:\"u32\",length:d.length},{name:\"pads\",type:\"u32\",length:t.pads.length},{name:\"strides\",type:\"u32\",length:t.strides.length});let l=t.pads.reduce((p,m)=>p+m);return[i,a,!!l,!1,!1]}},al=(e,t,r,n,o,i,a,d,l,p,m,u)=>{let h=o.format===\"NHWC\",_=t.type.value,y=M(\"output\",t.type.tensor,n);if(o.kernelShape.length<=2){let g=\"\",x=\"\",$=\"\",v=r-(h?2:1);if(m?g=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${v}] < 0 || xIndices[${v}]\n                      >= uniforms.x_shape[${v}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${i}\n                }`:g=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${i}\n                }`,o.kernelShape.length===2){let T=r-(h?3:2);u?x=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${T}] < 0 || xIndices[${T}] >= uniforms.x_shape[${T}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:x=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;\n                `,$=`\n              }\n            `}return`\n            ${e.registerUniforms(l).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n              let indices = ${y.offsetToIndices(\"global_idx\")};\n              var xIndices = ${y.offsetToIndices(\"global_idx\")};\n\n              var value = ${_}(${d});\n              var pad = 0;\n              ${x}\n              ${g}\n              ${$}\n              ${a}\n\n              output[global_idx] = value;\n            }`}else{if(h)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let g=o.kernelShape.length,x=o.pads.length,$=\"\";return p?$=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                ${i}\n              }`:$=`\n              }\n              let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n              ${i}\n            `,`\n            ${e.registerUniforms(l).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n              let indices = ${y.offsetToIndices(\"global_idx\")};\n              var xIndices = ${y.offsetToIndices(\"global_idx\")};\n\n              var offsets: array<u32, ${g}>;\n\n              var value = ${_}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${g-1}u; j++) {\n                  offsets[j] = offset / ${q(\"uniforms.kernelStrides\",\"j\",g)};\n                  offset -= offsets[j] * ${q(\"uniforms.kernelStrides\",\"j\",g)};\n                }\n                offsets[${g-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-g}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${q(\"uniforms.strides\",`j - ${r-g}u`,g)}\n                    + offsets[j - ${r-g}u] - ${q(\"uniforms.pads\",\"j - 2u\",x)};\n                  ${$}\n              }\n              ${a}\n\n              output[global_idx] = value;\n            }`}},sl=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,$h=e=>`${sl(e)};${e.countIncludePad}`,xh=e=>`${sl(e)};${e.storageOrder};${e.dilations}`,ul=e=>({format:e.format,autoPad:[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),dl=(e,t,r,n)=>{let[o,i]=ol(t,n,r),a=E(\"x\",t.dataType,t.dims.length),d=a.type.value,l=\"value += x_val;\",p=\"\";o.countIncludePad?p+=`value /= ${d}(uniforms.kernelSize);`:p+=`value /= ${d}(i32(uniforms.kernelSize) - pad);`;let[m,u,h,_,y]=il(i,o);m.push(...N(t.dims,i));let g=[\"rank\"];return{name:e,shaderCache:{hint:`${n.cacheKey};${h};${_};${y}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(i)/64)},programUniforms:m}),getShaderSource:x=>al(x,a,t.dims.length,i.length,o,l,p,0,u,h,_,y)}},ll=e=>{let t=e.count_include_pad!==0,r=ul(e);if(r.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");let n={countIncludePad:t,...r,cacheKey:\"\"};return{...n,cacheKey:$h(n)}},cl=(e,t)=>{en(e.inputs),e.compute(dl(\"AveragePool\",e.inputs[0],!1,t))},pl={autoPad:\"\",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},ml=e=>{let t=e.format;return{format:t,...pl,cacheKey:t}},fl=(e,t)=>{en(e.inputs),e.compute(dl(\"GlobalAveragePool\",e.inputs[0],!0,t))},hl=(e,t,r,n)=>{let[o,i]=ol(t,n,r),a=`\n      value = max(x_val, value);\n    `,d=\"\",l=E(\"x\",t.dataType,t.dims.length),p=[\"rank\"],[m,u,h,_,y]=il(i,o);return m.push(...N(t.dims,i)),{name:e,shaderCache:{hint:`${n.cacheKey};${h};${_};${y}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(i)/64)},programUniforms:m}),getShaderSource:g=>al(g,l,t.dims.length,i.length,o,a,d,t.dataType===10?-65504:-1e5,u,h,_,y)}},gl=(e,t)=>{en(e.inputs),e.compute(hl(\"MaxPool\",e.inputs[0],!1,t))},bl=e=>{let t=e.storage_order,r=e.dilations,n=ul(e);if(t!==0)throw new Error(\"column major storage order is not yet supported for MaxPool\");if(n.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");let o={storageOrder:t,dilations:r,...n,cacheKey:\"\"};return{...o,cacheKey:xh(o)}},yl=e=>{let t=e.format;return{format:t,...pl,cacheKey:t}},_l=(e,t)=>{en(e.inputs),e.compute(hl(\"GlobalMaxPool\",e.inputs[0],!0,t))}});var Th,Ih,vl,$l,xl=U(()=>{\"use strict\";J();ne();xe();ae();Th=(e,t)=>{if(e.length<2||e.length>3)throw new Error(\"DequantizeLinear requires 2 or 3 inputs.\");if(e.length===3&&e[1].dims===e[2].dims)throw new Error(\"x-scale and x-zero-point must have the same shape.\");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[0].dataType===6&&e.length>2)throw new Error(\"In the case of dequantizing int32 there is no zero point.\");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error(\"scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.\");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[1].dims.length!==e[2].dims.length)throw new Error(\"scale and zero-point inputs must have the same rank.\");if(!e[1].dims.map((r,n)=>r===e[2].dims[n]).reduce((r,n)=>r&&n,!0))throw new Error(\"scale and zero-point inputs must have the same shape.\")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error(\"blockSize must be set only for block quantization.\");if(!e[1].dims.map((o,i)=>i===t.axis||o===e[0].dims[i]).reduce((o,i)=>o&&i,!0))throw new Error(\"For block qunatization, scale input shape to match the input shape except for the axis\");if(e[1].dims.length!==e[0].dims.length)throw new Error(\"For block qunatization the scale input rank must be the same as the x rank.\");let r=e[0].dims[t.axis],n=e[1].dims[t.axis];if(t.blockSize<Math.ceil(r/n)||t.blockSize>Math.ceil(r/(n-1)-1))throw new Error(\"blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].\")}},Ih=(e,t)=>{let r=k.normalizeAxis(t.axis,e[0].dims.length),n=e[0].dataType,o=n===3,i=e[0].dims,a=e[1].dataType,d=k.size(i),l=n===3||n===2,p=l?[Math.ceil(k.size(e[0].dims)/4)]:e[0].dims,m=e[1].dims,u=e.length>2?e[2]:void 0,h=u?l?[Math.ceil(k.size(u.dims)/4)]:u.dims:void 0,_=m.length===0||m.length===1&&m[0]===1,y=_===!1&&m.length===1,g=me(d),x=_&&(!l||g===4),$=x?g:1,v=x&&!l?g:1,S=E(\"input\",l?12:n,p.length,v),T=E(\"scale\",a,m.length),A=u?E(\"zero_point\",l?12:n,h.length):void 0,C=M(\"output\",a,i.length,$),P=[S,T];A&&P.push(A);let D=[p,m];u&&D.push(h);let R=[{type:12,data:d/$},{type:12,data:r},{type:12,data:t.blockSize},...N(...D,i)],H=L=>{let re=[{name:\"output_size\",type:\"u32\"},{name:\"axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n      ${L.registerUniforms(re).declareVariables(...P,C)}\n      ${L.mainStart()}\n          ${L.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let output_indices = ${C.offsetToIndices(\"global_idx\")};\n\n          // Set input x\n          ${(()=>l?`\n            let input = ${S.getByOffset(\"global_idx / 4\")};\n            let x_vec = ${o?\"unpack4xI8(input)\":\"unpack4xU8(input)\"};\n            let x_value = ${$===1?\"x_vec[global_idx % 4]\":\"x_vec\"};`:`let x_value = ${S.getByOffset(\"global_idx\")};`)()};\n\n          // Set scale input\n          ${(()=>_?`let scale_value= ${T.getByOffset(\"0\")}`:y?`\n            let scale_index = ${C.indicesGet(\"output_indices\",\"uniforms.axis\")};\n            let scale_value= ${T.getByOffset(\"scale_index\")};`:`\n            var scale_indices: ${T.type.indices} = output_indices;\n            let index = ${T.indicesGet(\"scale_indices\",\"uniforms.axis\")} / uniforms.block_size;\n            ${T.indicesSet(\"scale_indices\",\"uniforms.axis\",\"index\")};\n            let scale_value= ${T.getByIndices(\"scale_indices\")};`)()};\n\n          // Set zero-point input\n          ${(()=>A?_?l?`\n                let zero_point_input = ${A.getByOffset(\"0\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${A.getByOffset(\"0\")}`:y?l?`\n                let zero_point_index = ${C.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_index / 4\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${C.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_value = ${A.getByOffset(\"zero_point_index\")};`:l?`\n                let zero_point_offset = ${T.indicesToOffset(\"scale_indices\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_offset / 4\")};\n                let zero_point_vec = ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${A.getByIndices(\"scale_indices\")};`:`let zero_point_value = ${l?o?\"i32\":\"u32\":S.type.value}(0);`)()};\n      // Compute and write output\n      ${C.setByOffset(\"global_idx\",`${C.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`};return{name:\"DequantizeLinear\",shaderCache:{hint:t.cacheKey,inputDependencies:A?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getShaderSource:H,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:Math.ceil(d/$/64),y:1,z:1},programUniforms:R})}},vl=(e,t)=>{Th(e.inputs,t),e.compute(Ih(e.inputs,t))},$l=e=>ee({axis:e.axis,blockSize:e.blockSize})});var Ch,Ah,Sl,Tl=U(()=>{\"use strict\";Le();J();ae();Ch=(e,t,r)=>{let n=e===t,o=e<t&&r<0,i=e>t&&r>0;if(n||o||i)throw new Error(\"Range these inputs' contents are invalid.\")},Ah=(e,t,r,n)=>{let o=Math.abs(Math.ceil((t-e)/r)),i=[o],a=o,d=[{type:12,data:a},{type:n,data:e},{type:n,data:r},...N(i)],l=p=>{let m=M(\"output\",n,i.length),u=m.type.value,h=[{name:\"outputSize\",type:\"u32\"},{name:\"start\",type:u},{name:\"delta\",type:u}];return`\n        ${p.registerUniforms(h).declareVariables(m)}\n        ${p.mainStart()}\n        ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        output[global_idx] = uniforms.start + ${u}(global_idx) * uniforms.delta;\n      }`};return{name:\"Range\",shaderCache:{hint:`${n}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:i,dataType:n}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:d})}},Sl=e=>{let t=0,r=0,n=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],n=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],n=e.inputs[2].getFloat32Array()[0]),_e.webgpu.validateInputContent&&Ch(t,r,n),e.compute(Ah(t,r,n,e.inputs[0].dataType),{inputs:[]})}});var kh,Eh,Il,Cl,Al=U(()=>{\"use strict\";J();ne();xe();ae();kh=(e,t,r,n)=>{if(e!==\"none\"&&n!==\"i32\"&&n!==\"u32\"&&n!==\"f32\")throw new Error(`Input ${n} is not supported with reduction ${e}.`);let o=`{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =`,i=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case\"none\":return`${t}=${r};`;case\"add\":return n===\"i32\"||n===\"u32\"?`atomicAdd(&${t}, bitcast<${n}>(${r}));`:`\n              ${o}bitcast<${n}>(oldValue) + (${r})${i}`;case\"max\":return n===\"i32\"||n===\"u32\"?`atomicMax(&${t}, bitcast<${n}>(${r}));`:`\n                ${o}max(bitcast<f32>(oldValue), (${r}))${i}`;case\"min\":return n===\"i32\"||n===\"u32\"?`atomicMin(&${t}, bitcast<${n}>(${r}));`:`${o}min(bitcast<${n}>(oldValue), (${r}))${i}`;case\"mul\":return`${o}(bitcast<${n}>(oldValue) * (${r}))${i}`;default:throw new Error(`Reduction ${e} is not supported.`)}},Eh=(e,t)=>{let r=e[0].dims,n=e[1].dims,o=r,i=1,a=Math.ceil(k.size(n)/i),d=n[n.length-1],l=k.sizeFromDimension(r,d),p=[{type:12,data:a},{type:12,data:d},{type:12,data:l},...N(e[1].dims,e[2].dims,o)],m=u=>{let h=E(\"indices\",e[1].dataType,e[1].dims.length),_=E(\"updates\",e[2].dataType,e[2].dims.length,i),y=t.reduction!==\"none\"&&t.reduction!==\"\"?ts(\"output\",e[0].dataType,o.length):M(\"output\",e[0].dataType,o.length,i);return`\n      ${u.registerUniform(\"output_size\",\"u32\").registerUniform(\"last_index_dimension\",\"u32\").registerUniform(\"num_updates_elements\",\"u32\").declareVariables(h,_,y)}\n      ${u.mainStart()}\n        ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n  var data_offset = 0u;\n  let indices_start = uniforms.last_index_dimension * global_idx;\n  let indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${e[0].dims.length===1?`\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;`:`\n    let element_count_dim = uniforms.output_strides[i - indices_start];\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}\n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));\n  }\n\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\n    ${kh(t.reduction,\"output[data_offset + i]\",\"value\",y.type.value)}\n  }\n\n      }`};return{name:\"ScatterND\",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:m}},Il=e=>ee({reduction:e.reduction}),Cl=(e,t)=>{e.compute(Eh(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}});var Ph,zh,Oh,kl,Dh,Bh,Mh,Rh,Uh,Nh,Vh,Wh,El,Lh,Gh,Hh,Fh,qh,Pl,zl,Ol=U(()=>{\"use strict\";J();ne();xe();ae();Ph=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error(\"Resize requires scales input values to be positive\")})),e.length>0){if(t.mode===\"linear\"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode===\"cubic\"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error(\"Resize requires scales input size to be 2 or 4 for cubic mode\")}},zh=(e,t,r)=>{t.every(o=>o>=0&&o<r||(()=>{throw new Error(\"Resize requires axes input values to be positive and less than rank\")}));let n=new Array(r).fill(1);return t.forEach((o,i)=>n[o]=e[i]),n},Oh=(e,t,r,n,o,i)=>{let[a,d,l]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach(m=>i.push(m));else if(t.coordinateTransformMode===\"tf_crop_and_resize\")throw new Error(\"Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize\");if(d>0&&e.length>d&&e[d].dims.length===1&&e[d].dims[0]>0){if(e[d].getFloat32Array().forEach(m=>n.push(m)),n.length!==0&&n.length!==p&&r>=18&&n.length!==t.axes.length)throw new Error(\"Resize requires scales input size to be same as input rank or axes size for opset 18 and up\");Ph(n,t),t.axes.length>0&&zh(n,t.axes,p).forEach((m,u)=>n[u]=m)}if(l>0&&e.length>l&&e[l].dims.length===1&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach(m=>o.push(Number(m))),o.length!==0&&o.length!==p&&r>=18&&o.length!==t.axes.length))throw new Error(\"Resize requires sizes input size to be same as input rank or axes size for opset 18 and up\");if(t.axes.length>0){if(n.length!==0&&n.length!==t.axes.length)throw new Error('Resize requires \"scales\" input size to be of axes rank when axes attributes is specified');if(o.length!==0&&o.length!==t.axes.length)throw new Error('Resize requires \"sizes\" input size to be of rank axes rank when axes attributes is specified')}if(typeof n<\"u\"&&typeof o<\"u\"&&n.length>0&&o.length>p)throw new Error(\"Resize requires only of scales or sizes to be specified\")},kl=(e,t,r,n)=>`\n  // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n  // offset-by-one error later in floor().\n  let big = (${e}) * (${t});\n  let whole = ${n}(big / (${r}));\n  let fract = ${n}(big % (${r})) / ${n}(${r});\n  return whole + fract;\n`,Dh=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case\"asymmetric\":return`\n          if (xScale < 1.0 || floor(xScale) != xScale) {\n            return ${t}(xResized) / ${t}(xScale);\n          } else {\n            ${kl(\"xResized\",\"lengthOriginal\",\"lengthResized\",t)}\n          }\n        `;case\"pytorch_half_pixel\":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case\"tf_half_pixel_for_nn\":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case\"align_corners\":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    ${kl(\"xResized\",\"lengthOriginal - 1\",\"lengthResized - 1\",t)}\n                  }`;case\"tf_crop_and_resize\":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case\"half_pixel_symmetric\":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case\"half_pixel\":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+\"}\",Bh=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case\"round_prefer_ceil\":return\"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }\";case\"floor\":return\"return floor(xOriginal);\";case\"ceil\":return\"return ceil(xOriginal);\";case\"round_prefer_floor\":return\"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }\";case\"simple\":default:if(t<11)return\"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }\";throw new Error(`Nearest mode ${e} is not supported`)}})()+\"}\",Mh=(e,t,r)=>{let n=new Array(r).fill(0).concat(new Array(r).fill(1)),o=e.length===0?n:e.slice();return t.length>0?(t.forEach((i,a)=>{n[i]=o[a],n[a+r]=o[t.length+a]}),n):o},Rh=(e,t,r,n)=>{let o=[];if(r.length>0)if(n.length>0){if(e.forEach(i=>o.push(i)),Math.max(...n)>e.length)throw new Error(\"axes is out of bound\");n.forEach((i,a)=>o[i]=r[a])}else r.forEach(i=>o.push(i));else{if(t.length===0)throw new Error(\"Resize requires either scales or sizes.\");o=e.map((i,a)=>Math.round(i*t[a]))}return o},Uh=(e,t,r)=>{let n=(()=>{switch(r.keepAspectRatioPolicy){case\"not_larger\":return r.axes.length>0?Math.min(...r.axes.map(i=>t[i]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case\"not_smaller\":return r.axes.length>0?Math.max(...r.axes.map(i=>t[i]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let o=e.slice();return r.axes.length>0?(r.axes.forEach(i=>t[i]=n),r.axes.forEach(i=>o[i]=Math.round(e[i]*t[i]))):(t.fill(n,0,t.length),o.forEach((i,a)=>o[a]=Math.round(i*t[a]))),o},Nh=(e,t,r,n,o)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet(\"output_indices\",\"i\")};\n        var scale = ${q(\"uniforms.scales\",\"i\",n)};\n        var roi_low = ${q(\"uniforms.roi\",\"i\",o)};\n        var roi_hi = ${q(\"uniforms.roi\",`i + ${t.length}`,o)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${q(\"uniforms.input_shape\",\"i\",t.length)};\n          var output_shape_i = ${q(\"uniforms.output_shape\",\"i\",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Vh=(e,t,r,n,o,i,a)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n        var input_index: u32;\n        var scale = ${q(\"uniforms.scales\",\"i\",o)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${q(\"uniforms.roi\",\"i\",i)};\n          var roi_hi = ${q(\"uniforms.roi\",`i + ${r.length}`,i)};\n          var input_shape_i = ${q(\"uniforms.input_shape\",\"i\",r.length)};\n          var output_shape_i = ${q(\"uniforms.output_shape\",\"i\",n.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")}\n      }\n      return input_indices;\n    }`,Wh=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet(\"input_indices\",\"i\")};\n        if (input_index < 0 || input_index >= ${q(\"uniforms.input_shape\",\"i\",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,El=(e,t,r,n)=>e.rank>n?`\n    ${e.indicesSet(\"input_indices\",t,\"channel\")};\n    ${e.indicesSet(\"input_indices\",r,\"batch\")};\n`:\"\",Lh=(e,t,r,n,o)=>{let[a,d,l,p]=r.length===2?[-1,0,1,-1]:[0,2,3,1],m=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${m} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(row, ${r[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(col, ${r[l]} - 1))`)};\n      ${El(e,p,a,2)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${m} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${m} = originalIndices[${d}];\n      var col:${m} = originalIndices[${l}];\n      ${n?`if (row < 0 || row > (${r[d]} - 1) || col < 0 || col > (${r[l]} - 1)) {\n        return ${o};\n      }`:\"\"};\n      row = max(0, min(row, ${r[d]} - 1));\n      col = max(0, min(col, ${r[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${p}])`:\"0\"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${a}])`:\"0\"};\n      var x11: ${m} = getInputValue(batch, channel, row1, col1);\n      var x12: ${m} = getInputValue(batch, channel, row1, col2);\n      var x21: ${m} = getInputValue(batch, channel, row2, col1);\n      var x22: ${m} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${m} = abs(row - ${m}(row1));\n      var dx2: ${m} = abs(${m}(row2) - row);\n      var dy1: ${m} = abs(col - ${m}(col1));\n      var dy2: ${m} = abs(${m}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Gh=(e,t,r,n,o,i,a,d,l,p)=>{let m=r.length===2,u=!0,[h,_]=m?[0,1]:u?[2,3]:[1,2],y=e.type.value,g=x=>{let $=x===h?\"row\":\"col\";return`\n      fn ${$}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${y} {\n        var output_index = ${t.indicesGet(\"output_indices\",x)};\n        var originalIdx: ${y} = getOriginalCoordinateFromResizedCoordinate(output_index, ${o[x]},\n        ${n[x]}, ${r[x]}, ${i[x]}, ${i[x]} + ${r.length});\n        var fractOriginalIdx: ${y} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[x]} - 1))) {\n          return ${l};\n        }\n        var data: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${$}: ${y} = originalIdx + ${y}(i);\n          if (${$} < 0 || ${$} >= ${r[x]}) {\n            ${(()=>p?`coefs[i + 1] = 0.0;\n                        continue;`:d?`return ${l};`:`${$} = max(0, min(${$}, ${r[x]} - 1));`)()};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet(\"input_indices_copy\",x,`u32(${$})`)};\n          data[i + 1] = ${x===h?e.getByIndices(\"input_indices_copy\"):\"rowCubicInterpolation(input_indices_copy, output_indices)\"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${g(h)};\n    ${g(_)};\n  fn getCubicInterpolationCoefs(s: ${y}) -> array<${y}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${y} = 1.0 - absS;\n    var twoMinusAbsS: ${y} = 2.0 - absS;\n    var onePlusAbsS: ${y} = 1.0 + absS;\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${y}, 4>, coefs: array<${y}, 4>) -> ${y} {\n    var coefsSum: ${y} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${y} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},Hh=(e,t,r,n,o)=>{let[a,d,l,p,m]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],u=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${u} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(depth, ${r[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(height, ${r[l]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",p,`max(0, min(width, ${r[p]} - 1))`)};\n      ${El(e,m,a,3)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${u} = originalIndices[${d}];\n      var height:${u} = originalIndices[${l}];\n      var width:${u} = originalIndices[${p}];\n      ${n?`if (depth < 0 || depth > (${r[d]} - 1) || height < 0 || height > (${r[l]} - 1) || width < 0 || (width > ${r[p]} - 1)) {\n      return ${o};\n        }`:\"\"};\n\n    depth = max(0, min(depth, ${r[d]} - 1));\n      height = max(0, min(height, ${r[l]} - 1));\n      width = max(0, min(width, ${r[p]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${m}])`:\"0\"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${a}])`:\"0\"};\n\n      var x111: ${u} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${u} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${u} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${u} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${u} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${u} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${u} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${u} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${u} = abs(depth - ${u}(depth1));\n      var dx2: ${u} = abs(${u}(depth2) - depth);\n      var dy1: ${u} = abs(height - ${u}(height1));\n      var dy2: ${u} = abs(${u}(height2) - height);\n      var dz1: ${u} = abs(width - ${u}(width1));\n      var dz2: ${u} = abs(${u}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Fh=(e,t,r,n,o,i)=>{let a=e.dims,d=Mh(i,t.axes,a.length),l=Rh(a,n,o,t.axes),p=n.slice();n.length===0&&(p=a.map((v,S)=>v===0?1:l[S]/v),t.keepAspectRatioPolicy!==\"stretch\"&&(l=Uh(a,p,t)));let m=M(\"output\",e.dataType,l.length),u=E(\"input\",e.dataType,a.length),h=k.size(l),_=a.length===l.length&&a.every((v,S)=>v===l[S]),y=t.coordinateTransformMode===\"tf_crop_and_resize\",g=t.extrapolationValue,x=u.type.value,$=v=>`\n      ${_?\"\":`\n      ${Dh(t.coordinateTransformMode,x)};\n      ${(()=>{switch(t.mode){case\"nearest\":return`\n              ${Wh(u,a)};\n              ${Bh(t.nearestMode,r,x)};\n              ${Vh(u,m,a,l,p.length,d.length,y)};\n              `;case\"linear\":return`\n              ${Nh(m,a,l,p.length,d.length)};\n              ${(()=>{if(a.length===2||a.length===4)return`${Lh(u,m,a,y,g)}`;if(a.length===3||a.length===5)return`${Hh(u,m,a,y,g)}`;throw Error(\"Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.\")})()};\n            `;case\"cubic\":return`\n            ${(()=>{if(a.length===2||a.length===4)return`${Gh(u,m,a,l,p,d,t.cubicCoeffA,y,t.extrapolationValue,t.excludeOutside)}`;throw Error(\"Cubic mode only supports input dims 2 and 4 are supported in linear mode.\")})()};\n            `;default:throw Error(\"Invalid resize mode\")}})()};\n      `}\n      ${v.registerUniform(\"output_size\",\"u32\").registerUniform(\"scales\",\"f32\",p.length).registerUniform(\"roi\",\"f32\",d.length).declareVariables(u,m)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n        ${_?\"output[global_idx] = input[global_idx];\":`\n        let output_indices = ${m.offsetToIndices(\"global_idx\")};\n        var input_indices: ${u.type.indices};\n        ${(()=>{switch(t.mode){case\"nearest\":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${u.getByIndices(\"input_indices\")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case\"linear\":return`output[global_idx] = ${a.length===2||a.length===4?\"bilinearInterpolation\":\"trilinearInterpolation\"}(output_indices);`;case\"cubic\":return\"output[global_idx] = bicubicInterpolation(output_indices);\";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:\"Resize\",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?t.mode===\"cubic\"?p:p.length:\"\"}|${o.length>0?o:\"\"}|${d.length>0?d:\"\"}|${_}|${t.mode===\"nearest\"?a.length:a}`,inputDependencies:[\"rank\"]},getShaderSource:$,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},{type:1,data:p},{type:1,data:d},...N(a,l)]})}},qh=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Pl=(e,t)=>{let r=[],n=[],o=[],i=qh(e);if(t.antialias!==0)throw Error(\"Only default value (0) for Antialias attribute is supported\");Oh(e.inputs,t,i,r,n,o),e.compute(Fh(e.inputs[0],t,i,r,n,o),{inputs:[0]})},zl=e=>{let t=e.antialias,r=e.axes,n=e.coordinateTransformMode,o=e.cubicCoeffA,i=e.excludeOutside!==0,a=e.extrapolationValue,d=e.keepAspectRatioPolicy,l=e.mode,p=e.nearestMode===\"\"?\"simple\":e.nearestMode;return ee({antialias:t,axes:r,coordinateTransformMode:n,cubicCoeffA:o,excludeOutside:i,extrapolationValue:a,keepAspectRatioPolicy:d,mode:l,nearestMode:p})}});var Kh,jh,Dl,Bl=U(()=>{\"use strict\";J();ne();xe();ae();Kh=(e,t)=>{let[r,n,o,i]=e,{numHeads:a,rotaryEmbeddingDim:d}=t;if(r.dims.length!==3&&r.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);if(!k.areEqual(n.dims,[])&&!k.areEqual(n.dims,[1])&&n.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${n.dims.length}`);if(o.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${o.dims.length}`);if(i.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${i.dims.length}`);if(!k.areEqual(o.dims,i.dims))throw new Error(\"Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape\");if(d>0&&a===0)throw new Error(\"num_heads must be provided if rotary_embedding_dim is specified\");let l=r.dims[0],p=r.dims[r.dims.length-2],m=o.dims[0],u=k.sizeFromDimension(r.dims,1)/p,h=d===0?o.dims[1]*2:u/a;if(d>h)throw new Error(\"rotary_embedding_dim must be less than or equal to head_size\");if(n.dims.length===2){if(l!==n.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${n.dims[0]}`);if(p!==n.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${n.dims[1]}`)}if(h/2!==o.dims[1]&&d/2!==o.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${o.dims[1]}`);if(p>m)throw new Error(\"Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported\")},jh=(e,t)=>{let{interleaved:r,numHeads:n,rotaryEmbeddingDim:o,scale:i}=t,a=e[0].dims[0],d=k.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],p=d/l,m=e[2].dims[1],u=o===0?m*2:p/n,h=new Array(a,l,p/u,u-m),_=k.computeStrides(h),y=[{type:1,data:i},{type:12,data:h},{type:12,data:_},...e[0].dims.length===3?new Array({type:12,data:[d,p,u,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[d,u,l*u,1]}):[],...N(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],g=x=>{let $=E(\"input\",e[0].dataType,e[0].dims.length),v=E(\"position_ids\",e[1].dataType,e[1].dims.length),S=E(\"cos_cache\",e[2].dataType,e[2].dims.length),T=E(\"sin_cache\",e[3].dataType,e[3].dims.length),A=M(\"output\",e[0].dataType,e[0].dims.length);return x.registerUniforms([{name:\"scale\",type:\"f32\"},{name:\"global_shape\",type:\"u32\",length:h.length},{name:\"global_strides\",type:\"u32\",length:_.length},{name:\"input_output_strides\",type:\"u32\",length:_.length}]),`\n        ${x.declareVariables($,v,S,T,A)}\n\n        ${x.mainStart(Et)}\n          let half_rotary_emb_dim = uniforms.${S.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"size\")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${v.broadcastedIndicesToOffset(\"bsnh.xy\",M(\"\",v.type.tensor,2))};\n            let position_id =\n                u32(${v.getByOffset(\"position_ids_idx\")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});\n            let j = i + select(half_rotary_emb_dim, 1, ${r});\n            let re = ${$.getByOffset(\"i\")} * ${S.get(\"position_id\",\"bsnh[3]\")} -\n                ${$.getByOffset(\"j\")} * ${T.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"i\",\"re\")}\n            let im = ${$.getByOffset(\"i\")} * ${T.get(\"position_id\",\"bsnh[3]\")} +\n                ${$.getByOffset(\"j\")} * ${S.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"j\",\"im\")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${A.setByOffset(\"k\",$.getByOffset(\"k\"))}\n          }\n        }`};return{name:\"RotaryEmbedding\",shaderCache:{hint:ee({interleaved:r}).cacheKey,inputDependencies:[\"rank\",\"rank\",\"rank\",\"rank\"]},getShaderSource:g,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(h)/Et)},programUniforms:y})}},Dl=(e,t)=>{Kh(e.inputs,t),e.compute(jh(e.inputs,t))}});var Yh,Zh,Ml,Rl=U(()=>{\"use strict\";J();ne();ae();Yh=e=>{if(!e||e.length<3)throw new Error(\"layerNorm requires at least 3 inputs.\");let t=e[0],r=e[1],n=e[2];if(t.dataType!==r.dataType||t.dataType!==n.dataType)throw new Error(\"All inputs must have the same data type\");if(t.dims.length!==3&&t.dims.length!==2)throw new Error(\"Input must be 2D or 3D\");if(r.dims.length!==3&&r.dims.length!==2)throw new Error(\"Skip must be 2D or 3D\");let o=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==o)throw new Error(\"Skip must have the same hidden size as input\");if(r.dims[r.dims.length-2]!==i)throw new Error(\"Skip must have the same sequence length as input\");if(n.dims.length!==1)throw new Error(\"Gamma must be 1D\");if(n.dims[n.dims.length-1]!==o)throw new Error(\"Gamma must have the same hidden size as input\");if(e.length>3){let a=e[3];if(a.dims.length!==1)throw new Error(\"Beta must be 1D\");if(a.dims[a.dims.length-1]!==o)throw new Error(\"Beta must have the same hidden size as input\")}if(e.length>4){let a=e[4];if(a.dims.length!==1)throw new Error(\"Bias must be 1D\");if(a.dims[a.dims.length-1]!==o)throw new Error(\"Bias must have the same hidden size as input\")}},Zh=(e,t,r,n)=>{let o=t.simplified,i=e[0].dims,a=k.size(i),d=i,l=a,p=i.slice(-1)[0],m=n?i.slice(0,-1).concat(1):[],u=!o&&e.length>3,h=e.length>4,_=n&&r>1,y=n&&r>2,g=r>3,x=64,$=me(p),v=[{type:12,data:l},{type:12,data:$},{type:12,data:p},{type:1,data:t.epsilon}],S=A=>{let C=[{name:\"output_size\",type:\"u32\"},{name:\"components\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}],P=[E(\"x\",e[0].dataType,e[0].dims,$),E(\"skip\",e[1].dataType,e[1].dims,$),E(\"gamma\",e[2].dataType,e[2].dims,$)];u&&P.push(E(\"beta\",e[3].dataType,e[3].dims,$)),h&&P.push(E(\"bias\",e[4].dataType,e[4].dims,$)),P.push(M(\"output\",e[0].dataType,d,$)),_&&P.push(M(\"mean_output\",1,m)),y&&P.push(M(\"inv_std_output\",1,m)),g&&P.push(M(\"input_skip_bias_sum\",e[0].dataType,d,$));let D=ye(e[0].dataType),R=ye(1,$);return`\n\n      ${A.registerUniforms(C).declareVariables(...P)}\n      var<workgroup> sum_shared : array<${R}, ${x}>;\n      var<workgroup> sum_squared_shared : array<${R}, ${x}>;\n\n      ${A.mainStart([x,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / ${x};\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / ${x};\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == ${x-1}) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${h?\"bias[offset1d + i]\":D+\"(0.0)\"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${g?\"input_skip_bias_sum[offset + i] = value;\":\"\"}\n          output[offset + i] = value;\n          let f32_value = ${Pt(D,$,\"value\")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = ${x};\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${qe(\"sum\",$)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${qe(\"square_sum\",$)} / f32(uniforms.hidden_size) ${o?\"\":\"- mean * mean\"} + uniforms.epsilon);\n        ${_?\"mean_output[global_idx] = mean;\":\"\"}\n        ${y?\"inv_std_output[global_idx] = inv_std_dev;\":\"\"}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${o?\"\":`- ${D}(mean)`}) *\n            ${D}(inv_std_dev) * gamma[offset1d + i]\n            ${u?\"+ beta[offset1d + i]\":\"\"};\n        }\n      }`},T=[{dims:d,dataType:e[0].dataType}];return r>1&&T.push({dims:m,dataType:1}),r>2&&T.push({dims:m,dataType:1}),r>3&&T.push({dims:i,dataType:e[0].dataType}),{name:\"SkipLayerNormalization\",shaderCache:{hint:`${$};${_};${y};${g}`,inputDependencies:e.map((A,C)=>\"type\")},getShaderSource:S,getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(l/p)},programUniforms:v})}},Ml=(e,t)=>{Yh(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(Zh(e.inputs,t,e.outputCount,!1),{outputs:n})}});var Qh,tn,Xh,Ul,Jh,eg,Nl,Vl,Wl=U(()=>{\"use strict\";J();ne();xe();ae();Qh=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error(\"axes, starts and ends must have the same length\")}else if(t.starts.length!==t.ends.length)throw new Error(\"starts and ends must have the same length\");e.slice(1).forEach((r,n)=>{if(e[n+1].dataType!==6&&e[n+1].dataType!==7)throw new Error(`Input ${n} must be an array of int32 or int64`)})},tn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(n=>r.push(Number(n)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(n=>r.push(Number(n)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Xh=(e,t)=>{if(e.length>1){let r=tn(e,1),n=tn(e,2),o=tn(e,3);return o.length===0&&(o=[...Array(e[0].dims.length).keys()]),ee({starts:r,ends:n,axes:o})}else return t},Ul=(e,t,r,n,o)=>{let i=e;return e<0&&(i+=r[n[t]]),o[t]<0?Math.max(0,Math.min(i,r[n[t]]-1)):Math.max(0,Math.min(i,r[n[t]]))},Jh=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${q(\"uniforms.input_shape\",\"i\",r.length)};\n            let steps_i = ${q(\"uniforms.steps\",\"i\",r.length)};\n            let signs_i = ${q(\"uniforms.signs\",\"i\",r.length)};\n            let starts_i = ${q(\"uniforms.starts\",\"i\",r.length)};\n            var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")};\n          }\n          return input_indices;\n      }`,eg=(e,t)=>{let r=e[0].dims,n=k.size(r),o=t.axes.length>0?k.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],i=tn(e,4);i.forEach($=>$!==0||(()=>{throw new Error(\"step cannot be 0\")})),i.length===0&&(i=Array(o.length).fill(1));let a=t.starts.map(($,v)=>Ul($,v,r,o,i)),d=t.ends.map(($,v)=>Ul($,v,r,o,i));if(o.length!==a.length||o.length!==d.length)throw new Error(\"start, ends and axes should have the same number of elements\");if(o.length!==r.length)for(let $=0;$<r.length;++$)o.includes($)||(a.splice($,0,0),d.splice($,0,r[$]),i.splice($,0,1));let l=i.map($=>Math.sign($));i.forEach(($,v,S)=>{if($<0){let T=(d[v]-a[v])/$,A=a[v],C=A+T*i[v];a[v]=C,d[v]=A,S[v]=-$}});let p=r.slice(0);o.forEach(($,v)=>{p[$]=Math.ceil((d[$]-a[$])/i[$])});let m={dims:p,dataType:e[0].dataType},u=M(\"output\",e[0].dataType,p.length),h=E(\"input\",e[0].dataType,e[0].dims.length),_=k.size(p),y=[{name:\"outputSize\",type:\"u32\"},{name:\"starts\",type:\"u32\",length:a.length},{name:\"signs\",type:\"i32\",length:l.length},{name:\"steps\",type:\"u32\",length:i.length}],g=[{type:12,data:_},{type:12,data:a},{type:6,data:l},{type:12,data:i},...N(e[0].dims,p)],x=$=>`\n      ${$.registerUniforms(y).declareVariables(h,u)}\n        ${Jh(h,u,r)}\n        ${$.mainStart()}\n          ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n          let output_indices = ${u.offsetToIndices(\"global_idx\")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${u.setByOffset(\"global_idx\",h.getByIndices(\"input_indices\"))}\n      }`;return{name:\"Slice\",shaderCache:{hint:`${l.length}_${a.length}_${i.length}`,inputDependencies:[\"rank\"]},getShaderSource:x,getRunData:()=>({outputs:[m],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:g})}},Nl=(e,t)=>{Qh(e.inputs,t);let r=Xh(e.inputs,t);e.compute(eg(e.inputs,r),{inputs:[0]})},Vl=e=>{let t=e.starts,r=e.ends,n=e.axes;return ee({starts:t,ends:r,axes:n})}});var tg,rg,Ll,Gl,Hl=U(()=>{\"use strict\";J();ne();xe();dt();ae();tg=e=>{if(!e||e.length!==1)throw new Error(\"Softmax op requires 1 input.\")},rg=(e,t)=>{let r=e.inputs[0],n=r.dims,o=k.size(n),i=n.length,a=k.normalizeAxis(t.axis,i),d=a<n.length-1,l,p=[];d?(p=Array.from({length:i},(P,D)=>D),p[a]=i-1,p[i-1]=a,l=e.compute(Pe(r,p),{inputs:[r],outputs:[-1]})[0]):l=r;let m=l.dims,u=m[i-1],h=o/u,_=me(u),y=u/_,g=64;h===1&&(g=256);let x=(P,D)=>D===4?`max(max(${P}.x, ${P}.y), max(${P}.z, ${P}.w))`:D===2?`max(${P}.x, ${P}.y)`:D===3?`max(max(${P}.x, ${P}.y), ${P}.z)`:P,$=E(\"x\",l.dataType,l.dims,_),v=M(\"result\",l.dataType,l.dims,_),S=$.type.value,T=ye(l.dataType)===\"f32\"?`var threadMax = ${S}(-3.402823e+38f);`:`var threadMax = ${S}(-65504.0h);`,A=P=>`\n      var<workgroup> rowMaxShared : ${S};\n      var<workgroup> rowSumShared : ${S};\n      var<workgroup> threadShared : array<${S}, ${g}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${S} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${S}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${P.registerUniform(\"packedCols\",\"i32\").declareVariables($,v)}\n      ${P.mainStart(g)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${g};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${T}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${S}(${x(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${S}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${S}(${qe(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`,C=e.compute({name:\"Softmax\",shaderCache:{hint:`${_};${g}`,inputDependencies:[\"type\"]},getRunData:()=>({outputs:[{dims:m,dataType:l.dataType}],dispatchGroup:{x:h},programUniforms:[{type:6,data:y}]}),getShaderSource:A},{inputs:[l],outputs:[d?-1:0]})[0];d&&e.compute(Pe(C,p),{inputs:[C]})},Ll=(e,t)=>{tg(e.inputs),rg(e,t)},Gl=e=>ee({axis:e.axis})});var Fl,ng,og,ig,ql,Kl=U(()=>{\"use strict\";J();ne();ae();Fl=e=>Array.from(e.getBigInt64Array(),Number),ng=e=>{if(!e||e.length!==2)throw new Error(\"Tile requires 2 inputs.\");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error(\"Tile only support float, float16, int32, and uint32 data types\");if(e[1].dataType!==7)throw new Error(\"Tile `repeats` input should be of int64 data type\");if(e[1].dims.length!==1)throw new Error(\"Tile `repeats` input should be 1-D\");if(Fl(e[1]).length!==e[0].dims.length)throw new Error(\"Tile `repeats` input should have same number of elements as rank of input data tensor\")},og=(e,t)=>{let r=[];for(let n=0;n<e.length;++n)r.push(e[n]*t[n]);return r},ig=(e,t)=>{let r=e[0].dims,n=t??Fl(e[1]),o=og(r,n),i=k.size(o),a=e[0].dataType,d=E(\"input\",a,r.length),l=M(\"output\",a,o.length),p=m=>`\n      const inputShape = ${d.indices(...r)};\n      ${m.registerUniform(\"output_size\",\"u32\").declareVariables(d,l)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let output_indices = ${l.offsetToIndices(\"global_idx\")};\n      var input_indices: ${d.type.indices};\n      for (var i = 0; i < ${r.length}; i++) {\n        let input_dim_i = ${d.indicesGet(\"uniforms.input_shape\",\"i\")};\n        let input_dim_value = ${l.indicesGet(\"output_indices\",\"i\")}  % input_dim_i;\n\n        ${d.indicesSet(\"input_indices\",\"i\",\"input_dim_value\")}\n      }\n      ${l.setByOffset(\"global_idx\",d.getByIndices(\"input_indices\"))}\n    }`;return{name:\"Tile\",shaderCache:{hint:`${n}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...N(e[0].dims,o)]}),getShaderSource:p}},ql=e=>{ng(e.inputs),e.compute(ig(e.inputs),{inputs:[0]})}});var ag,sg,jl,Yl=U(()=>{\"use strict\";J();ne();ae();ag=(e,t,r,n,o)=>{let i=M(\"output_data\",o,r.length,4),a=E(\"a_data\",t[1].dataType,t[1].dims.length,4),d=E(\"b_data\",t[2].dataType,t[2].dims.length,4),l=E(\"c_data\",t[0].dataType,t[0].dims.length,4),p,m=(u,h,_)=>`select(${h}, ${u}, ${_})`;if(!n)p=i.setByOffset(\"global_idx\",m(a.getByOffset(\"global_idx\"),d.getByOffset(\"global_idx\"),l.getByOffset(\"global_idx\")));else{let u=(h,_,y=\"\")=>{let g=`a_data[index_a${_}][component_a${_}]`,x=`b_data[index_b${_}][component_b${_}]`,$=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`\n            let output_indices${_} = ${i.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${a.broadcastedIndicesToOffset(`output_indices${_}`,i)};\n            let offset_b${_} = ${d.broadcastedIndicesToOffset(`output_indices${_}`,i)};\n            let offset_c${_} = ${l.broadcastedIndicesToOffset(`output_indices${_}`,i)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${h}[${_}] = ${y}(${m(g,x,$)});\n          `};o===9?p=`\n            var data = vec4<u32>(0);\n            ${u(\"data\",0,\"u32\")}\n            ${u(\"data\",1,\"u32\")}\n            ${u(\"data\",2,\"u32\")}\n            ${u(\"data\",3,\"u32\")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`\n            ${u(\"output_data[global_idx]\",0)}\n            ${u(\"output_data[global_idx]\",1)}\n            ${u(\"output_data[global_idx]\",2)}\n            ${u(\"output_data[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(l,a,d,i)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${p}\n      }`},sg=e=>{let t=e[1].dims,r=e[2].dims,n=e[0].dims,o=e[1].dataType,i=!(k.areEqual(t,r)&&k.areEqual(r,n)),a=t,d=k.size(t);if(i){let p=tt.calcShape(tt.calcShape(t,r,!1),n,!1);if(!p)throw new Error(\"Can't perform where op on the given tensors\");a=p,d=k.size(a)}let l=Math.ceil(d/4);return{name:\"Where\",shaderCache:{inputDependencies:[\"rank\",\"rank\",\"rank\"]},getShaderSource:p=>ag(p,e,a,i,o),getRunData:()=>({outputs:[{dims:a,dataType:o}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:l},...N(n,t,r,a)]})}},jl=e=>{e.compute(sg(e.inputs))}});var Zl,Ql=U(()=>{\"use strict\";Es();Hr();Os();Bs();wu();Pu();Du();Zu();nd();ad();dd();fd();bd();_d();$d();Td();Ad();Pd();Dd();Rd();Fd();jd();Zd();Xd();tl();xo();nl();wl();xl();Tl();Al();Lr();Ol();Bl();Rl();Wl();Hl();To();Kl();dt();qr();Yl();Zl=new Map([[\"Abs\",[Ms]],[\"Acos\",[Rs]],[\"Acosh\",[Us]],[\"Add\",[vu]],[\"ArgMax\",[ks,lo]],[\"ArgMin\",[As,lo]],[\"Asin\",[Ns]],[\"Asinh\",[Vs]],[\"Atan\",[Ws]],[\"Atanh\",[Ls]],[\"Attention\",[Ps]],[\"AveragePool\",[cl,ll]],[\"BatchNormalization\",[zs]],[\"BiasAdd\",[Ds]],[\"BiasSplitGelu\",[_u]],[\"Cast\",[Hs,Gs]],[\"Ceil\",[qs]],[\"Clip\",[Fs]],[\"Concat\",[zu,Ou]],[\"Conv\",[_o,yo]],[\"ConvTranspose\",[rd,ed]],[\"Cos\",[Ks]],[\"Cosh\",[js]],[\"CumSum\",[od,id]],[\"DepthToSpace\",[sd,ud]],[\"DequantizeLinear\",[vl,$l]],[\"Div\",[$u]],[\"Einsum\",[pd,md]],[\"Elu\",[Ys,Qt]],[\"Equal\",[xu]],[\"Erf\",[Zs]],[\"Exp\",[Qs]],[\"Expand\",[gd]],[\"FastGelu\",[yd]],[\"Floor\",[Xs]],[\"FusedConv\",[_o,yo]],[\"Gather\",[vd,wd]],[\"GatherElements\",[Ed,kd]],[\"GatherBlockQuantized\",[Id,Cd]],[\"GatherND\",[xd,Sd]],[\"Gelu\",[Js]],[\"Gemm\",[Od,zd]],[\"GlobalAveragePool\",[fl,ml]],[\"GlobalMaxPool\",[_l,yl]],[\"Greater\",[Cu]],[\"GreaterOrEqual\",[ku]],[\"GridSample\",[Bd,Md]],[\"GroupQueryAttention\",[Hd]],[\"HardSigmoid\",[su,au]],[\"InstanceNormalization\",[Kd]],[\"LayerNormalization\",[Yd]],[\"LeakyRelu\",[eu,Qt]],[\"Less\",[Au]],[\"LessOrEqual\",[Eu]],[\"Log\",[gu]],[\"MatMul\",[Qd]],[\"MatMulNBits\",[Jd,el]],[\"MaxPool\",[gl,bl]],[\"Mul\",[Su]],[\"MultiHeadAttention\",[Vd,Nd]],[\"Neg\",[ru]],[\"Not\",[tu]],[\"Pad\",[rl]],[\"Pow\",[Tu]],[\"QuickGelu\",[bu,Qt]],[\"Range\",[Sl]],[\"Reciprocal\",[nu]],[\"ReduceMin\",[$s]],[\"ReduceMean\",[bs]],[\"ReduceMax\",[vs]],[\"ReduceSum\",[Ss]],[\"ReduceProd\",[xs]],[\"ReduceL1\",[ys]],[\"ReduceL2\",[_s]],[\"ReduceLogSum\",[Is]],[\"ReduceLogSumExp\",[ws]],[\"ReduceSumSquare\",[Ts]],[\"Relu\",[ou]],[\"Resize\",[Pl,zl]],[\"RotaryEmbedding\",[Dl]],[\"ScatterND\",[Cl,Il]],[\"Sigmoid\",[iu]],[\"Sin\",[uu]],[\"Sinh\",[du]],[\"Slice\",[Nl,Vl]],[\"SkipLayerNormalization\",[Ml]],[\"Split\",[Wd,Ld]],[\"Sqrt\",[lu]],[\"Softmax\",[Ll,Gl]],[\"Sub\",[Iu]],[\"Tan\",[cu]],[\"Tanh\",[mu]],[\"ThresholdedRelu\",[hu,Qt]],[\"Tile\",[ql]],[\"Transpose\",[os,is]],[\"Where\",[jl]]])});var rn,Xl=U(()=>{\"use strict\";Le();et();ae();rn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,n,o,i){Ne(t.programInfo.name);let a=this.backend.device,d=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let l=[];for(let m of r)l.push({binding:l.length,resource:{buffer:m.buffer}});for(let m of n)l.push({binding:l.length,resource:{buffer:m.buffer}});i&&l.push({binding:l.length,resource:i});let p=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:l,label:t.programInfo.name});if(this.backend.sessionStatus===\"capturing\"){let m={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:p,dispatchGroup:o};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(m)}d.setPipeline(t.computePipeline),d.setBindGroup(0,p),d.dispatchWorkgroups(...o),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType===\"at-passes\")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Be(t.programInfo.name)}dispose(){}build(t,r){Ne(t.name);let n=this.backend.device,o=[];[{feature:\"shader-f16\",extension:\"f16\"},{feature:\"subgroups\",extension:\"subgroups\"},{feature:\"subgroups-f16\",extension:\"subgroups_f16\"}].forEach(u=>{n.features.has(u.feature)&&o.push(`enable ${u.extension};`)});let a=rs(r,this.backend.device.limits),d=t.getShaderSource(a),l=`${o.join(`\n`)}\n${a.additionalImplementations}\n${d}`,p=n.createShaderModule({code:l,label:t.name});se(\"verbose\",()=>`[WebGPU] ${t.name} shader code: ${l}`);let m=n.createComputePipeline({compute:{module:p,entryPoint:\"main\"},layout:\"auto\",label:t.name});return Be(t.name),{programInfo:t,computePipeline:m,uniformVariablesInfo:a.variablesInfo}}normalizeDispatchGroupSize(t){let r=typeof t==\"number\"?t:t.x,n=typeof t==\"number\"?1:t.y||1,o=typeof t==\"number\"?1:t.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=i&&n<=i&&o<=i)return[r,n,o];let a=r*n*o,d=Math.ceil(Math.sqrt(a));if(d>i){if(d=Math.ceil(Math.cbrt(a)),d>i)throw new Error(\"Total dispatch size exceeds WebGPU maximum.\");return[d,d,d]}else return[d,d,1]}}});var ug,dg,Io,Co,nn,Jl=U(()=>{\"use strict\";Le();J();et();Xn();Xa();Ql();Xl();ug=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let n=0;n<e.length;++n){let o=e[n].dataType;switch(t[n]){case\"none\":{r.push(\"\");break}case\"type\":{r.push(`${o}`);break}case\"rank\":{let i=e[n].dims.length;r.push(`${o};${i}`);break}case\"dims\":{let i=e[n].dims.join(\",\");r.push(`${o};${i}`);break}default:throw new Error(`unsupported input dependency: ${t[n]}`)}}return r.join(\"|\")},dg=(e,t,r)=>{let n=e.name;return e.shaderCache?.hint&&(n+=\"[\"+e.shaderCache.hint+\"]\"),n+=\":\"+r+`:${ug(t,e.shaderCache?.inputDependencies??new Array(t.length).fill(\"dims\"))}`,n},Io=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},Co=class{constructor(t){this.subgroupsSupported=t.features.has(\"subgroups\"),this.subgroupsF16Supported=t.features.has(\"subgroups\");let r=t.limits;!this.subgroupsSupported||!r.minSubgroupSize||!r.maxSubgroupSize?this.subgroupSizeRange=void 0:this.subgroupSizeRange=[r.minSubgroupSize,r.maxSubgroupSize]}},nn=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus=\"default\";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error(\"currentKernelCustomData(): currentKernelId is null. (should not happen)\");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let n=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},i=a=>r.features.has(a)&&n.push(a)&&!0;i(\"chromium-experimental-timestamp-query-inside-passes\")||i(\"timestamp-query\"),i(\"shader-f16\"),i(\"subgroups\")&&i(\"subgroups-f16\"),this.device=await r.requestDevice(o),this.deviceInfo=new Co(this.device),this.adapterInfo=new Io(r.info||await r.requestAdapterInfo()),this.gpuDataManager=Qa(this),this.programManager=new rn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Mr(t.logLevel,!!t.debug),this.device.onuncapturederror=a=>{a.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${a.error.message}`)},Object.defineProperty(this.env.webgpu,\"device\",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,\"adapter\",{value:r,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<\"u\"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),r={};this.queryType===\"at-passes\"&&(r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Ne(),this.endComputePass();let t;this.queryType!==\"none\"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!==\"none\"&&t.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.getMappedRange()),n=this.pendingQueries.get(t);for(let o=0;o<r.length/2;o++){let i=n[o],a=i.kernelId,d=this.kernels.get(a),l=d.kernelType,p=d.kernelName,m=i.programName,u=i.inputTensorViews,h=i.outputTensorViews,_=r[o*2],y=r[o*2+1];typeof this.queryTimeBase>\"u\"&&(this.queryTimeBase=_);let g=Number(_-this.queryTimeBase),x=Number(y-this.queryTimeBase);if(!Number.isSafeInteger(g)||!Number.isSafeInteger(x))throw new RangeError(\"incorrect timestamp range\");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:u.map($=>({dims:$.dims,dataType:bt($.dataType)})),outputsMetadata:h.map($=>({dims:$.dims,dataType:bt($.dataType)})),kernelId:a,kernelType:l,kernelName:p,programName:m,startTime:g,endTime:x});else{let $=\"\";u.forEach((S,T)=>{$+=`input[${T}]: [${S.dims}] | ${bt(S.dataType)}, `});let v=\"\";h.forEach((S,T)=>{v+=`output[${T}]: [${S.dims}] | ${bt(S.dataType)}, `}),console.log(`[profiling] kernel \"${a}|${l}|${p}|${m}\" ${$}${v}execution time: ${x-g} ns`)}_r(\"GPU\",`${m}::${_}::${y}`)}t.unmap(),this.pendingQueries.delete(t)}),Be()}run(t,r,n,o,i,a){Ne(t.name);let d=[];for(let S=0;S<r.length;++S){let T=r[S].data;if(T===0)continue;let A=this.gpuDataManager.get(T);if(!A)throw new Error(`no GPU data for input: ${T}`);d.push(A)}let{outputs:l,dispatchGroup:p,programUniforms:m}=t.getRunData(r),u=n.length===0?l.map((S,T)=>T):n;if(u.length!==l.length)throw new Error(`Output size ${u.length} must be equal to ${l.length}.`);let h=[],_=[];for(let S=0;S<l.length;++S){if(!Number.isInteger(u[S])||u[S]<-3||u[S]>=a)throw new Error(`Invalid output index: ${u[S]}`);if(u[S]===-3)continue;let T=u[S]===-1,A=u[S]===-2,C=T||A?i(l[S].dataType,l[S].dims):o(u[S],l[S].dataType,l[S].dims);if(h.push(C),C.data===0)continue;let P=this.gpuDataManager.get(C.data);if(!P)throw new Error(`no GPU data for output: ${C.data}`);if(T&&this.temporaryData.push(P),A){let D=this.kernelPersistentData.get(this.currentKernelId);D||(D=[],this.kernelPersistentData.set(this.currentKernelId,D)),D.push(P)}_.push(P)}if(d.length!==r.length||_.length!==h.length){if(_.length===0)return Be(t.name),h;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let y;if(m){let S=0,T=[];m.forEach(D=>{let R=typeof D.data==\"number\"?[D.data]:D.data;if(R.length===0)return;let H=D.type===10?2:4,L,re;D.type===10?(re=R.length>4?16:R.length>2?8:R.length*H,L=R.length>4?16:H*R.length):(re=R.length<=2?R.length*H:16,L=16),S=Math.ceil(S/re)*re,T.push(S);let V=D.type===10?8:4;S+=R.length>4?Math.ceil(R.length/V)*L:R.length*H});let A=16;S=Math.ceil(S/A)*A;let C=new ArrayBuffer(S);m.forEach((D,R)=>{let H=T[R],L=typeof D.data==\"number\"?[D.data]:D.data;if(D.type===6)new Int32Array(C,H,L.length).set(L);else if(D.type===12)new Uint32Array(C,H,L.length).set(L);else if(D.type===10)new Uint16Array(C,H,L.length).set(L);else if(D.type===1)new Float32Array(C,H,L.length).set(L);else throw new Error(`Unsupported uniform type: ${bt(D.type)}`)});let P=this.gpuDataManager.create(S,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(P.buffer,0,C,0,S),this.gpuDataManager.release(P.id),y={offset:0,size:S,buffer:P.buffer}}let g=this.programManager.normalizeDispatchGroupSize(p),x=g[1]===1&&g[2]===1,$=dg(t,r,x),v=this.programManager.getArtifact($);if(v||(v=this.programManager.build(t,g),this.programManager.setArtifact($,v),se(\"info\",()=>`[artifact] key: ${$}, programName: ${t.name}`)),m&&v.uniformVariablesInfo){if(m.length!==v.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${v.uniformVariablesInfo.length}, got ${m.length} in program \"${v.programInfo.name}\".`);for(let S=0;S<m.length;S++){let T=m[S],A=T.type,C=typeof T.data==\"number\"?1:T.data.length,[P,D]=v.uniformVariablesInfo[S];if(A!==P||C!==D)throw new Error(`Uniform variable ${S} mismatch: expect type ${P} with size ${D}, got type ${A} with size ${C} in program \"${v.programInfo.name}\".`)}}if(se(\"info\",()=>`[ProgramManager] run \"${t.name}\" (key=${$}) with ${g[0]}x${g[1]}x${g[2]}`),this.queryType!==\"none\"||this.sessionStatus===\"capturing\"){let S={kernelId:this.currentKernelId,programName:v.programInfo.name,inputTensorViews:r,outputTensorViews:h};this.pendingKernels.push(S),this.sessionStatus===\"capturing\"&&this.capturedPendingKernels.get(this.currentSessionId).push(S)}return this.programManager.run(v,d,_,g,y),Be(t.name),h}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,n,o){let i=Zl.get(t);if(!i)throw new Error(`kernel not implemented: ${t}`);let a={kernelType:t,kernelName:o,kernelEntry:i[0],attributes:[i[1],n]};this.kernels.set(r,a)}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let n of r)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,n){let o=this.kernels.get(t);if(!o)throw new Error(`kernel not created: ${t}`);let i=o.kernelType,a=o.kernelName,d=o.kernelEntry,l=o.attributes;if(this.currentKernelId!==null)throw new Error(`kernel \"[${i}] ${a}\" is not allowed to be called recursively`);this.currentKernelId=t,l[0]&&(l[1]=l[0](l[1]),l[0]=void 0),se(\"info\",()=>`[WebGPU] Start to run kernel \"[${i}] ${a}\"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope(\"validation\"),d(r,l[1]),0}catch(m){return n.push(Promise.resolve(`[WebGPU] Kernel \"[${i}] ${a}\" failed. ${m}`)),1}finally{p&&n.push(this.device.popErrorScope().then(m=>m?`GPU validation error for kernel \"[${i}] ${a}\": ${m.message}`:null));for(let m of this.temporaryData)this.gpuDataManager.release(m.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,n,o){let i=this.sessionExternalDataMapping.get(t);i||(i=new Map,this.sessionExternalDataMapping.set(t,i));let a=i.get(r),d=this.gpuDataManager.registerExternalBuffer(n,o,a);return i.set(r,[d,n]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,n){return async()=>{let o=await ro(this,t,r);return Rr(o.buffer,n)}}writeTimestamp(t){this.queryType===\"inside-passes\"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType=\"none\",(this.env.webgpu.profiling?.mode===\"default\"||(typeof this.env.trace>\"u\"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has(\"chromium-experimental-timestamp-query-inside-passes\")?this.queryType=\"inside-passes\":this.device.features.has(\"timestamp-query\")&&(this.queryType=\"at-passes\"),this.queryType!==\"none\"&&typeof this.querySet>\"u\"&&(this.querySet=this.device.createQuerySet({type:\"timestamp\",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){se(\"info\",\"captureBegin\"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus=\"capturing\"}captureEnd(){se(\"info\",\"captureEnd\"),this.flush(),this.sessionStatus=\"default\"}replay(){se(\"info\",\"replay\"),this.sessionStatus=\"replaying\";let t=this.capturedCommandList.get(this.currentSessionId),r=this.capturedPendingKernels.get(this.currentSessionId),n=t.length;this.pendingKernels=[];for(let o=0;o<n;o++){let i=this.getComputePassEncoder(),a=t[o];this.writeTimestamp(this.pendingDispatchNumber*2),i.setPipeline(a.computePipeline),i.setBindGroup(0,a.bindGroup),i.dispatchWorkgroups(...a.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!==\"none\"&&this.pendingKernels.push(r[o]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType===\"at-passes\")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus=\"default\"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var lg,ec,cg,tc,on,an,Ao,rc,nc=U(()=>{\"use strict\";et();lg=1,ec=()=>lg++,cg=new Map([[\"float32\",32],[\"float16\",16],[\"int32\",32],[\"uint32\",32],[\"int64\",64],[\"uint64\",64],[\"int8\",8],[\"uint8\",8],[\"int4\",4],[\"uint4\",4]]),tc=(e,t)=>{let r=cg.get(e);if(!r)throw new Error(\"Unsupported data type.\");return t.length>0?Math.ceil(t.reduce((n,o)=>n*o)*r/8):0},on=class{constructor(t){this.sessionId=t.sessionId,this.mlContext=t.context,this.mlTensor=t.tensor,this.dataType=t.dataType,this.tensorShape=t.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return tc(this.dataType,this.tensorShape)}destroy(){se(\"verbose\",()=>\"[WebNN] TensorWrapper.destroy\"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,r,n){return this.mlContext===t&&this.dataType===r&&this.tensorShape.length===n.length&&this.tensorShape.every((o,i)=>o===n[i])}},an=class{constructor(t,r){this.tensorManager=t;this.wrapper=r}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,r,n,o){if(this.wrapper){if(this.wrapper.canReuseTensor(t,r,n))return this.wrapper.tensor;if(o){if(this.wrapper.byteLength!==tc(r,n))throw new Error(\"Unable to copy data to tensor with different size.\");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let i=typeof MLTensorUsage>\"u\"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(r,n,i,!0,!0),o&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){if(this.wrapper)if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else se(\"verbose\",()=>\"Data size does not match tensor size. Releasing tensor.\"),this.releaseTensor();this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(t){if(this.activeUpload)if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(this.activeUpload):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error(\"Tensor has not been created.\");return t?this.wrapper.read(t):this.wrapper.read()}},Ao=class{constructor(t){this.backend=t;this.tensorTrackersById=new Map;this.freeTensors=[];this.externalTensors=new Set}reserveTensorId(){let t=ec();return this.tensorTrackersById.set(t,new an(this)),t}releaseTensorId(t){let r=this.tensorTrackersById.get(t);r&&(this.tensorTrackersById.delete(t),r.tensorWrapper&&this.releaseTensor(r.tensorWrapper))}async ensureTensor(t,r,n,o){se(\"verbose\",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${r}, shape: ${n}, copyOld: ${o}}`);let i=this.tensorTrackersById.get(t);if(!i)throw new Error(\"Tensor not found.\");return i.ensureTensor(this.backend.currentContext,r,n,o)}upload(t,r){let n=this.tensorTrackersById.get(t);if(!n)throw new Error(\"Tensor not found.\");n.upload(r)}async download(t,r){se(\"verbose\",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${r?.byteLength}}`);let n=this.tensorTrackersById.get(t);if(!n)throw new Error(\"Tensor not found.\");return n.download(r)}releaseTensorsForSession(t){for(let r of this.freeTensors)r.sessionId===t&&r.destroy();this.freeTensors=this.freeTensors.filter(r=>r.sessionId!==t)}registerTensor(t,r,n,o){let i=ec(),a=new on({sessionId:this.backend.currentSessionId,context:t,tensor:r,dataType:n,shape:o});return this.tensorTrackersById.set(i,new an(this,a)),this.externalTensors.add(a),i}async getCachedTensor(t,r,n,o,i){let a=this.backend.currentSessionId,d=this.backend.currentContext;for(let[p,m]of this.freeTensors.entries())if(m.canReuseTensor(d,t,r)){se(\"verbose\",()=>`[WebNN] Reusing tensor {dataType: ${t}, shape: ${r}}`);let u=this.freeTensors.splice(p,1)[0];return u.sessionId=a,u}se(\"verbose\",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, shape: ${r}}`);let l=await d.createTensor({dataType:t,shape:r,dimensions:r,usage:n,writable:o,readable:i});return new on({sessionId:a,context:d,tensor:l,dataType:t,shape:r})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},rc=(...e)=>new Ao(...e)});var oc,pg,sn,ic=U(()=>{\"use strict\";J();gt();Xn();nc();et();oc=new Map([[1,\"float32\"],[10,\"float16\"],[6,\"int32\"],[12,\"uint32\"],[7,\"int64\"],[13,\"uint64\"],[22,\"int4\"],[21,\"uint4\"],[3,\"int8\"],[2,\"uint8\"],[9,\"uint8\"]]),pg=(e,t)=>{if(e===t)return!0;if(e===void 0||t===void 0)return!1;let r=Object.keys(e).sort(),n=Object.keys(t).sort();return r.length===n.length&&r.every((o,i)=>o===n[i]&&e[o]===t[o])},sn=class{constructor(t){this.tensorManager=rc(this);this.mlContextBySessionId=new Map;this.sessionIdsByMLContext=new Map;this.mlContextCache=[];Mr(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error(\"No active session\");return this.activeSessionId}onRunStart(t){this.activeSessionId=t}async createMLContext(t){if(t instanceof GPUDevice){let n=this.mlContextCache.findIndex(o=>o.gpuDevice===t);if(n!==-1)return this.mlContextCache[n].mlContext;{let o=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:o}),o}}else if(t===void 0){let n=this.mlContextCache.findIndex(o=>o.options===void 0&&o.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let o=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:o}),o}}let r=this.mlContextCache.findIndex(n=>pg(n.options,t));if(r!==-1)return this.mlContextCache[r].mlContext;{let n=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:n}),n}}get currentContext(){let t=this.getMLContext(this.currentSessionId);if(!t)throw new Error(`No MLContext found for session ${this.currentSessionId}`);return t}registerMLContext(t,r){this.mlContextBySessionId.set(t,r);let n=this.sessionIdsByMLContext.get(r);n||(n=new Set,this.sessionIdsByMLContext.set(r,n)),n.add(t)}onReleaseSession(t){let r=this.mlContextBySessionId.get(t);if(!r)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t);let n=this.sessionIdsByMLContext.get(r);if(n.delete(t),n.size===0){this.sessionIdsByMLContext.delete(r);let o=this.mlContextCache.findIndex(i=>i.mlContext===r);o!==-1&&this.mlContextCache.splice(o,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){se(\"verbose\",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,r,n,o){let i=oc.get(r);if(!i)throw new Error(`Unsupported ONNX data type: ${r}`);return this.tensorManager.ensureTensor(t,i,n,o)}uploadTensor(t,r){if(!Te().shouldTransferToMLTensor)throw new Error(\"Trying to upload to a MLTensor while shouldTransferToMLTensor is false\");se(\"verbose\",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${r.byteLength}}`),this.tensorManager.upload(t,r)}async downloadTensor(t,r){return this.tensorManager.download(t,r)}createMLTensorDownloader(t,r){return async()=>{let n=await this.tensorManager.download(t);return Rr(n,r)}}registerMLTensor(t,r,n){let o=oc.get(r);if(!o)throw new Error(`Unsupported ONNX data type: ${r}`);let i=this.tensorManager.registerTensor(this.currentContext,t,o,n);return se(\"verbose\",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${o}, dimensions: ${n}} -> {tensorId: ${i}}`),i}registerMLConstant(t,r,n,o,i,a){if(!a)throw new Error(\"External mounted files are not available.\");let d=t;t.startsWith(\"./\")&&(d=t.substring(2));let l=a.get(d);if(!l)throw new Error(`File with name ${d} not found in preloaded files.`);if(r+n>l.byteLength)throw new Error(\"Out of bounds: data offset and length exceed the external file data size.\");let p=l.slice(r,r+n).buffer,m;switch(i.dataType){case\"float32\":m=new Float32Array(p);break;case\"float16\":m=new Uint16Array(p);break;case\"int32\":m=new Int32Array(p);break;case\"uint32\":m=new Uint32Array(p);break;case\"int64\":m=new BigInt64Array(p);break;case\"uint64\":m=new BigUint64Array(p);break;case\"int8\":m=new Int8Array(p);break;case\"int4\":case\"uint4\":case\"uint8\":m=new Uint8Array(p);break;default:throw new Error(`Unsupported data type: ${i.dataType} in creating WebNN Constant from external data.`)}return se(\"verbose\",()=>`[WebNN] registerMLConstant {dataType: ${i.dataType}, shape: ${i.shape}}}`),o.constant(i,m)}flush(){}}});var ac={};Ht(ac,{init:()=>mg});var tr,ko,mg,sc=U(()=>{\"use strict\";J();Jl();et();ne();ic();tr=class e{constructor(t,r,n,o){this.module=t;this.dataType=r;this.data=n;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error(\"Invalid data type\");let t=k.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error(\"Invalid data type\");let t=k.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error(\"Invalid data type\");let t=k.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error(\"Invalid data type\");let t=k.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(k.size(t)!==k.size(this.dims))throw new Error(\"Invalid new shape\");return new e(this.module,this.dataType,this.data,t)}},ko=class{constructor(t,r,n){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=r.adapterInfo,this.deviceInfo=r.deviceInfo;let o=t.PTR_SIZE,i=n/t.PTR_SIZE,a=o===4?\"i32\":\"i64\";this.opKernelContext=Number(t.getValue(o*i++,a));let d=Number(t.getValue(o*i++,a));this.outputCount=Number(t.getValue(o*i++,a)),this.customDataOffset=Number(t.getValue(o*i++,\"*\")),this.customDataSize=Number(t.getValue(o*i++,a));let l=[];for(let p=0;p<d;p++){let m=Number(t.getValue(o*i++,a)),u=Number(t.getValue(o*i++,\"*\")),h=Number(t.getValue(o*i++,a)),_=[];for(let y=0;y<h;y++)_.push(Number(t.getValue(o*i++,a)));l.push(new tr(t,m,u,_))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let n=r?.inputs?.map(d=>typeof d==\"number\"?this.inputs[d]:d)??this.inputs,o=r?.outputs??[],i=(d,l,p)=>new tr(this.module,l,this.output(d,p),p),a=(d,l)=>{let p=At(d,l);if(!p)throw new Error(`Unsupported data type: ${d}`);let m=p>0?this.backend.gpuDataManager.create(p).id:0;return new tr(this.module,d,m,l)};return this.backend.run(t,n,o,i,a,this.outputCount)}output(t,r){let n=this.module.stackSave();try{let o=this.module.PTR_SIZE,i=o===4?\"i32\":\"i64\",a=this.module.stackAlloc((1+r.length)*o);this.module.setValue(a,r.length,i);for(let d=0;d<r.length;d++)this.module.setValue(a+o*(d+1),r[d],i);return this.module._JsepOutput(this.opKernelContext,t,a)}catch(o){throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(n)}}},mg=async(e,t,r,n)=>{let o=t.jsepInit;if(!o)throw new Error(\"Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.\");if(e===\"webgpu\"){let i=new nn;await i.initialize(r,n),o(\"webgpu\",[i,a=>i.alloc(Number(a)),a=>i.free(a),(a,d,l,p=!1)=>{if(p)se(\"verbose\",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(a)}, dst=${Number(d)}, size=${Number(l)}`),i.memcpy(Number(a),Number(d));else{se(\"verbose\",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(a)}, gpuDataId=${Number(d)}, size=${Number(l)}`);let m=t.HEAPU8.subarray(Number(a>>>0),Number(a>>>0)+Number(l));i.upload(Number(d),m)}},async(a,d,l)=>{se(\"verbose\",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${d}, size=${l}`),await i.download(Number(a),()=>t.HEAPU8.subarray(Number(d)>>>0,Number(d+l)>>>0))},(a,d,l)=>i.createKernel(a,Number(d),l,t.UTF8ToString(t._JsepGetNodeName(Number(d)))),a=>i.releaseKernel(a),(a,d,l,p)=>{se(\"verbose\",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${a}, contextDataOffset=${d}`);let m=new ko(t,i,Number(d));return i.computeKernel(Number(a),m,p)},()=>i.captureBegin(),()=>i.captureEnd(),()=>i.replay()])}else{let i=new sn(r);o(\"webnn\",[i,()=>i.reserveTensorId(),a=>i.releaseTensorId(a),async(a,d,l,p)=>i.ensureTensor(a,d,l,p),(a,d)=>{i.uploadTensor(a,d)},async(a,d)=>i.downloadTensor(a,d)])}}});var fg,Sr,Tr,zt,hg,qt,Ir,Cr,uc,Ar,kr,Er,Fn=U(()=>{\"use strict\";Ga();Fa();J();gt();zr();Qn();fg=(e,t)=>{Te()._OrtInit(e,t)!==0&&ce(\"Can't initialize onnxruntime.\")},Sr=async e=>{fg(e.wasm.numThreads,Yt(e.logLevel))},Tr=async(e,t)=>{{let r=(sc(),gr(ac)).init;if(t===\"webgpu\"){if(typeof navigator>\"u\"||!navigator.gpu)throw new Error(\"WebGPU is not supported in current environment\");let n=e.webgpu.adapter;if(n){if(typeof n.limits!=\"object\"||typeof n.features!=\"object\"||typeof n.requestDevice!=\"function\")throw new Error(\"Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.\")}else{let o=e.webgpu.powerPreference;if(o!==void 0&&o!==\"low-power\"&&o!==\"high-performance\")throw new Error(`Invalid powerPreference setting: \"${o}\"`);let i=e.webgpu.forceFallbackAdapter;if(i!==void 0&&typeof i!=\"boolean\")throw new Error(`Invalid forceFallbackAdapter setting: \"${i}\"`);if(n=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:i}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.')}await r(\"webgpu\",Te(),e,n)}if(t===\"webnn\"){if(typeof navigator>\"u\"||!navigator.ml)throw new Error(\"WebNN is not supported in current environment\");await r(\"webnn\",Te(),e)}}},zt=new Map,hg=e=>{let t=Te(),r=t.stackSave();try{let n=t.PTR_SIZE,o=t.stackAlloc(2*n);t._OrtGetInputOutputCount(e,o,o+n)!==0&&ce(\"Can't get session input/output count.\");let a=n===4?\"i32\":\"i64\";return[Number(t.getValue(o,a)),Number(t.getValue(o+n,a))]}finally{t.stackRestore(r)}},qt=e=>{let t=Te(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Ir=async(e,t)=>{let r,n,o=Te();Array.isArray(e)?[r,n]=e:e.buffer===o.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=qt(e);let i=0,a=0,d=0,l=[],p=[],m=[];try{if([a,l]=Ha(t),t?.externalData&&o.mountExternalData){let v=[];for(let S of t.externalData){let T=typeof S==\"string\"?S:S.path;v.push(Zt(typeof S==\"string\"?S:S.data).then(A=>{o.mountExternalData(T,A)}))}await Promise.all(v)}for(let v of t?.executionProviders??[])if((typeof v==\"string\"?v:v.name)===\"webnn\"){if(o.shouldTransferToMLTensor=!1,typeof v!=\"string\"){let T=v,A=T?.context,C=T?.gpuDevice,P=T?.deviceType,D=T?.powerPreference;A?o.currentContext=A:C?o.currentContext=await o.jsepCreateMLContext(C):o.currentContext=await o.jsepCreateMLContext({deviceType:P,powerPreference:D})}else o.currentContext=await o.jsepCreateMLContext();break}i=await o._OrtCreateSession(r,n,a),i===0&&ce(\"Can't create a session.\"),o.jsepOnCreateSession?.(),o.currentContext&&(o.jsepRegisterMLContext(i,o.currentContext),o.currentContext=void 0,o.shouldTransferToMLTensor=!0);let[u,h]=hg(i),_=!!t?.enableGraphCapture,y=[],g=[],x=[];for(let v=0;v<u;v++){let S=o._OrtGetInputName(i,v);S===0&&ce(\"Can't get an input name.\"),p.push(S),y.push(o.UTF8ToString(S))}for(let v=0;v<h;v++){let S=o._OrtGetOutputName(i,v);S===0&&ce(\"Can't get an output name.\"),m.push(S);let T=o.UTF8ToString(S);g.push(T);{if(_&&t?.preferredOutputLocation===void 0){x.push(\"gpu-buffer\");continue}let A=typeof t?.preferredOutputLocation==\"string\"?t.preferredOutputLocation:t?.preferredOutputLocation?.[T]??\"cpu\";if(A!==\"cpu\"&&A!==\"cpu-pinned\"&&A!==\"gpu-buffer\"&&A!==\"ml-tensor\")throw new Error(`Not supported preferred output location: ${A}.`);if(_&&A!==\"gpu-buffer\")throw new Error(`Not supported preferred output location: ${A}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);x.push(A)}}let $=null;return x.some(v=>v===\"gpu-buffer\"||v===\"ml-tensor\")&&(d=o._OrtCreateBinding(i),d===0&&ce(\"Can't create IO binding.\"),$={handle:d,outputPreferredLocations:x,outputPreferredLocationsEncoded:x.map(v=>Zn(v))}),zt.set(i,[i,p,m,$,_,!1]),[i,y,g]}catch(u){throw p.forEach(h=>o._OrtFree(h)),m.forEach(h=>o._OrtFree(h)),d!==0&&o._OrtReleaseBinding(d)!==0&&ce(\"Can't release IO binding.\"),i!==0&&o._OrtReleaseSession(i)!==0&&ce(\"Can't release session.\"),u}finally{o._free(r),a!==0&&o._OrtReleaseSessionOptions(a)!==0&&ce(\"Can't release session options.\"),l.forEach(u=>o._free(u)),o.unmountExternalData?.()}},Cr=e=>{let t=Te(),r=zt.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[n,o,i,a,d]=r;a&&(d&&t._OrtClearBoundOutputs(a.handle)!==0&&ce(\"Can't clear bound outputs.\"),t._OrtReleaseBinding(a.handle)!==0&&ce(\"Can't release IO binding.\")),t.jsepOnReleaseSession?.(e),o.forEach(l=>t._OrtFree(l)),i.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(n)!==0&&ce(\"Can't release session.\"),zt.delete(e)},uc=(e,t,r,n,o,i=!1)=>{if(!e){t.push(0);return}let a=Te(),d=a.PTR_SIZE,l=e[0],p=e[1],m=e[3],u,h;if(l===\"string\"&&(m===\"gpu-buffer\"||m===\"ml-tensor\"))throw new Error(\"String tensor is not supported on GPU.\");if(i&&m!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if(m===\"gpu-buffer\"){let g=e[2].gpuBuffer;h=At(jt(l),p);let x=a.jsepRegisterBuffer;if(!x)throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');u=x(n,o,g,h)}else if(m===\"ml-tensor\"){let g=e[2].mlTensor;h=At(jt(l),p);let x=a.jsepRegisterMLTensor;if(!x)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');u=x(g,jt(l),p)}else{let g=e[2];if(Array.isArray(g)){h=d*g.length,u=a._malloc(h),r.push(u);for(let x=0;x<g.length;x++){if(typeof g[x]!=\"string\")throw new TypeError(`tensor data at index ${x} is not a string`);a.setValue(u+x*d,ke(g[x],r),\"*\")}}else h=g.byteLength,u=a._malloc(h),r.push(u),a.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,h),u)}let _=a.stackSave(),y=a.stackAlloc(4*p.length);try{p.forEach((x,$)=>a.setValue(y+$*d,x,d===4?\"i32\":\"i64\"));let g=a._OrtCreateTensor(jt(l),u,h,y,p.length,Zn(m));g===0&&ce(`Can't create tensor for input/output. session=${n}, index=${o}.`),t.push(g)}finally{a.stackRestore(_)}},Ar=async(e,t,r,n,o,i)=>{let a=Te(),d=a.PTR_SIZE,l=zt.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let p=l[0],m=l[1],u=l[2],h=l[3],_=l[4],y=l[5],g=t.length,x=n.length,$=0,v=[],S=[],T=[],A=[],C=a.stackSave(),P=a.stackAlloc(g*d),D=a.stackAlloc(g*d),R=a.stackAlloc(x*d),H=a.stackAlloc(x*d);try{a.jsepOnRunStart?.(p),[$,v]=La(i);for(let V=0;V<g;V++)uc(r[V],S,A,e,t[V],_);for(let V=0;V<x;V++)uc(o[V],T,A,e,g+n[V],_);for(let V=0;V<g;V++)a.setValue(P+V*d,S[V],\"*\"),a.setValue(D+V*d,m[t[V]],\"*\");for(let V=0;V<x;V++)a.setValue(R+V*d,T[V],\"*\"),a.setValue(H+V*d,u[n[V]],\"*\");if(h&&!y){let{handle:V,outputPreferredLocations:K,outputPreferredLocationsEncoded:we}=h;if(m.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${m.length}).`);for(let j=0;j<g;j++){let Q=t[j];await a._OrtBindInput(V,m[Q],S[j])!==0&&ce(`Can't bind input[${j}] for session=${e}.`)}for(let j=0;j<x;j++){let Q=n[j];o[j]?.[3]?a._OrtBindOutput(V,u[Q],T[j],0)!==0&&ce(`Can't bind pre-allocated output[${j}] for session=${e}.`):a._OrtBindOutput(V,u[Q],0,we[Q])!==0&&ce(`Can't bind output[${j}] to ${K[j]} for session=${e}.`)}zt.set(e,[p,m,u,h,_,!0])}let L;h?L=await a._OrtRunWithBinding(p,h.handle,x,R,$):L=await a._OrtRun(p,D,P,g,H,x,R,$),L!==0&&ce(\"failed to call OrtRun().\");let re=[];for(let V=0;V<x;V++){let K=Number(a.getValue(R+V*d,\"*\"));if(K===T[V]){re.push(o[V]);continue}let we=a.stackSave(),j=a.stackAlloc(4*d),Q=!1,ie,te=0;try{a._OrtGetTensorData(K,j,j+d,j+2*d,j+3*d)!==0&&ce(`Can't access output tensor data on index ${V}.`);let Oe=d===4?\"i32\":\"i64\",ve=Number(a.getValue(j,Oe));te=a.getValue(j+d,\"*\");let de=a.getValue(j+d*2,\"*\"),W=Number(a.getValue(j+d*3,Oe)),Y=[];for(let pe=0;pe<W;pe++)Y.push(Number(a.getValue(de+pe*d,Oe)));a._OrtFree(de)!==0&&ce(\"Can't free memory for tensor dims.\");let he=Y.reduce((pe,Ie)=>pe*Ie,1);ie=bt(ve);let De=h?.outputPreferredLocations[n[V]];if(ie===\"string\"){if(De===\"gpu-buffer\"||De===\"ml-tensor\")throw new Error(\"String tensor is not supported on GPU.\");let pe=[];for(let Ie=0;Ie<he;Ie++){let He=a.getValue(te+Ie*d,\"*\"),mn=a.getValue(te+(Ie+1)*d,\"*\"),wt=Ie===he-1?void 0:mn-He;pe.push(a.UTF8ToString(He,wt))}re.push([ie,Y,pe,\"cpu\"])}else if(De===\"gpu-buffer\"&&he>0){let pe=a.jsepGetBuffer;if(!pe)throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');let Ie=pe(te),He=At(ve,he);if(He===void 0||!Dr(ie))throw new Error(`Unsupported data type: ${ie}`);Q=!0,re.push([ie,Y,{gpuBuffer:Ie,download:a.jsepCreateDownloader(Ie,He,ie),dispose:()=>{a._OrtReleaseTensor(K)!==0&&ce(\"Can't release tensor.\")}},\"gpu-buffer\"])}else if(De===\"ml-tensor\"&&he>0){let pe=a.jsepEnsureTensor;if(!pe)throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');if(At(ve,he)===void 0||!Br(ie))throw new Error(`Unsupported data type: ${ie}`);let He=await pe(te,ve,Y,!1);Q=!0,re.push([ie,Y,{mlTensor:He,download:a.jsepCreateMLTensorDownloader(te,ie),dispose:()=>{a.jsepReleaseTensorId(te),a._OrtReleaseTensor(K)}},\"ml-tensor\"])}else{let pe=Or(ie),Ie=new pe(he);new Uint8Array(Ie.buffer,Ie.byteOffset,Ie.byteLength).set(a.HEAPU8.subarray(te,te+Ie.byteLength)),re.push([ie,Y,Ie,\"cpu\"])}}finally{a.stackRestore(we),ie===\"string\"&&te&&a._free(te),Q||a._OrtReleaseTensor(K)}}return h&&!_&&(a._OrtClearBoundOutputs(h.handle)!==0&&ce(\"Can't clear bound outputs.\"),zt.set(e,[p,m,u,h,_,!1])),re}finally{a.stackRestore(C),S.forEach(L=>a._OrtReleaseTensor(L)),T.forEach(L=>a._OrtReleaseTensor(L)),A.forEach(L=>a._free(L)),$!==0&&a._OrtReleaseRunOptions($),v.forEach(L=>a._free(L))}},kr=e=>{let t=Te(),r=zt.get(e);if(!r)throw new Error(\"invalid session id\");let n=r[0],o=t._OrtEndProfiling(n);o===0&&ce(\"Can't get an profile file name.\"),t._OrtFree(o)},Er=e=>{let t=[];for(let r of e){let n=r[2];!Array.isArray(n)&&\"buffer\"in n&&t.push(n.buffer)}return t}});var Ot,Ge,rr,dn,ln,un,Eo,Po,Wt,Lt,bg,dc,lc,cc,pc,mc,fc,hc,zo=U(()=>{\"use strict\";Le();Fn();gt();$r();Ot=()=>!!_e.wasm.proxy&&typeof document<\"u\",rr=!1,dn=!1,ln=!1,Po=new Map,Wt=(e,t)=>{let r=Po.get(e);r?r.push(t):Po.set(e,[t])},Lt=()=>{if(rr||!dn||ln||!Ge)throw new Error(\"worker not ready\")},bg=e=>{switch(e.data.type){case\"init-wasm\":rr=!1,e.data.err?(ln=!0,Eo[1](e.data.err)):(dn=!0,Eo[0]()),un&&(URL.revokeObjectURL(un),un=void 0);break;case\"init-ep\":case\"copy-from\":case\"create\":case\"release\":case\"run\":case\"end-profiling\":{let t=Po.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}default:}},dc=async()=>{if(!dn){if(rr)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(ln)throw new Error(\"previous call to 'initWasm()' failed.\");if(rr=!0,Ot())return new Promise((e,t)=>{Ge?.terminate(),Na().then(([r,n])=>{try{Ge=n,Ge.onerror=i=>t(i),Ge.onmessage=bg,Eo=[e,t];let o={type:\"init-wasm\",in:_e};!o.in.wasm.wasmPaths&&(r||\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\"))&&(o.in.wasm.wasmPaths={wasm:/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(app-pages-browser)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href}),Ge.postMessage(o),un=r}catch(o){t(o)}},t)});try{await xr(_e.wasm),await Sr(_e),dn=!0}catch(e){throw ln=!0,e}finally{rr=!1}}},lc=async e=>{if(Ot())return Lt(),new Promise((t,r)=>{Wt(\"init-ep\",[t,r]);let n={type:\"init-ep\",in:{epName:e,env:_e}};Ge.postMessage(n)});await Tr(_e,e)},cc=async e=>Ot()?(Lt(),new Promise((t,r)=>{Wt(\"copy-from\",[t,r]);let n={type:\"copy-from\",in:{buffer:e}};Ge.postMessage(n,[e.buffer])})):qt(e),pc=async(e,t)=>{if(Ot()){if(t?.preferredOutputLocation)throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');return Lt(),new Promise((r,n)=>{Wt(\"create\",[r,n]);let o={type:\"create\",in:{model:e,options:{...t}}},i=[];e instanceof Uint8Array&&i.push(e.buffer),Ge.postMessage(o,i)})}else return Ir(e,t)},mc=async e=>{if(Ot())return Lt(),new Promise((t,r)=>{Wt(\"release\",[t,r]);let n={type:\"release\",in:e};Ge.postMessage(n)});Cr(e)},fc=async(e,t,r,n,o,i)=>{if(Ot()){if(r.some(a=>a[3]!==\"cpu\"))throw new Error(\"input tensor on GPU is not supported for proxy.\");if(o.some(a=>a))throw new Error(\"pre-allocated output tensor is not supported for proxy.\");return Lt(),new Promise((a,d)=>{Wt(\"run\",[a,d]);let l=r,p={type:\"run\",in:{sessionId:e,inputIndices:t,inputs:l,outputIndices:n,options:i}};Ge.postMessage(p,Er(l))})}else return Ar(e,t,r,n,o,i)},hc=async e=>{if(Ot())return Lt(),new Promise((t,r)=>{Wt(\"end-profiling\",[t,r]);let n={type:\"end-profiling\",in:e};Ge.postMessage(n)});kr(e)}});var gc,yg,cn,bc=U(()=>{\"use strict\";Le();zo();J();vr();Qn();gc=(e,t)=>{switch(e.location){case\"cpu\":return[e.type,e.dims,e.data,\"cpu\"];case\"gpu-buffer\":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},\"gpu-buffer\"];case\"ml-tensor\":return[e.type,e.dims,{mlTensor:e.mlTensor},\"ml-tensor\"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},yg=e=>{switch(e[3]){case\"cpu\":return new Fe(e[0],e[2],e[1]);case\"gpu-buffer\":{let t=e[0];if(!Dr(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:n,dispose:o}=e[2];return Fe.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:o})}case\"ml-tensor\":{let t=e[0];if(!Br(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:n,dispose:o}=e[2];return Fe.fromMLTensor(r,{dataType:t,dims:e[1],download:n,dispose:o})}default:throw new Error(`invalid data location: ${e[3]}`)}},cn=class{async fetchModelAndCopyToWasmMemory(t){return cc(await Zt(t))}async loadModel(t,r){Ne();let n;typeof t==\"string\"? false?0:n=await this.fetchModelAndCopyToWasmMemory(t):n=t,[this.sessionId,this.inputNames,this.outputNames]=await pc(n,r),Be()}async dispose(){return mc(this.sessionId)}async run(t,r,n){Ne();let o=[],i=[];Object.entries(t).forEach(h=>{let _=h[0],y=h[1],g=this.inputNames.indexOf(_);if(g===-1)throw new Error(`invalid input '${_}'`);o.push(y),i.push(g)});let a=[],d=[];Object.entries(r).forEach(h=>{let _=h[0],y=h[1],g=this.outputNames.indexOf(_);if(g===-1)throw new Error(`invalid output '${_}'`);a.push(y),d.push(g)});let l=o.map((h,_)=>gc(h,()=>`input \"${this.inputNames[i[_]]}\"`)),p=a.map((h,_)=>h?gc(h,()=>`output \"${this.outputNames[d[_]]}\"`):null),m=await fc(this.sessionId,i,l,d,p,n),u={};for(let h=0;h<m.length;h++)u[this.outputNames[d[h]]]=a[h]??yg(m[h]);return Be(),u}startProfiling(){}endProfiling(){hc(this.sessionId)}}});var _c={};Ht(_c,{OnnxruntimeWebAssemblyBackend:()=>pn,initializeFlags:()=>yc,wasmBackend:()=>_g});var yc,pn,_g,wc=U(()=>{\"use strict\";Le();zo();bc();yc=()=>{if((typeof _e.wasm.initTimeout!=\"number\"||_e.wasm.initTimeout<0)&&(_e.wasm.initTimeout=0),_e.wasm.simd===!1&&console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof _e.wasm.proxy!=\"boolean\"&&(_e.wasm.proxy=!1),typeof _e.wasm.trace!=\"boolean\"&&(_e.wasm.trace=!1),typeof _e.wasm.numThreads!=\"number\"||!Number.isInteger(_e.wasm.numThreads)||_e.wasm.numThreads<=0)if(typeof self<\"u\"&&!self.crossOriginIsolated)_e.wasm.numThreads=1;else{let e=typeof navigator>\"u\"?Un(\"node:os\").cpus().length:navigator.hardwareConcurrency;_e.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},pn=class{async init(t){yc(),await dc(),await lc(t)}async createInferenceSessionHandler(t,r){let n=new cn;return await n.loadModel(t,r),Promise.resolve(n)}},_g=new pn});Le();Le();Le();var Ia=\"1.21.0-dev.20250206-d981b153d3\";var $1=Hn;{let e=(wc(),gr(_c)).wasmBackend;Tt(\"webgpu\",e,5),Tt(\"webnn\",e,5),Tt(\"cpu\",e,10),Tt(\"wasm\",e,10)}Object.defineProperty(_e.versions,\"web\",{value:Ia,enumerable:!0});\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n//# sourceMappingURL=ort.webgpu.bundle.min.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9vbm54cnVudGltZS13ZWJAMS4yMS4wLWRldi4yMDI1MDIwNi1kOTgxYjE1M2QzL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzP2JkODYiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QyxrQ0FBa0MsdUNBQXVDLG9FQUFvRSw2Q0FBNkMsaUJBQWlCLDJEQUEyRCwyREFBMkQsRUFBRSxtQ0FBbUMsZUFBZSx1QkFBdUIsdUJBQXVCLEVBQUUsZ0JBQWdCLGdHQUFnRyxtREFBbUQsRUFBRSxVQUFVLGtCQUFrQixlQUFlLFNBQVMsS0FBSyw2QkFBNkIsYUFBYSw4QkFBOEIscUZBQXFGLGdCQUFnQix3QkFBd0IscUJBQXFCLEVBQUUsS0FBSyx1QkFBdUIsNkVBQTZFLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxTQUFTLG9CQUFvQix1QkFBdUIsWUFBWSxZQUFZLGtDQUFrQyxpQkFBaUIsT0FBTyxXQUFXLE9BQU8sMkNBQTJDLGNBQWMsZ0JBQWdCLGlDQUFpQyxrQ0FBa0MsNkJBQTZCLHNCQUFzQixJQUFJLDJGQUEyRixTQUFTLHNCQUFzQixFQUFFLHdCQUF3QixRQUFRLHVCQUF1QixjQUFjLDRHQUE0RyxnQkFBZ0Isa0JBQWtCLDJCQUEyQixhQUFhLDZCQUE2QiwwREFBMEQsYUFBYSxPQUFPLElBQUksTUFBTSxjQUFjLEdBQUcsUUFBUSxhQUFhLDJFQUEyRSxFQUFFLHNEQUFzRCxFQUFFLEdBQUcsc0RBQXNELHNCQUFzQix1REFBdUQsSUFBSSxFQUFFLGNBQWMsYUFBYSxLQUFLLEVBQUUsaUJBQWlCLGFBQWEsb0NBQW9DLEVBQUUsb0JBQW9CLGFBQWEsS0FBSyxpQkFBaUIsT0FBTyxTQUFTLFVBQVUsV0FBVyxVQUFVLGlCQUFpQixlQUFlLGtJQUFrSSxFQUFFLEdBQUcs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Q0FBNEMsRUFBRSxJQUFJLG9CQUFvQixFQUFFLGNBQWMsOEJBQThCLGdEQUFnRCw2Q0FBNkMsRUFBRSxJQUFJLG9CQUFvQixFQUFFLHNDQUFzQyxzQkFBc0IsMENBQTBDLHVCQUF1QixvREFBb0QsWUFBWSxXQUFXLDZDQUE2QyxjQUFjLGtCQUFrQixlQUFlLHFCQUFxQixFQUFFLFVBQVUsT0FBTywrRUFBK0UsRUFBRSx1QkFBdUIsYUFBYSxLQUFLLEtBQUssS0FBSyxRQUFRLHVnQkFBdWdCLEtBQUsscUZBQXFGLG9EQUFvRCxVQUFVLGNBQWMsNEJBQTRCLHlDQUF5QyxhQUFhLGtEQUFrRCxXQUFXLEVBQUUsS0FBSyxLQUFLLEtBQUssd0NBQXdDLFdBQVcsZ0NBQWdDLGdFQUFnRSx5Q0FBeUMsdUJBQXVCLEVBQW9KO0FBQ2xoekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rbHVsZXNzL2Zsb3dlcnByZXNzL25vZGVfbW9kdWxlcy8ucG5wbS9vbm54cnVudGltZS13ZWJAMS4yMS4wLWRldi4yMDI1MDIwNi1kOTgxYjE1M2QzL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogT05OWCBSdW50aW1lIFdlYiB2MS4yMS4wLWRldi4yMDI1MDIwNi1kOTgxYjE1M2QzXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xudmFyIFJuPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgVnA9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgV3A9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIExwPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIFVuPShlPT50eXBlb2YgcmVxdWlyZTxcInVcIj9yZXF1aXJlOnR5cGVvZiBQcm94eTxcInVcIj9uZXcgUHJveHkoZSx7Z2V0Oih0LHIpPT4odHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0KVtyXX0pOmUpKGZ1bmN0aW9uKGUpe2lmKHR5cGVvZiByZXF1aXJlPFwidVwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJytlKydcIiBpcyBub3Qgc3VwcG9ydGVkJyl9KTt2YXIgVT0oZSx0KT0+KCk9PihlJiYodD1lKGU9MCkpLHQpO3ZhciBIdD0oZSx0KT0+e2Zvcih2YXIgciBpbiB0KVJuKGUscix7Z2V0OnRbcl0sZW51bWVyYWJsZTohMH0pfSxHcD0oZSx0LHIsbik9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IG8gb2YgV3AodCkpIUxwLmNhbGwoZSxvKSYmbyE9PXImJlJuKGUsbyx7Z2V0OigpPT50W29dLGVudW1lcmFibGU6IShuPVZwKHQsbykpfHxuLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIGdyPWU9PkdwKFJuKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciBicixTdCxUdCxIcCxYaSxObj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YnI9bmV3IE1hcCxTdD1bXSxUdD0oZSx0LHIpPT57aWYodCYmdHlwZW9mIHQuaW5pdD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj09XCJmdW5jdGlvblwiKXtsZXQgbj1ici5nZXQoZSk7aWYobj09PXZvaWQgMClici5zZXQoZSx7YmFja2VuZDp0LHByaW9yaXR5OnJ9KTtlbHNle2lmKG4ucHJpb3JpdHk+cilyZXR1cm47aWYobi5wcmlvcml0eT09PXImJm4uYmFja2VuZCE9PXQpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVnaXN0ZXIgYmFja2VuZCBcIiR7ZX1cIiB1c2luZyBwcmlvcml0eSAke3J9YCl9aWYocj49MCl7bGV0IG89U3QuaW5kZXhPZihlKTtvIT09LTEmJlN0LnNwbGljZShvLDEpO2ZvcihsZXQgaT0wO2k8U3QubGVuZ3RoO2krKylpZihici5nZXQoU3RbaV0pLnByaW9yaXR5PD1yKXtTdC5zcGxpY2UoaSwwLGUpO3JldHVybn1TdC5wdXNoKGUpfXJldHVybn10aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgdmFsaWQgYmFja2VuZFwiKX0sSHA9YXN5bmMgZT0+e2xldCB0PWJyLmdldChlKTtpZighdClyZXR1cm5cImJhY2tlbmQgbm90IGZvdW5kLlwiO2lmKHQuaW5pdGlhbGl6ZWQpcmV0dXJuIHQuYmFja2VuZDtpZih0LmFib3J0ZWQpcmV0dXJuIHQuZXJyb3I7e2xldCByPSEhdC5pbml0UHJvbWlzZTt0cnl7cmV0dXJuIHJ8fCh0LmluaXRQcm9taXNlPXQuYmFja2VuZC5pbml0KGUpKSxhd2FpdCB0LmluaXRQcm9taXNlLHQuaW5pdGlhbGl6ZWQ9ITAsdC5iYWNrZW5kfWNhdGNoKG4pe3JldHVybiByfHwodC5lcnJvcj1gJHtufWAsdC5hYm9ydGVkPSEwKSx0LmVycm9yfWZpbmFsbHl7ZGVsZXRlIHQuaW5pdFByb21pc2V9fX0sWGk9YXN5bmMgZT0+e2xldCB0PWUuZXhlY3V0aW9uUHJvdmlkZXJzfHxbXSxyPXQubWFwKGw9PnR5cGVvZiBsPT1cInN0cmluZ1wiP2w6bC5uYW1lKSxuPXIubGVuZ3RoPT09MD9TdDpyLG8saT1bXSxhPW5ldyBTZXQ7Zm9yKGxldCBsIG9mIG4pe2xldCBwPWF3YWl0IEhwKGwpO3R5cGVvZiBwPT1cInN0cmluZ1wiP2kucHVzaCh7bmFtZTpsLGVycjpwfSk6KG98fChvPXApLG89PT1wJiZhLmFkZChsKSl9aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2kubWFwKGw9PmBbJHtsLm5hbWV9XSAke2wuZXJyfWApLmpvaW4oXCIsIFwiKX1gKTtmb3IobGV0e25hbWU6bCxlcnI6cH1vZiBpKXIuaW5jbHVkZXMobCkmJmNvbnNvbGUud2FybihgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bH1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7cH1gKTtsZXQgZD10LmZpbHRlcihsPT5hLmhhcyh0eXBlb2YgbD09XCJzdHJpbmdcIj9sOmwubmFtZSkpO3JldHVybltvLG5ldyBQcm94eShlLHtnZXQ6KGwscCk9PnA9PT1cImV4ZWN1dGlvblByb3ZpZGVyc1wiP2Q6UmVmbGVjdC5nZXQobCxwKX0pXX19KTt2YXIgSmk9VSgoKT0+e1widXNlIHN0cmljdFwiO05uKCl9KTt2YXIgZWEsdGE9VSgoKT0+e1widXNlIHN0cmljdFwiO2VhPVwiMS4yMS4wLWRldi4yMDI1MDIwNi1kOTgxYjE1M2QzXCJ9KTt2YXIgcmEsVWUsVm49VSgoKT0+e1widXNlIHN0cmljdFwiO3RhKCk7cmE9XCJ3YXJuaW5nXCIsVWU9e3dhc206e30sd2ViZ2w6e30sd2ViZ3B1Ont9LHZlcnNpb25zOntjb21tb246ZWF9LHNldCBsb2dMZXZlbChlKXtpZihlIT09dm9pZCAwKXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcInx8W1widmVyYm9zZVwiLFwiaW5mb1wiLFwid2FybmluZ1wiLFwiZXJyb3JcIixcImZhdGFsXCJdLmluZGV4T2YoZSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKTtyYT1lfX0sZ2V0IGxvZ0xldmVsKCl7cmV0dXJuIHJhfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KFVlLFwibG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMH0pfSk7dmFyIF9lLG5hPVUoKCk9PntcInVzZSBzdHJpY3RcIjtWbigpO19lPVVlfSk7dmFyIG9hLGlhLGFhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtvYT0oZSx0KT0+e2xldCByPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKTtyLndpZHRoPWUuZGltc1szXSxyLmhlaWdodD1lLmRpbXNbMl07bGV0IG49ci5nZXRDb250ZXh0KFwiMmRcIik7aWYobiE9bnVsbCl7bGV0IG8saTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGk9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10saT1lLmRpbXNbMl0pO2xldCBhPXQ/LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGQ9dD8ubm9ybSxsLHA7ZD09PXZvaWQgMHx8ZC5tZWFuPT09dm9pZCAwP2w9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGQubWVhbj09XCJudW1iZXJcIj9sPVtkLm1lYW4sZC5tZWFuLGQubWVhbixkLm1lYW5dOihsPVtkLm1lYW5bMF0sZC5tZWFuWzFdLGQubWVhblsyXSwwXSxkLm1lYW5bM10hPT12b2lkIDAmJihsWzNdPWQubWVhblszXSkpLGQ9PT12b2lkIDB8fGQuYmlhcz09PXZvaWQgMD9wPVswLDAsMCwwXTp0eXBlb2YgZC5iaWFzPT1cIm51bWJlclwiP3A9W2QuYmlhcyxkLmJpYXMsZC5iaWFzLGQuYmlhc106KHA9W2QuYmlhc1swXSxkLmJpYXNbMV0sZC5iaWFzWzJdLDBdLGQuYmlhc1szXSE9PXZvaWQgMCYmKHBbM109ZC5iaWFzWzNdKSk7bGV0IG09aSpvLHU9MCxoPW0sXz1tKjIseT0tMTthPT09XCJSR0JBXCI/KHU9MCxoPW0sXz1tKjIseT1tKjMpOmE9PT1cIlJHQlwiPyh1PTAsaD1tLF89bSoyKTphPT09XCJSQkdcIiYmKHU9MCxfPW0saD1tKjIpO2ZvcihsZXQgZz0wO2c8aTtnKyspZm9yKGxldCB4PTA7eDxvO3grKyl7bGV0ICQ9KGUuZGF0YVt1KytdLXBbMF0pKmxbMF0sdj0oZS5kYXRhW2grK10tcFsxXSkqbFsxXSxTPShlLmRhdGFbXysrXS1wWzJdKSpsWzJdLFQ9eT09PS0xPzI1NTooZS5kYXRhW3krK10tcFszXSkqbFszXTtuLmZpbGxTdHlsZT1cInJnYmEoXCIrJCtcIixcIit2K1wiLFwiK1MrXCIsXCIrVCtcIilcIixuLmZpbGxSZWN0KHgsZywxLDEpfWlmKFwidG9EYXRhVVJMXCJpbiByKXJldHVybiByLnRvRGF0YVVSTCgpO3Rocm93IG5ldyBFcnJvcihcInRvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkXCIpfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX0saWE9KGUsdCk9PntsZXQgcj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik6bmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpLmdldENvbnRleHQoXCIyZFwiKSxuO2lmKHIhPW51bGwpe2xldCBvLGksYTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGk9ZS5kaW1zWzFdLGE9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10saT1lLmRpbXNbMl0sYT1lLmRpbXNbMV0pO2xldCBkPXQhPT12b2lkIDAmJnQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsbD10Py5ub3JtLHAsbTtsPT09dm9pZCAwfHxsLm1lYW49PT12b2lkIDA/cD1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2YgbC5tZWFuPT1cIm51bWJlclwiP3A9W2wubWVhbixsLm1lYW4sbC5tZWFuLGwubWVhbl06KHA9W2wubWVhblswXSxsLm1lYW5bMV0sbC5tZWFuWzJdLDI1NV0sbC5tZWFuWzNdIT09dm9pZCAwJiYocFszXT1sLm1lYW5bM10pKSxsPT09dm9pZCAwfHxsLmJpYXM9PT12b2lkIDA/bT1bMCwwLDAsMF06dHlwZW9mIGwuYmlhcz09XCJudW1iZXJcIj9tPVtsLmJpYXMsbC5iaWFzLGwuYmlhcyxsLmJpYXNdOihtPVtsLmJpYXNbMF0sbC5iaWFzWzFdLGwuYmlhc1syXSwwXSxsLmJpYXNbM10hPT12b2lkIDAmJihtWzNdPWwuYmlhc1szXSkpO2xldCB1PWkqbztpZih0IT09dm9pZCAwJiYodC5mb3JtYXQhPT12b2lkIDAmJmE9PT00JiZ0LmZvcm1hdCE9PVwiUkdCQVwifHxhPT09MyYmdC5mb3JtYXQhPT1cIlJHQlwiJiZ0LmZvcm1hdCE9PVwiQkdSXCIpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtsZXQgaD00LF89MCx5PTEsZz0yLHg9MywkPTAsdj11LFM9dSoyLFQ9LTE7ZD09PVwiUkdCQVwiPygkPTAsdj11LFM9dSoyLFQ9dSozKTpkPT09XCJSR0JcIj8oJD0wLHY9dSxTPXUqMik6ZD09PVwiUkJHXCImJigkPTAsUz11LHY9dSoyKSxuPXIuY3JlYXRlSW1hZ2VEYXRhKG8saSk7Zm9yKGxldCBBPTA7QTxpKm87Xys9aCx5Kz1oLGcrPWgseCs9aCxBKyspbi5kYXRhW19dPShlLmRhdGFbJCsrXS1tWzBdKSpwWzBdLG4uZGF0YVt5XT0oZS5kYXRhW3YrK10tbVsxXSkqcFsxXSxuLmRhdGFbZ109KGUuZGF0YVtTKytdLW1bMl0pKnBbMl0sbi5kYXRhW3hdPVQ9PT0tMT8yNTU6KGUuZGF0YVtUKytdLW1bM10pKnBbM119ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3JldHVybiBufX0pO3ZhciBXbixzYSx1YSxkYSxsYSxjYSxwYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eXIoKTtXbj0oZSx0KT0+e2lmKGU9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LmhlaWdodD09PXZvaWQgMHx8dC53aWR0aD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihcIk5IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtsZXR7aGVpZ2h0OnIsd2lkdGg6bn09dCxvPXQubm9ybT8/e21lYW46MjU1LGJpYXM6MH0saSxhO3R5cGVvZiBvLm1lYW49PVwibnVtYmVyXCI/aT1bby5tZWFuLG8ubWVhbixvLm1lYW4sby5tZWFuXTppPVtvLm1lYW5bMF0sby5tZWFuWzFdLG8ubWVhblsyXSxvLm1lYW5bM10/PzI1NV0sdHlwZW9mIG8uYmlhcz09XCJudW1iZXJcIj9hPVtvLmJpYXMsby5iaWFzLG8uYmlhcyxvLmJpYXNdOmE9W28uYmlhc1swXSxvLmJpYXNbMV0sby5iaWFzWzJdLG8uYmlhc1szXT8/MF07bGV0IGQ9dC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JBXCIsbD10LnRlbnNvckZvcm1hdCE9PXZvaWQgMCYmdC50ZW5zb3JGb3JtYXQhPT12b2lkIDA/dC50ZW5zb3JGb3JtYXQ6XCJSR0JcIixwPXIqbixtPWw9PT1cIlJHQkFcIj9uZXcgRmxvYXQzMkFycmF5KHAqNCk6bmV3IEZsb2F0MzJBcnJheShwKjMpLHU9NCxoPTAsXz0xLHk9MixnPTMseD0wLCQ9cCx2PXAqMixTPS0xO2Q9PT1cIlJHQlwiJiYodT0zLGg9MCxfPTEseT0yLGc9LTEpLGw9PT1cIlJHQkFcIj9TPXAqMzpsPT09XCJSQkdcIj8oeD0wLHY9cCwkPXAqMik6bD09PVwiQkdSXCImJih2PTAsJD1wLHg9cCoyKTtmb3IobGV0IEE9MDtBPHA7QSsrLGgrPXUseSs9dSxfKz11LGcrPXUpbVt4KytdPShlW2hdK2FbMF0pL2lbMF0sbVskKytdPShlW19dK2FbMV0pL2lbMV0sbVt2KytdPShlW3ldK2FbMl0pL2lbMl0sUyE9PS0xJiZnIT09LTEmJihtW1MrK109KGVbZ10rYVszXSkvaVszXSk7cmV0dXJuIGw9PT1cIlJHQkFcIj9uZXcgemUoXCJmbG9hdDMyXCIsbSxbMSw0LHIsbl0pOm5ldyB6ZShcImZsb2F0MzJcIixtLFsxLDMscixuXSl9LHNhPWFzeW5jKGUsdCk9PntsZXQgcj10eXBlb2YgSFRNTEltYWdlRWxlbWVudDxcInVcIiYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsbj10eXBlb2YgSW1hZ2VEYXRhPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VEYXRhLG89dHlwZW9mIEltYWdlQml0bWFwPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAsaT10eXBlb2YgZT09XCJzdHJpbmdcIixhLGQ9dD8/e30sbD0oKT0+e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIilyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtpZih0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzPFwidVwiKXJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7dGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWRcIil9LHA9bT0+dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PFwidVwiJiZtIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fG0gaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXM/bS5nZXRDb250ZXh0KFwiMmRcIik6bnVsbDtpZihyKXtsZXQgbT1sKCk7bS53aWR0aD1lLndpZHRoLG0uaGVpZ2h0PWUuaGVpZ2h0O2xldCB1PXAobSk7aWYodSE9bnVsbCl7bGV0IGg9ZS5oZWlnaHQsXz1lLndpZHRoO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJihoPXQucmVzaXplZEhlaWdodCxfPXQucmVzaXplZFdpZHRoKSx0IT09dm9pZCAwKXtpZihkPXQsdC50ZW5zb3JGb3JtYXQhPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnRcIik7ZC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9aCxkLndpZHRoPV99ZWxzZSBkLnRlbnNvckZvcm1hdD1cIlJHQkFcIixkLmhlaWdodD1oLGQud2lkdGg9Xzt1LmRyYXdJbWFnZShlLDAsMCksYT11LmdldEltYWdlRGF0YSgwLDAsXyxoKS5kYXRhfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIGlmKG4pe2xldCBtLHU7aWYodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMD8obT10LnJlc2l6ZWRIZWlnaHQsdT10LnJlc2l6ZWRXaWR0aCk6KG09ZS5oZWlnaHQsdT1lLndpZHRoKSx0IT09dm9pZCAwJiYoZD10KSxkLmZvcm1hdD1cIlJHQkFcIixkLmhlaWdodD1tLGQud2lkdGg9dSx0IT09dm9pZCAwKXtsZXQgaD1sKCk7aC53aWR0aD11LGguaGVpZ2h0PW07bGV0IF89cChoKTtpZihfIT1udWxsKV8ucHV0SW1hZ2VEYXRhKGUsMCwwKSxhPV8uZ2V0SW1hZ2VEYXRhKDAsMCx1LG0pLmRhdGE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2UgYT1lLmRhdGF9ZWxzZSBpZihvKXtpZih0PT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXBcIik7bGV0IG09bCgpO20ud2lkdGg9ZS53aWR0aCxtLmhlaWdodD1lLmhlaWdodDtsZXQgdT1wKG0pO2lmKHUhPW51bGwpe2xldCBoPWUuaGVpZ2h0LF89ZS53aWR0aDtyZXR1cm4gdS5kcmF3SW1hZ2UoZSwwLDAsXyxoKSxhPXUuZ2V0SW1hZ2VEYXRhKDAsMCxfLGgpLmRhdGEsZC5oZWlnaHQ9aCxkLndpZHRoPV8sV24oYSxkKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZXtpZihpKXJldHVybiBuZXcgUHJvbWlzZSgobSx1KT0+e2xldCBoPWwoKSxfPXAoaCk7aWYoIWV8fCFfKXJldHVybiB1KCk7bGV0IHk9bmV3IEltYWdlO3kuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIix5LnNyYz1lLHkub25sb2FkPSgpPT57aC53aWR0aD15LndpZHRoLGguaGVpZ2h0PXkuaGVpZ2h0LF8uZHJhd0ltYWdlKHksMCwwLGgud2lkdGgsaC5oZWlnaHQpO2xldCBnPV8uZ2V0SW1hZ2VEYXRhKDAsMCxoLndpZHRoLGguaGVpZ2h0KTtkLmhlaWdodD1oLmhlaWdodCxkLndpZHRoPWgud2lkdGgsbShXbihnLmRhdGEsZCkpfX0pO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfWlmKGEhPT12b2lkIDApcmV0dXJuIFduKGEsZCk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9LHVhPShlLHQpPT57bGV0e3dpZHRoOnIsaGVpZ2h0Om4sZG93bmxvYWQ6byxkaXNwb3NlOml9PXQsYT1bMSxuLHIsNF07cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdHlwZTpcImZsb2F0MzJcIix0ZXh0dXJlOmUsZGltczphLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LGRhPShlLHQpPT57bGV0e2RhdGFUeXBlOnIsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfT10O3JldHVybiBuZXcgemUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLHR5cGU6cj8/XCJmbG9hdDMyXCIsZ3B1QnVmZmVyOmUsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LGxhPShlLHQpPT57bGV0e2RhdGFUeXBlOnIsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfT10O3JldHVybiBuZXcgemUoe2xvY2F0aW9uOlwibWwtdGVuc29yXCIsdHlwZTpyPz9cImZsb2F0MzJcIixtbFRlbnNvcjplLGRpbXM6bixkb3dubG9hZDpvLGRpc3Bvc2U6aX0pfSxjYT0oZSx0LHIpPT5uZXcgemUoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLHR5cGU6ZSxkYXRhOnQsZGltczpyPz9bdC5sZW5ndGhdfSl9KTt2YXIgSXQsRnQsbWEsZmEsaGE9VSgoKT0+e1widXNlIHN0cmljdFwiO0l0PW5ldyBNYXAoW1tcImZsb2F0MzJcIixGbG9hdDMyQXJyYXldLFtcInVpbnQ4XCIsVWludDhBcnJheV0sW1wiaW50OFwiLEludDhBcnJheV0sW1widWludDE2XCIsVWludDE2QXJyYXldLFtcImludDE2XCIsSW50MTZBcnJheV0sW1wiaW50MzJcIixJbnQzMkFycmF5XSxbXCJib29sXCIsVWludDhBcnJheV0sW1wiZmxvYXQ2NFwiLEZsb2F0NjRBcnJheV0sW1widWludDMyXCIsVWludDMyQXJyYXldLFtcImludDRcIixVaW50OEFycmF5XSxbXCJ1aW50NFwiLFVpbnQ4QXJyYXldXSksRnQ9bmV3IE1hcChbW0Zsb2F0MzJBcnJheSxcImZsb2F0MzJcIl0sW1VpbnQ4QXJyYXksXCJ1aW50OFwiXSxbSW50OEFycmF5LFwiaW50OFwiXSxbVWludDE2QXJyYXksXCJ1aW50MTZcIl0sW0ludDE2QXJyYXksXCJpbnQxNlwiXSxbSW50MzJBcnJheSxcImludDMyXCJdLFtGbG9hdDY0QXJyYXksXCJmbG9hdDY0XCJdLFtVaW50MzJBcnJheSxcInVpbnQzMlwiXV0pLG1hPSExLGZhPSgpPT57aWYoIW1hKXttYT0hMDtsZXQgZT10eXBlb2YgQmlnSW50NjRBcnJheTxcInVcIiYmQmlnSW50NjRBcnJheS5mcm9tLHQ9dHlwZW9mIEJpZ1VpbnQ2NEFycmF5PFwidVwiJiZCaWdVaW50NjRBcnJheS5mcm9tLHI9dHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb207ZSYmKEl0LnNldChcImludDY0XCIsQmlnSW50NjRBcnJheSksRnQuc2V0KEJpZ0ludDY0QXJyYXksXCJpbnQ2NFwiKSksdCYmKEl0LnNldChcInVpbnQ2NFwiLEJpZ1VpbnQ2NEFycmF5KSxGdC5zZXQoQmlnVWludDY0QXJyYXksXCJ1aW50NjRcIikpLHI/KEl0LnNldChcImZsb2F0MTZcIixGbG9hdDE2QXJyYXkpLEZ0LnNldChGbG9hdDE2QXJyYXksXCJmbG9hdDE2XCIpKTpJdC5zZXQoXCJmbG9hdDE2XCIsVWludDE2QXJyYXkpfX19KTt2YXIgZ2EsYmEseWE9VSgoKT0+e1widXNlIHN0cmljdFwiO3lyKCk7Z2E9ZT0+e2xldCB0PTE7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2xldCBuPWVbcl07aWYodHlwZW9mIG4hPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke259YCk7aWYobjwwKXRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke259YCk7dCo9bn1yZXR1cm4gdH0sYmE9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyB6ZShlLnR5cGUsZS5kYXRhLHQpO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIixkYXRhOmUuZGF0YSx0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdGV4dHVyZTplLnRleHR1cmUsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiBuZXcgemUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLGdwdUJ1ZmZlcjplLmdwdUJ1ZmZlcix0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcIm1sLXRlbnNvclwiLG1sVGVuc29yOmUubWxUZW5zb3IsdHlwZTplLnR5cGUsZGltczp0fSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHRlbnNvclJlc2hhcGU6IHRlbnNvciBsb2NhdGlvbiAke2UubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKX19fSk7dmFyIHplLHlyPVUoKCk9PntcInVzZSBzdHJpY3RcIjthYSgpO3BhKCk7aGEoKTt5YSgpO3plPWNsYXNze2NvbnN0cnVjdG9yKHQscixuKXtmYSgpO2xldCBvLGk7aWYodHlwZW9mIHQ9PVwib2JqZWN0XCImJlwibG9jYXRpb25cImluIHQpc3dpdGNoKHRoaXMuZGF0YUxvY2F0aW9uPXQubG9jYXRpb24sbz10LnR5cGUsaT10LmRpbXMsdC5sb2NhdGlvbil7Y2FzZVwiY3B1LXBpbm5lZFwiOntsZXQgZD1JdC5nZXQobyk7aWYoIWQpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO2lmKCEodC5kYXRhIGluc3RhbmNlb2YgZCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgYnVmZmVyIHNob3VsZCBiZSBvZiB0eXBlICR7ZC5uYW1lfWApO3RoaXMuY3B1RGF0YT10LmRhdGE7YnJlYWt9Y2FzZVwidGV4dHVyZVwiOntpZihvIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gdGV4dHVyZWApO3RoaXMuZ3B1VGV4dHVyZURhdGE9dC50ZXh0dXJlLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcImdwdS1idWZmZXJcIjp7aWYobyE9PVwiZmxvYXQzMlwiJiZvIT09XCJmbG9hdDE2XCImJm8hPT1cImludDMyXCImJm8hPT1cImludDY0XCImJm8hPT1cInVpbnQzMlwiJiZvIT09XCJ1aW50OFwiJiZvIT09XCJib29sXCImJm8hPT1cInVpbnQ0XCImJm8hPT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7dGhpcy5ncHVCdWZmZXJEYXRhPXQuZ3B1QnVmZmVyLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcIm1sLXRlbnNvclwiOntpZihvIT09XCJmbG9hdDMyXCImJm8hPT1cImZsb2F0MTZcIiYmbyE9PVwiaW50MzJcIiYmbyE9PVwiaW50NjRcIiYmbyE9PVwidWludDMyXCImJm8hPT1cInVpbnQ2NFwiJiZvIT09XCJpbnQ4XCImJm8hPT1cInVpbnQ4XCImJm8hPT1cImJvb2xcIiYmbyE9PVwidWludDRcIiYmbyE9PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIE1MVGVuc29yYCk7dGhpcy5tbFRlbnNvckRhdGE9dC5tbFRlbnNvcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCl9ZWxzZXtsZXQgZCxsO2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKWlmKG89dCxsPW4sdD09PVwic3RyaW5nXCIpe2lmKCFBcnJheS5pc0FycmF5KHIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO2Q9cn1lbHNle2xldCBwPUl0LmdldCh0KTtpZihwPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke3R9LmApO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHQ9PT1cImZsb2F0MTZcIiYmcD09PVVpbnQxNkFycmF5fHx0PT09XCJ1aW50NFwifHx0PT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ3JlYXRpbmcgYSAke3R9IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlICR7cC5uYW1lfSBhcyBkYXRhLmApO3Q9PT1cInVpbnQ2NFwifHx0PT09XCJpbnQ2NFwiP2Q9cC5mcm9tKHIsQmlnSW50KTpkPXAuZnJvbShyKX1lbHNlIGlmKHIgaW5zdGFuY2VvZiBwKWQ9cjtlbHNlIGlmKHIgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSlpZih0PT09XCJ1aW50OFwiKWQ9VWludDhBcnJheS5mcm9tKHIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgVWludDhDbGFtcGVkQXJyYXkgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgdWludDhcIik7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7b30gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHtwfWApfWVsc2UgaWYobD1yLEFycmF5LmlzQXJyYXkodCkpe2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuXCIpO2xldCBwPXR5cGVvZiB0WzBdO2lmKHA9PT1cInN0cmluZ1wiKW89XCJzdHJpbmdcIixkPXQ7ZWxzZSBpZihwPT09XCJib29sZWFuXCIpbz1cImJvb2xcIixkPVVpbnQ4QXJyYXkuZnJvbSh0KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7cH0uYCl9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpbz1cInVpbnQ4XCIsZD1VaW50OEFycmF5LmZyb20odCk7ZWxzZXtsZXQgcD1GdC5nZXQodC5jb25zdHJ1Y3Rvcik7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHt0LmNvbnN0cnVjdG9yfS5gKTtvPXAsZD10fWlmKGw9PT12b2lkIDApbD1bZC5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkobCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO2k9bCx0aGlzLmNwdURhdGE9ZCx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwifWxldCBhPWdhKGkpO2lmKHRoaXMuY3B1RGF0YSYmYSE9PXRoaXMuY3B1RGF0YS5sZW5ndGgmJiEoKG89PT1cInVpbnQ0XCJ8fG89PT1cImludDRcIikmJk1hdGguY2VpbChhLzIpPT09dGhpcy5jcHVEYXRhLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7YX0pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO3RoaXMudHlwZT1vLHRoaXMuZGltcz1pLHRoaXMuc2l6ZT1hfXN0YXRpYyBhc3luYyBmcm9tSW1hZ2UodCxyKXtyZXR1cm4gc2EodCxyKX1zdGF0aWMgZnJvbVRleHR1cmUodCxyKXtyZXR1cm4gdWEodCxyKX1zdGF0aWMgZnJvbUdwdUJ1ZmZlcih0LHIpe3JldHVybiBkYSh0LHIpfXN0YXRpYyBmcm9tTUxUZW5zb3IodCxyKXtyZXR1cm4gbGEodCxyKX1zdGF0aWMgZnJvbVBpbm5lZEJ1ZmZlcih0LHIsbil7cmV0dXJuIGNhKHQscixuKX10b0RhdGFVUkwodCl7cmV0dXJuIG9hKHRoaXMsdCl9dG9JbWFnZURhdGEodCl7cmV0dXJuIGlhKHRoaXMsdCl9Z2V0IGRhdGEoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuY3B1RGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCBvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuXCIpO3JldHVybiB0aGlzLmNwdURhdGF9Z2V0IGxvY2F0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9ufWdldCB0ZXh0dXJlKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdVRleHR1cmVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLlwiKTtyZXR1cm4gdGhpcy5ncHVUZXh0dXJlRGF0YX1nZXQgZ3B1QnVmZmVyKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdUJ1ZmZlckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuXCIpO3JldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGF9Z2V0IG1sVGVuc29yKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLm1sVGVuc29yRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViTk4gTUxUZW5zb3IuXCIpO3JldHVybiB0aGlzLm1sVGVuc29yRGF0YX1hc3luYyBnZXREYXRhKHQpe3N3aXRjaCh0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kYXRhTG9jYXRpb24pe2Nhc2VcImNwdVwiOmNhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gdGhpcy5kYXRhO2Nhc2VcInRleHR1cmVcIjpjYXNlXCJncHUtYnVmZmVyXCI6Y2FzZVwibWwtdGVuc29yXCI6e2lmKCF0aGlzLmRvd25sb2FkZXIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLlwiKTtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RyeXt0aGlzLmlzRG93bmxvYWRpbmc9ITA7bGV0IHI9YXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7cmV0dXJuIHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIix0aGlzLmNwdURhdGE9cix0JiZ0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSxyfWZpbmFsbHl7dGhpcy5pc0Rvd25sb2FkaW5nPSExfX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCl9fWRpc3Bvc2UoKXtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLHRoaXMuY3B1RGF0YT12b2lkIDAsdGhpcy5ncHVUZXh0dXJlRGF0YT12b2lkIDAsdGhpcy5ncHVCdWZmZXJEYXRhPXZvaWQgMCx0aGlzLm1sVGVuc29yRGF0YT12b2lkIDAsdGhpcy5kb3dubG9hZGVyPXZvaWQgMCx0aGlzLmlzRG93bmxvYWRpbmc9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwibm9uZVwifWVuc3VyZVZhbGlkKCl7aWYodGhpcy5kYXRhTG9jYXRpb249PT1cIm5vbmVcIil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVuc29yIGlzIGRpc3Bvc2VkLlwiKX1yZXNoYXBlKHQpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSx0aGlzLmRvd25sb2FkZXJ8fHRoaXMuZGlzcG9zZXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc2hhcGUgYSB0ZW5zb3IgdGhhdCBvd25zIEdQVSByZXNvdXJjZS5cIik7cmV0dXJuIGJhKHRoaXMsdCl9fX0pO3ZhciBGZSxMbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eXIoKTtGZT16ZX0pO3ZhciBfcixfYSxOZSxCZSxHbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Vm4oKTtfcj0oZSx0KT0+eyh0eXBlb2YgVWUudHJhY2U+XCJ1XCI/IVVlLndhc20udHJhY2U6IVVlLnRyYWNlKXx8Y29uc29sZS50aW1lU3RhbXAoYCR7ZX06Ok9SVDo6JHt0fWApfSxfYT0oZSx0KT0+e2xldCByPW5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZyl8fFtdLG49ITE7Zm9yKGxldCBvPTA7bzxyLmxlbmd0aDtvKyspe2lmKG4mJiFyW29dLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSl7bGV0IGk9YEZVTkNfJHtlfTo6JHtyW29dLnRyaW0oKS5zcGxpdChcIiBcIilbMV19YDt0JiYoaSs9YDo6JHt0fWApLF9yKFwiQ1BVXCIsaSk7cmV0dXJufXJbb10uaW5jbHVkZXMoXCJUUkFDRV9GVU5DXCIpJiYobj0hMCl9fSxOZT1lPT57KHR5cGVvZiBVZS50cmFjZT5cInVcIj8hVWUud2FzbS50cmFjZTohVWUudHJhY2UpfHxfYShcIkJFR0lOXCIsZSl9LEJlPWU9PnsodHlwZW9mIFVlLnRyYWNlPlwidVwiPyFVZS53YXNtLnRyYWNlOiFVZS50cmFjZSl8fF9hKFwiRU5EXCIsZSl9fSk7dmFyIHdyLHdhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtObigpO0xuKCk7R24oKTt3cj1jbGFzcyBle2NvbnN0cnVjdG9yKHQpe3RoaXMuaGFuZGxlcj10fWFzeW5jIHJ1bih0LHIsbil7TmUoKTtsZXQgbz17fSxpPXt9O2lmKHR5cGVvZiB0IT1cIm9iamVjdFwifHx0PT09bnVsbHx8dCBpbnN0YW5jZW9mIEZlfHxBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmVlZHMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cIik7bGV0IGE9ITA7aWYodHlwZW9mIHI9PVwib2JqZWN0XCIpe2lmKHI9PT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC5cIik7aWYociBpbnN0YW5jZW9mIEZlKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHIubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7YT0hMTtmb3IobGV0IHAgb2Ygcil7aWYodHlwZW9mIHAhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7aWYodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKHApPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke3B9LmApO29bcF09bnVsbH1pZih0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpaT1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZXtsZXQgcD0hMSxtPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIpO2ZvcihsZXQgdSBvZiB0aGlzLm91dHB1dE5hbWVzKWlmKG0uaW5kZXhPZih1KSE9PS0xKXtsZXQgaD1yW3VdOyhoPT09bnVsbHx8aCBpbnN0YW5jZW9mIEZlKSYmKHA9ITAsYT0hMSxvW3VdPWgpfWlmKHApe2lmKHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbClpPW47ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGk9cn19ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtmb3IobGV0IHAgb2YgdGhpcy5pbnB1dE5hbWVzKWlmKHR5cGVvZiB0W3BdPlwidVwiKXRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7cH0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtpZihhKWZvcihsZXQgcCBvZiB0aGlzLm91dHB1dE5hbWVzKW9bcF09bnVsbDtsZXQgZD1hd2FpdCB0aGlzLmhhbmRsZXIucnVuKHQsbyxpKSxsPXt9O2ZvcihsZXQgcCBpbiBkKWlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQscCkpe2xldCBtPWRbcF07bSBpbnN0YW5jZW9mIEZlP2xbcF09bTpsW3BdPW5ldyBGZShtLnR5cGUsbS5kYXRhLG0uZGltcyl9cmV0dXJuIEJlKCksbH1hc3luYyByZWxlYXNlKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCl9c3RhdGljIGFzeW5jIGNyZWF0ZSh0LHIsbixvKXtOZSgpO2xldCBpLGE9e307aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpe2lmKGk9dCx0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSl7aWYoaT10LHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClhPXI7ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPFwidVwiJiZ0IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpe2xldCBtPXQsdT0wLGg9dC5ieXRlTGVuZ3RoO2lmKHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClhPXI7ZWxzZSBpZih0eXBlb2Ygcj09XCJudW1iZXJcIil7aWYodT1yLCFOdW1iZXIuaXNTYWZlSW50ZWdlcih1KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlT2Zmc2V0JyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKHU8MHx8dT49bS5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke20uYnl0ZUxlbmd0aH0pLmApO2lmKGg9dC5ieXRlTGVuZ3RoLXUsdHlwZW9mIG49PVwibnVtYmVyXCIpe2lmKGg9biwhTnVtYmVyLmlzU2FmZUludGVnZXIoaCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZihoPD0wfHx1K2g+bS5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke20uYnl0ZUxlbmd0aC11fV0uYCk7aWYodHlwZW9mIG89PVwib2JqZWN0XCImJm8hPT1udWxsKWE9bztlbHNlIGlmKHR5cGVvZiBvPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO2k9bmV3IFVpbnQ4QXJyYXkobSx1LGgpfWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMF06IG11c3QgYmUgJ3BhdGgnIG9yICdidWZmZXInLlwiKTtsZXRbZCxsXT1hd2FpdCBYaShhKSxwPWF3YWl0IGQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoaSxsKTtyZXR1cm4gQmUoKSxuZXcgZShwKX1zdGFydFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpfWVuZFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKX1nZXQgaW5wdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lc31nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzfX19KTt2YXIgRnAsdmE9VSgoKT0+e1widXNlIHN0cmljdFwiO3dhKCk7RnA9d3J9KTt2YXIgJGE9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIHhhPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBTYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgVGE9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIEhuPXt9O0h0KEhuLHtJbmZlcmVuY2VTZXNzaW9uOigpPT5GcCxUUkFDRTooKT0+X3IsVFJBQ0VfRlVOQ19CRUdJTjooKT0+TmUsVFJBQ0VfRlVOQ19FTkQ6KCk9PkJlLFRlbnNvcjooKT0+RmUsZW52OigpPT5fZSxyZWdpc3RlckJhY2tlbmQ6KCk9PlR0fSk7dmFyIExlPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKaSgpO25hKCk7dmEoKTtMbigpOyRhKCk7eGEoKTtHbigpO1NhKCk7VGEoKX0pO3ZhciB2cj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIga2E9e307SHQoa2Ese2RlZmF1bHQ6KCk9PnFwfSk7dmFyIENhLEFhLHFwLEVhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtGbigpO2d0KCk7JHIoKTtDYT1cIm9ydC13YXNtLXByb3h5LXdvcmtlclwiLEFhPWdsb2JhbFRoaXMuc2VsZj8ubmFtZT09PUNhO0FhJiYoc2VsZi5vbm1lc3NhZ2U9ZT0+e2xldHt0eXBlOnQsaW46cn09ZS5kYXRhO3RyeXtzd2l0Y2godCl7Y2FzZVwiaW5pdC13YXNtXCI6eHIoci53YXNtKS50aGVuKCgpPT57U3IocikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0sbj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOm59KX0pfSxuPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bn0pfSk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOntsZXR7ZXBOYW1lOm4sZW52Om99PXI7VHIobyxuKS50aGVuKCgpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dH0pfSxpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6aX0pfSk7YnJlYWt9Y2FzZVwiY29weS1mcm9tXCI6e2xldHtidWZmZXI6bn09cixvPXF0KG4pO3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0Om99KTticmVha31jYXNlXCJjcmVhdGVcIjp7bGV0e21vZGVsOm4sb3B0aW9uczpvfT1yO0lyKG4sbykudGhlbihpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6aX0pfSxpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6aX0pfSk7YnJlYWt9Y2FzZVwicmVsZWFzZVwiOkNyKHIpLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztjYXNlXCJydW5cIjp7bGV0e3Nlc3Npb25JZDpuLGlucHV0SW5kaWNlczpvLGlucHV0czppLG91dHB1dEluZGljZXM6YSxvcHRpb25zOmR9PXI7QXIobixvLGksYSxuZXcgQXJyYXkoYS5sZW5ndGgpLmZpbGwobnVsbCksZCkudGhlbihsPT57bC5zb21lKHA9PnBbM10hPT1cImNwdVwiKT9wb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpcIlByb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uXCJ9KTpwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDpsfSxFcihbLi4uaSwuLi5sXSkpfSxsPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bH0pfSk7YnJlYWt9Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOmtyKHIpLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztkZWZhdWx0On19Y2F0Y2gobil7cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bn0pfX0pO3FwPUFhP251bGw6ZT0+bmV3IFdvcmtlcihlPz9WZSx7dHlwZTpcIm1vZHVsZVwiLG5hbWU6Q2F9KX0pO3ZhciB6YT17fTtIdCh6YSx7ZGVmYXVsdDooKT0+S3B9KTt2YXIgcW4sUGEsS3AsT2E9VSgoKT0+e1widXNlIHN0cmljdFwiO1BhPShxbj1pbXBvcnQubWV0YS51cmwsYXN5bmMgZnVuY3Rpb24oZT17fSl7ZnVuY3Rpb24gdCgpe3JldHVybiBLLmJ1ZmZlciE9US5idWZmZXImJnBlKCksUX1mdW5jdGlvbiByKCl7cmV0dXJuIEsuYnVmZmVyIT1RLmJ1ZmZlciYmcGUoKSxpZX1mdW5jdGlvbiBuKCl7cmV0dXJuIEsuYnVmZmVyIT1RLmJ1ZmZlciYmcGUoKSx0ZX1mdW5jdGlvbiBvKCl7cmV0dXJuIEsuYnVmZmVyIT1RLmJ1ZmZlciYmcGUoKSxiZX1mdW5jdGlvbiBpKCl7cmV0dXJuIEsuYnVmZmVyIT1RLmJ1ZmZlciYmcGUoKSxPZX1mdW5jdGlvbiBhKCl7cmV0dXJuIEsuYnVmZmVyIT1RLmJ1ZmZlciYmcGUoKSx2ZX1mdW5jdGlvbiBkKCl7cmV0dXJuIEsuYnVmZmVyIT1RLmJ1ZmZlciYmcGUoKSxkZX1mdW5jdGlvbiBsKCl7cmV0dXJuIEsuYnVmZmVyIT1RLmJ1ZmZlciYmcGUoKSxoZX12YXIgcCxtLHU9T2JqZWN0LmFzc2lnbih7fSxlKSxoPW5ldyBQcm9taXNlKChzLGMpPT57cD1zLG09Y30pLF89dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIix5PXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCIsZz15JiZzZWxmLm5hbWU9PVwiZW0tcHRocmVhZFwiO3UubW91bnRFeHRlcm5hbERhdGE9KHMsYyk9PntzLnN0YXJ0c1dpdGgoXCIuL1wiKSYmKHM9cy5zdWJzdHJpbmcoMikpLCh1LkZifHwodS5GYj1uZXcgTWFwKSkuc2V0KHMsYyl9LHUudW5tb3VudEV4dGVybmFsRGF0YT0oKT0+e2RlbGV0ZSB1LkZifTt2YXIgeD1nbG9iYWxUaGlzLlNoYXJlZEFycmF5QnVmZmVyPz9uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOjAsbWF4aW11bTowLHNoYXJlZDohMH0pLmJ1ZmZlci5jb25zdHJ1Y3RvcjtsZXQgJD0oKT0+e2xldCBzPShmLGIsdyk9PiguLi5JKT0+e2xldCBPPVhlLEI9Yj8uKCk7ST1mKC4uLkkpO2xldCBHPWI/LigpO3JldHVybiBCIT09RyYmKGY9Ryx3KEIpLGI9dz1udWxsKSxYZSE9Tz9uZXcgUHJvbWlzZSgoRixYKT0+e2tuPXtyZXNvbHZlOkYscmVqZWN0Olh9fSk6SX0sYz1mPT5hc3luYyguLi5iKT0+e3RyeXtpZih1LkdiKXRocm93IEVycm9yKFwiU2Vzc2lvbiBhbHJlYWR5IHN0YXJ0ZWRcIik7bGV0IHc9dS5HYj17aGM6YlswXSxlcnJvcnM6W119LEk9YXdhaXQgZiguLi5iKTtpZih1LkdiIT09dyl0aHJvdyBFcnJvcihcIlNlc3Npb24gbWlzbWF0Y2hcIik7dS5IYj8uZmx1c2goKTtsZXQgTz13LmVycm9ycztpZigwPE8ubGVuZ3RoKXtsZXQgQj1hd2FpdCBQcm9taXNlLmFsbChPKTtpZihCPUIuZmlsdGVyKEc9PkcpLDA8Qi5sZW5ndGgpdGhyb3cgRXJyb3IoQi5qb2luKGBcbmApKX1yZXR1cm4gSX1maW5hbGx5e3UuR2I9bnVsbH19O3UuX09ydENyZWF0ZVNlc3Npb249cyh1Ll9PcnRDcmVhdGVTZXNzaW9uLCgpPT51Ll9PcnRDcmVhdGVTZXNzaW9uLGY9PnUuX09ydENyZWF0ZVNlc3Npb249ZiksdS5fT3J0UnVuPWMocyh1Ll9PcnRSdW4sKCk9PnUuX09ydFJ1bixmPT51Ll9PcnRSdW49ZikpLHUuX09ydFJ1bldpdGhCaW5kaW5nPWMocyh1Ll9PcnRSdW5XaXRoQmluZGluZywoKT0+dS5fT3J0UnVuV2l0aEJpbmRpbmcsZj0+dS5fT3J0UnVuV2l0aEJpbmRpbmc9ZikpLHUuX09ydEJpbmRJbnB1dD1zKHUuX09ydEJpbmRJbnB1dCwoKT0+dS5fT3J0QmluZElucHV0LGY9PnUuX09ydEJpbmRJbnB1dD1mKSwkPXZvaWQgMH07dS5qc2VwSW5pdD0ocyxjKT0+e2lmKCQ/LigpLHM9PT1cIndlYmdwdVwiKXtbdS5IYix1LlZiLHUuWmIsdS5PYix1LlliLHUua2IsdS4kYix1LmNjLHUuV2IsdS5YYix1LmFjXT1jO2xldCBmPXUuSGI7dS5qc2VwUmVnaXN0ZXJCdWZmZXI9KGIsdyxJLE8pPT5mLnJlZ2lzdGVyQnVmZmVyKGIsdyxJLE8pLHUuanNlcEdldEJ1ZmZlcj1iPT5mLmdldEJ1ZmZlcihiKSx1LmpzZXBDcmVhdGVEb3dubG9hZGVyPShiLHcsSSk9PmYuY3JlYXRlRG93bmxvYWRlcihiLHcsSSksdS5qc2VwT25DcmVhdGVTZXNzaW9uPWI9PntmLm9uQ3JlYXRlU2Vzc2lvbihiKX0sdS5qc2VwT25SZWxlYXNlU2Vzc2lvbj1iPT57Zi5vblJlbGVhc2VTZXNzaW9uKGIpfSx1LmpzZXBPblJ1blN0YXJ0PWI9PmYub25SdW5TdGFydChiKSx1LmRjPShiLHcpPT57Zi51cGxvYWQoYix3KX19ZWxzZSBpZihzPT09XCJ3ZWJublwiKXtbdS5IYix1LmJjLHUuUGIsdS5qc2VwRW5zdXJlVGVuc29yLHUuZWMsdS5qc2VwRG93bmxvYWRUZW5zb3JdPWMsdS5qc2VwUmVsZWFzZVRlbnNvcklkPXUuUGI7bGV0IGY9dS5IYjt1LmpzZXBPblJ1blN0YXJ0PWI9PmYub25SdW5TdGFydChiKSx1LmpzZXBSZWdpc3Rlck1MQ29udGV4dD0oYix3KT0+e2YucmVnaXN0ZXJNTENvbnRleHQoYix3KX0sdS5qc2VwT25SZWxlYXNlU2Vzc2lvbj1iPT57Zi5vblJlbGVhc2VTZXNzaW9uKGIpfSx1LmpzZXBDcmVhdGVNTFRlbnNvckRvd25sb2FkZXI9KGIsdyk9PmYuY3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKGIsdyksdS5qc2VwUmVnaXN0ZXJNTFRlbnNvcj0oYix3LEkpPT5mLnJlZ2lzdGVyTUxUZW5zb3IoYix3LEkpLHUuanNlcENyZWF0ZU1MQ29udGV4dD1iPT5mLmNyZWF0ZU1MQ29udGV4dChiKSx1LmpzZXBSZWdpc3Rlck1MQ29uc3RhbnQ9KGIsdyxJLE8sQik9PmYucmVnaXN0ZXJNTENvbnN0YW50KGIsdyxJLE8sQix1LkZiKX19O3ZhciB2LFMsVD1PYmplY3QuYXNzaWduKHt9LHUpLEE9KHMsYyk9Pnt0aHJvdyBjfSxDPVwiXCI7KF98fHkpJiYoeT9DPXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihDPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxxbiYmKEM9cW4pLEM9Qy5zdGFydHNXaXRoKFwiYmxvYjpcIik/XCJcIjpDLnN1YnN0cigwLEMucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSkseSYmKFM9cz0+e3ZhciBjPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gYy5vcGVuKFwiR0VUXCIscywhMSksYy5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGMuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShjLnJlc3BvbnNlKX0pLHY9KHMsYyxmKT0+e3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtiLm9wZW4oXCJHRVRcIixzLCEwKSxiLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsYi5vbmxvYWQ9KCk9PntiLnN0YXR1cz09MjAwfHxiLnN0YXR1cz09MCYmYi5yZXNwb25zZT9jKGIucmVzcG9uc2UpOmYoKX0sYi5vbmVycm9yPWYsYi5zZW5kKG51bGwpfSk7dmFyIFAsRD1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFI9Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpLEg9RCxMPVI7aWYoT2JqZWN0LmFzc2lnbih1LFQpLFQ9bnVsbCxnKXtsZXQgcz1mdW5jdGlvbihjKXt0cnl7dmFyIGY9Yy5kYXRhLGI9Zi5jbWQ7aWYoYj09PVwibG9hZFwiKXtsZXQgdz1bXTtzZWxmLm9ubWVzc2FnZT1JPT53LnB1c2goSSksc2VsZi5zdGFydFdvcmtlcj0oKT0+e3Bvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2ZvcihsZXQgSSBvZiB3KXMoSSk7c2VsZi5vbm1lc3NhZ2U9c307Zm9yKGxldCBJIG9mIGYuaGFuZGxlcnMpdVtJXSYmIXVbSV0ucHJveHl8fCh1W0ldPSguLi5PKT0+e3Bvc3RNZXNzYWdlKHtOYjpcImNhbGxIYW5kbGVyXCIscGM6SSxhcmdzOk99KX0sST09XCJwcmludFwiJiYoSD11W0ldKSxJPT1cInByaW50RXJyXCImJihMPXVbSV0pKTtLPWYud2FzbU1lbW9yeSxwZSgpLHJlKGYud2FzbU1vZHVsZSl9ZWxzZSBpZihiPT09XCJydW5cIil7T24oZi5wdGhyZWFkX3B0ciwwLDAsMSwwLDApLENuKGYucHRocmVhZF9wdHIpLHhjKCksR28oKSxWfHwoVmkoKSxWPSEwKTt0cnl7U2MoZi5zdGFydF9yb3V0aW5lLGYuYXJnKX1jYXRjaCh3KXtpZih3IT1cInVud2luZFwiKXRocm93IHd9fWVsc2UgYj09PVwiY2FuY2VsXCI/UnQoKSYmZnIoLTEpOmYudGFyZ2V0IT09XCJzZXRpbW1lZGlhdGVcIiYmKGI9PT1cImNoZWNrTWFpbGJveFwiP1YmJm9yKCk6YiYmKEwoYHdvcmtlcjogcmVjZWl2ZWQgdW5rbm93biBjb21tYW5kICR7Yn1gKSxMKGYpKSl9Y2F0Y2godyl7dGhyb3cgV2koKSx3fX07dmFyIHdnPXMscmUsVj0hMTtMPWZ1bmN0aW9uKC4uLmMpe2M9Yy5qb2luKFwiIFwiKSxjb25zb2xlLmVycm9yKGMpfSxzZWxmLmFsZXJ0PWZ1bmN0aW9uKC4uLmMpe3Bvc3RNZXNzYWdlKHtOYjpcImFsZXJ0XCIsdGV4dDpjLmpvaW4oXCIgXCIpLHJjOlJ0KCl9KX0sdS5pbnN0YW50aWF0ZVdhc209KGMsZik9Pm5ldyBQcm9taXNlKGI9PntyZT13PT57dz1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UodyxVbygpKSxmKHcpLGIoKX19KSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWM9Pnt0aHJvdyBjLnJlYXNvbnx8Y30sc2VsZi5vbm1lc3NhZ2U9c311Lndhc21CaW5hcnkmJihQPXUud2FzbUJpbmFyeSk7dmFyIEssd2UsaixRLGllLHRlLGJlLE9lLHZlLGRlLFcsWSxoZSxEZT0hMTtmdW5jdGlvbiBwZSgpe3ZhciBzPUsuYnVmZmVyO3UuSEVBUDg9UT1uZXcgSW50OEFycmF5KHMpLHUuSEVBUDE2PXRlPW5ldyBJbnQxNkFycmF5KHMpLHUuSEVBUFU4PWllPW5ldyBVaW50OEFycmF5KHMpLHUuSEVBUFUxNj1iZT1uZXcgVWludDE2QXJyYXkocyksdS5IRUFQMzI9T2U9bmV3IEludDMyQXJyYXkocyksdS5IRUFQVTMyPXZlPW5ldyBVaW50MzJBcnJheShzKSx1LkhFQVBGMzI9ZGU9bmV3IEZsb2F0MzJBcnJheShzKSx1LkhFQVBGNjQ9aGU9bmV3IEZsb2F0NjRBcnJheShzKSx1LkhFQVA2ND1XPW5ldyBCaWdJbnQ2NEFycmF5KHMpLHUuSEVBUFU2ND1ZPW5ldyBCaWdVaW50NjRBcnJheShzKX1pZighZyl7aWYoISgoSz1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOjI1NixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pKS5idWZmZXIgaW5zdGFuY2VvZiB4KSl0aHJvdyBMKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLEVycm9yKFwiYmFkIG1lbW9yeVwiKTtwZSgpfXZhciBJZT1bXSxIZT1bXSxtbj1bXSx3dD0wLGZuPW51bGwsR3Q9bnVsbDtmdW5jdGlvbiBPbygpe2lmKC0td3Q9PTAmJihmbiE9PW51bGwmJihjbGVhckludGVydmFsKGZuKSxmbj1udWxsKSxHdCkpe3ZhciBzPUd0O0d0PW51bGwscygpfX1mdW5jdGlvbiBjdChzKXt0aHJvdyBMKHM9XCJBYm9ydGVkKFwiK3MrXCIpXCIpLERlPSEwLGo9MSxzPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IocytcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbShzKSxzfXZhciBobixEbz1zPT5zLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpLEJvPXM9PnMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik7ZnVuY3Rpb24gTW8ocyl7aWYocz09aG4mJlApcmV0dXJuIG5ldyBVaW50OEFycmF5KFApO2lmKFMpcmV0dXJuIFMocyk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gUm8ocyxjLGYpe3JldHVybiBmdW5jdGlvbihiKXtpZighUCYmKF98fHkpKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIUJvKGIpKXJldHVybiBmZXRjaChiLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKHc9PntpZighdy5vayl0aHJvd2BmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICcke2J9J2A7cmV0dXJuIHcuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKCgpPT5NbyhiKSk7aWYodilyZXR1cm4gbmV3IFByb21pc2UoKHcsSSk9Pnt2KGIsTz0+dyhuZXcgVWludDhBcnJheShPKSksSSl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+TW8oYikpfShzKS50aGVuKGI9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGIsYykpLnRoZW4oZixiPT57TChgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtifWApLGN0KGIpfSl9ZnVuY3Rpb24gVW8oKXtyZXR1cm57YTp7TzokYyxBYTp2YyxiOkljLGFhOktvLEI6Wm8scWE6UW8sWTpKbyxfOmVpLHJhOnRpLG9hOnJpLGhhOm5pLG5hOm9pLEw6aWksWjphaSxXOnNpLHBhOnVpLFg6ZGksdmE6Q2MsRjprYyxROkVjLFA6emMsRTpEYyx1OkJjLHE6TWMsRzpSYyxBOkhjLFI6RmMsdWE6cWMsa2E6S2MsVTpqYyxiYTpZYyxIOlpjLGphOkNuLHRhOlFjLHQ6WGMsQmE6SmMseDpycCxvOm5wLG06aXAsYzpUbixuOmFwLGs6ZHAsdzpscCxwOmNwLGY6cHAsczptcCxsOmZwLGU6aHAsajpncCxpOmJwLGc6eXAsZDpfcCxlYTp3cCxmYTp2cCxnYTokcCxjYTp4aSxkYTpTaSxUOnhwLGg6U3AsRDpUcCxJOklwLE06Q3AseTpBcCxzYTprcCxWOkVwLHY6SWksejpQcCxOOnpwLFM6T3AsemE6RHAseWE6QnAsbGE6a2ksbWE6RWksJDp3bixDOlBpLEs6emksaWE6T2ksSjpEaSxhOksseGE6X24sd2E6UmkscjpVcH19fXZhciBnbj17OTE2ODY4OihzLGMsZixiLHcpPT57aWYodT09PXZvaWQgMHx8IXUuRmIpcmV0dXJuIDE7aWYoKHM9Q2UoTnVtYmVyKHM+Pj4wKSkpLnN0YXJ0c1dpdGgoXCIuL1wiKSYmKHM9cy5zdWJzdHJpbmcoMikpLCEocz11LkZiLmdldChzKSkpcmV0dXJuIDI7aWYoYz1OdW1iZXIoYz4+PjApLGY9TnVtYmVyKGY+Pj4wKSxiPU51bWJlcihiPj4+MCksYytmPnMuYnl0ZUxlbmd0aClyZXR1cm4gMzt0cnl7bGV0IEk9cy5zdWJhcnJheShjLGMrZik7c3dpdGNoKHcpe2Nhc2UgMDpyKCkuc2V0KEksYj4+PjApO2JyZWFrO2Nhc2UgMTp1LmRjKGIsSSk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gNH1yZXR1cm4gMH1jYXRjaHtyZXR1cm4gNH19LDkxNzU4MzoocyxjLGYpPT57dS5lYyhzLHIoKS5zdWJhcnJheShjPj4+MCxjK2Y+Pj4wKSl9LDkxNzY0NjooKT0+dS5iYygpLDkxNzY4NzpzPT57dS5QYihzKX0sOTE3NzIzOigpPT57dS5XYigpfSw5MTc3NTQ6KCk9Pnt1LlhiKCl9LDkxNzc4MzooKT0+e3UuYWMoKX0sOTE3ODA4OnM9PnUuVmIocyksOTE3ODQxOnM9PnUuWmIocyksOTE3ODczOihzLGMsZik9Pnt1Lk9iKE51bWJlcihzKSxOdW1iZXIoYyksTnVtYmVyKGYpLCEwKX0sOTE3OTM2OihzLGMsZik9Pnt1Lk9iKE51bWJlcihzKSxOdW1iZXIoYyksTnVtYmVyKGYpKX0sOTE3OTkzOigpPT50eXBlb2Ygd2FzbU9mZnNldENvbnZlcnRlcjxcInVcIiw5MTgwNTA6cz0+e3Uua2IoXCJBYnNcIixzLHZvaWQgMCl9LDkxODEwMTpzPT57dS5rYihcIk5lZ1wiLHMsdm9pZCAwKX0sOTE4MTUyOnM9Pnt1LmtiKFwiRmxvb3JcIixzLHZvaWQgMCl9LDkxODIwNTpzPT57dS5rYihcIkNlaWxcIixzLHZvaWQgMCl9LDkxODI1NzpzPT57dS5rYihcIlJlY2lwcm9jYWxcIixzLHZvaWQgMCl9LDkxODMxNTpzPT57dS5rYihcIlNxcnRcIixzLHZvaWQgMCl9LDkxODM2NzpzPT57dS5rYihcIkV4cFwiLHMsdm9pZCAwKX0sOTE4NDE4OnM9Pnt1LmtiKFwiRXJmXCIscyx2b2lkIDApfSw5MTg0Njk6cz0+e3Uua2IoXCJTaWdtb2lkXCIscyx2b2lkIDApfSw5MTg1MjQ6KHMsYyxmKT0+e3Uua2IoXCJIYXJkU2lnbW9pZFwiLHMse2FscGhhOmMsYmV0YTpmfSl9LDkxODYwMzpzPT57dS5rYihcIkxvZ1wiLHMsdm9pZCAwKX0sOTE4NjU0OnM9Pnt1LmtiKFwiU2luXCIscyx2b2lkIDApfSw5MTg3MDU6cz0+e3Uua2IoXCJDb3NcIixzLHZvaWQgMCl9LDkxODc1NjpzPT57dS5rYihcIlRhblwiLHMsdm9pZCAwKX0sOTE4ODA3OnM9Pnt1LmtiKFwiQXNpblwiLHMsdm9pZCAwKX0sOTE4ODU5OnM9Pnt1LmtiKFwiQWNvc1wiLHMsdm9pZCAwKX0sOTE4OTExOnM9Pnt1LmtiKFwiQXRhblwiLHMsdm9pZCAwKX0sOTE4OTYzOnM9Pnt1LmtiKFwiU2luaFwiLHMsdm9pZCAwKX0sOTE5MDE1OnM9Pnt1LmtiKFwiQ29zaFwiLHMsdm9pZCAwKX0sOTE5MDY3OnM9Pnt1LmtiKFwiQXNpbmhcIixzLHZvaWQgMCl9LDkxOTEyMDpzPT57dS5rYihcIkFjb3NoXCIscyx2b2lkIDApfSw5MTkxNzM6cz0+e3Uua2IoXCJBdGFuaFwiLHMsdm9pZCAwKX0sOTE5MjI2OnM9Pnt1LmtiKFwiVGFuaFwiLHMsdm9pZCAwKX0sOTE5Mjc4OnM9Pnt1LmtiKFwiTm90XCIscyx2b2lkIDApfSw5MTkzMjk6KHMsYyxmKT0+e3Uua2IoXCJDbGlwXCIscyx7bWluOmMsbWF4OmZ9KX0sOTE5Mzk4OnM9Pnt1LmtiKFwiQ2xpcFwiLHMsdm9pZCAwKX0sOTE5NDUwOihzLGMpPT57dS5rYihcIkVsdVwiLHMse2FscGhhOmN9KX0sOTE5NTA4OnM9Pnt1LmtiKFwiR2VsdVwiLHMsdm9pZCAwKX0sOTE5NTYwOnM9Pnt1LmtiKFwiUmVsdVwiLHMsdm9pZCAwKX0sOTE5NjEyOihzLGMpPT57dS5rYihcIkxlYWt5UmVsdVwiLHMse2FscGhhOmN9KX0sOTE5Njc2OihzLGMpPT57dS5rYihcIlRocmVzaG9sZGVkUmVsdVwiLHMse2FscGhhOmN9KX0sOTE5NzQ2OihzLGMpPT57dS5rYihcIkNhc3RcIixzLHt0bzpjfSl9LDkxOTgwNDpzPT57dS5rYihcIkFkZFwiLHMsdm9pZCAwKX0sOTE5ODU1OnM9Pnt1LmtiKFwiU3ViXCIscyx2b2lkIDApfSw5MTk5MDY6cz0+e3Uua2IoXCJNdWxcIixzLHZvaWQgMCl9LDkxOTk1NzpzPT57dS5rYihcIkRpdlwiLHMsdm9pZCAwKX0sOTIwMDA4OnM9Pnt1LmtiKFwiUG93XCIscyx2b2lkIDApfSw5MjAwNTk6cz0+e3Uua2IoXCJFcXVhbFwiLHMsdm9pZCAwKX0sOTIwMTEyOnM9Pnt1LmtiKFwiR3JlYXRlclwiLHMsdm9pZCAwKX0sOTIwMTY3OnM9Pnt1LmtiKFwiR3JlYXRlck9yRXF1YWxcIixzLHZvaWQgMCl9LDkyMDIyOTpzPT57dS5rYihcIkxlc3NcIixzLHZvaWQgMCl9LDkyMDI4MTpzPT57dS5rYihcIkxlc3NPckVxdWFsXCIscyx2b2lkIDApfSw5MjAzNDA6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlTWVhblwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkyMDUxNToocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VNYXhcIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjA2ODk6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlTWluXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTIwODYzOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZVByb2RcIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjEwMzg6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlU3VtXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTIxMjEyOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZUwxXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTIxMzg1OihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZUwyXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTIxNTU4OihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZUxvZ1N1bVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkyMTczNToocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VTdW1TcXVhcmVcIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjE5MTU6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlTG9nU3VtRXhwXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTIyMDk1OnM9Pnt1LmtiKFwiV2hlcmVcIixzLHZvaWQgMCl9LDkyMjE0ODoocyxjLGYpPT57dS5rYihcIlRyYW5zcG9zZVwiLHMse3Blcm06Yz9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYyk+Pj4wLE51bWJlcihmKT4+PjApKTpbXX0pfSw5MjIyNzI6KHMsYyxmLGIpPT57dS5rYihcIkRlcHRoVG9TcGFjZVwiLHMse2Jsb2Nrc2l6ZTpjLG1vZGU6Q2UoZiksZm9ybWF0OmI/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIyNDA1OihzLGMsZixiKT0+e3Uua2IoXCJEZXB0aFRvU3BhY2VcIixzLHtibG9ja3NpemU6Yyxtb2RlOkNlKGYpLGZvcm1hdDpiP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMjUzODoocyxjLGYsYix3LEksTyxCLEcsRixYLGxlLGdlLHosdWUpPT57dS5rYihcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6Rz9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOltmXSxncm91cDpiLGtlcm5lbFNoYXBlOlt3XSxwYWRzOltJLE9dLHN0cmlkZXM6W0JdLHdJc0NvbnN0OigpPT4hIXQoKVtGPj4+MF0sb3V0cHV0UGFkZGluZzpYP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKGxlKT4+PjApKTpbXSxvdXRwdXRTaGFwZTpnZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZ2UpPj4+MCxOdW1iZXIoeik+Pj4wKSk6W10sYWN0aXZhdGlvbjpDZSh1ZSl9KX0sOTIyOTcxOihzLGMsZixiLHcsSSxPLEIsRyxGLFgsbGUsZ2Useik9Pnt1LmtiKFwiQ29udlRyYW5zcG9zZVwiLHMse2Zvcm1hdDpCP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGYpPj4+MCwyKyhOdW1iZXIoZik+Pj4wKT4+PjApKSxncm91cDpiLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcih3KT4+PjAsMisoTnVtYmVyKHcpPj4+MCk+Pj4wKSkscGFkczpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLDQrKE51bWJlcihJKT4+PjApPj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKE8pPj4+MCwyKyhOdW1iZXIoTyk+Pj4wKT4+PjApKSx3SXNDb25zdDooKT0+ISF0KClbRz4+PjBdLG91dHB1dFBhZGRpbmc6Rj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoRik+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxvdXRwdXRTaGFwZTpsZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIobGUpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdLGFjdGl2YXRpb246Q2Uoeil9KX0sOTIzNjMyOihzLGMsZixiLHcsSSxPLEIsRyxGLFgsbGUsZ2Useix1ZSk9Pnt1LmtiKFwiQ29udlRyYW5zcG9zZVwiLHMse2Zvcm1hdDpHP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6W2ZdLGdyb3VwOmIsa2VybmVsU2hhcGU6W3ddLHBhZHM6W0ksT10sc3RyaWRlczpbQl0sd0lzQ29uc3Q6KCk9PiEhdCgpW0Y+Pj4wXSxvdXRwdXRQYWRkaW5nOlg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKFgpPj4+MCxOdW1iZXIobGUpPj4+MCkpOltdLG91dHB1dFNoYXBlOmdlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihnZSk+Pj4wLE51bWJlcih6KT4+PjApKTpbXSxhY3RpdmF0aW9uOkNlKHVlKX0pfSw5MjQwNjU6KHMsYyxmLGIsdyxJLE8sQixHLEYsWCxsZSxnZSx6KT0+e3Uua2IoXCJDb252VHJhbnNwb3NlXCIscyx7Zm9ybWF0OkI/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZik+Pj4wLDIrKE51bWJlcihmKT4+PjApPj4+MCkpLGdyb3VwOmIsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKHcpPj4+MCwyKyhOdW1iZXIodyk+Pj4wKT4+PjApKSxwYWRzOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsNCsoTnVtYmVyKEkpPj4+MCk+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoTyk+Pj4wLDIrKE51bWJlcihPKT4+PjApPj4+MCkpLHdJc0NvbnN0OigpPT4hIXQoKVtHPj4+MF0sb3V0cHV0UGFkZGluZzpGP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihGKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLG91dHB1dFNoYXBlOmxlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihsZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W10sYWN0aXZhdGlvbjpDZSh6KX0pfSw5MjQ3MjY6KHMsYyk9Pnt1LmtiKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjQ4MTc6KHMsYyxmLGIsdyxJLE8sQixHLEYsWCxsZSxnZSx6KT0+e3Uua2IoXCJBdmVyYWdlUG9vbFwiLHMse2Zvcm1hdDp6P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6YixzdG9yYWdlX29yZGVyOncsZGlsYXRpb25zOkk/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCxOdW1iZXIoTyk+Pj4wKSk6W10sa2VybmVsX3NoYXBlOkI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEIpPj4+MCxOdW1iZXIoRyk+Pj4wKSk6W10scGFkczpGP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihGKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLHN0cmlkZXM6bGU/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGxlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXX0pfSw5MjUyOTY6KHMsYyk9Pnt1LmtiKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjUzODc6KHMsYyxmLGIsdyxJLE8sQixHLEYsWCxsZSxnZSx6KT0+e3Uua2IoXCJBdmVyYWdlUG9vbFwiLHMse2Zvcm1hdDp6P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6YixzdG9yYWdlX29yZGVyOncsZGlsYXRpb25zOkk/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCxOdW1iZXIoTyk+Pj4wKSk6W10sa2VybmVsX3NoYXBlOkI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEIpPj4+MCxOdW1iZXIoRyk+Pj4wKSk6W10scGFkczpGP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihGKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLHN0cmlkZXM6bGU/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGxlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXX0pfSw5MjU4NjY6KHMsYyk9Pnt1LmtiKFwiR2xvYmFsTWF4UG9vbFwiLHMse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNTk1MzoocyxjLGYsYix3LEksTyxCLEcsRixYLGxlLGdlLHopPT57dS5rYihcIk1heFBvb2xcIixzLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOmIsc3RvcmFnZV9vcmRlcjp3LGRpbGF0aW9uczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLGtlcm5lbF9zaGFwZTpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEcpPj4+MCkpOltdLHBhZHM6Rj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoRik+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxzdHJpZGVzOmxlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihsZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W119KX0sOTI2NDI4OihzLGMpPT57dS5rYihcIkdsb2JhbE1heFBvb2xcIixzLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjY1MTU6KHMsYyxmLGIsdyxJLE8sQixHLEYsWCxsZSxnZSx6KT0+e3Uua2IoXCJNYXhQb29sXCIscyx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDpiLHN0b3JhZ2Vfb3JkZXI6dyxkaWxhdGlvbnM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihHKT4+PjApKTpbXSxwYWRzOkY/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEYpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sc3RyaWRlczpsZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIobGUpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdfSl9LDkyNjk5MDoocyxjLGYsYix3KT0+e3Uua2IoXCJHZW1tXCIscyx7YWxwaGE6YyxiZXRhOmYsdHJhbnNBOmIsdHJhbnNCOnd9KX0sOTI3MDk0OnM9Pnt1LmtiKFwiTWF0TXVsXCIscyx2b2lkIDApfSw5MjcxNDg6KHMsYyxmLGIpPT57dS5rYihcIkFyZ01heFwiLHMse2tlZXBEaW1zOiEhYyxzZWxlY3RMYXN0SW5kZXg6ISFmLGF4aXM6Yn0pfSw5MjcyNTY6KHMsYyxmLGIpPT57dS5rYihcIkFyZ01pblwiLHMse2tlZXBEaW1zOiEhYyxzZWxlY3RMYXN0SW5kZXg6ISFmLGF4aXM6Yn0pfSw5MjczNjQ6KHMsYyk9Pnt1LmtiKFwiU29mdG1heFwiLHMse2F4aXM6Y30pfSw5Mjc0Mjc6KHMsYyk9Pnt1LmtiKFwiQ29uY2F0XCIscyx7YXhpczpjfSl9LDkyNzQ4NzoocyxjLGYsYix3KT0+e3Uua2IoXCJTcGxpdFwiLHMse2F4aXM6YyxudW1PdXRwdXRzOmYsc3BsaXRTaXplczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkyNzY0MzpzPT57dS5rYihcIkV4cGFuZFwiLHMsdm9pZCAwKX0sOTI3Njk3OihzLGMpPT57dS5rYihcIkdhdGhlclwiLHMse2F4aXM6TnVtYmVyKGMpfSl9LDkyNzc2ODoocyxjKT0+e3Uua2IoXCJHYXRoZXJFbGVtZW50c1wiLHMse2F4aXM6TnVtYmVyKGMpfSl9LDkyNzg0NzoocyxjKT0+e3Uua2IoXCJHYXRoZXJORFwiLHMse2JhdGNoX2RpbXM6TnVtYmVyKGMpfSl9LDkyNzkyNjoocyxjLGYsYix3LEksTyxCLEcsRixYKT0+e3Uua2IoXCJSZXNpemVcIixzLHthbnRpYWxpYXM6YyxheGVzOmY/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGYpPj4+MCxOdW1iZXIoYik+Pj4wKSk6W10sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6Q2UodyksY3ViaWNDb2VmZkE6SSxleGNsdWRlT3V0c2lkZTpPLGV4dHJhcG9sYXRpb25WYWx1ZTpCLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpDZShHKSxtb2RlOkNlKEYpLG5lYXJlc3RNb2RlOkNlKFgpfSl9LDkyODI4ODoocyxjLGYsYix3LEksTyk9Pnt1LmtiKFwiU2xpY2VcIixzLHtzdGFydHM6Yz9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYyk+Pj4wLE51bWJlcihmKT4+PjApKTpbXSxlbmRzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W10sYXhlczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdfSl9LDkyODU1MjpzPT57dS5rYihcIlRpbGVcIixzLHZvaWQgMCl9LDkyODYwNDoocyxjLGYpPT57dS5rYihcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHMse2Vwc2lsb246Yyxmb3JtYXQ6Zj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5Mjg3MTg6KHMsYyxmKT0+e3Uua2IoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsZm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI4ODMyOnM9Pnt1LmtiKFwiUmFuZ2VcIixzLHZvaWQgMCl9LDkyODg4NToocyxjKT0+e3Uua2IoXCJFaW5zdW1cIixzLHtlcXVhdGlvbjpDZShjKX0pfSw5Mjg5NjY6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUGFkXCIscyx7bW9kZTpjLHZhbHVlOmYscGFkczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkyOTEwOToocyxjLGYsYix3LEkpPT57dS5rYihcIkJhdGNoTm9ybWFsaXphdGlvblwiLHMse2Vwc2lsb246Yyxtb21lbnR1bTpmLHNwYXRpYWw6ISF3LHRyYWluaW5nTW9kZTohIWIsZm9ybWF0Okk/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI5Mjc4OihzLGMsZixiLHcsSSk9Pnt1LmtiKFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLG1vbWVudHVtOmYsc3BhdGlhbDohIXcsdHJhaW5pbmdNb2RlOiEhYixmb3JtYXQ6ST9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5Mjk0NDc6KHMsYyxmKT0+e3Uua2IoXCJDdW1TdW1cIixzLHtleGNsdXNpdmU6TnVtYmVyKGMpLHJldmVyc2U6TnVtYmVyKGYpfSl9LDkyOTU0NDoocyxjLGYpPT57dS5rYihcIkRlcXVhbnRpemVMaW5lYXJcIixzLHtheGlzOmMsYmxvY2tTaXplOmZ9KX0sOTI5NjM0OihzLGMsZixiLHcpPT57dS5rYihcIkdyaWRTYW1wbGVcIixzLHthbGlnbl9jb3JuZXJzOmMsbW9kZTpDZShmKSxwYWRkaW5nX21vZGU6Q2UoYiksZm9ybWF0Onc/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI5ODA0OihzLGMsZixiLHcpPT57dS5rYihcIkdyaWRTYW1wbGVcIixzLHthbGlnbl9jb3JuZXJzOmMsbW9kZTpDZShmKSxwYWRkaW5nX21vZGU6Q2UoYiksZm9ybWF0Onc/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI5OTc0OihzLGMsZixiLHcsSSxPLEIsRyk9Pnt1LmtiKFwiQXR0ZW50aW9uXCIscyx7bnVtSGVhZHM6Yyxpc1VuaWRpcmVjdGlvbmFsOmYsbWFza0ZpbHRlclZhbHVlOmIsc2NhbGU6dyxkb1JvdGFyeTpJLHFrdkhpZGRlblNpemVzOk8/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEIpPj4+MCxOdW1iZXIoQikrTz4+PjApKTpbXSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiEhR30pfSw5MzAyNDY6cz0+e3Uua2IoXCJCaWFzQWRkXCIscyx2b2lkIDApfSw5MzAzMDE6cz0+e3Uua2IoXCJCaWFzU3BsaXRHZWx1XCIscyx2b2lkIDApfSw5MzAzNjI6cz0+e3Uua2IoXCJGYXN0R2VsdVwiLHMsdm9pZCAwKX0sOTMwNDE4OihzLGMsZixiLHcsSSxPLEIsRyxGLFgsbGUsZ2Useix1ZSxTZSk9Pnt1LmtiKFwiQ29udlwiLHMse2Zvcm1hdDpsZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGRpbGF0aW9uczpmP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihmKT4+PjAsTnVtYmVyKGIpPj4+MCkpOltdLGdyb3VwOncsa2VybmVsX3NoYXBlOkk/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCxOdW1iZXIoTyk+Pj4wKSk6W10scGFkczpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEcpPj4+MCkpOltdLHN0cmlkZXM6Rj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoRik+Pj4wLE51bWJlcihYKT4+PjApKTpbXSx3X2lzX2NvbnN0OigpPT4hIXQoKVtOdW1iZXIoZ2UpPj4+MF0sYWN0aXZhdGlvbjpDZSh6KSxhY3RpdmF0aW9uX3BhcmFtczp1ZT9BcnJheS5mcm9tKGQoKS5zdWJhcnJheShOdW1iZXIodWUpPj4+MCxOdW1iZXIoU2UpPj4+MCkpOltdfSl9LDkzMTAwMjpzPT57dS5rYihcIkdlbHVcIixzLHZvaWQgMCl9LDkzMTA1NDoocyxjLGYsYix3LEksTyxCLEcpPT57dS5rYihcIkdyb3VwUXVlcnlBdHRlbnRpb25cIixzLHtudW1IZWFkczpjLGt2TnVtSGVhZHM6ZixzY2FsZTpiLHNvZnRjYXA6dyxkb1JvdGFyeTpJLHJvdGFyeUludGVybGVhdmVkOk8sc21vb3RoU29mdG1heDpCLGxvY2FsV2luZG93U2l6ZTpHfSl9LDkzMTI3MToocyxjLGYsYik9Pnt1LmtiKFwiTGF5ZXJOb3JtYWxpemF0aW9uXCIscyx7YXhpczpjLGVwc2lsb246ZixzaW1wbGlmaWVkOiEhYn0pfSw5MzEzODI6KHMsYyxmLGIpPT57dS5rYihcIkxheWVyTm9ybWFsaXphdGlvblwiLHMse2F4aXM6YyxlcHNpbG9uOmYsc2ltcGxpZmllZDohIWJ9KX0sOTMxNDkzOihzLGMsZixiLHcsSSk9Pnt1LmtiKFwiTWF0TXVsTkJpdHNcIixzLHtrOmMsbjpmLGFjY3VyYWN5TGV2ZWw6YixiaXRzOncsYmxvY2tTaXplOkl9KX0sOTMxNjIwOihzLGMsZixiLHcsSSk9Pnt1LmtiKFwiTXVsdGlIZWFkQXR0ZW50aW9uXCIscyx7bnVtSGVhZHM6Yyxpc1VuaWRpcmVjdGlvbmFsOmYsbWFza0ZpbHRlclZhbHVlOmIsc2NhbGU6dyxkb1JvdGFyeTpJfSl9LDkzMTc3OToocyxjKT0+e3Uua2IoXCJRdWlja0dlbHVcIixzLHthbHBoYTpjfSl9LDkzMTg0MzoocyxjLGYsYix3KT0+e3Uua2IoXCJSb3RhcnlFbWJlZGRpbmdcIixzLHtpbnRlcmxlYXZlZDohIWMsbnVtSGVhZHM6Zixyb3RhcnlFbWJlZGRpbmdEaW06YixzY2FsZTp3fSl9LDkzMTk4MjoocyxjLGYpPT57dS5rYihcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsc2ltcGxpZmllZDohIWZ9KX0sOTMyMDg0OihzLGMsZik9Pnt1LmtiKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHMse2Vwc2lsb246YyxzaW1wbGlmaWVkOiEhZn0pfSw5MzIxODY6KHMsYyxmLGIpPT57dS5rYihcIkdhdGhlckJsb2NrUXVhbnRpemVkXCIscyx7Z2F0aGVyQXhpczpjLHF1YW50aXplQXhpczpmLGJsb2NrU2l6ZTpifSl9LDkzMjMwNzpzPT57dS4kYihzKX0sOTMyMzQxOihzLGMpPT51LmNjKE51bWJlcihzKSxOdW1iZXIoYyksdS5HYi5oYyx1LkdiLmVycm9ycyl9O2Z1bmN0aW9uIHZjKHMsYyxmKXtyZXR1cm4geWkoYXN5bmMoKT0+e2F3YWl0IHUuWWIoTnVtYmVyKHMpLE51bWJlcihjKSxOdW1iZXIoZikpfSl9ZnVuY3Rpb24gJGMoKXtyZXR1cm4gdHlwZW9mIHdhc21PZmZzZXRDb252ZXJ0ZXI8XCJ1XCJ9ZnVuY3Rpb24gYm4ocyl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke3N9KWAsdGhpcy5zdGF0dXM9c312YXIgeW49cz0+e3MudGVybWluYXRlKCkscy5vbm1lc3NhZ2U9KCk9Pnt9fSxObz1zPT57cHQubGVuZ3RoPT0wJiYoRm8oKSxIbyhwdFswXSkpO3ZhciBjPXB0LnBvcCgpO2lmKCFjKXJldHVybiA2OyR0LnB1c2goYyksWmVbcy5CYl09YyxjLkJiPXMuQmI7dmFyIGY9e2NtZDpcInJ1blwiLHN0YXJ0X3JvdXRpbmU6cy5pYyxhcmc6cy5SYixwdGhyZWFkX3B0cjpzLkJifTtyZXR1cm4gYy5wb3N0TWVzc2FnZShmLHMubmMpLDB9LHZ0PTAsJGU9KHMsYywuLi5mKT0+e2Zvcih2YXIgYj0yKmYubGVuZ3RoLHc9TW4oKSxJPUJuKDgqYiksTz1JPj4+MyxCPTA7QjxmLmxlbmd0aDtCKyspe3ZhciBHPWZbQl07dHlwZW9mIEc9PVwiYmlnaW50XCI/KFdbTysyKkJdPTFuLFdbTysyKkIrMV09Ryk6KFdbTysyKkJdPTBuLGwoKVtPKzIqQisxPj4+MF09Ryl9cmV0dXJuIHM9TGkocywwLGIsSSxjKSxocih3KSxzfTtmdW5jdGlvbiBfbihzKXtpZihnKXJldHVybiAkZSgwLDEscyk7aWYoaj1zLCEoMDx2dCkpe2Zvcih2YXIgYyBvZiAkdCl5bihjKTtmb3IoYyBvZiBwdCl5bihjKTtwdD1bXSwkdD1bXSxaZT1bXSxEZT0hMH1BKDAsbmV3IGJuKHMpKX1mdW5jdGlvbiBWbyhzKXtpZihnKXJldHVybiAkZSgxLDAscyk7d24ocyl9dmFyIHduPXM9PntpZihqPXMsZyl0aHJvdyBWbyhzKSxcInVud2luZFwiO19uKHMpfSxwdD1bXSwkdD1bXSxXbz1bXSxaZT17fSxMbz1zPT57dmFyIGM9cy5CYjtkZWxldGUgWmVbY10scHQucHVzaChzKSwkdC5zcGxpY2UoJHQuaW5kZXhPZihzKSwxKSxzLkJiPTAsRG4oYyl9O2Z1bmN0aW9uIEdvKCl7V28uZm9yRWFjaChzPT5zKCkpfXZhciBIbz1zPT5uZXcgUHJvbWlzZShjPT57cy5vbm1lc3NhZ2U9dz0+e3ZhciBJPSh3PXcuZGF0YSkuY21kO2lmKHcudGFyZ2V0VGhyZWFkJiZ3LnRhcmdldFRocmVhZCE9UnQoKSl7dmFyIE89WmVbdy50YXJnZXRUaHJlYWRdO08/Ty5wb3N0TWVzc2FnZSh3LHcudHJhbnNmZXJMaXN0KTpMKGBJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiJHtJfVwiIHRvIHRhcmdldCBwdGhyZWFkICR7dy50YXJnZXRUaHJlYWR9LCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFgKX1lbHNlIEk9PT1cImNoZWNrTWFpbGJveFwiP29yKCk6ST09PVwic3Bhd25UaHJlYWRcIj9Obyh3KTpJPT09XCJjbGVhbnVwVGhyZWFkXCI/TG8oWmVbdy50aHJlYWRdKTpJPT09XCJraWxsVGhyZWFkXCI/KHc9dy50aHJlYWQsST1aZVt3XSxkZWxldGUgWmVbd10seW4oSSksRG4odyksJHQuc3BsaWNlKCR0LmluZGV4T2YoSSksMSksSS5CYj0wKTpJPT09XCJjYW5jZWxUaHJlYWRcIj9aZVt3LnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6ST09PVwibG9hZGVkXCI/KHMubG9hZGVkPSEwLGMocykpOkk9PT1cImFsZXJ0XCI/YWxlcnQoYFRocmVhZCAke3cudGhyZWFkSWR9OiAke3cudGV4dH1gKTp3LnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCI/cy5wb3N0TWVzc2FnZSh3KTpJPT09XCJjYWxsSGFuZGxlclwiP3Vbdy5oYW5kbGVyXSguLi53LmFyZ3MpOkkmJkwoYHdvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCAke0l9YCl9LHMub25lcnJvcj13PT57dGhyb3cgTChgd29ya2VyIHNlbnQgYW4gZXJyb3IhICR7dy5maWxlbmFtZX06JHt3LmxpbmVub306ICR7dy5tZXNzYWdlfWApLHd9O3ZhciBmLGI9W107Zm9yKGYgb2ZbXSl1Lmhhc093blByb3BlcnR5KGYpJiZiLnB1c2goZik7cy5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLGhhbmRsZXJzOmIsd2FzbU1lbW9yeTpLLHdhc21Nb2R1bGU6d2V9KX0pO2Z1bmN0aW9uIEZvKCl7dmFyIHM9bmV3IFdvcmtlcihpbXBvcnQubWV0YS51cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwoXCJvcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzXCIsaW1wb3J0Lm1ldGEudXJsKTpuZXcgVVJMKGltcG9ydC5tZXRhLnVybCkse3R5cGU6XCJtb2R1bGVcIix3b3JrZXJEYXRhOlwiZW0tcHRocmVhZFwiLG5hbWU6XCJlbS1wdGhyZWFkXCJ9KTtwdC5wdXNoKHMpfXZhciBucj1zPT57Zm9yKDswPHMubGVuZ3RoOylzLnNoaWZ0KCkodSl9LHhjPSgpPT57dmFyIHM9UnQoKSxjPWEoKVtzKzUyPj4+Mj4+PjBdO3M9YSgpW3MrNTY+Pj4yPj4+MF0sSGkoYyxjLXMpLGhyKGMpfSxTYz0ocyxjKT0+e3Z0PTAscz1GaShzLGMpLDA8dnQ/aj1zOmZyKHMpfTtjbGFzcyBUY3tjb25zdHJ1Y3RvcihjKXt0aGlzLktiPWMtMjR9fWZ1bmN0aW9uIEljKHMsYyxmKXt2YXIgYj1uZXcgVGMocz4+Pj0wKTt0aHJvdyBjPj4+PTAsZj4+Pj0wLGEoKVtiLktiKzE2Pj4+Mj4+PjBdPTAsYSgpW2IuS2IrND4+PjI+Pj4wXT1jLGEoKVtiLktiKzg+Pj4yPj4+MF09ZixzfWZ1bmN0aW9uIHFvKHMsYyxmLGIpe3JldHVybiBnPyRlKDIsMSxzLGMsZixiKTpLbyhzLGMsZixiKX1mdW5jdGlvbiBLbyhzLGMsZixiKXtpZihzPj4+PTAsYz4+Pj0wLGY+Pj49MCxiPj4+PTAseD09PXZvaWQgMClyZXR1cm4gTChcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTaGFyZWRBcnJheUJ1ZmZlciwgcHRocmVhZHMgYXJlIG5vdCBhdmFpbGFibGUhXCIpLDY7dmFyIHc9W107cmV0dXJuIGcmJncubGVuZ3RoPT09MD9xbyhzLGMsZixiKToocz17aWM6ZixCYjpzLFJiOmIsbmM6d30sZz8ocy5OYj1cInNwYXduVGhyZWFkXCIscG9zdE1lc3NhZ2Uocyx3KSwwKTpObyhzKSl9dmFyIGpvPXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMCxZbz0ocyxjLGYpPT57dmFyIGI9KGM+Pj49MCkrZjtmb3IoZj1jO3NbZl0mJiEoZj49Yik7KSsrZjtpZigxNjxmLWMmJnMuYnVmZmVyJiZqbylyZXR1cm4gam8uZGVjb2RlKHMuYnVmZmVyIGluc3RhbmNlb2YgeD9zLnNsaWNlKGMsZik6cy5zdWJhcnJheShjLGYpKTtmb3IoYj1cIlwiO2M8Zjspe3ZhciB3PXNbYysrXTtpZigxMjgmdyl7dmFyIEk9NjMmc1tjKytdO2lmKCgyMjQmdyk9PTE5MiliKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZ3KTw8NnxJKTtlbHNle3ZhciBPPTYzJnNbYysrXTs2NTUzNj4odz0oMjQwJncpPT0yMjQ/KDE1JncpPDwxMnxJPDw2fE86KDcmdyk8PDE4fEk8PDEyfE88PDZ8NjMmc1tjKytdKT9iKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpOih3LT02NTUzNixiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fHc+PjEwLDU2MzIwfDEwMjMmdykpfX1lbHNlIGIrPVN0cmluZy5mcm9tQ2hhckNvZGUodyl9cmV0dXJuIGJ9LENlPShzLGMpPT4ocz4+Pj0wKT9ZbyhyKCkscyxjKTpcIlwiO2Z1bmN0aW9uIFpvKHMsYyxmKXtyZXR1cm4gZz8kZSgzLDEscyxjLGYpOjB9ZnVuY3Rpb24gUW8ocyxjKXtpZihnKXJldHVybiAkZSg0LDEscyxjKX12YXIgdm49cz0+e2Zvcih2YXIgYz0wLGY9MDtmPHMubGVuZ3RoOysrZil7dmFyIGI9cy5jaGFyQ29kZUF0KGYpOzEyNz49Yj9jKys6MjA0Nz49Yj9jKz0yOjU1Mjk2PD1iJiY1NzM0Mz49Yj8oYys9NCwrK2YpOmMrPTN9cmV0dXJuIGN9LFhvPShzLGMsZixiKT0+e2lmKCEoMDxiKSlyZXR1cm4gMDt2YXIgdz1mPj4+PTA7Yj1mK2ItMTtmb3IodmFyIEk9MDtJPHMubGVuZ3RoOysrSSl7dmFyIE89cy5jaGFyQ29kZUF0KEkpO2lmKDU1Mjk2PD1PJiY1NzM0Mz49TyYmKE89NjU1MzYrKCgxMDIzJk8pPDwxMCl8MTAyMyZzLmNoYXJDb2RlQXQoKytJKSksMTI3Pj1PKXtpZihmPj1iKWJyZWFrO2NbZisrPj4+MF09T31lbHNle2lmKDIwNDc+PU8pe2lmKGYrMT49YilicmVhaztjW2YrKz4+PjBdPTE5MnxPPj42fWVsc2V7aWYoNjU1MzU+PU8pe2lmKGYrMj49YilicmVhaztjW2YrKz4+PjBdPTIyNHxPPj4xMn1lbHNle2lmKGYrMz49YilicmVhaztjW2YrKz4+PjBdPTI0MHxPPj4xOCxjW2YrKz4+PjBdPTEyOHxPPj4xMiY2M31jW2YrKz4+PjBdPTEyOHxPPj42JjYzfWNbZisrPj4+MF09MTI4fDYzJk99fXJldHVybiBjW2Y+Pj4wXT0wLGYtd30sRHQ9KHMsYyxmKT0+WG8ocyxyKCksYyxmKTtmdW5jdGlvbiBKbyhzLGMpe2lmKGcpcmV0dXJuICRlKDUsMSxzLGMpfWZ1bmN0aW9uIGVpKHMsYyxmKXtpZihnKXJldHVybiAkZSg2LDEscyxjLGYpfWZ1bmN0aW9uIHRpKHMsYyxmKXtyZXR1cm4gZz8kZSg3LDEscyxjLGYpOjB9ZnVuY3Rpb24gcmkocyxjKXtpZihnKXJldHVybiAkZSg4LDEscyxjKX1mdW5jdGlvbiBuaShzLGMsZil7aWYoZylyZXR1cm4gJGUoOSwxLHMsYyxmKX1mdW5jdGlvbiBvaShzLGMsZixiKXtpZihnKXJldHVybiAkZSgxMCwxLHMsYyxmLGIpfWZ1bmN0aW9uIGlpKHMsYyxmLGIpe2lmKGcpcmV0dXJuICRlKDExLDEscyxjLGYsYil9ZnVuY3Rpb24gYWkocyxjLGYsYil7aWYoZylyZXR1cm4gJGUoMTIsMSxzLGMsZixiKX1mdW5jdGlvbiBzaShzKXtpZihnKXJldHVybiAkZSgxMywxLHMpfWZ1bmN0aW9uIHVpKHMsYyl7aWYoZylyZXR1cm4gJGUoMTQsMSxzLGMpfWZ1bmN0aW9uIGRpKHMsYyxmKXtpZihnKXJldHVybiAkZSgxNSwxLHMsYyxmKX12YXIgbGksbXQsQ2M9KCk9PntjdChcIlwiKX0sUWU9cz0+e2Zvcih2YXIgYz1cIlwiO3IoKVtzPj4+MF07KWMrPWxpW3IoKVtzKys+Pj4wXV07cmV0dXJuIGN9LCRuPXt9LHhuPXt9LEFjPXt9O2Z1bmN0aW9uIHN0KHMsYyxmPXt9KXtpZighKFwiYXJnUGFja0FkdmFuY2VcImluIGMpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlXCIpO3JldHVybiBmdW5jdGlvbihiLHcsST17fSl7dmFyIE89dy5uYW1lO2lmKCFiKXRocm93IG5ldyBtdChgdHlwZSBcIiR7T31cIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyYCk7aWYoeG4uaGFzT3duUHJvcGVydHkoYikpe2lmKEkuVGIpcmV0dXJuO3Rocm93IG5ldyBtdChgQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyR7T30nIHR3aWNlYCl9eG5bYl09dyxkZWxldGUgQWNbYl0sJG4uaGFzT3duUHJvcGVydHkoYikmJih3PSRuW2JdLGRlbGV0ZSAkbltiXSx3LmZvckVhY2goQj0+QigpKSl9KHMsYyxmKX12YXIgY2k9KHMsYyxmKT0+e3N3aXRjaChjKXtjYXNlIDE6cmV0dXJuIGY/Yj0+dCgpW2I+Pj4wXTpiPT5yKClbYj4+PjBdO2Nhc2UgMjpyZXR1cm4gZj9iPT5uKClbYj4+PjE+Pj4wXTpiPT5vKClbYj4+PjE+Pj4wXTtjYXNlIDQ6cmV0dXJuIGY/Yj0+aSgpW2I+Pj4yPj4+MF06Yj0+YSgpW2I+Pj4yPj4+MF07Y2FzZSA4OnJldHVybiBmP2I9PldbYj4+PjNdOmI9PllbYj4+PjNdO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlZ2VyIHdpZHRoICgke2N9KTogJHtzfWApfX07ZnVuY3Rpb24ga2MocyxjLGYpe2Y+Pj49MCxzdChzPj4+PTAse25hbWU6Yz1RZShjPj4+MCksZnJvbVdpcmVUeXBlOmI9PmIsdG9XaXJlVHlwZTpmdW5jdGlvbihiLHcpe2lmKHR5cGVvZiB3IT1cImJpZ2ludFwiJiZ0eXBlb2YgdyE9XCJudW1iZXJcIil0aHJvdyB3PXc9PT1udWxsP1wibnVsbFwiOihiPXR5cGVvZiB3KT09XCJvYmplY3RcInx8Yj09PVwiYXJyYXlcInx8Yj09PVwiZnVuY3Rpb25cIj93LnRvU3RyaW5nKCk6XCJcIit3LG5ldyBUeXBlRXJyb3IoYENhbm5vdCBjb252ZXJ0IFwiJHt3fVwiIHRvICR7dGhpcy5uYW1lfWApO3JldHVybiB0eXBlb2Ygdz09XCJudW1iZXJcIiYmKHc9QmlnSW50KHcpKSx3fSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpjaShjLGYsYy5pbmRleE9mKFwidVwiKT09LTEpLEViOm51bGx9KX12YXIgZnQ9ODtmdW5jdGlvbiBFYyhzLGMsZixiKXtzdChzPj4+PTAse25hbWU6Yz1RZShjPj4+MCksZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKHcpe3JldHVybiEhd30sdG9XaXJlVHlwZTpmdW5jdGlvbih3LEkpe3JldHVybiBJP2Y6Yn0sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6ZnVuY3Rpb24odyl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKHIoKVt3Pj4+MF0pfSxFYjpudWxsfSl9dmFyIFNuPVtdLHV0PVtdO2Z1bmN0aW9uIFRuKHMpezk8KHM+Pj49MCkmJi0tdXRbcysxXT09MCYmKHV0W3NdPXZvaWQgMCxTbi5wdXNoKHMpKX12YXIgUmU9cz0+e2lmKCFzKXRocm93IG5ldyBtdChcIkNhbm5vdCB1c2UgZGVsZXRlZCB2YWwuIGhhbmRsZSA9IFwiK3MpO3JldHVybiB1dFtzXX0sV2U9cz0+e3N3aXRjaChzKXtjYXNlIHZvaWQgMDpyZXR1cm4gMjtjYXNlIG51bGw6cmV0dXJuIDQ7Y2FzZSEwOnJldHVybiA2O2Nhc2UhMTpyZXR1cm4gODtkZWZhdWx0OmxldCBjPVNuLnBvcCgpfHx1dC5sZW5ndGg7cmV0dXJuIHV0W2NdPXMsdXRbYysxXT0xLGN9fTtmdW5jdGlvbiBJbihzKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoYSgpW3M+Pj4yPj4+MF0pfXZhciBQYz17bmFtZTpcImVtc2NyaXB0ZW46OnZhbFwiLGZyb21XaXJlVHlwZTpzPT57dmFyIGM9UmUocyk7cmV0dXJuIFRuKHMpLGN9LHRvV2lyZVR5cGU6KHMsYyk9PldlKGMpLGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOkluLEViOm51bGx9O2Z1bmN0aW9uIHpjKHMpe3JldHVybiBzdChzPj4+MCxQYyl9dmFyIE9jPShzLGMpPT57c3dpdGNoKGMpe2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKGQoKVtmPj4+Mj4+PjBdKX07Y2FzZSA4OnJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUobCgpW2Y+Pj4zPj4+MF0pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZmxvYXQgd2lkdGggKCR7Y30pOiAke3N9YCl9fTtmdW5jdGlvbiBEYyhzLGMsZil7Zj4+Pj0wLHN0KHM+Pj49MCx7bmFtZTpjPVFlKGM+Pj4wKSxmcm9tV2lyZVR5cGU6Yj0+Yix0b1dpcmVUeXBlOihiLHcpPT53LGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOk9jKGMsZiksRWI6bnVsbH0pfWZ1bmN0aW9uIEJjKHMsYyxmLGIsdyl7aWYocz4+Pj0wLGY+Pj49MCxjPVFlKGM+Pj4wKSx3PT09LTEmJih3PTQyOTQ5NjcyOTUpLHc9Qj0+QixiPT09MCl7dmFyIEk9MzItOCpmO3c9Qj0+Qjw8ST4+Pkl9dmFyIE89Yy5pbmNsdWRlcyhcInVuc2lnbmVkXCIpP2Z1bmN0aW9uKEIsRyl7cmV0dXJuIEc+Pj4wfTpmdW5jdGlvbihCLEcpe3JldHVybiBHfTtzdChzLHtuYW1lOmMsZnJvbVdpcmVUeXBlOncsdG9XaXJlVHlwZTpPLGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmNpKGMsZixiIT09MCksRWI6bnVsbH0pfWZ1bmN0aW9uIE1jKHMsYyxmKXtmdW5jdGlvbiBiKEkpe3ZhciBPPWEoKVtJPj4+Mj4+PjBdO3JldHVybiBJPWEoKVtJKzQ+Pj4yPj4+MF0sbmV3IHcodCgpLmJ1ZmZlcixJLE8pfXZhciB3PVtJbnQ4QXJyYXksVWludDhBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSxCaWdJbnQ2NEFycmF5LEJpZ1VpbnQ2NEFycmF5XVtjXTtzdChzPj4+PTAse25hbWU6Zj1RZShmPj4+MCksZnJvbVdpcmVUeXBlOmIsYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6Yn0se1RiOiEwfSl9ZnVuY3Rpb24gUmMocyxjKXtzPj4+PTA7dmFyIGY9KGM9UWUoYz4+PjApKT09PVwic3RkOjpzdHJpbmdcIjtzdChzLHtuYW1lOmMsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKGIpe3ZhciB3PWEoKVtiPj4+Mj4+PjBdLEk9Yis0O2lmKGYpZm9yKHZhciBPPUksQj0wO0I8PXc7KytCKXt2YXIgRz1JK0I7aWYoQj09d3x8cigpW0c+Pj4wXT09MCl7aWYoTz1DZShPLEctTyksRj09PXZvaWQgMCl2YXIgRj1PO2Vsc2UgRis9U3RyaW5nLmZyb21DaGFyQ29kZSgwKSxGKz1PO089RysxfX1lbHNle2ZvcihGPUFycmF5KHcpLEI9MDtCPHc7KytCKUZbQl09U3RyaW5nLmZyb21DaGFyQ29kZShyKClbSStCPj4+MF0pO0Y9Ri5qb2luKFwiXCIpfXJldHVybiBKZShiKSxGfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKGIsdyl7dyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYodz1uZXcgVWludDhBcnJheSh3KSk7dmFyIEk9dHlwZW9mIHc9PVwic3RyaW5nXCI7aWYoIShJfHx3IGluc3RhbmNlb2YgVWludDhBcnJheXx8dyBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHx3IGluc3RhbmNlb2YgSW50OEFycmF5KSl0aHJvdyBuZXcgbXQoXCJDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIHN0ZDo6c3RyaW5nXCIpO3ZhciBPPWYmJkk/dm4odyk6dy5sZW5ndGgsQj1tcig0K08rMSksRz1CKzQ7aWYoYSgpW0I+Pj4yPj4+MF09TyxmJiZJKUR0KHcsRyxPKzEpO2Vsc2UgaWYoSSlmb3IoST0wO0k8TzsrK0kpe3ZhciBGPXcuY2hhckNvZGVBdChJKTtpZigyNTU8Ril0aHJvdyBKZShHKSxuZXcgbXQoXCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHNcIik7cigpW0crST4+PjBdPUZ9ZWxzZSBmb3IoST0wO0k8TzsrK0kpcigpW0crST4+PjBdPXdbSV07cmV0dXJuIGIhPT1udWxsJiZiLnB1c2goSmUsQiksQn0sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6SW4sRWIoYil7SmUoYil9fSl9dmFyIHBpPXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGYtMTZsZVwiKTp2b2lkIDAsVWM9KHMsYyk9Pntmb3IodmFyIGY9cz4+MSxiPWYrYy8yOyEoZj49YikmJm8oKVtmPj4+MF07KSsrZjtpZigzMjwoZjw8PTEpLXMmJnBpKXJldHVybiBwaS5kZWNvZGUocigpLnNsaWNlKHMsZikpO2ZvcihmPVwiXCIsYj0wOyEoYj49Yy8yKTsrK2Ipe3ZhciB3PW4oKVtzKzIqYj4+PjE+Pj4wXTtpZih3PT0wKWJyZWFrO2YrPVN0cmluZy5mcm9tQ2hhckNvZGUodyl9cmV0dXJuIGZ9LE5jPShzLGMsZik9PntpZihmPz89MjE0NzQ4MzY0NywyPmYpcmV0dXJuIDA7dmFyIGI9YztmPShmLT0yKTwyKnMubGVuZ3RoP2YvMjpzLmxlbmd0aDtmb3IodmFyIHc9MDt3PGY7Kyt3KXt2YXIgST1zLmNoYXJDb2RlQXQodyk7bigpW2M+Pj4xPj4+MF09SSxjKz0yfXJldHVybiBuKClbYz4+PjE+Pj4wXT0wLGMtYn0sVmM9cz0+MipzLmxlbmd0aCxXYz0ocyxjKT0+e2Zvcih2YXIgZj0wLGI9XCJcIjshKGY+PWMvNCk7KXt2YXIgdz1pKClbcys0KmY+Pj4yPj4+MF07aWYodz09MClicmVhazsrK2YsNjU1MzY8PXc/KHctPTY1NTM2LGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8dz4+MTAsNTYzMjB8MTAyMyZ3KSk6Yis9U3RyaW5nLmZyb21DaGFyQ29kZSh3KX1yZXR1cm4gYn0sTGM9KHMsYyxmKT0+e2lmKGM+Pj49MCxmPz89MjE0NzQ4MzY0Nyw0PmYpcmV0dXJuIDA7dmFyIGI9YztmPWIrZi00O2Zvcih2YXIgdz0wO3c8cy5sZW5ndGg7Kyt3KXt2YXIgST1zLmNoYXJDb2RlQXQodyk7aWYoNTUyOTY8PUkmJjU3MzQzPj1JJiYoST02NTUzNisoKDEwMjMmSSk8PDEwKXwxMDIzJnMuY2hhckNvZGVBdCgrK3cpKSxpKClbYz4+PjI+Pj4wXT1JLChjKz00KSs0PmYpYnJlYWt9cmV0dXJuIGkoKVtjPj4+Mj4+PjBdPTAsYy1ifSxHYz1zPT57Zm9yKHZhciBjPTAsZj0wO2Y8cy5sZW5ndGg7KytmKXt2YXIgYj1zLmNoYXJDb2RlQXQoZik7NTUyOTY8PWImJjU3MzQzPj1iJiYrK2YsYys9NH1yZXR1cm4gY307ZnVuY3Rpb24gSGMocyxjLGYpe2lmKHM+Pj49MCxjPj4+PTAsZj1RZShmPj4+PTApLGM9PT0yKXZhciBiPVVjLHc9TmMsST1WYyxPPUI9Pm8oKVtCPj4+MT4+PjBdO2Vsc2UgYz09PTQmJihiPVdjLHc9TGMsST1HYyxPPUI9PmEoKVtCPj4+Mj4+PjBdKTtzdChzLHtuYW1lOmYsZnJvbVdpcmVUeXBlOkI9Pntmb3IodmFyIEcsRj1hKClbQj4+PjI+Pj4wXSxYPUIrNCxsZT0wO2xlPD1GOysrbGUpe3ZhciBnZT1CKzQrbGUqYztsZSE9RiYmTyhnZSkhPTB8fChYPWIoWCxnZS1YKSxHPT09dm9pZCAwP0c9WDooRys9U3RyaW5nLmZyb21DaGFyQ29kZSgwKSxHKz1YKSxYPWdlK2MpfXJldHVybiBKZShCKSxHfSx0b1dpcmVUeXBlOihCLEcpPT57aWYodHlwZW9mIEchPVwic3RyaW5nXCIpdGhyb3cgbmV3IG10KGBDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIEMrKyBzdHJpbmcgdHlwZSAke2Z9YCk7dmFyIEY9SShHKSxYPW1yKDQrRitjKTtyZXR1cm4gYSgpW1g+Pj4yPj4+MF09Ri9jLHcoRyxYKzQsRitjKSxCIT09bnVsbCYmQi5wdXNoKEplLFgpLFh9LGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOkluLEViKEIpe0plKEIpfX0pfWZ1bmN0aW9uIEZjKHMsYyl7c3Qocz4+Pj0wLHtVYjohMCxuYW1lOmM9UWUoYz4+PjApLGFyZ1BhY2tBZHZhbmNlOjAsZnJvbVdpcmVUeXBlOigpPT57fSx0b1dpcmVUeXBlOigpPT57fX0pfXZhciBxYz0oKT0+MTtmdW5jdGlvbiBLYyhzKXtPbihzPj4+MCwheSwxLCFfLDEzMTA3MiwhMSksR28oKX12YXIgbWk9cz0+e2lmKCFEZSl0cnl7aWYocygpLCEoMDx2dCkpdHJ5e2c/ZnIoaik6d24oail9Y2F0Y2goYyl7YyBpbnN0YW5jZW9mIGJufHxjPT1cInVud2luZFwifHxBKDAsYyl9fWNhdGNoKGMpe2MgaW5zdGFuY2VvZiBibnx8Yz09XCJ1bndpbmRcInx8QSgwLGMpfX07ZnVuY3Rpb24gQ24ocyl7cz4+Pj0wLHR5cGVvZiBBdG9taWNzLm9jPT1cImZ1bmN0aW9uXCImJihBdG9taWNzLm9jKGkoKSxzPj4+MixzKS52YWx1ZS50aGVuKG9yKSxzKz0xMjgsQXRvbWljcy5zdG9yZShpKCkscz4+PjIsMSkpfXZhciBvcj0oKT0+e3ZhciBzPVJ0KCk7cyYmKENuKHMpLG1pKEdpKSl9O2Z1bmN0aW9uIGpjKHMsYyl7KHM+Pj49MCk9PWM+Pj4wP3NldFRpbWVvdXQob3IpOmc/cG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDpzLGNtZDpcImNoZWNrTWFpbGJveFwifSk6KHM9WmVbc10pJiZzLnBvc3RNZXNzYWdlKHtjbWQ6XCJjaGVja01haWxib3hcIn0pfXZhciBBbj1bXTtmdW5jdGlvbiBZYyhzLGMsZixiLHcpe2ZvcihjPj4+PTAsYi89MixBbi5sZW5ndGg9YixmPXc+Pj4wPj4+Myx3PTA7dzxiO3crKylBblt3XT1XW2YrMip3XT9XW2YrMip3KzFdOmwoKVtmKzIqdysxPj4+MF07cmV0dXJuKGM/Z25bY106TnBbc10pKC4uLkFuKX1mdW5jdGlvbiBaYyhzKXtzPj4+PTAsZz9wb3N0TWVzc2FnZSh7Y21kOlwiY2xlYW51cFRocmVhZFwiLHRocmVhZDpzfSk6TG8oWmVbc10pfWZ1bmN0aW9uIFFjKHMpe312YXIgaXI9KHMsYyk9Pnt2YXIgZj14bltzXTtpZihmPT09dm9pZCAwKXRocm93IHM9TmkocyksZj1RZShzKSxKZShzKSxuZXcgbXQoYCR7Y30gaGFzIHVua25vd24gdHlwZSAke2Z9YCk7cmV0dXJuIGZ9LGZpPShzLGMsZik9Pnt2YXIgYj1bXTtyZXR1cm4gcz1zLnRvV2lyZVR5cGUoYixmKSxiLmxlbmd0aCYmKGEoKVtjPj4+Mj4+PjBdPVdlKGIpKSxzfTtmdW5jdGlvbiBYYyhzLGMsZil7cmV0dXJuIGM+Pj49MCxmPj4+PTAscz1SZShzPj4+MCksYz1pcihjLFwiZW12YWw6OmFzXCIpLGZpKGMsZixzKX1mdW5jdGlvbiBKYyhzLGMpe3JldHVybiBjPj4+PTAscz1SZShzPj4+MCksKGM9aXIoYyxcImVtdmFsOjphc1wiKSkudG9XaXJlVHlwZShudWxsLHMpfXZhciBhcj1zPT57dHJ5e3MoKX1jYXRjaChjKXtjdChjKX19LGh0PTAsWGU9bnVsbCxoaT0wLHNyPVtdLGdpPXt9LGJpPXt9LGVwPTAsa249bnVsbCx0cD1bXTtmdW5jdGlvbiB5aShzKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYoIURlKXtpZihodD09PTApe3ZhciBmPSExLGI9ITE7Yygodz0wKT0+e2lmKCFEZSYmKGhpPXcsZj0hMCxiKSl7aHQ9MixhcigoKT0+amkoWGUpKSx0eXBlb2YgQnJvd3NlcjxcInVcIiYmQnJvd3Nlci5MYi5TYiYmQnJvd3Nlci5MYi5yZXN1bWUoKSx3PSExO3RyeXt2YXIgST1mdW5jdGlvbigpe3ZhciBHPWkoKVtYZSs4Pj4+Mj4+PjBdO3JldHVybiBHPVpbYmlbR11dLC0tdnQsRygpfSgpfWNhdGNoKEcpe0k9Ryx3PSEwfXZhciBPPSExO2lmKCFYZSl7dmFyIEI9a247QiYmKGtuPW51bGwsKHc/Qi5yZWplY3Q6Qi5yZXNvbHZlKShJKSxPPSEwKX1pZih3JiYhTyl0aHJvdyBJfX0pLGI9ITAsZnx8KGh0PTEsWGU9ZnVuY3Rpb24oKXt2YXIgdz1tcig2NTU0OCksST13KzEyO2EoKVt3Pj4+Mj4+PjBdPUksYSgpW3crND4+PjI+Pj4wXT1JKzY1NTM2LEk9c3JbMF07dmFyIE89Z2lbSV07cmV0dXJuIE89PT12b2lkIDAmJihPPWVwKyssZ2lbSV09TyxiaVtPXT1JKSxJPU8saSgpW3crOD4+PjI+Pj4wXT1JLHd9KCksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuTGIuU2ImJkJyb3dzZXIuTGIucGF1c2UoKSxhcigoKT0+cWkoWGUpKSl9ZWxzZSBodD09PTI/KGh0PTAsYXIoWWkpLEplKFhlKSxYZT1udWxsLHRwLmZvckVhY2gobWkpKTpjdChgaW52YWxpZCBzdGF0ZTogJHtodH1gKTtyZXR1cm4gaGl9fShjPT57cygpLnRoZW4oYyl9KX1mdW5jdGlvbiBycChzKXtyZXR1cm4gcz4+Pj0wLHlpKCgpPT4ocz1SZShzKSkudGhlbihXZSkpfXZhciB1cj1bXTtmdW5jdGlvbiBucChzLGMsZixiKXtyZXR1cm4gZj4+Pj0wLGI+Pj49MCwocz11cltzPj4+MF0pKG51bGwsYz1SZShjPj4+MCksZixiKX12YXIgb3A9e30sZHI9cz0+e3ZhciBjPW9wW3NdO3JldHVybiBjPT09dm9pZCAwP1FlKHMpOmN9O2Z1bmN0aW9uIGlwKHMsYyxmLGIsdyl7cmV0dXJuIGY+Pj49MCxiPj4+PTAsdz4+Pj0wLChzPXVyW3M+Pj4wXSkoYz1SZShjPj4+MCksY1tmPWRyKGYpXSxiLHcpfXZhciBfaT0oKT0+dHlwZW9mIGdsb2JhbFRoaXM9PVwib2JqZWN0XCI/Z2xvYmFsVGhpczpGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7ZnVuY3Rpb24gYXAocyl7cmV0dXJuKHM+Pj49MCk9PTA/V2UoX2koKSk6KHM9ZHIocyksV2UoX2koKVtzXSkpfXZhciBzcD1zPT57dmFyIGM9dXIubGVuZ3RoO3JldHVybiB1ci5wdXNoKHMpLGN9LHVwPShzLGMpPT57Zm9yKHZhciBmPUFycmF5KHMpLGI9MDtiPHM7KytiKWZbYl09aXIoYSgpW2MrNCpiPj4+Mj4+PjBdLFwicGFyYW1ldGVyIFwiK2IpO3JldHVybiBmfSx3aT0ocyxjKT0+T2JqZWN0LmRlZmluZVByb3BlcnR5KGMsXCJuYW1lXCIse3ZhbHVlOnN9KTtmdW5jdGlvbiBkcChzLGMsZil7dmFyIGI9KGM9dXAocyxjPj4+MCkpLnNoaWZ0KCk7cy0tO3ZhciB3PWByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZnVuYywgZGVzdHJ1Y3RvcnNSZWYsIGFyZ3MpIHtcbmAsST0wLE89W107Zj09PTAmJk8ucHVzaChcIm9ialwiKTtmb3IodmFyIEI9W1wicmV0VHlwZVwiXSxHPVtiXSxGPTA7RjxzOysrRilPLnB1c2goXCJhcmdcIitGKSxCLnB1c2goXCJhcmdUeXBlXCIrRiksRy5wdXNoKGNbRl0pLHcrPWAgIHZhciBhcmcke0Z9ID0gYXJnVHlwZSR7Rn0ucmVhZFZhbHVlRnJvbVBvaW50ZXIoYXJncyR7ST9cIitcIitJOlwiXCJ9KTtcbmAsSSs9Y1tGXS5hcmdQYWNrQWR2YW5jZTtyZXR1cm4gdys9YCAgdmFyIHJ2ID0gJHtmPT09MT9cIm5ldyBmdW5jXCI6XCJmdW5jLmNhbGxcIn0oJHtPLmpvaW4oXCIsIFwiKX0pO1xuYCxiLlVifHwoQi5wdXNoKFwiZW12YWxfcmV0dXJuVmFsdWVcIiksRy5wdXNoKGZpKSx3Kz1gICByZXR1cm4gZW12YWxfcmV0dXJuVmFsdWUocmV0VHlwZSwgZGVzdHJ1Y3RvcnNSZWYsIHJ2KTtcbmApLEIucHVzaCh3K2B9O1xuYCkscz1mdW5jdGlvbihYKXt2YXIgbGU9RnVuY3Rpb247aWYoIShsZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBuZXdfIGNhbGxlZCB3aXRoIGNvbnN0cnVjdG9yIHR5cGUgJHt0eXBlb2YgbGV9IHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uYCk7dmFyIGdlPXdpKGxlLm5hbWV8fFwidW5rbm93bkZ1bmN0aW9uTmFtZVwiLGZ1bmN0aW9uKCl7fSk7cmV0dXJuIGdlLnByb3RvdHlwZT1sZS5wcm90b3R5cGUsZ2U9bmV3IGdlLChYPWxlLmFwcGx5KGdlLFgpKWluc3RhbmNlb2YgT2JqZWN0P1g6Z2V9KEIpKC4uLkcpLGY9YG1ldGhvZENhbGxlcjwoJHtjLm1hcChYPT5YLm5hbWUpLmpvaW4oXCIsIFwiKX0pID0+ICR7Yi5uYW1lfT5gLHNwKHdpKGYscykpfWZ1bmN0aW9uIGxwKHMpe3JldHVybiBzPWRyKHM+Pj4wKSxXZSh1W3NdKX1mdW5jdGlvbiBjcChzLGMpe3JldHVybiBjPj4+PTAscz1SZShzPj4+MCksYz1SZShjKSxXZShzW2NdKX1mdW5jdGlvbiBwcChzKXs5PChzPj4+PTApJiYodXRbcysxXSs9MSl9ZnVuY3Rpb24gbXAoKXtyZXR1cm4gV2UoW10pfWZ1bmN0aW9uIGZwKHMpe3M9UmUocz4+PjApO2Zvcih2YXIgYz1BcnJheShzLmxlbmd0aCksZj0wO2Y8cy5sZW5ndGg7ZisrKWNbZl09c1tmXTtyZXR1cm4gV2UoYyl9ZnVuY3Rpb24gaHAocyl7cmV0dXJuIFdlKGRyKHM+Pj4wKSl9ZnVuY3Rpb24gZ3AoKXtyZXR1cm4gV2Uoe30pfWZ1bmN0aW9uIGJwKHMpe2Zvcih2YXIgYz1SZShzPj4+PTApO2MubGVuZ3RoOyl7dmFyIGY9Yy5wb3AoKTtjLnBvcCgpKGYpfVRuKHMpfWZ1bmN0aW9uIHlwKHMsYyxmKXtjPj4+PTAsZj4+Pj0wLHM9UmUocz4+PjApLGM9UmUoYyksZj1SZShmKSxzW2NdPWZ9ZnVuY3Rpb24gX3AocyxjKXtyZXR1cm4gYz4+Pj0wLHM9KHM9aXIocz4+PjAsXCJfZW12YWxfdGFrZV92YWx1ZVwiKSkucmVhZFZhbHVlRnJvbVBvaW50ZXIoYyksV2Uocyl9ZnVuY3Rpb24gd3AocyxjKXtzPS05MDA3MTk5MjU0NzQwOTkyPnN8fDkwMDcxOTkyNTQ3NDA5OTI8cz9OYU46TnVtYmVyKHMpLGM+Pj49MCxzPW5ldyBEYXRlKDFlMypzKSxpKClbYz4+PjI+Pj4wXT1zLmdldFVUQ1NlY29uZHMoKSxpKClbYys0Pj4+Mj4+PjBdPXMuZ2V0VVRDTWludXRlcygpLGkoKVtjKzg+Pj4yPj4+MF09cy5nZXRVVENIb3VycygpLGkoKVtjKzEyPj4+Mj4+PjBdPXMuZ2V0VVRDRGF0ZSgpLGkoKVtjKzE2Pj4+Mj4+PjBdPXMuZ2V0VVRDTW9udGgoKSxpKClbYysyMD4+PjI+Pj4wXT1zLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxpKClbYysyND4+PjI+Pj4wXT1zLmdldFVUQ0RheSgpLHM9KHMuZ2V0VGltZSgpLURhdGUuVVRDKHMuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsaSgpW2MrMjg+Pj4yPj4+MF09c312YXIgQnQ9cz0+cyU0PT0wJiYocyUxMDAhPTB8fHMlNDAwPT0wKSx2aT1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSwkaT1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTtmdW5jdGlvbiB2cChzLGMpe3M9LTkwMDcxOTkyNTQ3NDA5OTI+c3x8OTAwNzE5OTI1NDc0MDk5MjxzP05hTjpOdW1iZXIocyksYz4+Pj0wLHM9bmV3IERhdGUoMWUzKnMpLGkoKVtjPj4+Mj4+PjBdPXMuZ2V0U2Vjb25kcygpLGkoKVtjKzQ+Pj4yPj4+MF09cy5nZXRNaW51dGVzKCksaSgpW2MrOD4+PjI+Pj4wXT1zLmdldEhvdXJzKCksaSgpW2MrMTI+Pj4yPj4+MF09cy5nZXREYXRlKCksaSgpW2MrMTY+Pj4yPj4+MF09cy5nZXRNb250aCgpLGkoKVtjKzIwPj4+Mj4+PjBdPXMuZ2V0RnVsbFllYXIoKS0xOTAwLGkoKVtjKzI0Pj4+Mj4+PjBdPXMuZ2V0RGF5KCk7dmFyIGY9KEJ0KHMuZ2V0RnVsbFllYXIoKSk/dmk6JGkpW3MuZ2V0TW9udGgoKV0rcy5nZXREYXRlKCktMXwwO2koKVtjKzI4Pj4+Mj4+PjBdPWYsaSgpW2MrMzY+Pj4yPj4+MF09LTYwKnMuZ2V0VGltZXpvbmVPZmZzZXQoKSxmPW5ldyBEYXRlKHMuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGI9bmV3IERhdGUocy5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtzPTB8KGYhPWImJnMuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4oYixmKSksaSgpW2MrMzI+Pj4yPj4+MF09c31mdW5jdGlvbiAkcChzKXtzPj4+PTA7dmFyIGM9bmV3IERhdGUoaSgpW3MrMjA+Pj4yPj4+MF0rMTkwMCxpKClbcysxNj4+PjI+Pj4wXSxpKClbcysxMj4+PjI+Pj4wXSxpKClbcys4Pj4+Mj4+PjBdLGkoKVtzKzQ+Pj4yPj4+MF0saSgpW3M+Pj4yPj4+MF0sMCksZj1pKClbcyszMj4+PjI+Pj4wXSxiPWMuZ2V0VGltZXpvbmVPZmZzZXQoKSx3PW5ldyBEYXRlKGMuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksST1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpLE89TWF0aC5taW4oSSx3KTtyZXR1cm4gMD5mP2koKVtzKzMyPj4+Mj4+PjBdPSsodyE9SSYmTz09Yik6MDxmIT0oTz09YikmJih3PU1hdGgubWF4KEksdyksYy5zZXRUaW1lKGMuZ2V0VGltZSgpKzZlNCooKDA8Zj9POncpLWIpKSksaSgpW3MrMjQ+Pj4yPj4+MF09Yy5nZXREYXkoKSxmPShCdChjLmdldEZ1bGxZZWFyKCkpP3ZpOiRpKVtjLmdldE1vbnRoKCldK2MuZ2V0RGF0ZSgpLTF8MCxpKClbcysyOD4+PjI+Pj4wXT1mLGkoKVtzPj4+Mj4+PjBdPWMuZ2V0U2Vjb25kcygpLGkoKVtzKzQ+Pj4yPj4+MF09Yy5nZXRNaW51dGVzKCksaSgpW3MrOD4+PjI+Pj4wXT1jLmdldEhvdXJzKCksaSgpW3MrMTI+Pj4yPj4+MF09Yy5nZXREYXRlKCksaSgpW3MrMTY+Pj4yPj4+MF09Yy5nZXRNb250aCgpLGkoKVtzKzIwPj4+Mj4+PjBdPWMuZ2V0WWVhcigpLHM9Yy5nZXRUaW1lKCksQmlnSW50KGlzTmFOKHMpPy0xOnMvMWUzKX1mdW5jdGlvbiB4aShzLGMsZixiLHcsSSxPKXtyZXR1cm4gZz8kZSgxNiwxLHMsYyxmLGIsdyxJLE8pOi01Mn1mdW5jdGlvbiBTaShzLGMsZixiLHcsSSl7aWYoZylyZXR1cm4gJGUoMTcsMSxzLGMsZixiLHcsSSl9ZnVuY3Rpb24geHAocyxjLGYsYil7cz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wO3ZhciB3PW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxJPW5ldyBEYXRlKHcsMCwxKSxPPW5ldyBEYXRlKHcsNiwxKTt3PUkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgQj1PLmdldFRpbWV6b25lT2Zmc2V0KCksRz1NYXRoLm1heCh3LEIpO2EoKVtzPj4+Mj4+PjBdPTYwKkcsaSgpW2M+Pj4yPj4+MF09Kyh3IT1CKSxJPShzPUY9PkYudG9Mb2NhbGVUaW1lU3RyaW5nKHZvaWQgMCx7aG91cjEyOiExLHRpbWVab25lTmFtZTpcInNob3J0XCJ9KS5zcGxpdChcIiBcIilbMV0pKEkpLE89cyhPKSxCPHc/KER0KEksZiwxNyksRHQoTyxiLDE3KSk6KER0KEksYiwxNyksRHQoTyxmLDE3KSl9dmFyIEVuPVtdLFRpPShzLGMpPT57RW4ubGVuZ3RoPTA7Zm9yKHZhciBmO2Y9cigpW3MrKz4+PjBdOyl7dmFyIGI9ZiE9MTA1O2MrPShiJj1mIT0xMTIpJiZjJTg/NDowLEVuLnB1c2goZj09MTEyP2EoKVtjPj4+Mj4+PjBdOmY9PTEwNj9XW2M+Pj4zXTpmPT0xMDU/aSgpW2M+Pj4yPj4+MF06bCgpW2M+Pj4zPj4+MF0pLGMrPWI/ODo0fXJldHVybiBFbn07ZnVuY3Rpb24gU3AocyxjLGYpe3JldHVybiBzPj4+PTAsYz1UaShjPj4+MCxmPj4+MCksZ25bc10oLi4uYyl9ZnVuY3Rpb24gVHAocyxjLGYpe3JldHVybiBzPj4+PTAsYz1UaShjPj4+MCxmPj4+MCksZ25bc10oLi4uYyl9dmFyIElwPSgpPT57fSxDcD0oKT0+RGF0ZS5ub3coKTtmdW5jdGlvbiBBcChzLGMpe3JldHVybiBMKENlKHM+Pj4wLGM+Pj4wKSl9dmFyIElpLGtwPSgpPT57dGhyb3cgdnQrPTEsXCJ1bndpbmRcIn07ZnVuY3Rpb24gRXAoKXtyZXR1cm4gNDI5NDkwMTc2MH1JaT0oKT0+cGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKTt2YXIgUHA9KCk9Pm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O2Z1bmN0aW9uIHpwKCl7cmV0dXJuIGN0KFwiQ2Fubm90IHVzZSBlbXNjcmlwdGVuX3BjX2dldF9mdW5jdGlvbiB3aXRob3V0IC1zVVNFX09GRlNFVF9DT05WRVJURVJcIiksMH1mdW5jdGlvbiBPcChzKXtzPj4+PTA7dmFyIGM9cigpLmxlbmd0aDtpZihzPD1jfHw0Mjk0OTAxNzYwPHMpcmV0dXJuITE7Zm9yKHZhciBmPTE7ND49ZjtmKj0yKXt2YXIgYj1jKigxKy4yL2YpO2I9TWF0aC5taW4oYixzKzEwMDY2MzI5Nik7dmFyIHc9TWF0aDtiPU1hdGgubWF4KHMsYik7ZTp7dz0ody5taW4uY2FsbCh3LDQyOTQ5MDE3NjAsYisoNjU1MzYtYiU2NTUzNiklNjU1MzYpLUsuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzUpLzY1NTM2O3RyeXtLLmdyb3codykscGUoKTt2YXIgST0xO2JyZWFrIGV9Y2F0Y2h7fUk9dm9pZCAwfWlmKEkpcmV0dXJuITB9cmV0dXJuITF9dmFyIGxyPSgpPT4oY3QoXCJDYW5ub3QgdXNlIGNvbnZlcnRGcmFtZVRvUEMgKG5lZWRlZCBieSBfX2J1aWx0aW5fcmV0dXJuX2FkZHJlc3MpIHdpdGhvdXQgLXNVU0VfT0ZGU0VUX0NPTlZFUlRFUlwiKSwwKSxNdD17fSxDaT1zPT57cy5mb3JFYWNoKGM9Pnt2YXIgZj1scigpO2YmJihNdFtmXT1jKX0pfTtmdW5jdGlvbiBEcCgpe3ZhciBzPUVycm9yKCkuc3RhY2sudG9TdHJpbmcoKS5zcGxpdChgXG5gKTtyZXR1cm4gc1swXT09XCJFcnJvclwiJiZzLnNoaWZ0KCksQ2kocyksTXQuUWI9bHIoKSxNdC5mYz1zLE10LlFifWZ1bmN0aW9uIEJwKHMsYyxmKXtpZihzPj4+PTAsYz4+Pj0wLE10LlFiPT1zKXZhciBiPU10LmZjO2Vsc2UoYj1FcnJvcigpLnN0YWNrLnRvU3RyaW5nKCkuc3BsaXQoYFxuYCkpWzBdPT1cIkVycm9yXCImJmIuc2hpZnQoKSxDaShiKTtmb3IodmFyIHc9MztiW3ddJiZscigpIT1zOykrK3c7Zm9yKHM9MDtzPGYmJmJbcyt3XTsrK3MpaSgpW2MrNCpzPj4+Mj4+PjBdPWxyKCk7cmV0dXJuIHN9dmFyIFBuLHpuPXt9LEFpPSgpPT57aWYoIVBuKXt2YXIgcyxjPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOih0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOlwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHMgaW4gem4pem5bc109PT12b2lkIDA/ZGVsZXRlIGNbc106Y1tzXT16bltzXTt2YXIgZj1bXTtmb3IocyBpbiBjKWYucHVzaChgJHtzfT0ke2Nbc119YCk7UG49Zn1yZXR1cm4gUG59O2Z1bmN0aW9uIGtpKHMsYyl7aWYoZylyZXR1cm4gJGUoMTgsMSxzLGMpO3M+Pj49MCxjPj4+PTA7dmFyIGY9MDtyZXR1cm4gQWkoKS5mb3JFYWNoKChiLHcpPT57dmFyIEk9YytmO2Zvcih3PWEoKVtzKzQqdz4+PjI+Pj4wXT1JLEk9MDtJPGIubGVuZ3RoOysrSSl0KClbdysrPj4+MF09Yi5jaGFyQ29kZUF0KEkpO3QoKVt3Pj4+MF09MCxmKz1iLmxlbmd0aCsxfSksMH1mdW5jdGlvbiBFaShzLGMpe2lmKGcpcmV0dXJuICRlKDE5LDEscyxjKTtzPj4+PTAsYz4+Pj0wO3ZhciBmPUFpKCk7YSgpW3M+Pj4yPj4+MF09Zi5sZW5ndGg7dmFyIGI9MDtyZXR1cm4gZi5mb3JFYWNoKHc9PmIrPXcubGVuZ3RoKzEpLGEoKVtjPj4+Mj4+PjBdPWIsMH1mdW5jdGlvbiBQaShzKXtyZXR1cm4gZz8kZSgyMCwxLHMpOjUyfWZ1bmN0aW9uIHppKHMsYyxmLGIpe3JldHVybiBnPyRlKDIxLDEscyxjLGYsYik6NTJ9ZnVuY3Rpb24gT2kocyxjLGYsYil7cmV0dXJuIGc/JGUoMjIsMSxzLGMsZixiKTo3MH12YXIgTXA9W251bGwsW10sW11dO2Z1bmN0aW9uIERpKHMsYyxmLGIpe2lmKGcpcmV0dXJuICRlKDIzLDEscyxjLGYsYik7Yz4+Pj0wLGY+Pj49MCxiPj4+PTA7Zm9yKHZhciB3PTAsST0wO0k8ZjtJKyspe3ZhciBPPWEoKVtjPj4+Mj4+PjBdLEI9YSgpW2MrND4+PjI+Pj4wXTtjKz04O2Zvcih2YXIgRz0wO0c8QjtHKyspe3ZhciBGPXIoKVtPK0c+Pj4wXSxYPU1wW3NdO0Y9PT0wfHxGPT09MTA/KChzPT09MT9IOkwpKFlvKFgsMCkpLFgubGVuZ3RoPTApOlgucHVzaChGKX13Kz1CfXJldHVybiBhKClbYj4+PjI+Pj4wXT13LDB9dmFyIEJpPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sTWk9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxScD0ocyxjKT0+e3QoKS5zZXQocyxjPj4+MCl9O2Z1bmN0aW9uIFJpKHMsYyxmLGIpe2Z1bmN0aW9uIHcoeix1ZSxTZSl7Zm9yKHo9dHlwZW9mIHo9PVwibnVtYmVyXCI/ei50b1N0cmluZygpOnp8fFwiXCI7ei5sZW5ndGg8dWU7KXo9U2VbMF0rejtyZXR1cm4gen1mdW5jdGlvbiBJKHosdWUpe3JldHVybiB3KHosdWUsXCIwXCIpfWZ1bmN0aW9uIE8oeix1ZSl7ZnVuY3Rpb24gU2UoUWkpe3JldHVybiAwPlFpPy0xOjA8UWk/MTowfXZhciB4dDtyZXR1cm4oeHQ9U2Uoei5nZXRGdWxsWWVhcigpLXVlLmdldEZ1bGxZZWFyKCkpKT09PTAmJih4dD1TZSh6LmdldE1vbnRoKCktdWUuZ2V0TW9udGgoKSkpPT09MCYmKHh0PVNlKHouZ2V0RGF0ZSgpLXVlLmdldERhdGUoKSkpLHh0fWZ1bmN0aW9uIEIoeil7c3dpdGNoKHouZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gejtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gRyh6KXt2YXIgdWU9ei5DYjtmb3Ioej1uZXcgRGF0ZShuZXcgRGF0ZSh6LkRiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8dWU7KXt2YXIgU2U9ei5nZXRNb250aCgpLHh0PShCdCh6LmdldEZ1bGxZZWFyKCkpP0JpOk1pKVtTZV07aWYoISh1ZT54dC16LmdldERhdGUoKSkpe3ouc2V0RGF0ZSh6LmdldERhdGUoKSt1ZSk7YnJlYWt9dWUtPXh0LXouZ2V0RGF0ZSgpKzEsei5zZXREYXRlKDEpLDExPlNlP3ouc2V0TW9udGgoU2UrMSk6KHouc2V0TW9udGgoMCksei5zZXRGdWxsWWVhcih6LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBTZT1uZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCkrMSwwLDQpLHVlPUIobmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsNCkpLFNlPUIoU2UpLDA+PU8odWUseik/MD49TyhTZSx6KT96LmdldEZ1bGxZZWFyKCkrMTp6LmdldEZ1bGxZZWFyKCk6ei5nZXRGdWxsWWVhcigpLTF9cz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wO3ZhciBGPWEoKVtiKzQwPj4+Mj4+PjBdO2Zvcih2YXIgWCBpbiBiPXtsYzppKClbYj4+PjI+Pj4wXSxrYzppKClbYis0Pj4+Mj4+PjBdLEliOmkoKVtiKzg+Pj4yPj4+MF0sTWI6aSgpW2IrMTI+Pj4yPj4+MF0sSmI6aSgpW2IrMTY+Pj4yPj4+MF0sRGI6aSgpW2IrMjA+Pj4yPj4+MF0sdmI6aSgpW2IrMjQ+Pj4yPj4+MF0sQ2I6aSgpW2IrMjg+Pj4yPj4+MF0sc2M6aSgpW2IrMzI+Pj4yPj4+MF0samM6aSgpW2IrMzY+Pj4yPj4+MF0sbWM6Rj9DZShGKTpcIlwifSxmPUNlKGYpLEY9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSlmPWYucmVwbGFjZShuZXcgUmVnRXhwKFgsXCJnXCIpLEZbWF0pO3ZhciBsZT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGdlPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoWCBpbiBGPXtcIiVhXCI6ej0+bGVbei52Yl0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOno9PmxlW3oudmJdLFwiJWJcIjp6PT5nZVt6LkpiXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6ej0+Z2Vbei5KYl0sXCIlQ1wiOno9PkkoKHouRGIrMTkwMCkvMTAwfDAsMiksXCIlZFwiOno9Pkkoei5NYiwyKSxcIiVlXCI6ej0+dyh6Lk1iLDIsXCIgXCIpLFwiJWdcIjp6PT5HKHopLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpHLFwiJUhcIjp6PT5JKHouSWIsMiksXCIlSVwiOno9Pigoej16LkliKT09MD96PTEyOjEyPHomJih6LT0xMiksSSh6LDIpKSxcIiVqXCI6ej0+e2Zvcih2YXIgdWU9MCxTZT0wO1NlPD16LkpiLTE7dWUrPShCdCh6LkRiKzE5MDApP0JpOk1pKVtTZSsrXSk7cmV0dXJuIEkoei5NYit1ZSwzKX0sXCIlbVwiOno9Pkkoei5KYisxLDIpLFwiJU1cIjp6PT5JKHoua2MsMiksXCIlblwiOigpPT5gXG5gLFwiJXBcIjp6PT4wPD16LkliJiYxMj56LkliP1wiQU1cIjpcIlBNXCIsXCIlU1wiOno9Pkkoei5sYywyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6ej0+ei52Ynx8NyxcIiVVXCI6ej0+SShNYXRoLmZsb29yKCh6LkNiKzctei52YikvNyksMiksXCIlVlwiOno9Pnt2YXIgdWU9TWF0aC5mbG9vcigoei5DYis3LSh6LnZiKzYpJTcpLzcpO2lmKDI+PSh6LnZiKzM3MS16LkNiLTIpJTcmJnVlKyssdWUpdWU9PTUzJiYoKFNlPSh6LnZiKzM3MS16LkNiKSU3KT09NHx8U2U9PTMmJkJ0KHouRGIpfHwodWU9MSkpO2Vsc2V7dWU9NTI7dmFyIFNlPSh6LnZiKzctei5DYi0xKSU3OyhTZT09NHx8U2U9PTUmJkJ0KHouRGIlNDAwLTEpKSYmdWUrK31yZXR1cm4gSSh1ZSwyKX0sXCIld1wiOno9PnoudmIsXCIlV1wiOno9PkkoTWF0aC5mbG9vcigoei5DYis3LSh6LnZiKzYpJTcpLzcpLDIpLFwiJXlcIjp6PT4oei5EYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6ej0+ei5EYisxOTAwLFwiJXpcIjp6PT57dmFyIHVlPTA8PSh6PXouamMpO3JldHVybiB6PU1hdGguYWJzKHopLzYwLCh1ZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyh6LzYwKjEwMCt6JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ej0+ei5tYyxcIiUlXCI6KCk9PlwiJVwifSxmPWYucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKSxGKWYuaW5jbHVkZXMoWCkmJihmPWYucmVwbGFjZShuZXcgUmVnRXhwKFgsXCJnXCIpLEZbWF0oYikpKTtyZXR1cm4gWD1mdW5jdGlvbih6KXt2YXIgdWU9QXJyYXkodm4oeikrMSk7cmV0dXJuIFhvKHosdWUsMCx1ZS5sZW5ndGgpLHVlfShmPWYucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxYLmxlbmd0aD5jPzA6KFJwKFgscyksWC5sZW5ndGgtMSl9ZnVuY3Rpb24gVXAocyxjLGYsYil7cmV0dXJuIFJpKHM+Pj4wLGM+Pj4wLGY+Pj4wLGI+Pj4wKX1nfHxmdW5jdGlvbigpe2Zvcih2YXIgcz11Lm51bVRocmVhZHMtMTtzLS07KUZvKCk7SWUudW5zaGlmdCgoKT0+e3d0KyssZnVuY3Rpb24oYyl7Zz9jKCk6UHJvbWlzZS5hbGwocHQubWFwKEhvKSkudGhlbihjKX0oKCk9Pk9vKCkpfSl9KCk7Zm9yKHZhciBVaT1BcnJheSgyNTYpLGNyPTA7MjU2PmNyOysrY3IpVWlbY3JdPVN0cmluZy5mcm9tQ2hhckNvZGUoY3IpO2xpPVVpLG10PXUuQmluZGluZ0Vycm9yPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3Iocyl7c3VwZXIocyksdGhpcy5uYW1lPVwiQmluZGluZ0Vycm9yXCJ9fSx1LkludGVybmFsRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihzKXtzdXBlcihzKSx0aGlzLm5hbWU9XCJJbnRlcm5hbEVycm9yXCJ9fSx1dC5wdXNoKDAsMSx2b2lkIDAsMSxudWxsLDEsITAsMSwhMSwxKSx1LmNvdW50X2VtdmFsX2hhbmRsZXM9KCk9PnV0Lmxlbmd0aC8yLTUtU24ubGVuZ3RoO3ZhciBOcD1bX24sVm8scW8sWm8sUW8sSm8sZWksdGkscmksbmksb2ksaWksYWksc2ksdWksZGkseGksU2ksa2ksRWksUGksemksT2ksRGldLFo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBzKGYsYil7cmV0dXJuIFo9Zi5leHBvcnRzLFo9ZnVuY3Rpb24oKXt2YXIgdz1aLEk9e307Zm9yKGxldFtPLEJdb2YgT2JqZWN0LmVudHJpZXModykpSVtPXT10eXBlb2YgQj09XCJmdW5jdGlvblwiPyguLi5HKT0+e3NyLnB1c2goTyk7dHJ5e3JldHVybiBCKC4uLkcpfWZpbmFsbHl7RGV8fChzci5wb3AoKSxYZSYmaHQ9PT0xJiZzci5sZW5ndGg9PT0wJiYoaHQ9MCx2dCs9MSxhcihLaSksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLnRjKCkpKX19OkI7cmV0dXJuIEl9KCksWj1mdW5jdGlvbigpe3ZhciB3PVosST1CPT5HPT5CKEcpPj4+MCxPPUI9PigpPT5CKCk+Pj4wO3JldHVybih3PU9iamVjdC5hc3NpZ24oe30sdykpLkRhPUkody5EYSksdy5nYj1PKHcuZ2IpLHcuaWI9SSh3LmliKSx3LmVtc2NyaXB0ZW5fbWFpbl9ydW50aW1lX3RocmVhZF9pZD1PKHcuZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkKSx3LnRiPUkody50Yiksdy51Yj1PKHcudWIpLHd9KCksV28ucHVzaChaLmpiKSxIZS51bnNoaWZ0KFouQ2EpLHdlPWIsT28oKSxafXZhciBjPVVvKCk7aWYod3QrKyx1Lmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIHUuaW5zdGFudGlhdGVXYXNtKGMscyl9Y2F0Y2goZil7TChgTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJHtmfWApLG0oZil9cmV0dXJuIGhufHw9dS5sb2NhdGVGaWxlP0RvKFwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21cIik/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiOnUubG9jYXRlRmlsZT91LmxvY2F0ZUZpbGUoXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiLEMpOkMrXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiOm5ldyBVUkwoXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiLGltcG9ydC5tZXRhLnVybCkuaHJlZixmdW5jdGlvbihmLGIpe3ZhciB3PWhuO3JldHVybiBQfHx0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmchPVwiZnVuY3Rpb25cInx8RG8odyl8fEJvKHcpfHx0eXBlb2YgZmV0Y2ghPVwiZnVuY3Rpb25cIj9Sbyh3LGYsYik6ZmV0Y2godyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihJPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhJLGYpLnRoZW4oYixmdW5jdGlvbihPKXtyZXR1cm4gTChgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7T31gKSxMKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksUm8odyxmLGIpfSkpfShjLGZ1bmN0aW9uKGYpe3MoZi5pbnN0YW5jZSxmLm1vZHVsZSl9KS5jYXRjaChtKSx7fX0oKSxOaT1zPT4oTmk9Wi5EYSkocyksVmk9KCk9PihWaT1aLkVhKSgpO3UuX09ydEluaXQ9KHMsYyk9Pih1Ll9PcnRJbml0PVouRmEpKHMsYyksdS5fT3J0R2V0TGFzdEVycm9yPShzLGMpPT4odS5fT3J0R2V0TGFzdEVycm9yPVouR2EpKHMsYyksdS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9KHMsYyxmLGIsdyxJLE8sQixHLEYpPT4odS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9Wi5IYSkocyxjLGYsYix3LEksTyxCLEcsRiksdS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9KHMsYyk9Pih1Ll9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1aLklhKShzLGMpLHUuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT0ocyxjLGYpPT4odS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPVouSmEpKHMsYyxmKSx1Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9KHMsYyxmKT0+KHUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1aLkthKShzLGMsZiksdS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPXM9Pih1Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9Wi5MYSkocyksdS5fT3J0Q3JlYXRlU2Vzc2lvbj0ocyxjLGYpPT4odS5fT3J0Q3JlYXRlU2Vzc2lvbj1aLk1hKShzLGMsZiksdS5fT3J0UmVsZWFzZVNlc3Npb249cz0+KHUuX09ydFJlbGVhc2VTZXNzaW9uPVouTmEpKHMpLHUuX09ydEdldElucHV0T3V0cHV0Q291bnQ9KHMsYyxmKT0+KHUuX09ydEdldElucHV0T3V0cHV0Q291bnQ9Wi5PYSkocyxjLGYpLHUuX09ydEdldElucHV0TmFtZT0ocyxjKT0+KHUuX09ydEdldElucHV0TmFtZT1aLlBhKShzLGMpLHUuX09ydEdldE91dHB1dE5hbWU9KHMsYyk9Pih1Ll9PcnRHZXRPdXRwdXROYW1lPVouUWEpKHMsYyksdS5fT3J0RnJlZT1zPT4odS5fT3J0RnJlZT1aLlJhKShzKSx1Ll9PcnRDcmVhdGVUZW5zb3I9KHMsYyxmLGIsdyxJKT0+KHUuX09ydENyZWF0ZVRlbnNvcj1aLlNhKShzLGMsZixiLHcsSSksdS5fT3J0R2V0VGVuc29yRGF0YT0ocyxjLGYsYix3KT0+KHUuX09ydEdldFRlbnNvckRhdGE9Wi5UYSkocyxjLGYsYix3KSx1Ll9PcnRSZWxlYXNlVGVuc29yPXM9Pih1Ll9PcnRSZWxlYXNlVGVuc29yPVouVWEpKHMpLHUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KHMsYyxmLGIpPT4odS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1aLlZhKShzLGMsZixiKSx1Ll9PcnRBZGRSdW5Db25maWdFbnRyeT0ocyxjLGYpPT4odS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9Wi5XYSkocyxjLGYpLHUuX09ydFJlbGVhc2VSdW5PcHRpb25zPXM9Pih1Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucz1aLlhhKShzKSx1Ll9PcnRDcmVhdGVCaW5kaW5nPXM9Pih1Ll9PcnRDcmVhdGVCaW5kaW5nPVouWWEpKHMpLHUuX09ydEJpbmRJbnB1dD0ocyxjLGYpPT4odS5fT3J0QmluZElucHV0PVouWmEpKHMsYyxmKSx1Ll9PcnRCaW5kT3V0cHV0PShzLGMsZixiKT0+KHUuX09ydEJpbmRPdXRwdXQ9Wi5fYSkocyxjLGYsYiksdS5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9cz0+KHUuX09ydENsZWFyQm91bmRPdXRwdXRzPVouJGEpKHMpLHUuX09ydFJlbGVhc2VCaW5kaW5nPXM9Pih1Ll9PcnRSZWxlYXNlQmluZGluZz1aLmFiKShzKSx1Ll9PcnRSdW5XaXRoQmluZGluZz0ocyxjLGYsYix3KT0+KHUuX09ydFJ1bldpdGhCaW5kaW5nPVouYmIpKHMsYyxmLGIsdyksdS5fT3J0UnVuPShzLGMsZixiLHcsSSxPLEIpPT4odS5fT3J0UnVuPVouY2IpKHMsYyxmLGIsdyxJLE8sQiksdS5fT3J0RW5kUHJvZmlsaW5nPXM9Pih1Ll9PcnRFbmRQcm9maWxpbmc9Wi5kYikocyksdS5fSnNlcE91dHB1dD0ocyxjLGYpPT4odS5fSnNlcE91dHB1dD1aLmViKShzLGMsZiksdS5fSnNlcEdldE5vZGVOYW1lPXM9Pih1Ll9Kc2VwR2V0Tm9kZU5hbWU9Wi5mYikocyk7dmFyIHByLFJ0PSgpPT4oUnQ9Wi5nYikoKSxKZT11Ll9mcmVlPXM9PihKZT11Ll9mcmVlPVouaGIpKHMpLG1yPXUuX21hbGxvYz1zPT4obXI9dS5fbWFsbG9jPVouaWIpKHMpLE9uPShzLGMsZixiLHcsSSk9PihPbj1aLmxiKShzLGMsZixiLHcsSSksV2k9KCk9PihXaT1aLm1iKSgpLExpPShzLGMsZixiLHcpPT4oTGk9Wi5uYikocyxjLGYsYix3KSxEbj1zPT4oRG49Wi5vYikocyksZnI9cz0+KGZyPVoucGIpKHMpLEdpPSgpPT4oR2k9Wi5xYikoKSxIaT0ocyxjKT0+KEhpPVoucmIpKHMsYyksaHI9cz0+KGhyPVouc2IpKHMpLEJuPXM9PihCbj1aLnRiKShzKSxNbj0oKT0+KE1uPVoudWIpKCksRmk9dS5keW5DYWxsX2lpPShzLGMpPT4oRmk9dS5keW5DYWxsX2lpPVoud2IpKHMsYykscWk9cz0+KHFpPVoueGIpKHMpLEtpPSgpPT4oS2k9Wi55YikoKSxqaT1zPT4oamk9Wi56YikocyksWWk9KCk9PihZaT1aLkFiKSgpO2Z1bmN0aW9uIFppKCl7MDx3dHx8KGc/KHAodSksZ3x8bnIoSGUpLHN0YXJ0V29ya2VyKHUpKToobnIoSWUpLDA8d3R8fHByfHwocHI9ITAsdS5jYWxsZWRSdW49ITAsRGV8fChnfHxucihIZSkscCh1KSxnfHxucihtbikpKSkpfXJldHVybiB1Ll9fX3N0YXJ0X2VtX2pzPTkzMjQ2OSx1Ll9fX3N0b3BfZW1fanM9OTMyNzE1LHUuc3RhY2tTYXZlPSgpPT5NbigpLHUuc3RhY2tSZXN0b3JlPXM9PmhyKHMpLHUuc3RhY2tBbGxvYz1zPT5CbihzKSx1LnNldFZhbHVlPWZ1bmN0aW9uKHMsYyxmPVwiaThcIil7c3dpdGNoKGYuZW5kc1dpdGgoXCIqXCIpJiYoZj1cIipcIiksZil7Y2FzZVwiaTFcIjpjYXNlXCJpOFwiOnQoKVtzPj4+MF09YzticmVhaztjYXNlXCJpMTZcIjpuKClbcz4+PjE+Pj4wXT1jO2JyZWFrO2Nhc2VcImkzMlwiOmkoKVtzPj4+Mj4+PjBdPWM7YnJlYWs7Y2FzZVwiaTY0XCI6V1tzPj4+M109QmlnSW50KGMpO2JyZWFrO2Nhc2VcImZsb2F0XCI6ZCgpW3M+Pj4yPj4+MF09YzticmVhaztjYXNlXCJkb3VibGVcIjpsKClbcz4+PjM+Pj4wXT1jO2JyZWFrO2Nhc2VcIipcIjphKClbcz4+PjI+Pj4wXT1jO2JyZWFrO2RlZmF1bHQ6Y3QoYGludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICR7Zn1gKX19LHUuZ2V0VmFsdWU9ZnVuY3Rpb24ocyxjPVwiaThcIil7c3dpdGNoKGMuZW5kc1dpdGgoXCIqXCIpJiYoYz1cIipcIiksYyl7Y2FzZVwiaTFcIjpjYXNlXCJpOFwiOnJldHVybiB0KClbcz4+PjBdO2Nhc2VcImkxNlwiOnJldHVybiBuKClbcz4+PjE+Pj4wXTtjYXNlXCJpMzJcIjpyZXR1cm4gaSgpW3M+Pj4yPj4+MF07Y2FzZVwiaTY0XCI6cmV0dXJuIFdbcz4+PjNdO2Nhc2VcImZsb2F0XCI6cmV0dXJuIGQoKVtzPj4+Mj4+PjBdO2Nhc2VcImRvdWJsZVwiOnJldHVybiBsKClbcz4+PjM+Pj4wXTtjYXNlXCIqXCI6cmV0dXJuIGEoKVtzPj4+Mj4+PjBdO2RlZmF1bHQ6Y3QoYGludmFsaWQgdHlwZSBmb3IgZ2V0VmFsdWU6ICR7Y31gKX19LHUuVVRGOFRvU3RyaW5nPUNlLHUuc3RyaW5nVG9VVEY4PUR0LHUubGVuZ3RoQnl0ZXNVVEY4PXZuLEd0PWZ1bmN0aW9uIHMoKXtwcnx8WmkoKSxwcnx8KEd0PXMpfSxaaSgpLHUuUFRSX1NJWkU9NCxofSksS3A9UGE7Z2xvYmFsVGhpcy5zZWxmPy5uYW1lPT09XCJlbS1wdGhyZWFkXCImJlBhKCl9KTt2YXIgTWEsanAsVmUsUmEsS24sWXAsWnAsVWEsUXAsRGEsTmEsQmEsVmEsJHI9VSgoKT0+e1widXNlIHN0cmljdFwiO3ZyKCk7TWE9ITF8fHR5cGVvZiBsb2NhdGlvbj5cInVcIj92b2lkIDA6bG9jYXRpb24ub3JpZ2luLGpwPSgpPT57aWYoISExKXJldHVybiBpbXBvcnQubWV0YS51cmw/LnN0YXJ0c1dpdGgoXCJmaWxlOlwiKT9uZXcgVVJMKG5ldyBVUkwoXCJvcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmLE1hKS5ocmVmOmltcG9ydC5tZXRhLnVybH0sVmU9anAoKSxSYT0oKT0+e2lmKFZlJiYhVmUuc3RhcnRzV2l0aChcImJsb2I6XCIpKXJldHVybiBWZS5zdWJzdHJpbmcoMCxWZS5sYXN0SW5kZXhPZihcIi9cIikrMSl9LEtuPShlLHQpPT57dHJ5e2xldCByPXQ/P1ZlO3JldHVybihyP25ldyBVUkwoZSxyKTpuZXcgVVJMKGUpKS5vcmlnaW49PT1NYX1jYXRjaHtyZXR1cm4hMX19LFlwPShlLHQpPT57bGV0IHI9dD8/VmU7dHJ5e3JldHVybihyP25ldyBVUkwoZSxyKTpuZXcgVVJMKGUpKS5ocmVmfWNhdGNoe3JldHVybn19LFpwPShlLHQpPT5gJHt0Pz9cIi4vXCJ9JHtlfWAsVWE9YXN5bmMgZT0+e2xldCByPWF3YWl0KGF3YWl0IGZldGNoKGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pKS5ibG9iKCk7cmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwocil9LFFwPWFzeW5jIGU9Pihhd2FpdCBpbXBvcnQoLyp3ZWJwYWNrSWdub3JlOnRydWUqL2UpKS5kZWZhdWx0LERhPShFYSgpLGdyKGthKSkuZGVmYXVsdCxOYT1hc3luYygpPT57aWYoIVZlKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIHByb3h5IHdvcmtlcjogY2Fubm90IGRldGVybWluZSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuXCIpO2lmKEtuKFZlKSlyZXR1cm5bdm9pZCAwLERhKCldO2xldCBlPWF3YWl0IFVhKFZlKTtyZXR1cm5bZSxEYShlKV19LEJhPShPYSgpLGdyKHphKSkuZGVmYXVsdCxWYT1hc3luYyhlLHQscik9PntpZighZSYmIXQmJkJhJiZWZSYmS24oVmUpKXJldHVyblt2b2lkIDAsQmFdO3tsZXQgbj1cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNcIixvPWU/P1lwKG4sdCksaT0hITEmJnImJm8mJiFLbihvLHQpLGE9aT9hd2FpdCBVYShvKTpvPz9acChuLHQpO3JldHVybltpP2E6dm9pZCAwLGF3YWl0IFFwKGEpXX19fSk7dmFyIGpuLFluLFByLFdhLFhwLEpwLHhyLFRlLGd0PVUoKCk9PntcInVzZSBzdHJpY3RcIjskcigpO1luPSExLFByPSExLFdhPSExLFhwPSgpPT57aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPlwidVwiKXJldHVybiExO3RyeXtyZXR1cm4gdHlwZW9mIE1lc3NhZ2VDaGFubmVsPFwidVwiJiZuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxKcD0oKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSx4cj1hc3luYyBlPT57aWYoWW4pcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKFByKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZGV0ZWN0ZWQuXCIpO2lmKFdhKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO1ByPSEwO2xldCB0PWUuaW5pdFRpbWVvdXQscj1lLm51bVRocmVhZHM7aWYoIUpwKCkpdGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlwiKTtsZXQgbj1YcCgpO3I+MSYmIW4mJih0eXBlb2Ygc2VsZjxcInVcIiYmIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCYmY29uc29sZS53YXJuKFwiZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gXCIrcitcIiwgYnV0IHRoaXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGVuYWJsZSBjcm9zc09yaWdpbklzb2xhdGVkIG1vZGUuIFNlZSBodHRwczovL3dlYi5kZXYvY3Jvc3Mtb3JpZ2luLWlzb2xhdGlvbi1ndWlkZS8gZm9yIG1vcmUgaW5mby5cIiksY29uc29sZS53YXJuKFwiV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEZhbGxpbmcgYmFjayB0byBzaW5nbGUtdGhyZWFkaW5nLlwiKSxlLm51bVRocmVhZHM9cj0xKTtsZXQgbz1lLndhc21QYXRocyxpPXR5cGVvZiBvPT1cInN0cmluZ1wiP286dm9pZCAwLGE9bz8ubWpzLGQ9YT8uaHJlZj8/YSxsPW8/Lndhc20scD1sPy5ocmVmPz9sLG09ZS53YXNtQmluYXJ5LFt1LGhdPWF3YWl0IFZhKGQsaSxyPjEpLF89ITEseT1bXTtpZih0PjAmJnkucHVzaChuZXcgUHJvbWlzZShnPT57c2V0VGltZW91dCgoKT0+e189ITAsZygpfSx0KX0pKSx5LnB1c2gobmV3IFByb21pc2UoKGcseCk9PntsZXQgJD17bnVtVGhyZWFkczpyfTtpZihtKSQud2FzbUJpbmFyeT1tO2Vsc2UgaWYocHx8aSkkLmxvY2F0ZUZpbGU9dj0+cD8/aSt2O2Vsc2UgaWYoZCYmZC5pbmRleE9mKFwiYmxvYjpcIikhPT0wKSQubG9jYXRlRmlsZT12PT5uZXcgVVJMKHYsZCkuaHJlZjtlbHNlIGlmKHUpe2xldCB2PVJhKCk7diYmKCQubG9jYXRlRmlsZT1TPT52K1MpfWgoJCkudGhlbih2PT57UHI9ITEsWW49ITAsam49dixnKCksdSYmVVJMLnJldm9rZU9iamVjdFVSTCh1KX0sdj0+e1ByPSExLFdhPSEwLHgodil9KX0pKSxhd2FpdCBQcm9taXNlLnJhY2UoeSksXyl0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LFRlPSgpPT57aWYoWW4mJmpuKXJldHVybiBqbjt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX19KTt2YXIga2UsS3QsY2UsenI9VSgoKT0+e1widXNlIHN0cmljdFwiO2d0KCk7a2U9KGUsdCk9PntsZXQgcj1UZSgpLG49ci5sZW5ndGhCeXRlc1VURjgoZSkrMSxvPXIuX21hbGxvYyhuKTtyZXR1cm4gci5zdHJpbmdUb1VURjgoZSxvLG4pLHQucHVzaChvKSxvfSxLdD0oZSx0LHIsbik9PntpZih0eXBlb2YgZT09XCJvYmplY3RcIiYmZSE9PW51bGwpe2lmKHIuaGFzKGUpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO3IuYWRkKGUpfU9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtvLGldKT0+e2xldCBhPXQ/dCtvOm87aWYodHlwZW9mIGk9PVwib2JqZWN0XCIpS3QoaSxhK1wiLlwiLHIsbik7ZWxzZSBpZih0eXBlb2YgaT09XCJzdHJpbmdcInx8dHlwZW9mIGk9PVwibnVtYmVyXCIpbihhLGkudG9TdHJpbmcoKSk7ZWxzZSBpZih0eXBlb2YgaT09XCJib29sZWFuXCIpbihhLGk/XCIxXCI6XCIwXCIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIGl9YCl9KX0sY2U9ZT0+e2xldCB0PVRlKCkscj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgbj10LlBUUl9TSVpFLG89dC5zdGFja0FsbG9jKDIqbik7dC5fT3J0R2V0TGFzdEVycm9yKG8sbytuKTtsZXQgaT1OdW1iZXIodC5nZXRWYWx1ZShvLG49PT00P1wiaTMyXCI6XCJpNjRcIikpLGE9dC5nZXRWYWx1ZShvK24sXCIqXCIpLGQ9YT90LlVURjhUb1N0cmluZyhhKTpcIlwiO3Rocm93IG5ldyBFcnJvcihgJHtlfSBFUlJPUl9DT0RFOiAke2l9LCBFUlJPUl9NRVNTQUdFOiAke2R9YCl9ZmluYWxseXt0LnN0YWNrUmVzdG9yZShyKX19fSk7dmFyIExhLEdhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtndCgpO3pyKCk7TGE9ZT0+e2xldCB0PVRlKCkscj0wLG49W10sbz1lfHx7fTt0cnl7aWYoZT8ubG9nU2V2ZXJpdHlMZXZlbD09PXZvaWQgMClvLmxvZ1NldmVyaXR5TGV2ZWw9MjtlbHNlIGlmKHR5cGVvZiBlLmxvZ1NldmVyaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nU2V2ZXJpdHlMZXZlbCl8fGUubG9nU2V2ZXJpdHlMZXZlbDwwfHxlLmxvZ1NldmVyaXR5TGV2ZWw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nU2V2ZXJpdHlMZXZlbH1gKTtpZihlPy5sb2dWZXJib3NpdHlMZXZlbD09PXZvaWQgMClvLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZih0eXBlb2YgZS5sb2dWZXJib3NpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1ZlcmJvc2l0eUxldmVsfWApO2U/LnRlcm1pbmF0ZT09PXZvaWQgMCYmKG8udGVybWluYXRlPSExKTtsZXQgaT0wO3JldHVybiBlPy50YWchPT12b2lkIDAmJihpPWtlKGUudGFnLG4pKSxyPXQuX09ydENyZWF0ZVJ1bk9wdGlvbnMoby5sb2dTZXZlcml0eUxldmVsLG8ubG9nVmVyYm9zaXR5TGV2ZWwsISFvLnRlcm1pbmF0ZSxpKSxyPT09MCYmY2UoXCJDYW4ndCBjcmVhdGUgcnVuIG9wdGlvbnMuXCIpLGU/LmV4dHJhIT09dm9pZCAwJiZLdChlLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKGEsZCk9PntsZXQgbD1rZShhLG4pLHA9a2UoZCxuKTt0Ll9PcnRBZGRSdW5Db25maWdFbnRyeShyLGwscCkhPT0wJiZjZShgQ2FuJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHthfSAtICR7ZH0uYCl9KSxbcixuXX1jYXRjaChpKXt0aHJvdyByIT09MCYmdC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMociksbi5mb3JFYWNoKGE9PnQuX2ZyZWUoYSkpLGl9fX0pO3ZhciBlbSx0bSxybSxubSxIYSxGYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z3QoKTt6cigpO2VtPWU9Pntzd2l0Y2goZSl7Y2FzZVwiZGlzYWJsZWRcIjpyZXR1cm4gMDtjYXNlXCJiYXNpY1wiOnJldHVybiAxO2Nhc2VcImV4dGVuZGVkXCI6cmV0dXJuIDI7Y2FzZVwiYWxsXCI6cmV0dXJuIDk5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7ZX1gKX19LHRtPWU9Pntzd2l0Y2goZSl7Y2FzZVwic2VxdWVudGlhbFwiOnJldHVybiAwO2Nhc2VcInBhcmFsbGVsXCI6cmV0dXJuIDE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke2V9YCl9fSxybT1lPT57ZS5leHRyYXx8KGUuZXh0cmE9e30pLGUuZXh0cmEuc2Vzc2lvbnx8KGUuZXh0cmEuc2Vzc2lvbj17fSk7bGV0IHQ9ZS5leHRyYS5zZXNzaW9uO3QudXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseXx8KHQudXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseT1cIjFcIiksZS5leGVjdXRpb25Qcm92aWRlcnMmJmUuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUocj0+KHR5cGVvZiByPT1cInN0cmluZ1wiP3I6ci5uYW1lKT09PVwid2ViZ3B1XCIpJiYoZS5lbmFibGVNZW1QYXR0ZXJuPSExKX0sbm09KGUsdCxyKT0+e2ZvcihsZXQgbiBvZiB0KXtsZXQgbz10eXBlb2Ygbj09XCJzdHJpbmdcIj9uOm4ubmFtZTtzd2l0Y2gobyl7Y2FzZVwid2Vibm5cIjppZihvPVwiV0VCTk5cIix0eXBlb2YgbiE9XCJzdHJpbmdcIil7bGV0IGQ9bj8uZGV2aWNlVHlwZTtpZihkKXtsZXQgbD1rZShcImRldmljZVR5cGVcIixyKSxwPWtlKGQscik7VGUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsbCxwKSE9PTAmJmNlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2RldmljZVR5cGUnIC0gJHtkfS5gKX19YnJlYWs7Y2FzZVwid2ViZ3B1XCI6aWYobz1cIkpTXCIsdHlwZW9mIG4hPVwic3RyaW5nXCIpe2xldCBhPW47aWYoYT8ucHJlZmVycmVkTGF5b3V0KXtpZihhLnByZWZlcnJlZExheW91dCE9PVwiTkNIV1wiJiZhLnByZWZlcnJlZExheW91dCE9PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyICdOQ0hXJyBvciAnTkhXQyc6ICR7YS5wcmVmZXJyZWRMYXlvdXR9YCk7bGV0IGQ9a2UoXCJwcmVmZXJyZWRMYXlvdXRcIixyKSxsPWtlKGEucHJlZmVycmVkTGF5b3V0LHIpO1RlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGQsbCkhPT0wJiZjZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwcmVmZXJyZWRMYXlvdXQnIC0gJHthLnByZWZlcnJlZExheW91dH0uYCl9fWJyZWFrO2Nhc2VcIndhc21cIjpjYXNlXCJjcHVcIjpjb250aW51ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7b31gKX1sZXQgaT1rZShvLHIpO1RlKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKGUsaSkhPT0wJiZjZShgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtvfS5gKX19LEhhPWU9PntsZXQgdD1UZSgpLHI9MCxuPVtdLG89ZXx8e307cm0obyk7dHJ5e2xldCBpPWVtKG8uZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD8/XCJhbGxcIiksYT10bShvLmV4ZWN1dGlvbk1vZGU/P1wic2VxdWVudGlhbFwiKSxkPXR5cGVvZiBvLmxvZ0lkPT1cInN0cmluZ1wiP2tlKG8ubG9nSWQsbik6MCxsPW8ubG9nU2V2ZXJpdHlMZXZlbD8/MjtpZighTnVtYmVyLmlzSW50ZWdlcihsKXx8bDwwfHxsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtsfWApO2xldCBwPW8ubG9nVmVyYm9zaXR5TGV2ZWw/PzA7aWYoIU51bWJlci5pc0ludGVnZXIocCl8fHA8MHx8cD40KXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7cH1gKTtsZXQgbT10eXBlb2Ygby5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPT1cInN0cmluZ1wiP2tlKG8ub3B0aW1pemVkTW9kZWxGaWxlUGF0aCxuKTowO2lmKHI9dC5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMoaSwhIW8uZW5hYmxlQ3B1TWVtQXJlbmEsISFvLmVuYWJsZU1lbVBhdHRlcm4sYSwhIW8uZW5hYmxlUHJvZmlsaW5nLDAsZCxsLHAsbSkscj09PTAmJmNlKFwiQ2FuJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIiksby5leGVjdXRpb25Qcm92aWRlcnMmJm5tKHIsby5leGVjdXRpb25Qcm92aWRlcnMsbiksby5lbmFibGVHcmFwaENhcHR1cmUhPT12b2lkIDApe2lmKHR5cGVvZiBvLmVuYWJsZUdyYXBoQ2FwdHVyZSE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEVycm9yKGBlbmFibGVHcmFwaENhcHR1cmUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWU6ICR7by5lbmFibGVHcmFwaENhcHR1cmV9YCk7bGV0IHU9a2UoXCJlbmFibGVHcmFwaENhcHR1cmVcIixuKSxoPWtlKG8uZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCksbik7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHIsdSxoKSE9PTAmJmNlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2VuYWJsZUdyYXBoQ2FwdHVyZScgLSAke28uZW5hYmxlR3JhcGhDYXB0dXJlfS5gKX1pZihvLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpZm9yKGxldFt1LGhdb2YgT2JqZWN0LmVudHJpZXMoby5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSl7aWYodHlwZW9mIHUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSBuYW1lIG11c3QgYmUgYSBzdHJpbmc6ICR7dX1gKTtpZih0eXBlb2YgaCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoaCl8fGg8MCl0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIHZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcjogJHtofWApO2xldCBfPWtlKHUsbik7dC5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlKHIsXyxoKSE9PTAmJmNlKGBDYW4ndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHt1fSAtICR7aH0uYCl9cmV0dXJuIG8uZXh0cmEhPT12b2lkIDAmJkt0KG8uZXh0cmEsXCJcIixuZXcgV2Vha1NldCwodSxoKT0+e2xldCBfPWtlKHUsbikseT1rZShoLG4pO3QuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShyLF8seSkhPT0wJiZjZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7dX0gLSAke2h9LmApfSksW3Isbl19Y2F0Y2goaSl7dGhyb3cgciE9PTAmJnQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhyKSE9PTAmJmNlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpLG4uZm9yRWFjaChhPT50Ll9mcmVlKGEpKSxpfX19KTt2YXIganQsYnQsQXQsT3IsWXQsRHIsQnIsWm4sSj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7anQ9ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2Nhc2VcImludDRcIjpyZXR1cm4gMjI7Y2FzZVwidWludDRcIjpyZXR1cm4gMjE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sYnQ9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDEwOnJldHVyblwiZmxvYXQxNlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2Nhc2UgMjI6cmV0dXJuXCJpbnQ0XCI7Y2FzZSAyMTpyZXR1cm5cInVpbnQ0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sQXQ9KGUsdCk9PntsZXQgcj1bLTEsNCwxLDEsMiwyLDQsOCwtMSwxLDIsOCw0LDgsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLjUsLjVdW2VdLG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0LnJlZHVjZSgobyxpKT0+byppLDEpO3JldHVybiByPjA/TWF0aC5jZWlsKG4qcik6dm9pZCAwfSxPcj1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb20/RmxvYXQxNkFycmF5OlVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSxZdD1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0sRHI9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixCcj1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ2NFwifHxlPT09XCJpbnQ4XCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLFpuPWU9Pntzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybiA1O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2V9YCl9fX0pO3ZhciBadCxRbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dnIoKTtadD1hc3luYyBlPT57aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpaWYoITEpdHJ5e2xldHtyZWFkRmlsZTp0fT1VbihcIm5vZGU6ZnMvcHJvbWlzZXNcIik7cmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQoZSkpfWNhdGNoKHQpe2lmKHQuY29kZT09PVwiRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFXCIpe2xldHtjcmVhdGVSZWFkU3RyZWFtOnJ9PVVuKFwibm9kZTpmc1wiKSxuPXIoZSksbz1bXTtmb3IgYXdhaXQobGV0IGkgb2YgbilvLnB1c2goaSk7cmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQobykpfXRocm93IHR9ZWxzZXtsZXQgdD1hd2FpdCBmZXRjaChlKTtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfWApO2xldCByPXQuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSxuPXI/cGFyc2VJbnQociwxMCk6MDtpZihuPDEwNzM3NDE4MjQpcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQuYXJyYXlCdWZmZXIoKSk7e2lmKCF0LmJvZHkpdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZX0sIG5vIHJlc3BvbnNlIGJvZHkuYCk7bGV0IG89dC5ib2R5LmdldFJlYWRlcigpLGk7dHJ5e2k9bmV3IEFycmF5QnVmZmVyKG4pfWNhdGNoKGQpe2lmKGQgaW5zdGFuY2VvZiBSYW5nZUVycm9yKXtsZXQgbD1NYXRoLmNlaWwobi82NTUzNik7aT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOmwsbWF4aW11bTpsfSkuYnVmZmVyfWVsc2UgdGhyb3cgZH1sZXQgYT0wO2Zvcig7Oyl7bGV0e2RvbmU6ZCx2YWx1ZTpsfT1hd2FpdCBvLnJlYWQoKTtpZihkKWJyZWFrO2xldCBwPWwuYnl0ZUxlbmd0aDtuZXcgVWludDhBcnJheShpLGEscCkuc2V0KGwpLGErPXB9cmV0dXJuIG5ldyBVaW50OEFycmF5KGksMCxuKX19ZWxzZSByZXR1cm4gZSBpbnN0YW5jZW9mIEJsb2I/bmV3IFVpbnQ4QXJyYXkoYXdhaXQgZS5hcnJheUJ1ZmZlcigpKTplIGluc3RhbmNlb2YgVWludDhBcnJheT9lOm5ldyBVaW50OEFycmF5KGUpfX0pO3ZhciBvbSxpbSxxYSxLYSxNcixhbSxzZSxldD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO29tPVtcIlZcIixcIklcIixcIldcIixcIkVcIixcIkZcIl0saW09KGUsdCk9Pntjb25zb2xlLmxvZyhgWyR7b21bZV19LCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfV0ke3R9YCl9LE1yPShlLHQpPT57cWE9ZSxLYT10fSxhbT0oZSx0KT0+e2xldCByPVl0KGUpLG49WXQocWEpO3I+PW4mJmltKHIsdHlwZW9mIHQ9PVwiZnVuY3Rpb25cIj90KCk6dCl9LHNlPSguLi5lKT0+e0thJiZhbSguLi5lKX19KTt2YXIgUnIsWG49VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtScj0oZSx0KT0+bmV3KE9yKHQpKShlKX0pO3ZhciBVcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgamEsSm4sZW8sc20sdW0sWWEscm8sdG8sUWEsWGE9VSgoKT0+e1widXNlIHN0cmljdFwiO2V0KCk7VXIoKTtqYT1uZXcgTWFwKFtbNjQsMjUwXSxbMTI4LDIwMF0sWzI1NiwyMDBdLFs1MTIsMjAwXSxbMjA0OCwyMzBdLFs0MDk2LDIwMF0sWzgxOTIsNTBdLFsxNjM4NCw1MF0sWzMyNzY4LDUwXSxbNjU1MzYsNTBdLFsxMzEwNzIsNTBdLFsyNjIxNDQsNTBdLFs1MjQyODgsNTBdLFsxMDQ4NTc2LDUwXSxbMjA5NzE1MiwzMF0sWzQxOTQzMDQsMjBdLFs4Mzg4NjA4LDEwXSxbMTI1ODI5MTIsMTBdLFsxNjc3NzIxNiwxMF0sWzI2MjE0NDAwLDE1XSxbMzM1NTQ0MzIsMjJdLFs0NDIzNjgwMCwyXSxbNTg5ODI0MDAsNl0sWzY3MTA4ODY0LDZdLFsxMzQyMTc3MjgsNl0sWzE2Nzc3MjE2MCw2XV0pLEpuPVtdLGVvPWU9Pk1hdGguY2VpbChOdW1iZXIoZSkvMTYpKjE2LHNtPWU9Pntmb3IobGV0IHQ9MDt0PEpuLmxlbmd0aDt0Kyspe2xldCByPUpuW3RdO2lmKGU8PXIpcmV0dXJuIHJ9cmV0dXJuIE1hdGguY2VpbChlLzE2KSoxNn0sdW09MSxZYT0oKT0+dW0rKyxybz1hc3luYyhlLHQscixuKT0+e2xldCBvPWVvKHIpLGk9ZS5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm8sdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR9KTt0cnl7bGV0IGE9ZS5nZXRDb21tYW5kRW5jb2RlcigpO2UuZW5kQ29tcHV0ZVBhc3MoKSxhLmNvcHlCdWZmZXJUb0J1ZmZlcih0LDAsaSwwLG8pLGUuZmx1c2goKSxhd2FpdCBpLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCk7bGV0IGQ9aS5nZXRNYXBwZWRSYW5nZSgpO2lmKG4pe2xldCBsPW4oKTtyZXR1cm4gbC5zZXQobmV3IFVpbnQ4QXJyYXkoZCwwLHIpKSxsfWVsc2UgcmV0dXJuIG5ldyBVaW50OEFycmF5KGQuc2xpY2UoMCxyKSl9ZmluYWxseXtpLmRlc3Ryb3koKX19LHRvPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXAsdGhpcy5idWZmZXJzUGVuZGluZz1bXSx0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnM9bmV3IE1hcDtmb3IobGV0W3Jdb2YgamEpSm4ucHVzaChyKSx0aGlzLmZyZWVCdWZmZXJzLnNldChyLFtdKSx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5zZXQocixbXSk7dGhpcy5zZXNzaW9uQ291bnQ9MH11cGxvYWQodCxyKXtsZXQgbj1yLmJ1ZmZlcixvPXIuYnl0ZU9mZnNldCxpPXIuYnl0ZUxlbmd0aCxhPWVvKGkpLGQ9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFkKXRocm93IG5ldyBFcnJvcihcImdwdSBkYXRhIGZvciB1cGxvYWRpbmcgZG9lcyBub3QgZXhpc3RcIik7aWYoTnVtYmVyKGQub3JpZ2luYWxTaXplKSE9PWkpdGhyb3cgbmV3IEVycm9yKGBpbmNvbnNpc3RlbnQgZGF0YSBzaXplLiBncHUgZGF0YSBzaXplPSR7ZC5vcmlnaW5hbFNpemV9LCBkYXRhIHNpemU9JHtpfWApO2xldCBsPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHttYXBwZWRBdENyZWF0aW9uOiEwLHNpemU6YSx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfV1JJVEV8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KSxwPWwuZ2V0TWFwcGVkUmFuZ2UoKTtuZXcgVWludDhBcnJheShwKS5zZXQobmV3IFVpbnQ4QXJyYXkobixvLGkpKSxsLnVubWFwKCk7bGV0IG09dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO20uY29weUJ1ZmZlclRvQnVmZmVyKGwsMCxkLmdwdURhdGEuYnVmZmVyLDAsYSksdGhpcy5iYWNrZW5kLmRldmljZS5xdWV1ZS5zdWJtaXQoW20uZmluaXNoKCldKSxsLmRlc3Ryb3koKSxzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVwbG9hZChpZD0ke3R9KWApfW1lbWNweSh0LHIpe2xldCBuPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtsZXQgbz10aGlzLnN0b3JhZ2VDYWNoZS5nZXQocik7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiZGVzdGluYXRpb24gZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtpZihuLm9yaWdpbmFsU2l6ZSE9PW8ub3JpZ2luYWxTaXplKXRocm93IG5ldyBFcnJvcihcImluY29uc2lzdGVudCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGdwdSBkYXRhIHNpemVcIik7bGV0IGk9ZW8obi5vcmlnaW5hbFNpemUpLGE9dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksYS5jb3B5QnVmZmVyVG9CdWZmZXIobi5ncHVEYXRhLmJ1ZmZlciwwLG8uZ3B1RGF0YS5idWZmZXIsMCxpKX1yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQscixuKXtsZXQgbztpZihuKXtpZihvPW5bMF0sdD09PW5bMV0pcmV0dXJuIHNlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7cn0pID0+IGlkPSR7b30sIGJ1ZmZlciBpcyB0aGUgc2FtZSwgc2tpcC5gKSxvO2lmKHRoaXMuYmFja2VuZC5jYXB0dXJlZENvbW1hbmRMaXN0Lmhhcyh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCkpdGhyb3cgbmV3IEVycm9yKGBSZWdpc3RlcmluZyBhIGRpZmZlcmVudCBleHRlcm5hbCBidWZmZXIgdW5kZXIgZ3JhcGggY2FwdHVyZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlxuICAgICAgICAgICAgIFBsZWFzZSB1c2UgdGhlIHByZXZpb3VzIGV4dGVybmFsIGJ1ZmZlciFgKX1lbHNlIG89WWEoKTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KG8se2dwdURhdGE6e2lkOm8sdHlwZTowLGJ1ZmZlcjp0fSxvcmlnaW5hbFNpemU6cn0pLHNlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7cn0pID0+IGlkPSR7b30sIHJlZ2lzdGVyZWQuYCksb311bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCl7dCE9PXZvaWQgMCYmKHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZSh0KSxzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcigpID0+IGlkPSR7dH1gKSl9Y3JlYXRlKHQscj1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKXtsZXQgbj1zbSh0KSxvLGk9KHImR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFLGE9KHImR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNO2lmKGl8fGEpe2xldCBwPShpP3RoaXMuZnJlZUJ1ZmZlcnM6dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMpLmdldChuKTtwP3AubGVuZ3RoPjA/bz1wLnBvcCgpOm89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6bix1c2FnZTpyfSk6bz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLHVzYWdlOnJ9KX1lbHNlIG89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6bix1c2FnZTpyfSk7bGV0IGQ9e2lkOllhKCksdHlwZTowLGJ1ZmZlcjpvfTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGQuaWQse2dwdURhdGE6ZCxvcmlnaW5hbFNpemU6TnVtYmVyKHQpfSksc2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZT0ke3R9KSA9PiBpZD0ke2QuaWR9YCksZH1nZXQodCl7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KT8uZ3B1RGF0YX1yZWxlYXNlKHQpe2xldCByPXR5cGVvZiB0PT1cImJpZ2ludFwiP051bWJlcih0KTp0LG49dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHIpO2lmKCFuKXtpZih0aGlzLnN0b3JhZ2VDYWNoZS5zaXplPT09MClyZXR1cm4gMDt0aHJvdyBuZXcgRXJyb3IoXCJyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdFwiKX1yZXR1cm4gc2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWxlYXNlKGlkPSR7cn0pLCBncHVEYXRhSWQ9JHtuLmdwdURhdGEuaWR9YCksdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHIpLHRoaXMuYnVmZmVyc1BlbmRpbmcucHVzaChuLmdwdURhdGEuYnVmZmVyKSxuLm9yaWdpbmFsU2l6ZX1hc3luYyBkb3dubG9hZCh0LHIpe2xldCBuPXRoaXMuc3RvcmFnZUNhY2hlLmdldChOdW1iZXIodCkpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImRhdGEgZG9lcyBub3QgZXhpc3RcIik7YXdhaXQgcm8odGhpcy5iYWNrZW5kLG4uZ3B1RGF0YS5idWZmZXIsbi5vcmlnaW5hbFNpemUscil9cmVmcmVzaFBlbmRpbmdCdWZmZXJzKCl7aWYodGhpcy5idWZmZXJzUGVuZGluZy5sZW5ndGghPT0wKWlmKHRoaXMuYmFja2VuZC5zZXNzaW9uU3RhdHVzPT09XCJkZWZhdWx0XCIpe2ZvcihsZXQgdCBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKXtsZXQgcj1qYS5nZXQodC5zaXplKTtpZigodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0Upe2xldCBuPXRoaXMuZnJlZUJ1ZmZlcnMuZ2V0KHQuc2l6ZSl8fFtdO3I9PT12b2lkIDB8fG4ubGVuZ3RoPj1yP3QuZGVzdHJveSgpOm4ucHVzaCh0KX1lbHNlIGlmKCh0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STSl7bGV0IG49dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZ2V0KHQuc2l6ZSl8fFtdO3I9PT12b2lkIDB8fG4ubGVuZ3RoPj1yP3QuZGVzdHJveSgpOm4ucHVzaCh0KX1lbHNlIHQuZGVzdHJveSgpfXRoaXMuYnVmZmVyc1BlbmRpbmc9W119ZWxzZXtsZXQgdD10aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKTt0fHwodD1bXSx0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuc2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkLHQpKTtmb3IobGV0IHIgb2YgdGhpcy5idWZmZXJzUGVuZGluZyl0LnB1c2gocik7dGhpcy5idWZmZXJzUGVuZGluZz1bXX19ZGlzcG9zZSgpe3RoaXMuZnJlZUJ1ZmZlcnMuZm9yRWFjaCh0PT57dC5mb3JFYWNoKHI9PntyLmRlc3Ryb3koKX0pfSksdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZm9yRWFjaCh0PT57dC5mb3JFYWNoKHI9PntyLmRlc3Ryb3koKX0pfSksdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaCh0PT57dC5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCl9KSx0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZm9yRWFjaCh0PT57dC5mb3JFYWNoKHI9PntyLmRlc3Ryb3koKX0pfSksdGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnM9bmV3IE1hcH1vbkNyZWF0ZVNlc3Npb24oKXt0aGlzLnNlc3Npb25Db3VudCs9MX1vblJlbGVhc2VTZXNzaW9uKHQpe2xldCByPXRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodCk7ciYmKHIuZm9yRWFjaChuPT57bi5kZXN0cm95KCl9KSx0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZGVsZXRlKHQpKSx0aGlzLnNlc3Npb25Db3VudC09MSx0aGlzLnNlc3Npb25Db3VudD09PTAmJihzZShcIndhcm5pbmdcIiwoKT0+XCJbV2ViR1BVXSBDbGVhcmluZyB3ZWJncHUgYnVmZmVyIGNhY2hlXCIpLHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2gobj0+e24uZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpfSksdGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCl9fSxRYT0oLi4uZSk9Pm5ldyB0byguLi5lKX0pO3ZhciBubyxlZSx4ZT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bm89Y2xhc3N7Y29uc3RydWN0b3IodCl7T2JqZWN0LmFzc2lnbih0aGlzLHQpfWdldCBjYWNoZUtleSgpe3JldHVybiB0aGlzLmtleXx8KHRoaXMua2V5PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAodD0+YCR7dGhpc1t0XX1gKS5qb2luKFwiO1wiKSksdGhpcy5rZXl9fSxlZT1lPT5uZXcgbm8oZSl9KTt2YXIgb28sdHQsayxrdCxOcixKYSxlcyxuZT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7b289Y2xhc3N7c3RhdGljIGNhbGNNYXRNdWxTaGFwZSh0LHIpe3JldHVybiB0WzFdIT09clswXT92b2lkIDA6W3RbMF0sclsxXV19fSx0dD1jbGFzc3tzdGF0aWMgY2FsY1NoYXBlKHQscixuPSExKXtsZXQgbz10Lmxlbmd0aCxpPXIubGVuZ3RoO2lmKG89PT0wKXJldHVybiByO2lmKGk9PT0wKXJldHVybiB0O2xldCBhPU1hdGgubWF4KHQubGVuZ3RoLHIubGVuZ3RoKSxkPW5ldyBBcnJheShhKTtpZihuKXtpZihvPDJ8fGk8MilyZXR1cm47bGV0IGw9b28uY2FsY01hdE11bFNoYXBlKFt0W28tMl0sdFtvLTFdXSxbcltpLTJdLHJbaS0xXV0pO2lmKGw9PT12b2lkIDApcmV0dXJuO1tkW2EtMl0sZFthLTFdXT1sfWZvcihsZXQgbD1uPzM6MTtsPD1hO2wrKyl7bGV0IHA9by1sPDA/MTp0W28tbF0sbT1pLWw8MD8xOnJbaS1sXTtpZihwIT09bSYmcD4xJiZtPjEpcmV0dXJuO2xldCB1PU1hdGgubWF4KHAsbSk7aWYocCYmbSlkW2EtbF09TWF0aC5tYXgocCxtKTtlbHNle2lmKHU+MSlyZXR1cm47ZFthLWxdPTB9fXJldHVybiBkfXN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHQscil7bGV0IG49dC5sZW5ndGgsbz1yLmxlbmd0aDtpZihuPm8pcmV0dXJuITE7Zm9yKGxldCBpPTE7aTw9bjtpKyspaWYodFtuLWldIT09MSYmdFtuLWldIT09cltvLWldKXJldHVybiExO3JldHVybiEwfX0saz1jbGFzcyBle3N0YXRpYyBzaXplKHQpe3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHQubGVuZ3RoKX1zdGF0aWMgY29udmVydFNoYXBlKHQscj00KXtsZXQgbj10Lmxlbmd0aDtpZihuPT09MClyZXR1cm5bXTtsZXQgbz1uZXcgQXJyYXkobiksaT1uLTE7Zm9yKDtpPj0wOyl7aWYodFtpXSVyPT09MCl7b1tpXT10W2ldL3I7YnJlYWt9aWYociV0W2ldIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29udmVydCBzaGFwZVwiKTtvW2ldPTEsci89dFtpXSxpLS19Zm9yKGktLTtpPj0wO2ktLSlvW2ldPXRbaV07cmV0dXJuIG99c3RhdGljIHNpemVGcm9tRGltZW5zaW9uKHQscil7aWYocjwwfHxyPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtyfSBmb3Igc2l6ZUZyb21EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxyLHQubGVuZ3RoKX1zdGF0aWMgc2l6ZVRvRGltZW5zaW9uKHQscil7aWYocjwwfHxyPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtyfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsMCxyKX1zdGF0aWMgZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LHIsbil7bGV0IG89MTtmb3IobGV0IGk9cjtpPG47aSsrKXtpZih0W2ldPDApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLlwiKTtvKj1OdW1iZXIodFtpXSl9cmV0dXJuIG99c3RhdGljIGNvbXB1dGVTdHJpZGVzKHQpe2xldCByPXQubGVuZ3RoO2lmKHI9PT0wKXJldHVybltdO2lmKHI9PT0xKXJldHVyblsxXTtsZXQgbj1uZXcgQXJyYXkocik7bltyLTFdPTEsbltyLTJdPXRbci0xXTtmb3IobGV0IG89ci0zO28+PTA7LS1vKW5bb109bltvKzFdKnRbbysxXTtyZXR1cm4gbn1zdGF0aWMgbm9ybWFsaXplQXhpcyh0LHIpe2lmKHQ8LXImJnQ+PXIpdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uXCIpO3JldHVybiB0PDA/dCtyOnR9c3RhdGljIG5vcm1hbGl6ZUF4ZXModCxyKXtyZXR1cm4gdC5tYXAobj0+dGhpcy5ub3JtYWxpemVBeGlzKG4scj8/dC5sZW5ndGgpKX1zdGF0aWMgc29ydEJhc2VkT25QZXJtKHQscil7cmV0dXJuIHI/ci5tYXAobj0+dFtuXSk6dC5zbGljZSgpLnJldmVyc2UoKX1zdGF0aWMgcGFkU2hhcGUodCxyKXtsZXQgbj10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKG8saSk9Pm8rcltpXStyW2krbl0pfXN0YXRpYyBhcmVFcXVhbCh0LHIpe3JldHVybiB0Lmxlbmd0aCE9PXIubGVuZ3RoPyExOnQuZXZlcnkoKG4sbyk9Pm49PT1yW29dKX19LGt0PWNsYXNzIGV7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQscixuLG8saSxhKXtpZighdCYmbi5sZW5ndGghPT1yLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IGQ9MDtkPHIubGVuZ3RoLTI7ZCsrKWQ+PW4ubGVuZ3RoP24ucHVzaChyW2QrMl0pOm5bZF09cltkKzJdO2ZvcihsZXQgZD0wO2Q8bi5sZW5ndGg7ZCsrKWlmKGQ8by5sZW5ndGgpe2lmKG9bZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIG8ucHVzaCgxKTtmb3IobGV0IGQ9MDtkPG4ubGVuZ3RoO2QrKylpZihkPGkubGVuZ3RoKXtpZihpW2RdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGkucHVzaCgxKTtmb3IobGV0IGQ9MDtkPG4ubGVuZ3RoKjI7ZCsrKWlmKGQ8YS5sZW5ndGgpe2lmKGFbZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgYS5wdXNoKDApO2ZvcihsZXQgZD0wO2Q8bi5sZW5ndGg7ZCsrKXtpZihuW2RdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZihhW2RdPj1uW2RdfHxhW2Qrbi5sZW5ndGhdPj1uW2RdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxyLG4sbyxpLGEsZCl7aWYoZCl7aWYoaS5sZW5ndGghPT0yKih0Lmxlbmd0aC0yKSl0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihvLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2ZvcihsZXQgbD0wO2w8dC5sZW5ndGgtMjtsKyspZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0W2wrKGE/MToyKV0scltsXSxuW2xdLG9bbF0saSxsLGwrdC5sZW5ndGgtMixkKX19c3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUodCxyLG4sbyxpLGEsZCl7aWYoci5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwXCIpO2xldCBsPVtyWzBdLHJbMV1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcih0LHIsbCxuLG8saSxhLGQpLGx9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxyLG4sbyxpLGEsZCl7aWYodC5sZW5ndGg8PTB8fHIubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7bGV0IGw9W3RbMF0sclswXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKCExLHQsbCxuLG8saSxhLGQpLGx9c3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcih0LHIsbixvLGksYSxkLGwpe2lmKHQpZm9yKGxldCBwPTA7cDxyLmxlbmd0aC0yO3ArKyluLnB1c2goMSk7ZWxzZSBmb3IobGV0IHA9MDtwPHIubGVuZ3RoLTI7cCsrKW4ucHVzaChlLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHJbcCsyXSxvW3BdLGlbcF0sYVtwXSxkLHAscCtyLmxlbmd0aC0yLGwpKX1zdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodCxyLG4sbyxpLGEsZCxsKXtsZXQgcD1uKihvLTEpKzE7aWYobCYmbCE9PVwiTk9UU0VUXCIpc3dpdGNoKGwpe2Nhc2VcIlZBTElEXCI6cmV0dXJuIGlbYV09MCxpW2RdPTAsTWF0aC5mbG9vcigodC1wKS9yKzEpO2Nhc2VcIlNBTUVfTE9XRVJcIjpjYXNlXCJTQU1FX1VQUEVSXCI6aWYobiE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSXCIpO3tsZXQgdT0oKHQrci0xKS9yLTEpKnIrby10O3JldHVybiBpW2FdPU1hdGguZmxvb3IobD09PVwiU0FNRV9MT1dFUlwiPyh1KzEpLzI6dS8yKSxpW2RdPXUtaVthXSxNYXRoLmZsb29yKCh0K3UtbykvcisxKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEF1dG9QYWQgdHlwZVwiKX1lbHNlIHJldHVybiBNYXRoLmZsb29yKCh0K2lbYV0raVtkXS1wKS9yKzEpfX0sTnI9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQscixuLG8saSl7aWYodC5sZW5ndGghPT0yfHxuLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IGEsZCxsO3I/KGE9dFsxXSxkPXRbMF0pOihhPXRbMF0sZD10WzFdKTtsZXQgcD0tMTtpZihvPyhsPW5bMF0scD0xKToobD1uWzFdLHA9MCksbltwXSE9PWQpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKGE8PTB8fGw8PTB8fGQ8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYoaSYmIXR0LmlzVmFsaWRCcm9hZGNhc3QoaSxbYSxsXSkpdGhyb3cgbmV3IEVycm9yKFwiZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3RcIik7cmV0dXJuW2EsbCxkXX19LEphPS0zNDAyODIzNDY2Mzg1Mjg4NmUyMixlcz0zNDAyODIzNDY2Mzg1Mjg4NmUyMn0pO3ZhciBFdCxhbyx5ZSxFZSxOLG1lLHNvLFB0LHFlLHEsVnIsRSxNLHRzLFdyLGlvLHJzLGFlPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTtFdD02NCxhbz0oZSx0KT0+e2lmKHQ9PT0zKXRocm93IG5ldyBFcnJvcihcInZlYzMgaGFzIHNhbWUgYWxpZ25tZW50IGFzIHZlYzQsIHVzZSB2ZWM0IGluc3RlYWRcIik7c3dpdGNoKE51bWJlcihlKSl7Y2FzZSAxMDpyZXR1cm4gdD4xP2B2ZWMke3R9PGYxNj5gOlwiZjE2XCI7Y2FzZSAxOnJldHVybiB0PjE/YHZlYyR7dH08ZjMyPmA6XCJmMzJcIjtjYXNlIDY6cmV0dXJuIHQ+MT9gdmVjJHt0fTxpMzI+YDpcImkzMlwiO2Nhc2UgMTI6cmV0dXJuIHQ+MT9gdmVjJHt0fTx1MzI+YDpcInUzMlwiO2Nhc2UgNzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwiaTMyXCJdO2Nhc2UgMTM6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcInUzMlwiXTtjYXNlIDk6aWYodCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiYm9vbCBtdXN0IGJlIHZlYzRcIik7cmV0dXJuW1widTMyXCIsXCJ2ZWM0PGJvb2w+XCJdO2Nhc2UgMjI6cmV0dXJuXCJpMzJcIjtjYXNlIDIxOnJldHVyblwidTMyXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke2V9YCl9fSx5ZT0oZSx0PTEpPT57bGV0IHI9YW8oZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzBdfSxFZT0oZSx0PTEpPT57bGV0IHI9YW8oZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzFdfSxOPSguLi5lKT0+e2xldCB0PVtdO3JldHVybiBlLmZvckVhY2gocj0+e3IubGVuZ3RoIT09MCYmdC5wdXNoKHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTprLmNvbXB1dGVTdHJpZGVzKHIpfSl9KSx0fSxtZT1lPT5lJTQ9PT0wPzQ6ZSUyPT09MD8yOjEsc289KGU9XCJmMzJcIix0LHI9XCIwXCIpPT4hdHx8dD09PTE/YCR7ZX0oJHtyfSlgOmB2ZWMke3R9PCR7ZX0+KCR7cn0pYCxQdD0oZSx0LHIpPT5lPT09XCJmMzJcIj9yOnQ9PT0xP2BmMzIoJHtyfSlgOmB2ZWMke3R9PGYzMj4oJHtyfSlgLHFlPShlLHQpPT50PT09ND9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueiArICR7ZX0udylgOnQ9PT0yP2AoJHtlfS54ICsgJHtlfS55KWA6dD09PTM/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnopYDplLHE9KGUsdCxyLG4pPT5lLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnI+ND90eXBlb2YgdD09XCJzdHJpbmdcIj9uPT09XCJmMTZcIj9gJHtlfVsoJHt0fSkgLyA4XVsoJHt0fSkgJSA4IC8gNF1bKCR7dH0pICUgOCAlIDRdYDpgJHtlfVsoJHt0fSkgLyA0XVsoJHt0fSkgJSA0XWA6bj09PVwiZjE2XCI/YCR7ZX1bJHtNYXRoLmZsb29yKHQvOCl9XVske01hdGguZmxvb3IodCU4LzQpfV1bJHt0JTglNH1dYDpgJHtlfVske01hdGguZmxvb3IodC80KX1dWyR7dCU0fV1gOnI+MT9gJHtlfVske3R9XWA6ZSxWcj0oZSx0LHIsbixvKT0+e2xldCBpPXR5cGVvZiByPT1cIm51bWJlclwiLGE9aT9yOnIubGVuZ3RoLGQ9Wy4uLm5ldyBBcnJheShhKS5rZXlzKCldLGw9YTwyP1widTMyXCI6YTw9ND9gdmVjJHthfTx1MzI+YDpgYXJyYXk8dTMyLCAke2F9PmAscD1hbyh0LG8pLG09dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzFdLHU9dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzBdLGg9e2luZGljZXM6bCx2YWx1ZTptLHN0b3JhZ2U6dSx0ZW5zb3I6dH0sXz1XPT50eXBlb2YgVz09XCJzdHJpbmdcIj9XOmAke1d9dWAseT17b2Zmc2V0VG9JbmRpY2VzOiExLGluZGljZXNUb09mZnNldDohMSxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDohMSxzZXQ6ITEsc2V0QnlJbmRpY2VzOiExLGdldDohMSxnZXRCeUluZGljZXM6ITF9LGc9aT9cInVuaWZvcm1zLlwiOlwiXCIseD1gJHtnfSR7ZX1fc2hhcGVgLCQ9YCR7Z30ke2V9X3N0cmlkZXNgLHY9XCJcIjtmb3IobGV0IFc9MDtXPGEtMTtXKyspdis9YFxuICAgIGxldCBkaW0ke1d9ID0gY3VycmVudCAvICR7cSgkLFcsYSl9O1xuICAgIGxldCByZXN0JHtXfSA9IGN1cnJlbnQgJSAke3EoJCxXLGEpfTtcbiAgICBpbmRpY2VzWyR7V31dID0gZGltJHtXfTtcbiAgICBjdXJyZW50ID0gcmVzdCR7V307XG4gICAgYDt2Kz1gaW5kaWNlc1ske2EtMX1dID0gY3VycmVudDtgO2xldCBTPWE8Mj9cIlwiOmBcbiAgZm4gbzJpXyR7ZX0ob2Zmc2V0OiB1MzIpIC0+ICR7aC5pbmRpY2VzfSB7XG4gICAgdmFyIGluZGljZXM6ICR7aC5pbmRpY2VzfTtcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcbiAgICAke3Z9XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1gLFQ9Vz0+KHkub2Zmc2V0VG9JbmRpY2VzPSEwLGE8Mj9XOmBvMmlfJHtlfSgke1d9KWApLEE9W107aWYoYT49Milmb3IobGV0IFc9YS0xO1c+PTA7Vy0tKUEucHVzaChgJHtxKCQsVyxhKX0gKiAoaW5kaWNlc1ske1d9XSlgKTtsZXQgQz1hPDI/XCJcIjpgXG4gIGZuIGkyb18ke2V9KGluZGljZXM6ICR7aC5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICByZXR1cm4gJHtBLmpvaW4oXCIrXCIpfTtcbiAgfWAsUD1XPT4oeS5pbmRpY2VzVG9PZmZzZXQ9ITAsYTwyP1c6YGkyb18ke2V9KCR7V30pYCksRD0oLi4uVyk9PmE9PT0wP1wiMHVcIjpgJHtoLmluZGljZXN9KCR7Vy5tYXAoXykuam9pbihcIixcIil9KWAsUj0oVyxZKT0+YTwyP2Ake1d9YDpgJHtxKFcsWSxhKX1gLEg9KFcsWSxoZSk9PmE8Mj9gJHtXfT0ke2hlfTtgOmAke3EoVyxZLGEpfT0ke2hlfTtgLEw9e30scmU9KFcsWSk9Pnt5LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0PSEwO2xldCBoZT1gJHtZLm5hbWV9YnJvYWRjYXN0ZWRJbmRpY2VzVG8ke2V9T2Zmc2V0YDtpZihoZSBpbiBMKXJldHVybmAke2hlfSgke1d9KWA7bGV0IERlPVtdO2ZvcihsZXQgcGU9YS0xO3BlPj0wO3BlLS0pe2xldCBJZT1ZLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIscGUrWS5yYW5rLWEpO0RlLnB1c2goYCR7UigkLHBlKX0gKiAoJHtJZX0gJSAke1IoeCxwZSl9KWApfXJldHVybiBMW2hlXT1gZm4gJHtoZX0ob3V0cHV0SW5kaWNlczogJHtZLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgICAgICAgICAgcmV0dXJuICR7RGUubGVuZ3RoPjA/RGUuam9pbihcIitcIik6XCIwdVwifTtcbiAgICAgICAgICAgfWAsYCR7aGV9KCR7V30pYH0sVj0oVyxZKT0+KCgpPT57aWYoaC5zdG9yYWdlPT09aC52YWx1ZSlyZXR1cm5gJHtlfVske1d9XT0ke1l9O2A7aWYoaC5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmaC52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYCR7ZX1bJHtXfV09dmVjMjx1MzI+KHUzMigke1l9KSwgc2VsZWN0KDB1LCAweEZGRkZGRkZGdSwgJHtZfSA8IDApKTtgO2lmKGguc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmgudmFsdWU9PT1cInUzMlwiKXJldHVybmAke2V9WyR7V31dPXZlYzI8dTMyPih1MzIoJHtZfSksIDB1KTtgO2lmKGguc3RvcmFnZT09PVwidTMyXCImJmgudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gJHtlfVske1d9XT1kb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPigke1l9KSk7YDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7aC5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke2gudmFsdWV9IHlldGApfSkoKSxLPVc9PigoKT0+e2lmKGguc3RvcmFnZT09PWgudmFsdWUpcmV0dXJuYCR7ZX1bJHtXfV1gO2lmKGguc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmgudmFsdWU9PT1cImkzMlwiKXJldHVybmBpMzIoJHtlfVske1d9XS54KWA7aWYoaC5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmaC52YWx1ZT09PVwidTMyXCIpcmV0dXJuYHUzMigke2V9WyR7V31dLngpYDtpZihoLnN0b3JhZ2U9PT1cInUzMlwiJiZoLnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYHZlYzQ8Ym9vbD4oYm9vbCgke2V9WyR7V31dICYgMHhGRnUpLCBib29sKCR7ZX1bJHtXfV0gJiAweEZGMDB1KSwgYm9vbCgke2V9WyR7V31dICYgMHhGRjAwMDB1KSwgYm9vbCgke2V9WyR7V31dICYgMHhGRjAwMDAwMHUpKWA7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke2guc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHtoLnZhbHVlfSB5ZXRgKX0pKCksd2U9YTwyP1wiXCI6YFxuICBmbiBnZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke2guaW5kaWNlc30pIC0+ICR7bX0ge1xuICAgIHJldHVybiAke0soYGkyb18ke2V9KGluZGljZXMpYCl9O1xuICB9YCxqPWE8Mj9cIlwiOigoKT0+e2xldCBXPWQubWFwKGhlPT5gZCR7aGV9OiB1MzJgKS5qb2luKFwiLCBcIiksWT1kLm1hcChoZT0+YGQke2hlfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXG4gIGZuIGdldF8ke2V9KCR7V30pIC0+ICR7bX0ge1xuICAgIHJldHVybiBnZXRfJHtlfUJ5SW5kaWNlcygke0QoWSl9KTtcbiAgfWB9KSgpLFE9KC4uLlcpPT57aWYoVy5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke2F9YCk7bGV0IFk9Vy5tYXAoXykuam9pbihcIixcIik7cmV0dXJuIGE9PT0wP0soXCIwdVwiKTphPT09MT9LKFlbMF0pOih5LmdldD0hMCx5LmdldEJ5SW5kaWNlcz0hMCx5LmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX0oJHtZfSlgKX0saWU9Vz0+YTwyP0soVyk6KHkuZ2V0QnlJbmRpY2VzPSEwLHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfUJ5SW5kaWNlcygke1d9KWApLHRlPWE8Mj9cIlwiOmBcbiAgZm4gc2V0XyR7ZX1CeUluZGljZXMoaW5kaWNlczogJHtoLmluZGljZXN9LCB2YWx1ZTogJHttfSkge1xuICAgICR7VihgaTJvXyR7ZX0oaW5kaWNlcylgLFwidmFsdWVcIil9XG4gIH1gLGJlPWE8Mj9cIlwiOigoKT0+e2xldCBXPWQubWFwKGhlPT5gZCR7aGV9OiB1MzJgKS5qb2luKFwiLCBcIiksWT1kLm1hcChoZT0+YGQke2hlfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXG4gIGZuIHNldF8ke2V9KCR7V30sIHZhbHVlOiAke219KSB7XG4gICAgc2V0XyR7ZX1CeUluZGljZXMoJHtEKFkpfSwgdmFsdWUpO1xuICB9YH0pKCk7cmV0dXJue2ltcGw6KCk9PntsZXQgVz1bXSxZPSExO3JldHVybiB5Lm9mZnNldFRvSW5kaWNlcyYmKFcucHVzaChTKSxZPSEwKSx5LmluZGljZXNUb09mZnNldCYmKFcucHVzaChDKSxZPSEwKSx5LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0JiYoT2JqZWN0LnZhbHVlcyhMKS5mb3JFYWNoKGhlPT5XLnB1c2goaGUpKSxZPSEwKSx5LnNldCYmKFcucHVzaChiZSksWT0hMCkseS5zZXRCeUluZGljZXMmJihXLnB1c2godGUpLFk9ITApLHkuZ2V0JiYoVy5wdXNoKGopLFk9ITApLHkuZ2V0QnlJbmRpY2VzJiYoVy5wdXNoKHdlKSxZPSEwKSwhaSYmWSYmVy51bnNoaWZ0KGBjb25zdCAke3h9ID0gJHtoLmluZGljZXN9KCR7ci5qb2luKFwiLFwiKX0pO2AsYGNvbnN0ICR7JH0gPSAke2guaW5kaWNlc30oJHtrLmNvbXB1dGVTdHJpZGVzKHIpLmpvaW4oXCIsXCIpfSk7YCksVy5qb2luKGBcbmApfSx0eXBlOmgsb2Zmc2V0VG9JbmRpY2VzOlQsaW5kaWNlc1RvT2Zmc2V0OlAsYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6cmUsaW5kaWNlczpELGluZGljZXNHZXQ6UixpbmRpY2VzU2V0Okgsc2V0OiguLi5XKT0+e2lmKFcubGVuZ3RoIT09YSsxKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke2F9YCk7bGV0IFk9V1thXTtpZih0eXBlb2YgWSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZSBtdXN0IGJlIHN0cmluZ1wiKTtsZXQgaGU9Vy5zbGljZSgwLGEpLm1hcChfKS5qb2luKFwiLFwiKTtyZXR1cm4gYT09PTA/VihcIjB1XCIsWSk6YT09PTE/VihoZVswXSxZKTooeS5zZXQ9ITAseS5zZXRCeUluZGljZXM9ITAseS5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9KCR7aGV9LCAke1l9KWApfSxzZXRCeU9mZnNldDpWLHNldEJ5SW5kaWNlczooVyxZKT0+YTwyP1YoVyxZKTooeS5zZXRCeUluZGljZXM9ITAseS5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9QnlJbmRpY2VzKCR7V30sICR7WX0pO2ApLGdldDpRLGdldEJ5T2Zmc2V0OkssZ2V0QnlJbmRpY2VzOmllLHVzYWdlOm4sbmFtZTplLHN0cmlkZXM6JCxzaGFwZTp4LHJhbms6YX19LEU9KGUsdCxyLG49MSk9PlZyKGUsdCxyLFwiaW5wdXRcIixuKSxNPShlLHQscixuPTEpPT5WcihlLHQscixcIm91dHB1dFwiLG4pLHRzPShlLHQscik9PlZyKGUsdCxyLFwiYXRvbWljT3V0cHV0XCIsMSksV3I9KGUsdCxyLG49MSk9PlZyKGUsdCxyLFwiaW50ZXJuYWxcIixuKSxpbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIpe3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXA9dDt0aGlzLmxpbWl0cz1yO3RoaXMuaW50ZXJuYWxWYXJpYWJsZXM9W107dGhpcy52YXJpYWJsZXM9W107dGhpcy51bmlmb3Jtcz1bXTt0aGlzLnZhcmlhYmxlSW5kZXg9MH1ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHQpe3JldHVybmBpZiAoZ2xvYmFsX2lkeCA+PSAke3R5cGVvZiB0PT1cIm51bWJlclwiP2Ake3R9dWA6dH0pIHsgcmV0dXJuOyB9YH1tYWluU3RhcnQodD1FdCl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0WzBdLG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzFdLG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzJdO2lmKHI+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfHxuPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWXx8bz50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVopdGhyb3cgbmV3IEVycm9yKGB3b3JrZ3JvdXAgc2l6ZSBbJHtyfSwgJHtufSwgJHtvfV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgc2l6ZSBbJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVh9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWX0sICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafV0uYCk7aWYocipuKm8+dGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwKXRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7cn0sICR7bn0sICR7b31dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIGludm9jYXRpb25zICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwfS5gKTtsZXQgaT10aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdPT09MSYmdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXT09PTEsYT1pP2BAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPmA6YEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obnVtX3dvcmtncm91cHMpIG51bV93b3JrZ3JvdXBzIDogdmVjMzx1MzI+YCxkPWk/YGxldCBnbG9iYWxfaWR4ID0gZ2xvYmFsX2lkLng7XG4gICAgICAgICBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLng7YDpgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC56ICogbnVtX3dvcmtncm91cHNbMF0gKiBudW1fd29ya2dyb3Vwc1sxXSArXG4gICAgICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiBudW1fd29ya2dyb3Vwc1swXSArIHdvcmtncm91cF9pZC54O1xuICAgICAgICAgbGV0IGdsb2JhbF9pZHggPSB3b3JrZ3JvdXBfaW5kZXggKiAke3IqbipvfXUgKyBsb2NhbF9pZHg7YDtyZXR1cm5gQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7cn0sICR7bn0sICR7b30pXG4gIGZuIG1haW4oJHthfSkge1xuICAgICR7ZH1cbiAgYH1hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpe3QucmFuayE9PTAmJih0LnNoYXBlLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnNoYXBlLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pLHQuc3RyaWRlcy5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zdHJpZGVzLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pKX1kZWNsYXJlVmFyaWFibGUodCxyKXtpZih0LnVzYWdlPT09XCJpbnRlcm5hbFwiKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2UgaW50ZXJuYWwgdmFyaWFibGUgd2l0aCBkZWNsYXJlVmFyaWFibGUoKS4gdXNlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLnZhcmlhYmxlcy5wdXNoKHQpLHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KTtsZXQgbj10LnVzYWdlPT09XCJpbnB1dFwiP1wicmVhZFwiOlwicmVhZF93cml0ZVwiLG89dC51c2FnZT09PVwiYXRvbWljT3V0cHV0XCI/XCJhdG9taWM8aTMyPlwiOnQudHlwZS5zdG9yYWdlO3JldHVybmBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtyfSkgdmFyPHN0b3JhZ2UsICR7bn0+ICR7dC5uYW1lfTogYXJyYXk8JHtvfT47YH1kZWNsYXJlVmFyaWFibGVzKC4uLnQpe3JldHVybiB0Lm1hcChyPT50aGlzLmRlY2xhcmVWYXJpYWJsZShyLHRoaXMudmFyaWFibGVJbmRleCsrKSkuam9pbihgXG5gKX1yZWdpc3RlckludGVybmFsVmFyaWFibGUodCl7aWYodC51c2FnZSE9PVwiaW50ZXJuYWxcIil0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIGlucHV0IG9yIG91dHB1dCB2YXJpYWJsZSB3aXRoIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSgpLiB1c2UgZGVjbGFyZVZhcmlhYmxlcygpIGluc3RlYWQuXCIpO3RoaXMuaW50ZXJuYWxWYXJpYWJsZXMucHVzaCh0KSx0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCl9cmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5mb3JFYWNoKHI9PnRoaXMucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHIpKSx0aGlzfXJlZ2lzdGVyVW5pZm9ybSh0LHIsbj0xKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQsdHlwZTpyLGxlbmd0aDpufSksdGhpc31yZWdpc3RlclVuaWZvcm1zKHQpe3JldHVybiB0aGlzLnVuaWZvcm1zPXRoaXMudW5pZm9ybXMuY29uY2F0KHQpLHRoaXN9dW5pZm9ybURlY2xhcmF0aW9uKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVyblwiXCI7bGV0IHQ9W107Zm9yKGxldHtuYW1lOnIsdHlwZTpuLGxlbmd0aDpvfW9mIHRoaXMudW5pZm9ybXMpaWYobyYmbz40KW49PT1cImYxNlwiP3QucHVzaChgQGFsaWduKDE2KSAke3J9OmFycmF5PG1hdDJ4NDwke259PiwgJHtNYXRoLmNlaWwoby84KX0+YCk6dC5wdXNoKGAke3J9OmFycmF5PHZlYzQ8JHtufT4sICR7TWF0aC5jZWlsKG8vNCl9PmApO2Vsc2V7bGV0IGk9bz09bnVsbHx8bz09PTE/bjpgdmVjJHtvfTwke259PmA7dC5wdXNoKGAke3J9OiR7aX1gKX1yZXR1cm5gXG4gICAgICBzdHJ1Y3QgVW5pZm9ybXMgeyAke3Quam9pbihcIiwgXCIpfSB9O1xuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7dGhpcy52YXJpYWJsZUluZGV4fSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztgfWdldCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKCl7cmV0dXJuIHRoaXMudW5pZm9ybURlY2xhcmF0aW9uKCkrdGhpcy52YXJpYWJsZXMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcbmApK3RoaXMuaW50ZXJuYWxWYXJpYWJsZXMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcbmApfWdldCB2YXJpYWJsZXNJbmZvKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVybjtsZXQgdD1yPT5bMTIsMTAsMSw2XVtbXCJ1MzJcIixcImYxNlwiLFwiZjMyXCIsXCJpMzJcIl0uaW5kZXhPZihyKV07cmV0dXJuIHRoaXMudW5pZm9ybXMubWFwKHI9Plt0KHIudHlwZSksci5sZW5ndGg/PzFdKX19LHJzPShlLHQpPT5uZXcgaW8oZSx0KX0pO3ZhciBkbSxucyxsbSxjbSxwbSxtbSxQZSxvcyxpcyxkdD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTthZSgpO2RtPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYodC5sZW5ndGghPT0wJiZ0Lmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBwZXJtIHNpemUgJHt0Lmxlbmd0aH0gZG9lcyBub3QgbWF0Y2ggaW5wdXQgcmFuayAke2VbMF0uZGltcy5sZW5ndGh9YCl9LG5zPShlLHQpPT50Lmxlbmd0aCE9PTA/dDpbLi4ubmV3IEFycmF5KGUpLmtleXMoKV0ucmV2ZXJzZSgpLGxtPShlLHQpPT5rLnNvcnRCYXNlZE9uUGVybShlLG5zKGUubGVuZ3RoLHQpKSxjbT0oZSx0LHIsbik9PntsZXQgbz1gZm4gcGVybShpOiAke24udHlwZS5pbmRpY2VzfSkgLT4gJHtyLnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke3IudHlwZS5pbmRpY2VzfTtgO2ZvcihsZXQgaT0wO2k8dDsrK2kpbys9YGFbJHtlW2ldfV09aVske2l9XTtgO3JldHVybiBvKz1cInJldHVybiBhO31cIn0scG09KGUsdCk9PntsZXQgcj1bXSxuPVtdO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7KytvKWVbb10hPT0xJiZyLnB1c2goZVtvXSksZVt0W29dXSE9PTEmJm4ucHVzaCh0W29dKTtyZXR1cm57bmV3U2hhcGU6cixuZXdQZXJtOm59fSxtbT0oZSx0KT0+e2xldCByPTA7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24paWYodFtlW25dXSE9PTEpe2lmKGVbbl08cilyZXR1cm4hMTtyPWVbbl19cmV0dXJuITB9LFBlPShlLHQpPT57bGV0IHI9ZS5kYXRhVHlwZSxuPWUuZGltcy5sZW5ndGgsbz1ucyhuLHQpLGk9bG0oZS5kaW1zLG8pLGE9ZS5kaW1zLGQ9aSxsPW48Mnx8bW0obyxlLmRpbXMpLHA7aWYobClyZXR1cm4gcD1nPT57bGV0IHg9RShcImlucHV0XCIscixhLDQpLCQ9TShcIm91dHB1dFwiLHIsZCw0KTtyZXR1cm5gXG4gICR7Zy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeCwkKX1cbiAgJHtnLm1haW5TdGFydCgpfVxuICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XG4gIH1gfSx7bmFtZTpcIlRyYW5zcG9zZUNvcHlcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCBnPWsuc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZy82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOk1hdGguY2VpbChnLzQpfV19fSxnZXRTaGFkZXJTb3VyY2U6cH07bGV0e25ld1NoYXBlOm0sbmV3UGVybTp1fT1wbShlLmRpbXMsbyksaD1rLmFyZUVxdWFsKHUsWzIsMywxXSksXz1rLmFyZUVxdWFsKHUsWzMsMSwyXSk7aWYobS5sZW5ndGg9PT0yfHxofHxfKXthPWg/W21bMF0sbVsxXSptWzJdXTpfP1ttWzBdKm1bMV0sbVsyXV06bSxkPVthWzFdLGFbMF1dO2xldCBnPTE2O3JldHVybiBwPXg9PntsZXQgJD1FKFwiYVwiLHIsYS5sZW5ndGgpLHY9TShcIm91dHB1dFwiLHIsZC5sZW5ndGgpO3JldHVybmBcbiAgJHt4LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcygkLHYpfVxuICB2YXI8d29ya2dyb3VwPiB0aWxlIDogYXJyYXk8YXJyYXk8JHt2LnR5cGUudmFsdWV9LCAke2crMX0+LCAke2d9PjtcbiAgJHt4Lm1haW5TdGFydChbZyxnLDFdKX1cbiAgICBsZXQgc3RyaWRlID0gKHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSAtIDEpIC8gJHtnfSArIDE7XG4gICAgbGV0IHdvcmtncm91cF9pZF94ID0gd29ya2dyb3VwX2luZGV4ICUgc3RyaWRlO1xuICAgIGxldCB3b3JrZ3JvdXBfaWRfeSA9IHdvcmtncm91cF9pbmRleCAvIHN0cmlkZTtcbiAgICBsZXQgaW5wdXRfY29sID0gd29ya2dyb3VwX2lkX3kgKiAke2d9dSArIGxvY2FsX2lkLng7XG4gICAgbGV0IGlucHV0X3JvdyA9IHdvcmtncm91cF9pZF94ICogJHtnfXUgKyBsb2NhbF9pZC55O1xuICAgIGlmIChpbnB1dF9yb3cgPCB1bmlmb3Jtcy5hX3NoYXBlWzBdICYmIGlucHV0X2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMV0pIHtcbiAgICAgIHRpbGVbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAkeyQuZ2V0QnlJbmRpY2VzKGAkeyQudHlwZS5pbmRpY2VzfShpbnB1dF9yb3csIGlucHV0X2NvbClgKX07XG4gICAgfVxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGxldCBvdXRwdXRfY29sID0gd29ya2dyb3VwX2lkX3ggKiAke2d9dSArIGxvY2FsX2lkLng7XG4gICAgbGV0IG91dHB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeSAqICR7Z311ICsgbG9jYWxfaWQueTtcbiAgICBpZiAob3V0cHV0X3JvdyA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVswXSAmJiBvdXRwdXRfY29sIDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdKSB7XG4gICAgICAke3Yuc2V0QnlJbmRpY2VzKGAke3YudHlwZS5pbmRpY2VzfShvdXRwdXRfcm93LCBvdXRwdXRfY29sKWAsXCJ0aWxlW2xvY2FsX2lkLnhdW2xvY2FsX2lkLnldXCIpfVxuICAgIH1cbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlU2hhcmVkXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgeD1rLnNpemUoaSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGRbMV0vZykseTpNYXRoLmNlaWwoZFswXS9nKX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOnh9LC4uLk4oYSxkKV19fSxnZXRTaGFkZXJTb3VyY2U6cH19cmV0dXJuIHA9Zz0+e2xldCB4PUUoXCJhXCIscixhLmxlbmd0aCksJD1NKFwib3V0cHV0XCIscixkLmxlbmd0aCk7cmV0dXJuYFxuICAke2cucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHgsJCl9XG5cbiAgJHtjbShvLG4seCwkKX1cblxuICAke2cubWFpblN0YXJ0KCl9XG4gICAgJHtnLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBpbmRpY2VzID0gJHskLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XG5cbiAgICAkeyQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIseC5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKSl9XG4gIH1gfSx7bmFtZTpcIlRyYW5zcG9zZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IGc9ay5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChnLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmd9LC4uLk4oYSxkKV19fSxnZXRTaGFkZXJTb3VyY2U6cH19LG9zPShlLHQpPT57ZG0oZS5pbnB1dHMsdC5wZXJtKSxlLmNvbXB1dGUoUGUoZS5pbnB1dHNbMF0sdC5wZXJtKSl9LGlzPWU9PmVlKHtwZXJtOmUucGVybX0pfSk7dmFyIGZtLGhtLGdtLGJtLHltLF9tLHdtLHZtLCRtLHhtLHJ0LGFzLHNzLHVzLGRzLGxzLGNzLHBzLG1zLGZzLGhzLGdzPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO0xyKCk7ZHQoKTtmbT17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKVwiLGwxOlwiYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSlcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxobT17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LGdtPXttYXg6XCJfQVtvZmZzZXRdXCIsbWluOlwiX0Fbb2Zmc2V0XVwiLG1lYW46XCIwXCIsc3VtOlwiMFwiLHByb2Q6XCIxXCIsc3VtU3F1YXJlOlwiMFwiLGxvZ1N1bUV4cDpcIjBcIixsMTpcIjBcIixsMjpcIjBcIixsb2dTdW06XCIwXCJ9LGJtPXttYXg6XCJiZXN0VmFsdWVcIixtaW46XCJiZXN0VmFsdWVcIixzdW06XCJiZXN0VmFsdWVcIixwcm9kOlwiYmVzdFZhbHVlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlXCIsbG9nU3VtRXhwOlwibG9nKGJlc3RWYWx1ZSlcIixsMTpcImJlc3RWYWx1ZVwiLGwyOlwic3FydChiZXN0VmFsdWUpXCIsbG9nU3VtOlwibG9nKGJlc3RWYWx1ZSlcIn0seW09KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IG49dC1lO248dDsrK24pci5wdXNoKG4pO3JldHVybiByfSxfbT0oZSx0KT0+e2xldCByPVtdLG49ZS5sZW5ndGg7Zm9yKGxldCBpPTA7aTxuO2krKyl0LmluZGV4T2YoaSk9PT0tMSYmci5wdXNoKGVbaV0pO2xldCBvPXQubWFwKGk9PmVbaV0pO3JldHVybltyLG9dfSx3bT0oZSx0KT0+e2xldCByPWUubGVuZ3RoK3QubGVuZ3RoLG49W10sbz0wO2ZvcihsZXQgaT0wO2k8cjtpKyspdC5pbmRleE9mKGkpPT09LTE/bi5wdXNoKGVbbysrXSk6bi5wdXNoKDEpO3JldHVybiBufSx2bT0oZSx0KT0+e2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKWlmKGVbZS5sZW5ndGgtci0xXSE9PXQtMS1yKXJldHVybiExO3JldHVybiEwfSwkbT0oZSx0KT0+e2xldCByPVtdO2lmKCF2bShlLHQpKXtmb3IobGV0IG49MDtuPHQ7KytuKWUuaW5kZXhPZihuKT09PS0xJiZyLnB1c2gobik7ZS5mb3JFYWNoKG49PnIucHVzaChuKSl9cmV0dXJuIHJ9LHhtPShlLHQscixuLG8saSxhKT0+e2xldCBkPXJbMF0uZGltcyxsPWsuc2l6ZShpKSxwPWsuc2l6ZShhKSxtPUUoXCJfQVwiLHJbMF0uZGF0YVR5cGUsZCksdT1NKFwib3V0cHV0XCIsbyxpKSxoPTY0O2w9PT0xJiYoaD0yNTYpO2xldCBfPWBcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PGYzMiwgJHtofT47XG4gICAgICAgYCx5PWc9PmBcbiAgICAgICAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcInJlZHVjZVNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG0sdSl9XG4gICAgICAgICR7X31cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7Zy5tYWluU3RhcnQoaCl9XG5cbiAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBnbG9iYWxfaWR4IC8gJHtofTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuXG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IGYzMigke2dtW25dfSk7XG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke2h9KSB7XG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBmMzIoJHttLmdldEJ5T2Zmc2V0KFwib2Zmc2V0ICsga1wiKX0pO1xuICAgICAgICAgICBiZXN0VmFsdWUgPSAke2ZtW25dfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHtofXUpO1xuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGFCZXN0VmFsdWVzW2xvY2FsX2lkeCArIGludGVydmFsXTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7aG1bbl19O1xuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xuICAgICAgICAgICR7dS5zZXRCeU9mZnNldChcIm91dHB1dEluZGV4XCIsYCR7bj09PVwibWVhblwiP2Ake3UudHlwZS5zdG9yYWdlfShiZXN0VmFsdWUgLyBmMzIodW5pZm9ybXMucmVkdWNlU2l6ZSkpYDpgJHt1LnR5cGUuc3RvcmFnZX0oJHtibVtuXX0pYH1gKX07XG4gICAgICAgICB9XG4gICAgICAgIH1gO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH07JHtofWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOnksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Omx9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpwfV19KX19LHJ0PShlLHQscixuKT0+e2xldCBvPWUuaW5wdXRzLmxlbmd0aD09PTE/cjp1byhlLmlucHV0cyxyKSxpPW8uYXhlcztpLmxlbmd0aD09PTAmJiFvLm5vb3BXaXRoRW1wdHlBeGVzJiYoaT1lLmlucHV0c1swXS5kaW1zLm1hcCgoXyx5KT0+eSkpO2xldCBhPWsubm9ybWFsaXplQXhlcyhpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSxkPWEsbD1lLmlucHV0c1swXSxwPSRtKGQsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO3AubGVuZ3RoPjAmJihsPWUuY29tcHV0ZShQZShlLmlucHV0c1swXSxwKSx7aW5wdXRzOlswXSxvdXRwdXRzOlstMV19KVswXSxkPXltKGQubGVuZ3RoLGwuZGltcy5sZW5ndGgpKTtsZXRbbSx1XT1fbShsLmRpbXMsZCksaD1tO28ua2VlcERpbXMmJihoPXdtKG0sYSkpLGUuY29tcHV0ZSh4bSh0LG8uY2FjaGVLZXksW2xdLG4sZS5pbnB1dHNbMF0uZGF0YVR5cGUsaCx1KSx7aW5wdXRzOltsXX0pfSxhcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VNZWFuU2hhcmVkXCIsdCxcIm1lYW5cIil9LHNzPShlLHQpPT57cnQoZSxcIlJlZHVjZUwxU2hhcmVkXCIsdCxcImwxXCIpfSx1cz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VMMlNoYXJlZFwiLHQsXCJsMlwiKX0sZHM9KGUsdCk9PntydChlLFwiUmVkdWNlTG9nU3VtRXhwU2hhcmVkXCIsdCxcImxvZ1N1bUV4cFwiKX0sbHM9KGUsdCk9PntydChlLFwiUmVkdWNlTWF4U2hhcmVkXCIsdCxcIm1heFwiKX0sY3M9KGUsdCk9PntydChlLFwiUmVkdWNlTWluU2hhcmVkXCIsdCxcIm1pblwiKX0scHM9KGUsdCk9PntydChlLFwiUmVkdWNlUHJvZFNoYXJlZFwiLHQsXCJwcm9kXCIpfSxtcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VTdW1TaGFyZWRcIix0LFwic3VtXCIpfSxmcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VTdW1TcXVhcmVTaGFyZWRcIix0LFwic3VtU3F1YXJlXCIpfSxocz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VMb2dTdW1TaGFyZWRcIix0LFwibG9nU3VtXCIpfX0pO3ZhciBudCxTbSxHcix1byxvdCxUbSxJbSxDbSxBbSxrbSxFbSxQbSx6bSxPbSxEbSxpdCxicyx5cyxfcyx3cyx2cywkcyx4cyxTcyxUcyxJcyxMcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTthZSgpO2dzKCk7bnQ9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGUubGVuZ3RoPT09MiYmZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGVzIGlucHV0IGRpbXMuXCIpfSxTbT1lPT5bXCJcIixcIlwiLGB2YXIgdmFsdWUgPSAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSxHcj0oZSx0LHIsbixvLGksYT0hMSxkPSExKT0+e2xldCBsPVtdLHA9clswXS5kaW1zLG09cC5sZW5ndGgsdT1rLm5vcm1hbGl6ZUF4ZXMobyxtKSxoPSFkJiZ1Lmxlbmd0aD09PTA7cC5mb3JFYWNoKCh4LCQpPT57aHx8dS5pbmRleE9mKCQpPj0wP2EmJmwucHVzaCgxKTpsLnB1c2goeCl9KTtsZXQgXz1sLmxlbmd0aCx5PWsuc2l6ZShsKTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOng9PntsZXQgJD1bXSx2PUUoXCJfQVwiLHJbMF0uZGF0YVR5cGUsbSksUz1NKFwib3V0cHV0XCIsaSxfKSxUPW4odixTLHUpLEE9VFsyXTtmb3IobGV0IEM9MCxQPTA7QzxtO0MrKylofHx1LmluZGV4T2YoQyk+PTA/KGEmJlArKyxBPWBmb3IodmFyIGoke0N9OiB1MzIgPSAwOyBqJHtDfSA8ICR7cFtDXX07IGoke0N9KyspIHtcbiAgICAgICAgICAgICAgICAgICR7VFsyXS5pbmNsdWRlcyhcImxhc3RfaW5kZXhcIik/YGxldCBsYXN0X2luZGV4ID0gaiR7Q307YDpcIlwifVxuICAgICAgICAgICAgICAgICAgJHt2LmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsQyxgaiR7Q31gKX1cbiAgICAgICAgICAgICAgICAgICR7QX1cbiAgICAgICAgICAgICAgICB9YCk6KCQucHVzaChgJHt2LmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsQyxTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFApKX07YCksUCsrKTtyZXR1cm5gXG5cbiAgICAgICAgJHt4LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh2LFMpfVxuXG4gICAgICAgICR7eC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke3YudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAkeyQuam9pbihgXG5gKX1cbiAgICAgICAgICAke1RbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxuICAgICAgICAgICR7VFsxXX1cbiAgICAgICAgICAke0F9XG4gICAgICAgICAgJHtUWzNdfVxuICAgICAgICAgICR7VC5sZW5ndGg9PT00P1Muc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKTpULnNsaWNlKDQpLmpvaW4oYFxuYCl9XG4gICAgICAgIH1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmwsZGF0YVR5cGU6aX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6eX0sLi4uTihwLGwpXX0pfX0sdW89KGUsdCk9PntsZXQgcj1bXTtyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJmVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobj0+ci5wdXNoKE51bWJlcihuKSkpLGVlKHtheGVzOnIsa2VlcERpbXM6dC5rZWVwRGltcyxub29wV2l0aEVtcHR5QXhlczp0Lm5vb3BXaXRoRW1wdHlBeGVzfSl9LG90PShlLHQscixuKT0+e2xldCBvPWUuaW5wdXRzLGk9by5sZW5ndGg9PT0xP3I6dW8obyxyKTtlLmNvbXB1dGUoR3IodCx7aGludDppLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtvWzBdXSxpLm5vb3BXaXRoRW1wdHlBeGVzJiZpLmF4ZXMubGVuZ3RoPT09MD9TbTpuLGkuYXhlcyxvWzBdLmRhdGFUeXBlLGkua2VlcERpbXMsaS5ub29wV2l0aEVtcHR5QXhlcykse2lucHV0czpbMF19KX0sVG09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZUxvZ1N1bVwiLHQsKG4sbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxJbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTDFcIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gYWJzKCR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXSl9LENtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VMMlwiLHQsKG4sbyk9PltgdmFyIHQgPSAke28udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9ICh0ICogdCk7YCxcInZhbHVlID0gc3FydCh2YWx1ZSk7XCJdKX0sQW09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZUxvZ1N1bUV4cFwiLHQsKG4sbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBleHAoJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LGttPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VNYXhcIix0LChuLG8saSk9PntsZXQgYT1bXTtmb3IobGV0IGQ9MDtkPG4ucmFuaztkKyspKGkuaW5kZXhPZihkKT49MHx8aS5sZW5ndGg9PT0wKSYmYS5wdXNoKG4uaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLDApKTtyZXR1cm5bYCR7YS5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwiXCJdfSl9LEVtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VNZWFuXCIsdCwobixvLGkpPT57bGV0IGE9MTtmb3IobGV0IGQ9MDtkPG4ucmFuaztkKyspKGkuaW5kZXhPZihkKT49MHx8aS5sZW5ndGg9PT0wKSYmKGEqPWUuaW5wdXRzWzBdLmRpbXNbZF0pO3JldHVybltcInZhciBzdW0gPSBmMzIoMCk7XCIsXCJcIixgc3VtICs9IGYzMigke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsYGxldCB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfShzdW0gLyAke2F9KTtgXX0pfSxQbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTWluXCIsdCwobixvLGkpPT57bGV0IGE9W107Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJmEucHVzaChgaW5wdXRfaW5kaWNlc1ske2R9XSA9IDA7YCk7cmV0dXJuW2Ake2Euam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxgdmFsdWUgPSBtaW4odmFsdWUsICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXX0pfSx6bT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlUHJvZFwiLHQsKG4sbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMSk7YCxcIlwiLGB2YWx1ZSAqPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSl9LE9tPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VTdW1cIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSxEbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlU3VtU3F1YXJlXCIsdCwobixvKT0+W2B2YXIgdCA9ICR7by50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTsgdmFsdWUgKz0gdCAqIHQ7YCxcIlwiXSl9LGl0PShlLHQscik9PntpZih0Lmxlbmd0aD09PTApcmV0dXJuIHI7bGV0IG49MSxvPTE7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspdC5pbmRleE9mKGkpPT09LTE/bio9ZVtpXTpvKj1lW2ldO3JldHVybiBvPDMyJiZuPjEwMjR9LGJzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/RW0oZSx0KTphcyhlLHQpfSx5cz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0ltKGUsdCk6c3MoZSx0KX0sX3M9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9DbShlLHQpOnVzKGUsdCl9LHdzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/QW0oZSx0KTpkcyhlLHQpfSx2cz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2ttKGUsdCk6bHMoZSx0KX0sJHM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9QbShlLHQpOmNzKGUsdCl9LHhzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/em0oZSx0KTpwcyhlLHQpfSxTcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP09tKGUsdCk6bXMoZSx0KX0sVHM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9EbShlLHQpOmZzKGUsdCl9LElzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/VG0oZSx0KTpocyhlLHQpfX0pO3ZhciBDcyxBcyxrcyxsbyxFcz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO3hlKCk7THIoKTtDcz1lPT57aWYoIWV8fGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJBcmdNaW5NYXhPcCBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxBcz0oZSx0KT0+e0NzKGUuaW5wdXRzKTtsZXQgcj0obixvLGkpPT57bGV0IGE9W107Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJmEucHVzaChgaW5wdXRfaW5kaWNlc1ske2R9XSA9IDA7YCk7cmV0dXJuW2Ake2Euam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI8PVwiOlwiPFwifSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xuICAgICAgIH1gLFwiXCIsby5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RfaW5kZXhcIildfTtlLmNvbXB1dGUoR3IoXCJBcmdNaW5cIix7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtlLmlucHV0c1swXV0scixbdC5heGlzXSw3LHQua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LGtzPShlLHQpPT57Q3MoZS5pbnB1dHMpO2xldCByPShuLG8saSk9PntsZXQgYT1bXTtmb3IobGV0IGQ9MDtkPG4ucmFuaztkKyspKGkuaW5kZXhPZihkKT49MHx8aS5sZW5ndGg9PT0wKSYmYS5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7ZH1dID0gMDtgKTtyZXR1cm5bYCR7YS5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLGBpZiAoJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIj49XCI6XCI+XCJ9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXCJcIixvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdF9pbmRleFwiKV19O2UuY29tcHV0ZShHcihcImFyZ01heFwiLHtoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2UuaW5wdXRzWzBdXSxyLFt0LmF4aXNdLDcsdC5rZWVwRGltcykse2lucHV0czpbMF19KX0sbG89ZT0+ZWUoZSl9KTt2YXIgQm0sY28sTW0sUm0sVW0sVXQsTm0sUHMsSHI9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO1VyKCk7YWUoKTtCbT0oZSx0KT0+e2xldCByPWVbMF0sbj1lWzFdLG89ZVsyXSxpPWVbM10sYT1lWzRdLGQ9ZVs1XTtpZihhJiZkKXRocm93IG5ldyBFcnJvcihcIkF0dGVudGlvbiBjYW5ub3QgaGF2ZSBib3RoIHBhc3QgYW5kIGF0dGVudGlvbl9iaWFzXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJpbnB1dFwiIG11c3QgaGF2ZSAzIGRpbWVuc2lvbnMnKTtsZXQgbD1yLmRpbXNbMF0scD1yLmRpbXNbMV0sbT1yLmRpbXNbMl07aWYoby5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO2lmKG4uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ3ZWlnaHRzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMnKTtpZihuLmRpbXNbMF0hPT1tKXRocm93IG5ldyBFcnJvcihcIklucHV0IDEgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDIgb2YgaW5wdXQgMFwiKTtpZihvLmRpbXNbMF0hPT1uLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMSBvZiBpbnB1dCBcIndlaWdodHNcIicpO2xldCB1PW8uZGltc1swXS8zLGg9dSxfPWg7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGg+MCl7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgYXR0cmlidXRlIHNob3VsZCBoYXZlIDMgZWxlbWVudHNcIik7Zm9yKGxldCBTIG9mIHQucWt2SGlkZGVuU2l6ZXMpaWYoUyV0Lm51bUhlYWRzIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgbnVtX2hlYWRzXCIpO3U9dC5xa3ZIaWRkZW5TaXplc1swXSxoPXQucWt2SGlkZGVuU2l6ZXNbMV0sXz10LnFrdkhpZGRlblNpemVzWzJdfWxldCB5PXA7aWYodSE9PWgpdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBzYW1lIGFzIHRoZSBzZWNvbmRcIik7aWYoby5kaW1zWzBdIT09dStoK18pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBzdW0gb2YgUS9LL1YgaGlkZGVuIHNpemVzJyk7bGV0IGc9MDtpZihhKXtpZihoIT09Xyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGV4cGVjdCBrX2hpZGRlbl9zaXplID09IHZfaGlkZGVuX3NpemUnKTtpZihhLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIG11c3QgaGF2ZSA1IGRpbWVuc2lvbnMnKTtpZihhLmRpbXNbMF0hPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlyc3QgZGltZW5zaW9uIG11c3QgYmUgMicpO2lmKGEuZGltc1sxXSE9PWwpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBzZWNvbmQgZGltZW5zaW9uIG11c3QgYmUgYmF0Y2hfc2l6ZScpO2lmKGEuZGltc1syXSE9PXQubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHMnKTtpZihhLmRpbXNbNF0hPT1oL3QubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaWZ0aCBkaW1lbnNpb24gbXVzdCBiZSBrX2hpZGRlbl9zaXplIC8gbnVtX2hlYWRzJyk7dC5wYXN0UHJlc2VudFNoYXJlQnVmZmVyfHwoZz1hLmRpbXNbM10pfWxldCB4PXkrZywkPS0xLHY9MDtpZihpKXRocm93IG5ldyBFcnJvcihcIk1hc2sgbm90IHN1cHBvcnRlZFwiKTtpZihhKXRocm93IG5ldyBFcnJvcihcInBhc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihkKXtpZihkLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBtdXN0IGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoZC5kaW1zWzBdIT09bHx8ZC5kaW1zWzFdIT09dC5udW1IZWFkc3x8ZC5kaW1zWzJdIT09cHx8ZC5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyl9cmV0dXJue2JhdGNoU2l6ZTpsLHNlcXVlbmNlTGVuZ3RoOnAscGFzdFNlcXVlbmNlTGVuZ3RoOmcsa3ZTZXF1ZW5jZUxlbmd0aDp5LHRvdGFsU2VxdWVuY2VMZW5ndGg6eCxtYXhTZXF1ZW5jZUxlbmd0aDokLGlucHV0SGlkZGVuU2l6ZTptLGhpZGRlblNpemU6dSx2SGlkZGVuU2l6ZTpfLGhlYWRTaXplOk1hdGguZmxvb3IodS90Lm51bUhlYWRzKSx2SGVhZFNpemU6TWF0aC5mbG9vcihfL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTp2LHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczohMSxwYXNzUGFzdEluS3Y6ITEscWt2Rm9ybWF0OjF9fSxjbz0oZSx0LHIpPT50JiZlP2BcbiAgICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQgPSB1MzIoJHt0LmdldEJ5T2Zmc2V0KFwiMFwiKX0pO1xuICAgICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gbWF4KHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCwgdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpO1xuICAgICAgbGV0IGlzX3N1YnNlcXVlbnRfcHJvbXB0OiBib29sID0gc2VxdWVuY2VfbGVuZ3RoID4gMSAmJiBzZXF1ZW5jZV9sZW5ndGggIT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgbGV0IGlzX2ZpcnN0X3Byb21wdDogYm9vbCA9IGlzX3N1YnNlcXVlbnRfcHJvbXB0ID09IGZhbHNlICYmIHNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XG4gICAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1MzIoJHtlPy5nZXRCeU9mZnNldChcImJhdGNoSWR4XCIpfSkgKyAxO1xuICAgICAgdmFyIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoOiB1MzIgPSAwO1xuICAgICAgaWYgKGlzX2ZpcnN0X3Byb21wdCA9PSBmYWxzZSkge1xuICAgICAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCAtIHNlcXVlbmNlX2xlbmd0aDtcbiAgICAgIH1cbiAgICAgICBgOmBcbiAgICAke3I/XCJsZXQgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aFwiOlwiXCJ9O1xuICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICBgLE1tPShlLHQscixuLG8saSxhLGQpPT57bGV0IGw9bWUoYT8xOmkpLHA9NjQsbT1pL2w7bTxwJiYocD0zMik7bGV0IHU9TWF0aC5jZWlsKGkvbC9wKSxoPVt7dHlwZToxMixkYXRhOnR9LHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6bX0se3R5cGU6MTIsZGF0YTp1fV0sXz15ZShlLmRhdGFUeXBlLGwpLHk9RWUoMSxsKSxnPVtcInR5cGVcIl07YSYmZy5wdXNoKFwidHlwZVwiKSxkJiZnLnB1c2goXCJ0eXBlXCIpO2xldCB4PSQ9PntsZXQgdj1NKFwieFwiLGUuZGF0YVR5cGUsZS5kaW1zLGwpLFM9W3ZdLFQ9YT9FKFwic2VxX2xlbnNcIixhLmRhdGFUeXBlLGEuZGltcyk6dm9pZCAwO1QmJlMucHVzaChUKTtsZXQgQT1kP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO0EmJlMucHVzaChBKTtsZXQgQz1FZShlLmRhdGFUeXBlKSxQPVt7bmFtZTpcImJhdGNoX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInNlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZWxlbWVudHNfcGVyX3RocmVhZFwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX21heDogYXJyYXk8ZjMyLCAke3B9PjtcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX3N1bTogYXJyYXk8ZjMyLCAke3B9PjtcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoUCkuZGVjbGFyZVZhcmlhYmxlcyguLi5TKX1cbiAgJHskLm1haW5TdGFydChbcCwxLDFdKX1cbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGg7XG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICAke2NvKFQsQSwhMSl9XG4gICAgbGV0IGxvY2FsX29mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQ7XG4gICAgbGV0IG9mZnNldCA9IChnbG9iYWxfaWR4IC8gJHtwfSkgKiB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGggKyBsb2NhbF9vZmZzZXQ7XG4gICAgbGV0IHNlcV9jYXVzYWxfbGVuZ3RoID0gJHthP1widTMyKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgd29ya2dyb3VwX2lkLnkgKyAxKVwiOlwidG90YWxfc2VxdWVuY2VfbGVuZ3RoXCJ9O1xuICAgIHZhciB0aHJlYWRfbWF4X3ZlY3RvciA9ICR7eX0oLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICB0aHJlYWRfbWF4X3ZlY3RvciA9IG1heCgke3l9KHhbb2Zmc2V0ICsgaV0pLCB0aHJlYWRfbWF4X3ZlY3Rvcik7XG4gICAgfVxuICAgIHRocmVhZF9tYXhbbG9jYWxfaWR4XSA9ICR7KCgpPT57c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5cInRocmVhZF9tYXhfdmVjdG9yXCI7Y2FzZSAyOnJldHVyblwibWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpXCI7Y2FzZSA0OnJldHVyblwibWF4KG1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSwgbWF4KHRocmVhZF9tYXhfdmVjdG9yLnosIHRocmVhZF9tYXhfdmVjdG9yLncpKVwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2x9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIG1heF92YWx1ZSA9ICBmMzIoLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7cH07IGkrKykge1xuICAgICAgbWF4X3ZhbHVlID0gbWF4KHRocmVhZF9tYXhbaV0sIG1heF92YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHN1bV92ZWN0b3IgPSAke3l9KDApO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICBzdW1fdmVjdG9yICs9IGV4cCgke3l9KHhbb2Zmc2V0ICsgaV0pIC0gbWF4X3ZhbHVlKTtcbiAgICB9XG4gICAgdGhyZWFkX3N1bVtsb2NhbF9pZHhdID0gJHsoKCk9Pntzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwic3VtX3ZlY3RvclwiO2Nhc2UgMjpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueVwiO2Nhc2UgNDpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSArIHN1bV92ZWN0b3IueiArIHN1bV92ZWN0b3Iud1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2x9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIHN1bTogZjMyID0gMDtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3B9OyBpKyspIHtcbiAgICAgIHN1bSArPSB0aHJlYWRfc3VtW2ldO1xuICAgIH1cblxuICAgIGlmIChzdW0gPT0gMCkge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7di50eXBlLnZhbHVlfSgke0N9KDEuMCkgLyAke0N9KHNlcV9jYXVzYWxfbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmMzJpbnB1dCA9ICR7eX0oeFtvZmZzZXQgKyBpXSk7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke3YudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4X3ZhbHVlKSAvIHN1bSk7XG4gICAgICB9XG4gICAgfVxuICAgICAgJHthP2BcbiAgICAgICAgZm9yICh2YXIgdG90YWxfc2VxX2lkOiB1MzIgPSBzZXFfY2F1c2FsX2xlbmd0aDsgdG90YWxfc2VxX2lkICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoOyB0b3RhbF9zZXFfaWQrKykge1xuICAgICAgICAgIHhbb2Zmc2V0ICsgdG90YWxfc2VxX2lkXSA9ICR7di50eXBlLnZhbHVlfSgke0N9KDApKTtcbiAgICAgICAgfWA6XCJcIn07XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblByb2JzU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9OyR7X307JHtsfWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0U2hhZGVyU291cmNlOngsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltdLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvcCkseTpvLHo6dCpyfSxwcm9ncmFtVW5pZm9ybXM6aH0pfX0sUm09KGUsdCxyLG4sbyxpLGEsZCxsKT0+e2xldCBwPWEraS5rdlNlcXVlbmNlTGVuZ3RoLG09W2kuYmF0Y2hTaXplLGkubnVtSGVhZHMsaS5zZXF1ZW5jZUxlbmd0aCxwXSx1PWU+MSYmbixoPWkua3ZOdW1IZWFkcz9pLmt2TnVtSGVhZHM6aS5udW1IZWFkcyxfPXU/W2kuYmF0Y2hTaXplLGgscCxpLmhlYWRTaXplXTp2b2lkIDAseT1pLm5SZXBzP2kublJlcHM6MSxnPWkuc2NhbGU9PT0wPzEvTWF0aC5zcXJ0KGkuaGVhZFNpemUpOmkuc2NhbGUseD1tZShpLmhlYWRTaXplKSwkPWkuaGVhZFNpemUveCx2PTEyLFM9e3g6TWF0aC5jZWlsKHAvdikseTpNYXRoLmNlaWwoaS5zZXF1ZW5jZUxlbmd0aC92KSx6OmkuYmF0Y2hTaXplKmkubnVtSGVhZHN9LFQ9W3t0eXBlOjEyLGRhdGE6aS5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6aS5udW1IZWFkc30se3R5cGU6MTIsZGF0YTppLmhlYWRTaXplfSx7dHlwZToxLGRhdGE6Z30se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOmkua3ZTZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTp5fV0sQT11JiZuJiZrLnNpemUobi5kaW1zKT4wLEM9W1widHlwZVwiLFwidHlwZVwiXTtBJiZDLnB1c2goXCJ0eXBlXCIpLG8mJkMucHVzaChcInR5cGVcIiksZCYmQy5wdXNoKFwidHlwZVwiKSxsJiZDLnB1c2goXCJ0eXBlXCIpO2xldCBQPVt7ZGltczptLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO3UmJlAucHVzaCh7ZGltczpfLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBEPVI9PntsZXQgSD1FKFwicVwiLHQuZGF0YVR5cGUsdC5kaW1zLHgpLEw9RShcImtleVwiLHIuZGF0YVR5cGUsci5kaW1zLHgpLHJlPVtILExdO2lmKEEpe2xldCB0ZT1FKFwicGFzdF9rZXlcIixuLmRhdGFUeXBlLG4uZGltcyx4KTtyZS5wdXNoKHRlKX1vJiZyZS5wdXNoKEUoXCJhdHRlbnRpb25fYmlhc1wiLG8uZGF0YVR5cGUsby5kaW1zKSk7bGV0IFY9ZD9FKFwic2VxX2xlbnNcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO1YmJnJlLnB1c2goVik7bGV0IEs9bD9FKFwidG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0XCIsbC5kYXRhVHlwZSxsLmRpbXMpOnZvaWQgMDtLJiZyZS5wdXNoKEspO2xldCB3ZT1NKFwib3V0cHV0XCIsdC5kYXRhVHlwZSxtKSxqPVt3ZV07dSYmai5wdXNoKE0oXCJwcmVzZW50X2tleVwiLHQuZGF0YVR5cGUsXyx4KSk7bGV0IFE9RWUoMSx4KSxpZT1be25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1faGVhZHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGVhZF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImt2X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJuX3JlcHNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7dn11O1xuXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke0gudHlwZS5zdG9yYWdlfSwgJHt2KnZ9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUs6IGFycmF5PCR7SC50eXBlLnN0b3JhZ2V9LCAke3Yqdn0+O1xuICAke1IucmVnaXN0ZXJVbmlmb3JtcyhpZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5yZSwuLi5qKX1cbiAgJHtSLm1haW5TdGFydChbdix2LDFdKX1cbiAgICAvLyB4IGhvbGRzIHRoZSBOIGFuZCB5IGhvbGRzIHRoZSBNXG4gICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQga3ZIZWFkSWR4ID0gJHt5PT09MT9cImhlYWRJZHhcIjpcImhlYWRJZHggLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICAgbGV0IGt2X251bV9oZWFkcyA9ICR7eT09PTE/XCJ1bmlmb3Jtcy5udW1faGVhZHNcIjpcInVuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgbSA9IHdvcmtncm91cF9pZC55ICogVElMRV9TSVpFO1xuICAgIGxldCBuID0gd29ya2dyb3VwX2lkLnggKiBUSUxFX1NJWkU7XG4gICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk47XG4gICAgJHtjbyhWLEssITApfVxuICAgIGxldCBhYnNLdkhlYWRJZHggPSBiYXRjaElkeCAqIGt2X251bV9oZWFkcyArIGt2SGVhZElkeDtcbiAgICBsZXQgcU9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLksgKyBtICogdW5pZm9ybXMuSztcbiAgICAke0EmJnU/XCJsZXQgcGFzdEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSztcIjpcIlwifTtcbiAgICBsZXQga09mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCAqIHVuaWZvcm1zLks7XG4gICAgJHt1P1wibGV0IHByZXNlbnRLZXlPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSztcIjpcIlwifVxuICAgIHZhciB2YWx1ZSA9ICR7UX0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcVtxT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAkeygoKT0+QSYmdT9gXG4gICAgICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfWA6YFxuICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgfWApKCl9XG4gICAgICAke3U/YGlmIChuICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgIHByZXNlbnRfa2V5W3ByZXNlbnRLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XSA9IHRpbGVLW2lkeF07XG4gICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZSArPSAke1F9KHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnggKyBrXSk7XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIGdsb2JhbF9pZC54IDwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICBsZXQgaGVhZE9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gaGVhZE9mZnNldCArIGdsb2JhbF9pZC55ICogdW5pZm9ybXMuTiArIGdsb2JhbF9pZC54O1xuICAgICAgdmFyIHN1bTogZjMyID0gJHsoKCk9Pntzd2l0Y2goeCl7Y2FzZSAxOnJldHVyblwidmFsdWVcIjtjYXNlIDI6cmV0dXJuXCJ2YWx1ZS54ICsgdmFsdWUueVwiO2Nhc2UgNDpyZXR1cm5cInZhbHVlLnggKyB2YWx1ZS55ICsgdmFsdWUueiArIHZhbHVlLndcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHt4fWApfX0pKCl9O1xuICAgICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9ICR7d2UudHlwZS52YWx1ZX0gKHN1bSAqIHVuaWZvcm1zLmFscGhhKSArICR7bz9cImF0dGVudGlvbl9iaWFzW291dHB1dElkeF1cIjpcIjAuMFwifTtcbiAgICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblByb2JzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eH07JHtvIT09dm9pZCAwfTske24hPT12b2lkIDB9OyR7ZX1gLGlucHV0RGVwZW5kZW5jaWVzOkN9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpQLGRpc3BhdGNoR3JvdXA6Uyxwcm9ncmFtVW5pZm9ybXM6VH0pLGdldFNoYWRlclNvdXJjZTpEfX0sVW09KGUsdCxyLG4sbyxpLGE9dm9pZCAwLGQ9dm9pZCAwKT0+e2xldCBsPWkrby5rdlNlcXVlbmNlTGVuZ3RoLHA9by5uUmVwcz9vLm5SZXBzOjEsbT1vLnZIaWRkZW5TaXplKnAsdT1lPjEmJm4saD1vLmt2TnVtSGVhZHM/by5rdk51bUhlYWRzOm8ubnVtSGVhZHMsXz11P1tvLmJhdGNoU2l6ZSxoLGwsby5oZWFkU2l6ZV06dm9pZCAwLHk9W28uYmF0Y2hTaXplLG8uc2VxdWVuY2VMZW5ndGgsbV0sZz0xMix4PXt4Ok1hdGguY2VpbChvLnZIZWFkU2l6ZS9nKSx5Ok1hdGguY2VpbChvLnNlcXVlbmNlTGVuZ3RoL2cpLHo6by5iYXRjaFNpemUqby5udW1IZWFkc30sJD1be3R5cGU6MTIsZGF0YTpvLnNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6by52SGVhZFNpemV9LHt0eXBlOjEyLGRhdGE6by5udW1IZWFkc30se3R5cGU6MTIsZGF0YTpvLmhlYWRTaXplfSx7dHlwZToxMixkYXRhOm19LHt0eXBlOjEyLGRhdGE6aX0se3R5cGU6MTIsZGF0YTpvLmt2U2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6cH1dLHY9dSYmbiYmay5zaXplKG4uZGltcyk+MCxTPVtcInR5cGVcIixcInR5cGVcIl07diYmUy5wdXNoKFwidHlwZVwiKSxhJiZTLnB1c2goXCJ0eXBlXCIpLGQmJlMucHVzaChcInR5cGVcIik7bGV0IFQ9W3tkaW1zOnksZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV07dSYmVC5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSk7bGV0IEE9Qz0+e2xldCBQPUUoXCJwcm9ic1wiLHQuZGF0YVR5cGUsdC5kaW1zKSxEPUUoXCJ2XCIsci5kYXRhVHlwZSxyLmRpbXMpLFI9W1AsRF07diYmUi5wdXNoKEUoXCJwYXN0X3ZhbHVlXCIsbi5kYXRhVHlwZSxuLmRpbXMpKTtsZXQgSD1hP0UoXCJzZXFfbGVuc1wiLGEuZGF0YVR5cGUsYS5kaW1zKTp2b2lkIDA7YSYmUi5wdXNoKEgpO2xldCBMPWQ/RShcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLGQuZGF0YVR5cGUsZC5kaW1zKTp2b2lkIDA7ZCYmUi5wdXNoKEwpO2xldCBWPVtNKFwib3V0cHV0XCIsdC5kYXRhVHlwZSx5KV07dSYmVi5wdXNoKE0oXCJwcmVzZW50X3ZhbHVlXCIsdC5kYXRhVHlwZSxfKSk7bGV0IEs9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJ2X2hpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImt2X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJuX3JlcHNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7Z311O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtQLnR5cGUudmFsdWV9LCAke2cqZ30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlVjogYXJyYXk8JHtQLnR5cGUudmFsdWV9LCAke2cqZ30+O1xuICAke0MucmVnaXN0ZXJVbmlmb3JtcyhLKS5kZWNsYXJlVmFyaWFibGVzKC4uLlIsLi4uVil9XG4gICR7Qy5tYWluU3RhcnQoW2csZywxXSl9XG4gICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICBsZXQga3ZIZWFkSWR4ID0gJHtwPT09MT9cImhlYWRJZHhcIjpcImhlYWRJZHggLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICBsZXQga3ZfbnVtX2hlYWRzID0gJHtwPT09MT9cInVuaWZvcm1zLm51bV9oZWFkc1wiOlwidW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgIGxldCBuID0gZ2xvYmFsX2lkLng7XG4gICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcbiAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5LO1xuICAgJHtjbyhILEwsITApfVxuICAgbGV0IG9mZnNldEEgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XG4gICBsZXQgYWJzS3ZIZWFkSWR4ID0gYmF0Y2hJZHggKiBrdl9udW1faGVhZHMgKyBrdkhlYWRJZHg7IC8vIGt2SGVhZElkeCBpcyByZWxhdGl2ZSB0byB0aGUgYmF0Y2hcbiAgICR7diYmdT9cImxldCBwYXN0VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBuO1wiOlwiXCJ9O1xuICAgbGV0IHZPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICsgbjtcbiAgICR7dT9cImxldCBwcmVzZW50VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSyArIG47XCI6XCJcIn1cbiAgIHZhciB2YWx1ZSA9ICR7UC50eXBlLnN0b3JhZ2V9KDApO1xuICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBwcm9ic1tvZmZzZXRBICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAgICR7KCgpPT52JiZ1P2BcbiAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgcGFzdF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gcGFzdF92YWx1ZVtwYXN0VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH0gZWxzZSBpZiAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgfVxuICAgICAgYDpgXG4gICAgICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGlsZVZbaWR4XSA9IHZbdk9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgICAgIH1gKSgpfVxuICAgICAgICAke3U/YFxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICBwcmVzZW50X3ZhbHVlW3ByZXNlbnRWYWx1ZU9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXSA9IHRpbGVWW2lkeF07XG4gICAgICAgIH1gOlwiXCJ9XG4gICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoOyBrKyspIHtcbiAgICAgICB2YWx1ZSArPSB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlVltUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueF07XG4gICAgIH1cbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgfVxuXG4gICAvLyB3ZSBuZWVkIHRvIHRyYW5zcG9zZSBvdXRwdXQgZnJvbSBCTlNIX3YgdG8gQlNORF92XG4gICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgbGV0IG91dHB1dElkeCA9IGJhdGNoSWR4ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemUgKyBtICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZVxuICAgICAgICsgaGVhZElkeCAqIHVuaWZvcm1zLk4gKyBuO1xuICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9IHZhbHVlO1xuICAgfVxuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25TY29yZVwiLHNoYWRlckNhY2hlOntoaW50OmAke24hPT12b2lkIDB9OyR7ZX1gLGlucHV0RGVwZW5kZW5jaWVzOlN9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpULGRpc3BhdGNoR3JvdXA6eCxwcm9ncmFtVW5pZm9ybXM6JH0pLGdldFNoYWRlclNvdXJjZTpBfX0sVXQ9KGUsdCxyLG4sbyxpLGEsZCxsLHAsbT12b2lkIDAsdT12b2lkIDApPT57bGV0IGg9TWF0aC5taW4oZS5vdXRwdXRDb3VudCwxKyhhPzE6MCkrKGQ/MTowKSksXz1oPjE/cC5wYXN0U2VxdWVuY2VMZW5ndGg6MCx5PV8rcC5rdlNlcXVlbmNlTGVuZ3RoLGc9bCYmay5zaXplKGwuZGltcyk+MD9sOnZvaWQgMCx4PVt0LHJdO2g+MSYmYSYmay5zaXplKGEuZGltcyk+MCYmeC5wdXNoKGEpLGcmJngucHVzaChnKSxtJiZ4LnB1c2gobSksdSYmeC5wdXNoKHUpO2xldCAkPWUuY29tcHV0ZShSbShoLHQscixhLGcscCxfLG0sdSkse2lucHV0czp4LG91dHB1dHM6aD4xP1stMSwxXTpbLTFdfSlbMF07ZS5jb21wdXRlKE1tKCQscC5iYXRjaFNpemUscC5udW1IZWFkcyxfLHAuc2VxdWVuY2VMZW5ndGgseSxtLHUpLHtpbnB1dHM6bSYmdT9bJCxtLHVdOlskXSxvdXRwdXRzOltdfSk7bGV0IHY9WyQsbl07aD4xJiZkJiZrLnNpemUoZC5kaW1zKT4wJiZ2LnB1c2goZCksbSYmdi5wdXNoKG0pLHUmJnYucHVzaCh1KSxlLmNvbXB1dGUoVW0oaCwkLG4sZCxwLF8sbSx1KSx7aW5wdXRzOnYsb3V0cHV0czpoPjE/WzAsMl06WzBdfSl9LE5tPShlLHQpPT57bGV0IHI9W3QuYmF0Y2hTaXplLHQubnVtSGVhZHMsdC5zZXF1ZW5jZUxlbmd0aCx0LmhlYWRTaXplXSxuPXQuc2VxdWVuY2VMZW5ndGgsbz10LmlucHV0SGlkZGVuU2l6ZSxpPXQuaGVhZFNpemUsYT0xMixkPXt4Ok1hdGguY2VpbCh0LmhlYWRTaXplL2EpLHk6TWF0aC5jZWlsKHQuc2VxdWVuY2VMZW5ndGgvYSksejp0LmJhdGNoU2l6ZSp0Lm51bUhlYWRzfSxsPVtlLmlucHV0c1swXSxlLmlucHV0c1sxXSxlLmlucHV0c1syXV0scD1be3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6aX0se3R5cGU6MTIsZGF0YTp0Lm51bUhlYWRzfSx7dHlwZToxMixkYXRhOnQuaGVhZFNpemV9LHt0eXBlOjEyLGRhdGE6dC5oaWRkZW5TaXplfSx7dHlwZToxMixkYXRhOnQuaGlkZGVuU2l6ZSt0LmhpZGRlblNpemUrdC52SGlkZGVuU2l6ZX1dLG09dT0+e2xldCBoPU0oXCJvdXRwdXRfcVwiLGxbMF0uZGF0YVR5cGUsciksXz1NKFwib3V0cHV0X2tcIixsWzBdLmRhdGFUeXBlLHIpLHk9TShcIm91dHB1dF92XCIsbFswXS5kYXRhVHlwZSxyKSxnPUUoXCJpbnB1dFwiLGxbMF0uZGF0YVR5cGUsbFswXS5kaW1zKSx4PUUoXCJ3ZWlnaHRcIixsWzFdLmRhdGFUeXBlLGxbMV0uZGltcyksJD1FKFwiYmlhc1wiLGxbMl0uZGF0YVR5cGUsbFsyXS5kaW1zKSx2PWcudHlwZS5zdG9yYWdlLFM9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJsZGJcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7YX11O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSW5wdXQ6IGFycmF5PCR7dn0sICR7YSphfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRROiBhcnJheTwke3Z9LCAke2EqYX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0SzogYXJyYXk8JHt2fSwgJHthKmF9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodFY6IGFycmF5PCR7dn0sICR7YSphfT47XG4gICR7dS5yZWdpc3RlclVuaWZvcm1zKFMpLmRlY2xhcmVWYXJpYWJsZXMoZyx4LCQsaCxfLHkpfVxuICAke3UubWFpblN0YXJ0KFthLGEsMV0pfVxuICAgIGxldCBiYXRjaEluZGV4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGhlYWROdW1iZXIgPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgbSA9IGdsb2JhbF9pZC55O1xuICAgIGxldCBuID0gZ2xvYmFsX2lkLng7XG5cbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiYXRjaEluZGV4ICogKHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LKSArIG0gKiB1bmlmb3Jtcy5LO1xuICAgIGxldCBiaWFzT2Zmc2V0USA9IGhlYWROdW1iZXIgKiB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgbGV0IGJpYXNPZmZzZXRLID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0UTtcbiAgICBsZXQgYmlhc09mZnNldFYgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRLO1xuXG4gICAgdmFyIHZhbHVlUSA9ICR7dn0oMCk7XG4gICAgdmFyIHZhbHVlSyA9ICR7dn0oMCk7XG4gICAgdmFyIHZhbHVlViA9ICR7dn0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlSW5wdXRbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gaW5wdXRbaW5wdXRPZmZzZXQgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBuICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLmxkYjtcbiAgICAgICAgdGlsZVdlaWdodFFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRRICsgb2Zmc2V0XTtcbiAgICAgICAgdGlsZVdlaWdodEtbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRLICsgb2Zmc2V0XTtcbiAgICAgICAgdGlsZVdlaWdodFZbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRWICsgb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgbGV0IGlucHV0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrO1xuICAgICAgICBsZXQgd2VpZ2h0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54O1xuICAgICAgICB2YWx1ZVEgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0UVt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgICAgdmFsdWVLICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodEtbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlViArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRWW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgbGV0IGhlYWRPZmZzZXQgPSAobSAqIHVuaWZvcm1zLk4gKyBuKSAlIHVuaWZvcm1zLmhlYWRfc2l6ZTtcbiAgICB2YWx1ZVEgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFFdO1xuICAgIHZhbHVlSyArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0S107XG4gICAgdmFsdWVWICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRWXTtcblxuICAgIGxldCBvZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICAgbGV0IG91dHB1dElkeCA9IG9mZnNldCArIG0gKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgIG91dHB1dF9xW291dHB1dElkeF0gPSB2YWx1ZVE7XG4gICAgICBvdXRwdXRfa1tvdXRwdXRJZHhdID0gdmFsdWVLO1xuICAgICAgb3V0cHV0X3Zbb3V0cHV0SWR4XSA9IHZhbHVlVjtcbiAgICB9XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiQXR0ZW50aW9uUHJlcGFyZVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0se2RpbXM6cixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSx7ZGltczpyLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XSxkaXNwYXRjaEdyb3VwOmQscHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6bX0se2lucHV0czpsLG91dHB1dHM6Wy0xLC0xLC0xXX0pfSxQcz0oZSx0KT0+e2xldCByPUJtKGUuaW5wdXRzLHQpLFtuLG8saV09Tm0oZSxyKTtyZXR1cm4gVXQoZSxuLG8saSxlLmlucHV0c1s0XSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxlLmlucHV0c1s1XSxyKX19KTt2YXIgVm0sV20sTG0senMsT3M9VSgoKT0+e1widXNlIHN0cmljdFwiO0xlKCk7SigpO25lKCk7eGUoKTthZSgpO1ZtPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHNcIik7bGV0IHI9KG4sbyxpKT0+e2xldCBhPW8ubGVuZ3RoO2lmKGEhPT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYCR7aX06IG51bSBkaW1lbnNpb25zICE9ICR7YX1gKTtvLmZvckVhY2goKGQsbCk9PntpZihkIT09bltsXSl0aHJvdyBuZXcgRXJyb3IoYCR7aX06IGRpbVske2x9XSBkbyBub3QgbWF0Y2hgKX0pfTtpZihlWzBdLmRpbXMubGVuZ3RoPjEpe2xldCBuPXQuZm9ybWF0PT09XCJOSFdDXCI/dC5zcGF0aWFsP2VbMF0uZGltcy5zbGljZSgtMSk6ZVswXS5kaW1zLnNsaWNlKC0xKS5jb25jYXQoZVswXS5kaW1zLnNsaWNlKDEsZVswXS5kaW1zLmxlbmd0aC0xKSk6ZVswXS5kaW1zLnNsaWNlKDEsdC5zcGF0aWFsPzI6dm9pZCAwKTtyKGVbMV0uZGltcyxuLFwiSW52YWxpZCBpbnB1dCBzY2FsZVwiKSxyKGVbMl0uZGltcyxuLFwiSW52YWxpZCBpbnB1dCBCXCIpLHIoZVszXS5kaW1zLG4sXCJJbnZhbGlkIGlucHV0IG1lYW5cIikscihlWzRdLmRpbXMsbixcIkludmFsaWQgaW5wdXQgdmFyXCIpfWVsc2UgcihlWzFdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBzY2FsZVwiKSxyKGVbMl0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IEJcIikscihlWzNdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBtZWFuXCIpLHIoZVs0XS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgdmFyXCIpfSxXbT0oZSx0KT0+e2xldHtlcHNpbG9uOnIsc3BhdGlhbDpuLGZvcm1hdDpvfT10LGk9ZVswXS5kaW1zLGE9bj9tZShpW2kubGVuZ3RoLTFdKToxLGQ9bz09PVwiTkhXQ1wiJiZpLmxlbmd0aD4xP2E6MSxsPWsuc2l6ZShpKS9hLHA9bixtPXA/aS5sZW5ndGg6aSx1PUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsYSksaD1FKFwic2NhbGVcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyxkKSxfPUUoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsZCkseT1FKFwiaW5wdXRNZWFuXCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMsZCksZz1FKFwiaW5wdXRWYXJcIixlWzRdLmRhdGFUeXBlLGVbNF0uZGltcyxkKSx4PU0oXCJ5XCIsZVswXS5kYXRhVHlwZSxtLGEpLCQ9KCk9PntsZXQgUz1cIlwiO2lmKG4pUz1gbGV0IGNPZmZzZXQgPSAke2kubGVuZ3RoPT09MT9cIjB1XCI6bz09PVwiTkhXQ1wiP2BvdXRwdXRJbmRpY2VzWyR7aS5sZW5ndGgtMX1dIC8gJHthfWA6XCJvdXRwdXRJbmRpY2VzWzFdXCJ9O2A7ZWxzZSBpZihvPT09XCJOQ0hXXCIpUz1gXG4gICAgICAgICAgICAke3guaW5kaWNlc1NldChcIm91dHB1dEluZGljZXNcIixcIjBcIixcIjBcIil9XG4gICAgICAgICAgICBsZXQgY09mZnNldCA9ICR7eC5pbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIpfTtgO2Vsc2V7Uz1gdmFyIGNJbmRpY2VzID0gJHtoLnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGNJbmRpY2VzWzBdID0gb3V0cHV0SW5kaWNlc1ske2kubGVuZ3RoLTF9XTtgO2ZvcihsZXQgVD0xO1Q8aC5yYW5rO1QrKylTKz1gY0luZGljZXNbJHtUfV0gPSBvdXRwdXRJbmRpY2VzWyR7VH1dO2A7Uys9YGxldCBjT2Zmc2V0ID0gJHtoLmluZGljZXNUb09mZnNldChcImNJbmRpY2VzXCIpfTtgfXJldHVybiBTfSx2PVM9PmBcbiAgY29uc3QgZXBzaWxvbiA9ICR7cn07XG4gICR7Uy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh1LGgsXyx5LGcseCl9XG4gICR7Uy5tYWluU3RhcnQoKX1cbiAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHt4Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7YX1gKX07XG4gICAgJHskKCl9XG4gICAgbGV0IHNjYWxlID0gJHtoLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IGJpYXMgPSAke18uZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgaW5wdXRNZWFuID0gJHt5LmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IGlucHV0VmFyID0gJHtnLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IHggPSAke3UuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgdmFsdWUgPSAoeCAtIGlucHV0TWVhbikgKiBpbnZlcnNlU3FydChpbnB1dFZhciArIGVwc2lsb24pICogc2NhbGUgKyBiaWFzO1xuICAgICR7eC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YDtyZXR1cm57bmFtZTpcIkJhdGNoTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuZXBzaWxvbn1fJHt0LmZvcm1hdH1fJHtufV8ke2F9YCxpbnB1dERlcGVuZGVuY2llczpwP1tcInJhbmtcIixcInR5cGVcIixcInR5cGVcIixcInR5cGVcIixcInR5cGVcIl06dm9pZCAwfSxnZXRTaGFkZXJTb3VyY2U6dixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmVbMF0uZGltcyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczpwP1t7dHlwZToxMixkYXRhOmx9LC4uLk4oaSldOlt7dHlwZToxMixkYXRhOmx9XX0pfX0sTG09ZT0+ZWUoZSksenM9KGUsdCk9PntsZXR7aW5wdXRzOnIsb3V0cHV0Q291bnQ6bn09ZSxvPUxtKHsuLi50LG91dHB1dENvdW50Om59KTtpZihfZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJlZtKHIsbyksdC50cmFpbmluZ01vZGUpdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hOb3JtYWxpemF0aW9uIHRyYWluaW5nTW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7ZS5jb21wdXRlKFdtKHIsbykpfX0pO3ZhciBHbSxIbSxEcyxCcz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bmUoKTthZSgpO0dtPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnNcIik7aWYoIVszMjAsNjQwLDEyODBdLmluY2x1ZGVzKGVbMF0uZGltc1syXSkpdGhyb3cgbmV3IEVycm9yKFwibnVtYmVyIG9mIGNoYW5uZWxzIHNob3VsZCBiZSAzMjAsIDY0MCBvciAxMjgwXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zWzJdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWVcIil9LEhtPWU9PntsZXQgdD1lWzBdLmRpbXMscj1lWzBdLmRpbXNbMl0sbj1rLnNpemUodCkvNCxvPWVbMF0uZGF0YVR5cGUsaT1FKFwiaW5wdXRcIixvLHQsNCksYT1FKFwiYmlhc1wiLG8sW3JdLDQpLGQ9RShcInJlc2lkdWFsXCIsbyx0LDQpLGw9TShcIm91dHB1dFwiLG8sdCw0KTtyZXR1cm57bmFtZTpcIkJpYXNBZGRcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfX0pLGdldFNoYWRlclNvdXJjZTptPT5gXG4gIGNvbnN0IGNoYW5uZWxzID0gJHtyfXUgLyA0O1xuICAke20uZGVjbGFyZVZhcmlhYmxlcyhpLGEsZCxsKX1cblxuICAke20ubWFpblN0YXJ0KCl9XG4gICAgJHttLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobil9XG4gICAgbGV0IHZhbHVlID0gJHtpLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX1cbiAgICAgICsgJHthLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAlIGNoYW5uZWxzXCIpfSArICR7ZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICR7bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YH19LERzPWU9PntHbShlLmlucHV0cyksZS5jb21wdXRlKEhtKGUuaW5wdXRzKSl9fSk7dmFyIEZtLGZlLE1zLFJzLFVzLE5zLFZzLFdzLExzLEdzLEhzLHFtLEZzLHFzLEtzLGpzLFF0LFlzLEZyLFpzLFFzLFhzLEpzLGV1LHR1LHJ1LG51LG91LGl1LGF1LHN1LHV1LGR1LGx1LGN1LHB1LG11LHBvLG1vLGZ1LGh1LGd1LEttLGptLGJ1LHFyPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7Rm09KGUsdCxyLG4sbyxpLGEpPT57bGV0IGQ9TWF0aC5jZWlsKHQvNCksbD1cIlwiO3R5cGVvZiBvPT1cInN0cmluZ1wiP2w9YCR7b30oYSlgOmw9byhcImFcIik7bGV0IHA9RShcImlucHV0RGF0YVwiLHIsW2RdLDQpLG09TShcIm91dHB1dERhdGFcIixuLFtkXSw0KSx1PVt7bmFtZTpcInZlY19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuIGEmJnUucHVzaCguLi5hKSxgXG4gICAgICAke2UucmVnaXN0ZXJVbmlmb3Jtcyh1KS5kZWNsYXJlVmFyaWFibGVzKHAsbSl9XG5cbiAgJHtpPz9cIlwifVxuXG4gICR7ZS5tYWluU3RhcnQoKX1cbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuXG4gICAgbGV0IGEgPSAke3AuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke20uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbCl9XG4gIH1gfSxmZT0oZSx0LHIsbixvLGk9ZS5kYXRhVHlwZSxhLGQpPT57bGV0IGw9W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKGsuc2l6ZShlLmRpbXMpLzQpfV07cmV0dXJuIGEmJmwucHVzaCguLi5hKSx7bmFtZTp0LHNoYWRlckNhY2hlOntoaW50Om8saW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOnA9PkZtKHAsay5zaXplKGUuZGltcyksZS5kYXRhVHlwZSxpLHIsbixkKSxnZXRSdW5EYXRhOnA9Pih7b3V0cHV0czpbe2RpbXM6ZS5kaW1zLGRhdGFUeXBlOml9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChrLnNpemUocFswXS5kaW1zKS82NC80KX0scHJvZ3JhbVVuaWZvcm1zOmx9KX19LE1zPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBYnNcIixcImFic1wiKSl9LFJzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBY29zXCIsXCJhY29zXCIpKX0sVXM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFjb3NoXCIsXCJhY29zaFwiKSl9LE5zPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBc2luXCIsXCJhc2luXCIpKX0sVnM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFzaW5oXCIsXCJhc2luaFwiKSl9LFdzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBdGFuXCIsXCJhdGFuXCIpKX0sTHM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkF0YW5oXCIsXCJhdGFuaFwiKSl9LEdzPWU9PmVlKGUpLEhzPShlLHQpPT57bGV0IHI7c3dpdGNoKHQudG8pe2Nhc2UgMTA6cj1cInZlYzQ8ZjE2PlwiO2JyZWFrO2Nhc2UgMTpyPVwidmVjNDxmMzI+XCI7YnJlYWs7Y2FzZSAxMjpyPVwidmVjNDx1MzI+XCI7YnJlYWs7Y2FzZSA2OnI9XCJ2ZWM0PGkzMj5cIjticmVhaztjYXNlIDk6cj1cInZlYzQ8Ym9vbD5cIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBSYW5nZUVycm9yKGBub3Qgc3VwcG9ydGVkIHR5cGUgKHNwZWNpZmllZCBpbiBhdHRyaWJ1dGUgJ3RvJyBmcm9tICdDYXN0JyBvcGVyYXRvcik6ICR7dC50b31gKX1lLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDYXN0XCIscix2b2lkIDAsdC5jYWNoZUtleSx0LnRvKSl9LHFtPWU9PntsZXQgdCxyLG49ZS5sZW5ndGg+PTImJmVbMV0uZGF0YSE9PTAsbz1lLmxlbmd0aD49MyYmZVsyXS5kYXRhIT09MDtzd2l0Y2goZVswXS5kYXRhVHlwZSl7Y2FzZSAxOnQ9bj9lWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdOi0zNDAyODIzNDY2Mzg1Mjg4NmUyMixyPW8/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTozNDAyODIzNDY2Mzg1Mjg4NmUyMjticmVhaztjYXNlIDEwOnQ9bj9lWzFdLmdldFVpbnQxNkFycmF5KClbMF06NjQ1MTEscj1vP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTozMTc0MzticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydCBkYXRhIHR5cGVcIil9cmV0dXJuIGVlKHttaW46dCxtYXg6cn0pfSxGcz0oZSx0KT0+e2xldCByPXR8fHFtKGUuaW5wdXRzKSxuPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDbGlwXCIsbz0+YGNsYW1wKCR7b30sIHZlYzQ8JHtufT4odW5pZm9ybXMubWluKSwgdmVjNDwke259Pih1bmlmb3Jtcy5tYXgpKWAsdm9pZCAwLHIuY2FjaGVLZXksdm9pZCAwLFt7dHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxkYXRhOnIubWlufSx7dHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxkYXRhOnIubWF4fV0sW3tuYW1lOlwibWluXCIsdHlwZTpufSx7bmFtZTpcIm1heFwiLHR5cGU6bn1dKSx7aW5wdXRzOlswXX0pfSxxcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQ2VpbFwiLFwiY2VpbFwiKSl9LEtzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDb3NcIixcImNvc1wiKSl9LGpzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDb3NoXCIsXCJjb3NoXCIpKX0sUXQ9ZT0+ZWUoZSksWXM9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiRWx1XCIsbj0+YGVsdV92ZjMyKCR7bn0pYCxgXG4gIGNvbnN0IGVsdV9hbHBoYV8gPSAke3J9KCR7dC5hbHBoYX0pO1xuXG4gIGZuIGVsdV9mMzIoYTogJHtyfSkgLT4gJHtyfSB7XG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XG4gIH1cblxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PCR7cn0+KSAtPiB2ZWM0PCR7cn0+IHtcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcbiAgfWAsdC5jYWNoZUtleSkpfSxGcj0oZT1cImYzMlwiKT0+YFxuY29uc3QgcjA6ICR7ZX0gPSAwLjMyNzU5MTE7XG5jb25zdCByMTogJHtlfSA9IDAuMjU0ODI5NTkyO1xuY29uc3QgcjI6ICR7ZX0gPSAtMC4yODQ0OTY3MzY7XG5jb25zdCByMzogJHtlfSA9IDEuNDIxNDEzNzQxO1xuY29uc3QgcjQ6ICR7ZX0gPSAtMS40NTMxNTIwMjc7XG5jb25zdCByNTogJHtlfSA9IDEuMDYxNDA1NDI5O1xuXG5mbiBlcmZfdmYzMih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IGFic3YgPSBhYnModik7XG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XG4gIHJldHVybiBzaWduKHYpICogKDEuMCAtICgoKChyNSAqIHggKyByNCkgKiB4ICsgcjMpICogeCArIHIyKSAqIHggKyByMSkgKiB4ICogZXhwKC1hYnN2ICogYWJzdikpO1xufWAsWnM9ZT0+e2xldCB0PUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJFcmZcIixyPT5gZXJmX3ZmMzIoJHtyfSlgLEZyKHQpKSl9LFFzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJFeHBcIixcImV4cFwiKSl9LFhzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJGbG9vclwiLFwiZmxvb3JcIikpfSxKcz1lPT57bGV0IHQ9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkdlbHVcIixyPT5gMC41ICogJHtyfSAqICgxLjAgKyBlcmZfdmYzMigke3J9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLEZyKHQpKSl9LGV1PShlLHQpPT57bGV0IHI9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkxlYWt5UmVsdVwiLG49PmBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke259LCAke259LCAke259ID49IHZlYzQ8JHtyfT4oMC4wKSlgLGBjb25zdCBsZWFreV9yZWx1X2FscGhhXyA9ICR7cn0oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSl9LHR1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJOb3RcIix0PT5gISR7dH1gKSl9LHJ1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJOZWdcIix0PT5gLSR7dH1gKSl9LG51PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJSZWNpcHJvY2FsXCIsdD0+YDEuMC8ke3R9YCkpfSxvdT1lPT57bGV0IHQ9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlJlbHVcIixyPT5gc2VsZWN0KHZlYzQ8JHt0fT4oMC4wKSwgJHtyfSwgJHtyfSA+IHZlYzQ8JHt0fT4oMC4wKSlgKSl9LGl1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJTaWdtb2lkXCIsdD0+YCgxLjAgLyAoMS4wICsgZXhwKC0ke3R9KSkpYCkpfSxhdT1lPT5lZShlKSxzdT0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJIYXJkU2lnbW9pZFwiLG49PmBtYXgodmVjNDwke3J9PigwLjApLCBtaW4odmVjNDwke3J9PigxLjApLCAke3QuYWxwaGF9ICogJHtufSArIHZlYzQ8JHtyfT4oJHt0LmJldGF9KSkpYCx2b2lkIDAsdC5jYWNoZUtleSkpfSx1dT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiU2luXCIsXCJzaW5cIikpfSxkdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiU2luaFwiLFwic2luaFwiKSl9LGx1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJTcXJ0XCIsXCJzcXJ0XCIpKX0sY3U9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlRhblwiLFwidGFuXCIpKX0scHU9ZT0+YHNpZ24oJHtlfSkgKiAoMSAtIGV4cCgtMiAqIGFicygke2V9KSkpIC8gKDEgKyBleHAoLTIgKiBhYnMoJHtlfSkpKWAsbXU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlRhbmhcIixwdSkpfSxwbz0oZT1cImYzMlwiKT0+YFxuY29uc3QgZmFzdF9nZWx1X2E6ICR7ZX0gPSAwLjU7XG5jb25zdCBmYXN0X2dlbHVfYjogJHtlfSA9IDAuNzk3ODg0NTYwODAyODY1NDtcbmNvbnN0IGZhc3RfZ2VsdV9jOiAke2V9ID0gMC4wMzU2Nzc0MDgxMzYzMDAxMjU7XG5cbmZuIHRhbmhfdih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgcmV0dXJuICR7cHUoXCJ2XCIpfTtcbn1cbmAsbW89ZT0+YChmYXN0X2dlbHVfYSArIGZhc3RfZ2VsdV9hICogdGFuaF92KCR7ZX0gKiAoZmFzdF9nZWx1X2MgKiAke2V9ICogJHtlfSArIGZhc3RfZ2VsdV9iKSkpICogJHtlfWAsZnU9ZT0+e2xldCB0PUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJGYXN0R2VsdVwiLG1vLHBvKHQpLHZvaWQgMCxlLmlucHV0c1swXS5kYXRhVHlwZSkpfSxodT0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtyZXR1cm4gZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiVGhyZXNob2xkZWRSZWx1XCIsbj0+YHNlbGVjdCh2ZWM0PCR7cn0+KDAuMCksICR7bn0sICR7bn0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXyA9IHZlYzQ8JHtyfT4oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSksMH0sZ3U9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkxvZ1wiLFwibG9nXCIpKX0sS209KGUsdCk9PmBcbmNvbnN0IGFscGhhID0gdmVjNDwke2V9Pigke3R9KTtcbmNvbnN0IG9uZSA9ICR7ZX0oMS4wKTtcbmNvbnN0IHplcm8gPSAke2V9KDAuMCk7XG5cbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IHYgPSB4ICphbHBoYTtcbiAgdmFyIHgxIDogdmVjNDwke2V9PjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XG4gICAgICB4MVtpXSA9IG9uZSAvIChvbmUgKyBleHAoLXZbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHggKiB4MTtcbn1cbmAsam09ZT0+YHF1aWNrX2dlbHVfaW1wbCgke2V9KWAsYnU9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiUXVpY2tHZWx1XCIsam0sS20ocix0LmFscGhhKSx0LmNhY2hlS2V5LGUuaW5wdXRzWzBdLmRhdGFUeXBlKSl9fSk7dmFyIFltLFptLF91LHd1PVUoKCk9PntcInVzZSBzdHJpY3RcIjtuZSgpO2FlKCk7cXIoKTtZbT1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMjU2MCw1MTIwLDEwMjQwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcImhpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxabT1lPT57bGV0IHQ9ZVswXS5kaW1zLnNsaWNlKCk7dFsyXT10WzJdLzI7bGV0IHI9RShcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsNCksbj1FKFwiYmlhc1wiLGVbMF0uZGF0YVR5cGUsW2VbMF0uZGltc1syXV0sNCksbz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx0LDQpLGk9ay5zaXplKHQpLzQsYT15ZShlWzBdLmRhdGFUeXBlKTtyZXR1cm57bmFtZTpcIkJpYXNTcGxpdEdlbHVcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpsPT5gXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7ZVswXS5kaW1zWzJdLzQvMn11O1xuXG4gICR7bC5kZWNsYXJlVmFyaWFibGVzKHIsbixvKX1cblxuICAke0ZyKGEpfVxuXG4gICR7bC5tYWluU3RhcnQoKX1cbiAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhpKX1cbiAgICBsZXQgYmlhc0lkeCA9IGdsb2JhbF9pZHggJSBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcbiAgICBsZXQgdmFsdWVMZWZ0ID0gaW5wdXRbaW5wdXRPZmZzZXRdICsgYmlhc1tiaWFzSWR4XTtcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XG5cbiAgICAke28uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZUxlZnQgKiBnZWx1UmlnaHRcIil9XG4gIH1gfX0sX3U9ZT0+e1ltKGUuaW5wdXRzKSxlLmNvbXB1dGUoWm0oZS5pbnB1dHMpKX19KTt2YXIgUW0sWG0sYXQsdnUsJHUseHUsU3UsVHUsSXUsQ3UsQXUsa3UsRXUsUHU9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO2FlKCk7UW09KGUsdCxyLG4sbyxpLGEsZCxsLHAsbSx1KT0+e2xldCBoLF87dHlwZW9mIGQ9PVwic3RyaW5nXCI/aD1fPSh2LFMpPT5gJHtkfSgoJHt2fSksKCR7U30pKWA6dHlwZW9mIGQ9PVwiZnVuY3Rpb25cIj9oPV89ZDooaD1kLnNjYWxhcixfPWQudmVjdG9yKTtsZXQgeT1NKFwib3V0cHV0RGF0YVwiLG0sbi5sZW5ndGgsNCksZz1FKFwiYURhdGFcIixsLHQubGVuZ3RoLDQpLHg9RShcImJEYXRhXCIscCxyLmxlbmd0aCw0KSwkO2lmKG8paWYoaSl7bGV0IHY9ay5zaXplKHQpPT09MSxTPWsuc2l6ZShyKT09PTEsVD10Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdJTQ9PT0wLEE9ci5sZW5ndGg+MCYmcltyLmxlbmd0aC0xXSU0PT09MDt2fHxTPyQ9eS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixfKHY/YCR7Zy50eXBlLnZhbHVlfSgke2cuZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6Zy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksUz9gJHt4LnR5cGUudmFsdWV9KCR7eC5nZXRCeU9mZnNldChcIjBcIil9LngpYDp4LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpOiQ9YFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeCAqIDR1XCIpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBID0gJHtnLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLHkpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCID0gJHt4LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLHkpfTtcbiAgICAgICAgICAgICR7eS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixfKGF8fFQ/Zy5nZXRCeU9mZnNldChcIm9mZnNldEEgLyA0dVwiKTpgJHtnLnR5cGUudmFsdWV9KCR7Zy5nZXRCeU9mZnNldChcIm9mZnNldEEgLyA0dVwiKX1bb2Zmc2V0QSAlIDR1XSlgLGF8fEE/eC5nZXRCeU9mZnNldChcIm9mZnNldEIgLyA0dVwiKTpgJHt4LnR5cGUudmFsdWV9KCR7eC5nZXRCeU9mZnNldChcIm9mZnNldEIgLyA0dVwiKX1bb2Zmc2V0QiAlIDR1XSlgKSl9XG4gICAgICAgICAgYH1lbHNlICQ9eS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixfKGcuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLHguZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk7ZWxzZXtpZighaSl0aHJvdyBuZXcgRXJyb3IoXCJubyBuZWNlc3NhcnkgdG8gdXNlIHNjYWxhciBpbXBsZW1lbnRhdGlvbiBmb3IgZWxlbWVudC13aXNlIGJpbmFyeSBvcCBpbXBsZW1lbnRhdGlvbi5cIik7bGV0IHY9KFMsVCxBPVwiXCIpPT57bGV0IEM9YGFEYXRhW2luZGV4QSR7VH1dW2NvbXBvbmVudEEke1R9XWAsUD1gYkRhdGFbaW5kZXhCJHtUfV1bY29tcG9uZW50QiR7VH1dYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7VH0gPSAke3kub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke1R9dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBJHtUfSA9ICR7Zy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7VH1gLHkpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCJHtUfSA9ICR7eC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7VH1gLHkpfTtcbiAgICAgICAgICAgIGxldCBpbmRleEEke1R9ID0gb2Zmc2V0QSR7VH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleEIke1R9ID0gb2Zmc2V0QiR7VH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRBJHtUfSA9IG9mZnNldEEke1R9ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QiR7VH0gPSBvZmZzZXRCJHtUfSAlIDR1O1xuICAgICAgICAgICAgJHtTfVske1R9XSA9ICR7QX0oJHtoKEMsUCl9KTtcbiAgICAgICAgICBgfTttPT09OT8kPWBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICAgICBvdXRwdXREYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A6JD1gXG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMSl9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMil9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZyx4LHkpfVxuXG4gICAgICAgICR7dT8/XCJcIn1cblxuICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XG4gICAgICAgICR7JH1cbiAgICAgIH1gfSxYbT0oZSx0LHIsbixvLGksYT1yLmRhdGFUeXBlKT0+e2xldCBkPXIuZGltcy5tYXAoZz0+TnVtYmVyKGcpPz8xKSxsPW4uZGltcy5tYXAoZz0+TnVtYmVyKGcpPz8xKSxwPSFrLmFyZUVxdWFsKGQsbCksbT1kLHU9ay5zaXplKGQpLGg9ITEsXz0hMSx5PVtwXTtpZihwKXtsZXQgZz10dC5jYWxjU2hhcGUoZCxsLCExKTtpZighZyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTttPWcuc2xpY2UoKSx1PWsuc2l6ZShtKTtsZXQgeD1rLnNpemUoZCk9PT0xLCQ9ay5zaXplKGwpPT09MSx2PWQubGVuZ3RoPjAmJmRbZC5sZW5ndGgtMV0lND09PTAsUz1sLmxlbmd0aD4wJiZsW2wubGVuZ3RoLTFdJTQ9PT0wO3kucHVzaCh4KSx5LnB1c2goJCkseS5wdXNoKHYpLHkucHVzaChTKTtsZXQgVD0xO2ZvcihsZXQgQT0xO0E8bS5sZW5ndGg7QSsrKXtsZXQgQz1kW2QubGVuZ3RoLUFdLFA9bFtsLmxlbmd0aC1BXTtpZihDPT09UClUKj1DO2Vsc2UgYnJlYWt9VCU0PT09MD8oXz0hMCxoPSEwKTooeHx8JHx8dnx8UykmJihoPSEwKX1lbHNlIGg9ITA7cmV0dXJuIHkucHVzaChoKSx7bmFtZTplLHNoYWRlckNhY2hlOntoaW50OnQreS5tYXAoZz0+Zy50b1N0cmluZygpKS5qb2luKFwiX1wiKSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6Zz0+UW0oZyxkLGwsbSxoLHAsXyxvLHIuZGF0YVR5cGUsbi5kYXRhVHlwZSxhLGkpLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bSxkYXRhVHlwZTphfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwodS82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOk1hdGguY2VpbChrLnNpemUobSkvNCl9LC4uLk4oZCxsLG0pXX0pfX0sYXQ9KGUsdCxyLG4sbyxpKT0+e2UuY29tcHV0ZShYbSh0LG8/P1wiXCIsZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0scixuLGkpKX0sdnU9ZT0+e2F0KGUsXCJBZGRcIiwodCxyKT0+YCR7dH0rJHtyfWApfSwkdT1lPT57YXQoZSxcIkRpdlwiLCh0LHIpPT5gJHt0fS8ke3J9YCl9LHh1PWU9PnthdChlLFwiRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH09PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT09JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxTdT1lPT57YXQoZSxcIk11bFwiLCh0LHIpPT5gJHt0fSoke3J9YCl9LFR1PWU9PntsZXQgdD1FKFwiaW5wdXRcIixlLmlucHV0c1swXS5kYXRhVHlwZSxlLmlucHV0c1swXS5kaW1zKS50eXBlLnZhbHVlO2F0KGUsXCJQb3dcIix7c2NhbGFyOihuLG8pPT5gcG93X2N1c3RvbSgke259LCR7b30pYCx2ZWN0b3I6KG4sbyk9PmBwb3dfdmVjdG9yX2N1c3RvbSgke259LCR7b30pYH0sYFxuICAgIGZuIHBvd19jdXN0b20oYSA6ICR7dH0sIGIgOiAke3R9KSAtPiAke3R9IHtcbiAgICAgIGlmIChiID09ICR7dH0oMC4wKSkge1xuICAgICAgICByZXR1cm4gJHt0fSgxLjApO1xuICAgICAgfSBlbHNlIGlmIChhIDwgJHt0fSgwLjApICYmIGYzMihiKSAhPSBmbG9vcihmMzIoYikpKSB7XG4gICAgICAgIHJldHVybiAke3R9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgJHt0fSgxLjApLCByb3VuZChmMzIoYWJzKGIpICUgJHt0fSgyLjApKSkgIT0gMS4wKSAqICR7dH0oJHt0PT09XCJpMzJcIj9cInJvdW5kXCI6XCJcIn0ocG93KGYzMihhYnMoYSkpLCBmMzIoYikpKSk7XG4gICAgfVxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dH0+LCBiIDogdmVjNDwke3R9PikgLT4gdmVjNDwke3R9PiB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdmVjdG9yaXplZCBwb3dcbiAgICAgIHJldHVybiB2ZWM0PCR7dH0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcbiAgICB9XG4gICAgICBgKX0sSXU9ZT0+e2F0KGUsXCJTdWJcIiwodCxyKT0+YCR7dH0tJHtyfWApfSxDdT1lPT57YXQoZSxcIkdyZWF0ZXJcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH0+JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PiR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sQXU9ZT0+e2F0KGUsXCJMZXNzXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PCR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fTwke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LGt1PWU9PnthdChlLFwiR3JlYXRlck9yRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH0+PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT49JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxFdT1lPT57YXQoZSxcIkxlc3NPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PD0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX19KTt2YXIgZWYsdGYscmYsbmYsenUsT3UsRHU9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtlZj0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2xldCByPTAsbj1lW3JdLG89bi5kYXRhVHlwZSxpPW4uZGltcy5sZW5ndGg7ZS5mb3JFYWNoKChhLGQpPT57aWYoZCE9PXIpe2lmKGEuZGF0YVR5cGUhPT1vKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGJlIG9uZSB0eXBlXCIpO2lmKGEuZGltcy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGVcIik7YS5kaW1zLmZvckVhY2goKGwscCk9PntpZihwIT09dCYmbCE9PW4uZGltc1twXSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX0pfX0pfSx0Zj0oZSx0KT0+YFxuICBmbiBjYWxjdWxhdGVJbnB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7ZX11Pigke3R9KTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX07IGkgKz0gMXUgKSB7XG4gICAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtlfXU7XG4gIH1gLHJmPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgsbj1bXTtmb3IobGV0IG89MDtvPHI7KytvKXtsZXQgaT10LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGVbb10uZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKSk7cj09PTE/bi5wdXNoKGkpOm89PT0wP24ucHVzaChgaWYgKGlucHV0SW5kZXggPT0gJHtvfXUpIHsgJHtpfSB9YCk6bz09PXItMT9uLnB1c2goYGVsc2UgeyAke2l9IH1gKTpuLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtvfSkgeyAke2l9IH1gKX1yZXR1cm4gbi5qb2luKGBcbmApfSxuZj0oZSx0LHIsbik9PntsZXQgbz1rLnNpemUociksaT1uZXcgQXJyYXkoZS5sZW5ndGgpLGE9bmV3IEFycmF5KGUubGVuZ3RoKSxkPTAsbD1bXSxwPVtdLG09W3t0eXBlOjEyLGRhdGE6b31dO2ZvcihsZXQgZz0wO2c8ZS5sZW5ndGg7KytnKWQrPWVbZ10uZGltc1t0XSxpW2ddPWQscC5wdXNoKGVbZ10uZGltcy5sZW5ndGgpLGFbZ109RShgaW5wdXQke2d9YCxuLHBbZ10pLGwucHVzaChcInJhbmtcIiksbS5wdXNoKHt0eXBlOjEyLGRhdGE6aVtnXX0pO2ZvcihsZXQgZz0wO2c8ZS5sZW5ndGg7KytnKW0ucHVzaCguLi5OKGVbZ10uZGltcykpO20ucHVzaCguLi5OKHIpKTtsZXQgdT1NKFwib3V0cHV0XCIsbixyLmxlbmd0aCksaD11LmluZGljZXNHZXQoXCJpbmRpY2VzXCIsdCksXz1BcnJheS5mcm9tKEFycmF5KGkubGVuZ3RoKS5rZXlzKCkpLm1hcChnPT5gdW5pZm9ybXMuc2l6ZUluQ29uY2F0QXhpcyR7Z31gKS5qb2luKFwiLFwiKSx5PWc9PmBcblxuICAkeygoKT0+e2cucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpO2ZvcihsZXQgeD0wO3g8ZS5sZW5ndGg7eCsrKWcucmVnaXN0ZXJVbmlmb3JtKGBzaXplSW5Db25jYXRBeGlzJHt4fWAsXCJ1MzJcIik7cmV0dXJuIGcuZGVjbGFyZVZhcmlhYmxlcyguLi5hLHUpfSkoKX1cblxuICAke3RmKGkubGVuZ3RoLF8pfVxuXG4gICR7Zy5tYWluU3RhcnQoKX1cbiAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7dS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke2h9KTtcbiAgICBpZiAoaW5wdXRJbmRleCAhPSAwdSkge1xuICAgICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7aS5sZW5ndGh9dT4oJHtffSk7XG4gICAgICAke2h9IC09IHNpemVJbkNvbmNhdEF4aXNbaW5wdXRJbmRleCAtIDF1XTtcbiAgICB9XG5cbiAgICAke3JmKGEsdSl9XG4gIH1gO3JldHVybntuYW1lOlwiQ29uY2F0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOmx9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTpufV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOnl9fSx6dT0oZSx0KT0+e2xldCByPWUuaW5wdXRzLG49clswXS5kaW1zLG89ay5ub3JtYWxpemVBeGlzKHQuYXhpcyxuLmxlbmd0aCk7ZWYocixvKTtsZXQgaT1uLnNsaWNlKCk7aVtvXT1yLnJlZHVjZSgoZCxsKT0+ZCsobC5kaW1zLmxlbmd0aD5vP2wuZGltc1tvXTowKSwwKTtsZXQgYT1yLmZpbHRlcihkPT5rLnNpemUoZC5kaW1zKT4wKTtlLmNvbXB1dGUobmYoYSxvLGksclswXS5kYXRhVHlwZSkse2lucHV0czphfSl9LE91PWU9PmVlKHtheGlzOmUuYXhpc30pfSk7dmFyIEtlLGplLFllLEtyLHl0PVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTtLZT0oZSx0LHI9XCJmMzJcIik9Pntzd2l0Y2goZS5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6cmV0dXJuYHZhbHVlID0gbWF4KHZhbHVlLCAke3R9KDAuMCkpO2A7Y2FzZVwiU2lnbW9pZFwiOnJldHVybmB2YWx1ZSA9ICgke3R9KDEuMCkgLyAoJHt0fSgxLjApICsgZXhwKC12YWx1ZSkpKTtgO2Nhc2VcIkNsaXBcIjpyZXR1cm5gdmFsdWUgPSBjbGFtcCh2YWx1ZSwgJHt0fSgke3J9KHVuaWZvcm1zLmNsaXBfbWluKSksICR7dH0oJHtyfSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO2Nhc2VcIkhhcmRTaWdtb2lkXCI6cmV0dXJuYHZhbHVlID0gbWF4KCR7dH0oMC4wKSwgbWluKCR7dH0oMS4wKSwgJHtyfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSArICR7cn0odW5pZm9ybXMuYmV0YSkpKTtgO2Nhc2VcIkxlYWt5UmVsdVwiOnJldHVybmB2YWx1ZSA9IHNlbGVjdCgke3J9KHVuaWZvcm1zLmFscGhhKSAqIHZhbHVlLCB2YWx1ZSwgdmFsdWUgPj0gJHt0fSgwLjApKTtgO2Nhc2VcIlRhbmhcIjpyZXR1cm5gbGV0IGUyeCA9IGV4cCgtMi4wICogYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2lnbih2YWx1ZSkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xuICAgICAgICBgO2Nhc2VcIlwiOnJldHVyblwiXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGl2YXRpb24gJHtlLmFjdGl2YXRpb259YCl9fSxqZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5jbGlwTWF4fSx7dHlwZToxLGRhdGE6ZS5jbGlwTWlufSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0se3R5cGU6MSxkYXRhOmUuYmV0YX0pOmUuYWN0aXZhdGlvbj09PVwiTGVha3lSZWx1XCImJnQucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0pfSxZZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7bmFtZTpcImNsaXBfbWF4XCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImNsaXBfbWluXCIsdHlwZTpcImYzMlwifSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImJldGFcIix0eXBlOlwiZjMyXCJ9KTplLmFjdGl2YXRpb249PT1cIkxlYWt5UmVsdVwiJiZ0LnB1c2goe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0pfSxLcj1lPT57bGV0IHQ9ZT8uYWN0aXZhdGlvbnx8XCJcIjtpZih0PT09XCJIYXJkU2lnbW9pZFwiKXtsZXRbcixuXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8Wy4yLC41XTtyZXR1cm57YWN0aXZhdGlvbjp0LGFscGhhOnIsYmV0YTpufX1lbHNlIGlmKHQ9PT1cIkNsaXBcIil7bGV0W3Isbl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFtKYSxlc107cmV0dXJue2FjdGl2YXRpb246dCxjbGlwTWF4Om4sY2xpcE1pbjpyfX1lbHNlIGlmKHQ9PT1cIkxlYWt5UmVsdVwiKXtsZXRbcl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFsuMDFdO3JldHVybnthY3RpdmF0aW9uOnQsYWxwaGE6cn19cmV0dXJue2FjdGl2YXRpb246dH19fSk7dmFyIEFlLEJ1LGpyPVUoKCk9PntcInVzZSBzdHJpY3RcIjtBZT0oZSx0KT0+e3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dH0+YDtjYXNlIDM6cmV0dXJuYHZlYzM8JHt0fT5gO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3R9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7ZX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxCdT1lPT5gXG4gICAgICAke2U/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7XCI6XCJcIn1cbiAgICAgIGB9KTt2YXIgTXUsUnU9VSgoKT0+e1widXNlIHN0cmljdFwiO011PWU9PmBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke2V9LngpLCBpMzIoJHtlfS55KSwgaTMyKCR7ZX0ueiksIDEpKTtcbn1cbmB9KTt2YXIgWHQsWXIsWnI9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO2FlKCk7eXQoKTtYdD0oZSx0LHIsbixvKT0+e2xldCBpPW4tcjtyZXR1cm5gXG4gICAgICAke0FycmF5LmZyb20oe2xlbmd0aDpyfSkubWFwKChhLGQpPT5gXG4gICAgICBpZiAoJHtxKHQuc2hhcGUsZCx0LnJhbmspfSAhPSAxKSB7XG4gICAgICAgICR7dC5pbmRpY2VzU2V0KGUsZCxxKG8sZCtpLG4pKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7dC5pbmRpY2VzU2V0KGUsZCwwKX1cbiAgICAgIH1gKS5qb2luKFwiXCIpfVxuYH0sWXI9KGUsdCxyLG4sbz0hMSxpKT0+e2xldCBhPWVbMF0uZGltcyxkPWVbMV0uZGltcyxsPWFbYS5sZW5ndGgtMl0scD1kW2QubGVuZ3RoLTFdLG09YVthLmxlbmd0aC0xXSx1PW1lKHApLGg9bWUobSksXz1tZShsKSx5PWsuc2l6ZShyKS91L18sZz1lLmxlbmd0aD4yLHg9bj9uLnNsaWNlKDAsLTIpOnIuc2xpY2UoMCwtMiksdj1bay5zaXplKHgpLGwscF0sUz1be3R5cGU6MTIsZGF0YTp5fSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTptfV07amUodCxTKSxTLnB1c2goLi4uTih4LGEsZCkpLGcmJlMucHVzaCguLi5OKGVbMl0uZGltcykpLFMucHVzaCguLi5OKHYpKTtsZXQgVD1BPT57bGV0IEM9V3IoXCJiYXRjaF9kaW1zXCIsZVswXS5kYXRhVHlwZSx4Lmxlbmd0aCksUD1FKFwiYVwiLGVbMF0uZGF0YVR5cGUsYS5sZW5ndGgsaCksRD1FKFwiYlwiLGVbMV0uZGF0YVR5cGUsZC5sZW5ndGgsdSksUj1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx2Lmxlbmd0aCx1KSxIPXllKFIudHlwZS50ZW5zb3IpLEw9S2UodCxSLnR5cGUudmFsdWUsSCkscmU9W1AsRF0sVj1cIlwiO2lmKGcpe2xldCBqPW8/dToxO3JlLnB1c2goRShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsaikpLFY9YCR7bz9gdmFsdWUgKz0gYmlhc1tjb2wgLyAke2p9XTtgOmB2YWx1ZSArPSAke1IudHlwZS52YWx1ZX0oYmlhc1tyb3cgKyBpXSk7YH1gfWxldCBLPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifV07WWUodCxLKTtsZXQgd2U9KCk9PntsZXQgaj1gdmFyIGFfZGF0YTogJHtQLnR5cGUudmFsdWV9O2A7Zm9yKGxldCBRPTA7UTxoO1ErKylqKz1gXG4gICAgICAgICAgICAgIGxldCBiX2RhdGEke1F9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7UX0pICogdW5pZm9ybXMuTiArIGNvbCkgLyAke3V9XTtgO2ZvcihsZXQgUT0wO1E8XztRKyspe2orPWBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke1F9KSAqIHVuaWZvcm1zLksgKyBrKSAvICR7aH1dO2A7Zm9yKGxldCBpZT0wO2llPGg7aWUrKylqKz1gXG4gICAgICAgICAgICB2YWx1ZXNbJHtRfV0gPSBmbWEoJHtELnR5cGUudmFsdWV9KGFfZGF0YSR7aD09PTE/XCJcIjpgWyR7aWV9XWB9KSwgYl9kYXRhJHtpZX0sIHZhbHVlc1ske1F9XSk7XG5gfXJldHVybiBqfTtyZXR1cm5gXG4gICR7QS5yZWdpc3RlclVuaWZvcm1zKEspLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoQykuZGVjbGFyZVZhcmlhYmxlcyguLi5yZSxSKX1cbiAgJHtBLm1haW5TdGFydCgpfVxuICAgICR7QS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGNvbCA9IChnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLk4gLyAke3V9KSkgKiAke3V9O1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLk4gLyAke3V9KTtcbiAgICBsZXQgc3RyaWRlMSA9IHVuaWZvcm1zLk0gLyAke199O1xuICAgIGxldCByb3cgPSAoaW5kZXgxICUgc3RyaWRlMSkgKiAke199O1xuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHN0cmlkZTE7XG5cbiAgICAke3IubGVuZ3RoPT09Mj9cIlwiOmBsZXQgYmF0Y2hfaW5kaWNlcyA9ICR7Qy5vZmZzZXRUb0luZGljZXMoXCJiYXRjaFwiKX07YH1cblxuICAgIHZhciBhX2luZGljZXM6ICR7UC50eXBlLmluZGljZXN9O1xuICAgICR7WHQoXCJhX2luZGljZXNcIixQLFAucmFuay0yLEMucmFuayxcImJhdGNoX2luZGljZXNcIil9XG4gICAgJHtQLmluZGljZXNTZXQoXCJhX2luZGljZXNcIixQLnJhbmstMiwwKX1cbiAgICAke1AuaW5kaWNlc1NldChcImFfaW5kaWNlc1wiLFAucmFuay0xLDApfVxuICAgIGxldCBhX29mZnNldCA9ICR7UC5pbmRpY2VzVG9PZmZzZXQoXCJhX2luZGljZXNcIil9O1xuXG4gICAgdmFyIGJfaW5kaWNlczogJHtELnR5cGUuaW5kaWNlc307XG4gICAgJHtYdChcImJfaW5kaWNlc1wiLEQsRC5yYW5rLTIsQy5yYW5rLFwiYmF0Y2hfaW5kaWNlc1wiKX1cbiAgICAke0QuaW5kaWNlc1NldChcImJfaW5kaWNlc1wiLEQucmFuay0yLDApfVxuICAgICR7RC5pbmRpY2VzU2V0KFwiYl9pbmRpY2VzXCIsRC5yYW5rLTEsMCl9XG4gICAgbGV0IGJfb2Zmc2V0ID0gJHtELmluZGljZXNUb09mZnNldChcImJfaW5kaWNlc1wiKX07XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtSLnR5cGUudmFsdWV9LCAke199PjtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsgPSBrICsgJHtofSkge1xuICAgICAgJHt3ZSgpfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke199dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke1Z9XG4gICAgICAke0x9XG4gICAgICBsZXQgY3VyX2luZGljZXMgPSAke1IudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93ICsgaSwgY29sKTtcbiAgICAgIGxldCBvZmZzZXQgPSAke1IuaW5kaWNlc1RvT2Zmc2V0KFwiY3VyX2luZGljZXNcIil9O1xuICAgICAgJHtSLnNldEJ5T2Zmc2V0KGBvZmZzZXQgLyAke3V9YCxcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1cbiAgYH07cmV0dXJue25hbWU6XCJNYXRNdWxOYWl2ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYWN0aXZhdGlvbn07JHt1fTske2h9OyR7X307JHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6Zz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aT9pKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6U30pLGdldFNoYWRlclNvdXJjZTpUfX19KTt2YXIgb2YsYWYsZm8sVXUsc2YsaG8sdWYsSnQsUXI9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO2FlKCk7eXQoKTtacigpO2pyKCk7b2Y9KGUsdCk9PmU/YFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICBgOmBcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXG4gICAgICAgICAga1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIGAsYWY9KGUsdCk9PmU/YFxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMSA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XG4gICAgICAgICR7dD09PTM/XCJcIjpcImxldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107XCJ9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldO1wifVxuICAgICAgICB9YDpgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldO1wifVxuICAgICAgICB9YCxmbz0oZSx0LHI9XCJmMzJcIixuLG89ITEsaT0zMixhPSExLGQ9MzIpPT57bGV0IGw9dFsxXSplWzFdLHA9dFswXSplWzBdLG09bz9sOmksdT1vP2k6bCxoPW0vdFswXSxfPWkvdFsxXTtpZighKChvJiZoPT09NCYmZVsxXT09PTR8fCFvJiYoaD09PTN8fGg9PT00KSkmJm0ldFswXT09PTAmJmkldFsxXT09PTAmJmVbMF09PT00KSl0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHtvfSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7aH0gYW5kIHdvcmtQZXJUaHJlYWRbMV0gJHtlWzFdfSBtdXN0IGJlIDQuXG4gICAgICBPdGhlcndpc2UsIGlubmVyRWxlbWVudFNpemUgJHtofSBtdXN0IGJlIDMgb3IgNC5cbiAgdGlsZUFXaWR0aCAke219IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LiB0aWxlSW5uZXIgJHtpfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7dFsxXX0uIGNvbFBlclRocmVhZCAke2VbMF19IG11c3QgYmUgNC5gKTtyZXR1cm5gXG52YXI8d29ya2dyb3VwPiBtbV9Bc3ViOiBhcnJheTxhcnJheTx2ZWMke2h9PCR7cn0+LCAke20vaH0+LCAke3V9PjtcbnZhcjx3b3JrZ3JvdXA+IG1tX0JzdWI6IGFycmF5PGFycmF5PHZlYzQ8JHtyfT4sICR7cC9lWzBdfT4sICR7aX0+O1xuXG5jb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xuY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcbmNvbnN0IGlubmVyRWxlbWVudFNpemUgPSAke2h9O1xuY29uc3QgdGlsZUlubmVyID0gJHtpfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgbGV0IHRpbGVSb3cgPSBsb2NhbFJvdyAqIHJvd1BlclRocmVhZDtcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcblxuICBsZXQgZ2xvYmFsUm93ID1pMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCk7XG4gIGxldCBiYXRjaCA9ICR7YT9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcbiAgJHtuP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHtuLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cbiAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtsfTtcblxuICBsZXQgbnVtX3RpbGVzID0gJHthP2Ake01hdGguY2VpbChkL2kpfWA6XCIodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xuICB2YXIga1N0YXJ0ID0gJHthP2BpMzIoZ2xvYmFsSWQueikgKiAke2R9YDpcIjBcIn07XG5cbiAgdmFyIGFjYzogYXJyYXk8dmVjNDwke3J9Piwgcm93UGVyVGhyZWFkPjtcblxuICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgbGV0IHRpbGVSb3dCID0gbG9jYWxSb3cgKiAke199O1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3cgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgICR7b2YobyxuKX1cbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7X307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLCBrU3RhcnQgKyBpbnB1dFJvdywgZ2xvYmFsQ29sJHtuP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcbiAgICAgICAgICBsZXQgQkNhY2hlZDAgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDEgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xuICAgICAgICAgICR7aD09PTM/XCJcIjpcImxldCBCQ2FjaGVkMyA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVt0aWxlQ29sXTtcIn1cblxuICAgICAgICAgICR7YWYobyxoKX1cbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICB9XG5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcbiAgfVxufWB9LFV1PShlLHQpPT5lP2BcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICAgICAgYDpgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgICAgIGAsc2Y9ZT0+ZT9cImxldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddO1wiOlwibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107XCIsaG89KGUsdCxyPVwiZjMyXCIsbixvPSExLGk9MzIsYT0hMSxkPTMyLGw9ITEpPT57bGV0IHA9ZVsxXSp0WzFdLG09ZVswXSp0WzBdLHU9bz9wOmksaD1vP2k6cDtpZighKGgldFsxXT09PTAmJnUldFswXT09PTAmJmkldFsxXT09PTApKXRocm93IG5ldyBFcnJvcihgdGlsZUFIaWdodCAke2h9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19LCB0aWxlQVdpZHRoICR7dX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0sIHRpbGVJbm5lciAke2l9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19YCk7bGV0IF89aC90WzFdLHk9dS90WzBdLGc9aS90WzFdLHg9bD9gXG4gICAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gICAgbGV0IGxvY2FsQ29sID0gaTMyKGxvY2FsSWQueCk7XG4gICAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtwfTtcbiAgICBsZXQgZ2xvYmFsQ29sU3RhcnQgPSBpMzIod29ya2dyb3VwSWQueCkgKiAke219O1xuXG4gICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke2h9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xuICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7dX07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XG4gICAgICAgICAgJHtVdShvLG4pfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7aX07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7bX07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke24/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPjtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bbG9jYWxDb2wgKyBpbm5lciAqICR7dFswXX1dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSAke28/YG1tX0FzdWJba11bbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dO2A6YG1tX0FzdWJbbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dW2tdO2B9XG4gICAgICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gK1xuICAgICAgICAgICAgICAgIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIGxldCBnUm93ID0gZ2xvYmFsUm93U3RhcnQgKyBsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfTtcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGxldCBnQ29sID0gZ2xvYmFsQ29sU3RhcnQgKyBsb2NhbENvbCArIGlubmVyQ29sICogJHt0WzBdfTtcbiAgICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdSb3csIGdDb2wsIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYDpgXG5sZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcblxubGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3B9O1xuXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7X307XG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7eX07XG5sZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7Z307XG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtffTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHt5fTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sQSArIGlubmVyQ29sO1xuICAgICAgJHtVdShvLG4pfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7Z307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sICsgaW5uZXJDb2w7XG4gICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgIGdsb2JhbENvbCArIGlubmVyQ29sJHtuP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgfVxuICB9XG4gIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD47XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICR7c2Yobyl9XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICsgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcbn1cblxuZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gIH1cbn1cbmA7cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8JHtyfSwgJHt1fT4sICR7aH0+O1xuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8JHtyfSwgJHttfT4sICR7aX0+O1xuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xuICBjb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xuICBjb25zdCB0aWxlSW5uZXIgPSAke2l9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gICAgbGV0IGJhdGNoID0gJHthP1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xuICAgICR7bj9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7bi5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XG4gICAgbGV0IG51bV90aWxlcyA9ICR7YT9gJHtNYXRoLmNlaWwoZC9pKX1gOlwiKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcbiAgICB2YXIga1N0YXJ0ID0gJHthP2BpMzIoZ2xvYmFsSWQueikgKiAke2R9YDpcIjBcIn07XG5cbiAgICB2YXIgYWNjIDogYXJyYXk8YXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPiwgcm93UGVyVGhyZWFkPjtcbiAgICAke3h9XG4gIH1cbmB9LHVmPShlLHQscixuLG89ITEpPT57bGV0W2ksYSxkLGxdPW4scD15ZShuWzBdLnR5cGUudGVuc29yKTtyZXR1cm5gXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtpLnR5cGUuaW5kaWNlc30pIC0+ICR7QWUoZSxwKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHtBZShlLHApfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcilcbiAgICAgIHtcbiAgICAgICAgdmFyIGFJbmRpY2VzOiAke2EudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHtYdChcImFJbmRpY2VzXCIsYSxhLnJhbmstMixpLnJhbmssXCJiYXRjaEluZGljZXNcIil9XG4gICAgICAgICR7YS5pbmRpY2VzU2V0KFwiYUluZGljZXNcIixhLnJhbmstMixcInUzMihyb3cpXCIpfVxuICAgICAgICAke2EuaW5kaWNlc1NldChcImFJbmRpY2VzXCIsYS5yYW5rLTEsXCJ1MzIoY29sSW4pXCIpfVxuICAgICAgICB2YWx1ZSA9ICR7YS5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtpLnR5cGUuaW5kaWNlc30pIC0+ICR7QWUoZSxwKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHtBZShlLHApfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgICAgdmFyIGJJbmRpY2VzOiAke2QudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHtYdChcImJJbmRpY2VzXCIsZCxkLnJhbmstMixpLnJhbmssXCJiYXRjaEluZGljZXNcIil9XG4gICAgICAgICR7ZC5pbmRpY2VzU2V0KFwiYkluZGljZXNcIixkLnJhbmstMixcInUzMihyb3cpXCIpfVxuICAgICAgICAke2QuaW5kaWNlc1NldChcImJJbmRpY2VzXCIsZC5yYW5rLTEsXCJ1MzIoY29sSW4pXCIpfVxuICAgICAgICB2YWx1ZSA9ICR7ZC5nZXRCeUluZGljZXMoXCJiSW5kaWNlc1wiKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7QWUoZSxwKX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzM8aTMyPihiYXRjaCwgcm93LCBjb2xJbik7XG4gICAgICAgICR7dD9gdmFsdWUgPSB2YWx1ZSArICR7bz9cImJpYXNbY29sSW5dXCI6YCR7QWUoZSxwKX0oYmlhc1tyb3ddKWB9O2A6XCJcIn1cbiAgICAgICAgJHtyfVxuICAgICAgICAke2wuc2V0QnlJbmRpY2VzKFwidmVjMzx1MzI+KGNvb3JkcylcIixcInZhbHVlXCIpfVxuICAgICAgfVxuICAgIH1cbiAgICBgfSxKdD0oZSx0LHIsbixvPSExLGkpPT57bGV0IGE9ZVswXS5kaW1zLGQ9ZVsxXS5kaW1zLGw9YS5zbGljZSgwLC0yKSxwPWQuc2xpY2UoMCwtMiksbT1uP24uc2xpY2UoMCwtMik6ci5zbGljZSgwLC0yKSx1PWsuc2l6ZShtKSxoPWFbYS5sZW5ndGgtMl0sXz1hW2EubGVuZ3RoLTFdLHk9ZFtkLmxlbmd0aC0xXSxnPV8lND09PTAmJnklND09PTAseD1oPD04P1s0LDEsMV06WzQsNCwxXSwkPVs4LDgsMV0sdj1bTWF0aC5jZWlsKHkvJFswXS94WzBdKSxNYXRoLmNlaWwoaC8kWzFdL3hbMV0pLE1hdGguY2VpbCh1LyRbMl0veFsyXSldLFM9Zz80OjEsVD1bLi4ubCxoLF8vU10sQT1ULmxlbmd0aCxDPVsuLi5wLF8seS9TXSxQPUMubGVuZ3RoLEQ9W3UsaCx5L1NdLFI9W3t0eXBlOjYsZGF0YTpofSx7dHlwZTo2LGRhdGE6eX0se3R5cGU6NixkYXRhOl99XTtqZSh0LFIpLFIucHVzaCguLi5OKG0sVCxDKSk7bGV0IEg9W1wicmFua1wiLFwicmFua1wiXSxMPWUubGVuZ3RoPjI7TCYmKFIucHVzaCguLi5OKGVbMl0uZGltcykpLEgucHVzaChcInJhbmtcIikpLFIucHVzaCguLi5OKEQpKTtsZXQgcmU9Vj0+e2xldCBLPW0ubGVuZ3RoLHdlPVdyKFwiYmF0Y2hEaW1zXCIsZVswXS5kYXRhVHlwZSxLLDEpLGo9eWUoZVswXS5kYXRhVHlwZSksUT1FKFwiYVwiLGVbMF0uZGF0YVR5cGUsQSxTKSxpZT1FKFwiYlwiLGVbMV0uZGF0YVR5cGUsUCxTKSx0ZT1NKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxELmxlbmd0aCxTKSxiZT1bUSxpZV07aWYoTCl7bGV0IFk9bz9TOjE7YmUucHVzaChFKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxZKSl9bGV0IE9lPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn1dO1llKHQsT2UpO2xldCB2ZT15ZSh0ZS50eXBlLnRlbnNvciksZGU9S2UodCx0ZS50eXBlLnZhbHVlLHZlKSxXPXVmKFMsTCxkZSxbd2UsUSxpZSx0ZV0sbyk7cmV0dXJuYFxuICAke1YucmVnaXN0ZXJVbmlmb3JtcyhPZSkucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyh3ZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5iZSx0ZSl9XG4gICR7V31cbiAgJHtnP2ZvKHgsJCxqLHdlKTpobyh4LCQsaix3ZSl9XG4gICAgICAgICAgICAgICAgICAgYH07cmV0dXJue25hbWU6XCJNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDpgJHt4fTske3QuYWN0aXZhdGlvbn07JHtnfTske299YCxpbnB1dERlcGVuZGVuY2llczpIfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmk/aShyKTpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OnZbMF0seTp2WzFdLHo6dlsyXX0scHJvZ3JhbVVuaWZvcm1zOlJ9KSxnZXRTaGFkZXJTb3VyY2U6cmV9fX0pO3ZhciBkZixOdSxWdT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO2V0KCk7YWUoKTt5dCgpO2pyKCk7UnUoKTtRcigpO2RmPShlLHQscixuLG89ITEsaSxhPTQsZD00LGw9NCxwPVwiZjMyXCIpPT57bGV0IG09SD0+e3N3aXRjaChIKXtjYXNlIDE6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXhdO1wiO2Nhc2UgMzpyZXR1cm5gcmVzRGF0YSA9IHZlYzM8JHtwfT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO2Nhc2UgNDpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleCAvIDRdO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7SH0gaXMgbm90IHN1cHBvcnRlZC5gKX19LHU9SD0+e3N3aXRjaChIKXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgKyBjb2xJbl07XCI7Y2FzZSA0OnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pIC8gNCArIGNvbEluXTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0h9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxoPWU/YFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeFJvdywgeENvbCwgeENoKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XG4gICAgYCxfPWU/YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxuICAgICAgcm93ICUgb3V0V2lkdGgsXG4gICAgICBjb2wpO1xuICAgIGA6YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGAseT1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVsyXSlcIixnPWU/XCJpMzIodW5pZm9ybXMueF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy54X3NoYXBlWzNdKVwiLHg9ZT9cInJvd1wiOlwiY29sXCIsJD1lP1wiY29sXCI6XCJyb3dcIix2PWBcbiAgICBsZXQgaW5DaGFubmVscyA9IGkzMih1bmlmb3Jtcy53X3NoYXBlWzJdKTtcbiAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XG4gICAgbGV0IG91dFJvdyA9ICR7eH0gLyBvdXRXaWR0aDtcbiAgICBsZXQgb3V0Q29sID0gJHt4fSAlIG91dFdpZHRoO1xuXG4gICAgbGV0IFdSb3cgPSAkeyR9IC8gKGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKSAqIGluQ2hhbm5lbHMpO1xuICAgIGxldCBXQ29sID0gJHskfSAvIGluQ2hhbm5lbHMgJSBpMzIodW5pZm9ybXMud19zaGFwZVsxXSk7XG4gICAgbGV0IHhSb3cgPSBvdXRSb3cgKiB1bmlmb3Jtcy5zdHJpZGVbMF0gKyB1bmlmb3Jtcy5kaWxhdGlvblswXSAqIFdSb3cgLSB1bmlmb3Jtcy5wYWRbMF07XG4gICAgbGV0IHhDb2wgPSBvdXRDb2wgKiB1bmlmb3Jtcy5zdHJpZGVbMV0gKyB1bmlmb3Jtcy5kaWxhdGlvblsxXSAqIFdDb2wgLSB1bmlmb3Jtcy5wYWRbMV07XG4gICAgbGV0IHhDaCA9ICR7JH0gJSBpbkNoYW5uZWxzO1xuICAgIHZhciByZXNEYXRhID0gJHtBZShhLHApfSgwLjApO1xuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXG4gICAgLy8gdGhlICdzYW1lJyBwYWRkaW5nIHR5cGUuXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHt5fSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7Z30pIHtcbiAgICAgICR7aH1cbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKTtcbiAgICAgICR7bShhKX1cbiAgICB9XG4gICAgcmV0dXJuIHJlc0RhdGE7YCxTPWU/dCYmbj9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICAke3Z9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKSB7XG4gICAgICAke3Z9XG4gICAgfVxuICAgIHJldHVybiAke0FlKGEscCl9KDAuMCk7YDpuJiZyP2BcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2F9O1xuICAgICR7dn1gOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2F9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7dn1cbiAgICB9XG4gICAgcmV0dXJuICR7QWUoYSxwKX0oMC4wKTtgLFQ9ZT9uJiZyP3UoZCk6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZH07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgJHt1KGQpfVxuICAgIH1cbiAgICByZXR1cm4gJHtBZShkLHApfSgwLjApO2A6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZH07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlcikge1xuICAgICAgJHt1KGQpfVxuICAgIH1cbiAgICByZXR1cm4gJHtBZShkLHApfSgwLjApO2AsQT1BZShsLHApLEM9ZT9BZShhLHApOkFlKGQscCksUD1lP0FlKGQscCk6QWUoYSxwKSxEPUtlKGksQSxwKTtyZXR1cm5gXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtDfSB7XG4gICAgICAke2U/UzpUfVxuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7UH0ge1xuICAgICAgJHtlP1Q6U31cbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUluIDogJHtBfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtsfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XG4gICAgICAke199XG4gICAgICAke0J1KG8pfVxuICAgICAgJHtEfVxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWB9LE51PShlLHQscixuLG8saSxhLGQsbCk9PntsZXQgcD10LmZvcm1hdD09PVwiTkhXQ1wiLG09cD9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLHU9clswXSxoPXA/clsyXTpyWzNdLF89cD9yWzFdOnJbMl0seT1wP3JbM106clsxXSxnPXAmJihtJTQ9PT0wfHxtJTM9PT0wKSYmeSU0PT09MCx4PXA/eTpoKl8sJD1wP2gqXzp5LHY9WzgsOCwxXSxTPW48PTg/WzQsMSwxXTpbNCw0LDFdLFQ9W01hdGguY2VpbCh4L3ZbMF0vU1swXSksTWF0aC5jZWlsKCQvdlsxXS9TWzFdKSxNYXRoLmNlaWwodS92WzJdL1NbMl0pXTtzZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfbW1fd2ViZ3B1XSBkaXNwYXRjaCA9ICR7VH1gKTtsZXQgQT1nP3AmJm0lNCE9PTA/Mzo0OjEsQz12WzFdKlNbMV0sUD12WzBdKlNbMF0sRD1NYXRoLm1heCh2WzBdKkEsdlsxXSksUj1uJUM9PT0wLEg9byVQPT09MCxMPWklRD09PTAscmU9Zz9bQSw0LDRdOlsxLDEsMV0sVj1be3R5cGU6NixkYXRhOm59LHt0eXBlOjYsZGF0YTpvfSx7dHlwZTo2LGRhdGE6aX0se3R5cGU6NixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX0se3R5cGU6NixkYXRhOnQuc3RyaWRlc30se3R5cGU6NixkYXRhOnQuZGlsYXRpb25zfV07amUodCxWKSxWLnB1c2goLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IEs9W1wicmFua1wiLFwicmFua1wiXTthJiYoVi5wdXNoKC4uLk4oZVsyXS5kaW1zKSksSy5wdXNoKFwicmFua1wiKSksVi5wdXNoKC4uLk4ocikpO2xldCB3ZT1qPT57bGV0IFE9W3tuYW1lOlwiZGltX2Ffb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2Jfb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2lubmVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcInBhZFwiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJzdHJpZGVcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwiZGlsYXRpb25cIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9XTtZZSh0LFEpO2xldCBpZT1nPzQ6MSx0ZT15ZShlWzBdLmRhdGFUeXBlKSxiZT1gXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAke2c/YHZlYzQ8JHt0ZX0+YDp0ZX0pIHtcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke2c/YHZlYzQ8JHt0ZX0+YDp0ZX0odmFsdWUpO1xuICAgICAgfVxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHMoZDAgOiBpMzIsIGQxIDogaTMyLCBkMiA6IGkzMiwgZDMgOiBpMzIsIHZhbHVlIDogJHtnP2B2ZWM0PCR7dGV9PmA6dGV9KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7Zz9cIi8gNFwiOlwiXCJ9LCB2YWx1ZSk7XG4gICAgICB9YCxPZT1FKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCxBPT09Mz8xOkEpLHZlPUUoXCJ3XCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLGllKSxkZT1bT2UsdmVdLFc9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgsaWUpO2lmKGEpe2xldCBZPUUoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLGllKTtkZS5wdXNoKFkpLGJlKz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7Zz9gdmVjNDwke3RlfT5gOnRlfSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7cD9cIndcIjpcInlcIn0ke2c/XCIvIDRcIjpcIlwifV07XG4gICAgICAgIH1gfXJldHVybmBcbiAgICAgICAgJHtNdShcInVuaWZvcm1zLnJlc3VsdF9zdHJpZGVzXCIpfVxuICAgICAgICAvL3N0cnVjdCBVbmlmb3JtcyB7IHhTaGFwZSA6IHZlYzQ8aTMyPiwgd1NoYXBlIDogdmVjNDxpMzI+LCBvdXRTaGFwZSA6IHZlYzQ8aTMyPixcbiAgICAgICAgLy8gIG91dFNoYXBlU3RyaWRlczogdmVjMzxpMzI+LCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+LCBwYWQgOiB2ZWMyPGkzMj4sIHN0cmlkZSA6IHZlYzI8aTMyPixcbiAgICAgICAgLy8gIGRpbGF0aW9uIDogdmVjMjxpMzI+LCBkaW1BT3V0ZXIgOiBpMzIsIGRpbUJPdXRlciA6IGkzMiwgZGltSW5uZXIgOiBpMzIgfTtcbiAgICAgICAgJHtqLnJlZ2lzdGVyVW5pZm9ybXMoUSkuZGVjbGFyZVZhcmlhYmxlcyguLi5kZSxXKX1cbiAgICAgICAgJHtiZX1cbiAgICAgICAgJHtkZihwLFIsSCxMLGEsdCxyZVswXSxyZVsxXSxyZVsyXSx0ZSl9XG4gICAgICAgICR7Zz9mbyhTLHYsdGUsdm9pZCAwLCFwLEQpOmhvKFMsdix0ZSx2b2lkIDAsIXAsRCwhMSx2b2lkIDAsZCl9YH07cmV0dXJue25hbWU6XCJDb252MkRNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske0F9OyR7Z307JHtSfTske0h9OyR7TH07JHtDfTske1B9OyR7RH1gLGlucHV0RGVwZW5kZW5jaWVzOkt9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bD9sKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6VFswXSx5OlRbMV0sejpUWzJdfSxwcm9ncmFtVW5pZm9ybXM6Vn0pLGdldFNoYWRlclNvdXJjZTp3ZX19fSk7dmFyIGxmLFd1LFhyLGNmLEx1LHBmLEd1LEh1LEZ1PVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7ZXQoKTtuZSgpO2FlKCk7eXQoKTtqcigpO2xmPWU9PntsZXQgdD0xO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXQqPWVbcl07cmV0dXJuIHR9LFd1PWU9PnR5cGVvZiBlPT1cIm51bWJlclwiP1tlLGUsZV06ZSxYcj0oZSx0KT0+dDw9MT9lOmUrKGUtMSkqKHQtMSksY2Y9KGUsdCxyLG49MSk9PntsZXQgbz1Ycih0LG4pO3JldHVybiBNYXRoLmZsb29yKChlWzBdKihyLTEpLXIrbykvMil9LEx1PShlLHQscixuLG8pPT57bz09bnVsbCYmKG89Y2YoZSx0WzBdLG5bMF0pKTtsZXQgaT1bMCwwLDAscl07Zm9yKGxldCBhPTA7YTwzO2ErKyllW2FdKzIqbz49dFthXSYmKGlbYV09TWF0aC50cnVuYygoZVthXS10W2FdKzIqbykvblthXSsxKSk7cmV0dXJuIGl9LHBmPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtLHUsaCxfO2lmKGU9PT1cIlZBTElEXCImJihlPTApLHR5cGVvZiBlPT1cIm51bWJlclwiKXttPXt0b3A6ZSxib3R0b206ZSxsZWZ0OmUscmlnaHQ6ZSxmcm9udDplLGJhY2s6ZX07bGV0IHk9THUoW3QscixuLDFdLFtkLGwscF0sMSxbbyxpLGFdLGUpO3U9eVswXSxoPXlbMV0sXz15WzJdfWVsc2UgaWYoQXJyYXkuaXNBcnJheShlKSl7aWYoIWUuZXZlcnkoKGcseCwkKT0+Zz09PSRbMF0pKXRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO209e3RvcDplWzBdLGJvdHRvbTplWzFdLGxlZnQ6ZVsyXSxyaWdodDplWzNdLGZyb250OmVbNF0sYmFjazplWzVdfTtsZXQgeT1MdShbdCxyLG4sMV0sW2QsbCxwXSwxLFtvLGksYV0sZVswXSk7dT15WzBdLGg9eVsxXSxfPXlbMl19ZWxzZSBpZihlPT09XCJTQU1FX1VQUEVSXCIpe3U9TWF0aC5jZWlsKHQvbyksaD1NYXRoLmNlaWwoci9pKSxfPU1hdGguY2VpbChuL2EpO2xldCB5PSh1LTEpKm8rZC10LGc9KGgtMSkqaStsLXIseD0oXy0xKSphK3AtbiwkPU1hdGguZmxvb3IoeS8yKSx2PXktJCxTPU1hdGguZmxvb3IoZy8yKSxUPWctUyxBPU1hdGguZmxvb3IoeC8yKSxDPXgtQTttPXt0b3A6Uyxib3R0b206VCxsZWZ0OkEscmlnaHQ6Qyxmcm9udDokLGJhY2s6dn19ZWxzZSB0aHJvdyBFcnJvcihgVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO3JldHVybntwYWRJbmZvOm0sb3V0RGVwdGg6dSxvdXRIZWlnaHQ6aCxvdXRXaWR0aDpffX0sR3U9KGUsdCxyLG4sbyxpPSExLGE9XCJjaGFubmVsc0xhc3RcIik9PntsZXQgZCxsLHAsbSx1O2lmKGE9PT1cImNoYW5uZWxzTGFzdFwiKVtkLGwscCxtLHVdPWU7ZWxzZSBpZihhPT09XCJjaGFubmVsc0ZpcnN0XCIpW2QsdSxsLHAsbV09ZTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7YX1gKTtsZXRbaCwsXyx5LGddPXQsW3gsJCx2XT1XdShyKSxbUyxULEFdPVd1KG4pLEM9WHIoXyxTKSxQPVhyKHksVCksRD1YcihnLEEpLHtwYWRJbmZvOlIsb3V0RGVwdGg6SCxvdXRIZWlnaHQ6TCxvdXRXaWR0aDpyZX09cGYobyxsLHAsbSx4LCQsdixDLFAsRCksVj1pP2gqdTpoLEs9WzAsMCwwLDAsMF07cmV0dXJuIGE9PT1cImNoYW5uZWxzRmlyc3RcIj9LPVtkLFYsSCxMLHJlXTphPT09XCJjaGFubmVsc0xhc3RcIiYmKEs9W2QsSCxMLHJlLFZdKSx7YmF0Y2hTaXplOmQsZGF0YUZvcm1hdDphLGluRGVwdGg6bCxpbkhlaWdodDpwLGluV2lkdGg6bSxpbkNoYW5uZWxzOnUsb3V0RGVwdGg6SCxvdXRIZWlnaHQ6TCxvdXRXaWR0aDpyZSxvdXRDaGFubmVsczpWLHBhZEluZm86UixzdHJpZGVEZXB0aDp4LHN0cmlkZUhlaWdodDokLHN0cmlkZVdpZHRoOnYsZmlsdGVyRGVwdGg6XyxmaWx0ZXJIZWlnaHQ6eSxmaWx0ZXJXaWR0aDpnLGVmZmVjdGl2ZUZpbHRlckRlcHRoOkMsZWZmZWN0aXZlRmlsdGVySGVpZ2h0OlAsZWZmZWN0aXZlRmlsdGVyV2lkdGg6RCxkaWxhdGlvbkRlcHRoOlMsZGlsYXRpb25IZWlnaHQ6VCxkaWxhdGlvbldpZHRoOkEsaW5TaGFwZTplLG91dFNoYXBlOkssZmlsdGVyU2hhcGU6dH19LEh1PShlLHQscixuLG8saSk9PntsZXQgYT1pPT09XCJjaGFubmVsc0xhc3RcIixkPWE/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSxsPSExLHA9WzY0LDEsMV0sbT17eDpyLm1hcCgodixTKT0+Uyl9LHU9W01hdGguY2VpbChsZihtLngubWFwKHY9PnJbdl0pKS9wWzBdKSwxLDFdO3NlKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYzZF9uYWl2ZV93ZWJncHVdIGRpc3BhdGNoID0gJHt1fWApO2xldCBoPWw/YSYmZCU0IT09MD8zOjQ6MSxfPWsuc2l6ZShyKSx5PVt7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOnQuc3RyaWRlc30se3R5cGU6MTIsZGF0YTp0LmRpbGF0aW9uc31dO2plKHQseSkseS5wdXNoKC4uLk4oZVswXS5kaW1zLGVbMV0uZGltcykpO2xldCBnPVtcInJhbmtcIixcInJhbmtcIl0seD1lLmxlbmd0aD09PTM7eCYmKHkucHVzaCguLi5OKGVbMl0uZGltcykpLGcucHVzaChcInJhbmtcIikpLHkucHVzaCguLi5OKHIpKTtsZXQgJD12PT57bGV0IFM9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOm4ubGVuZ3RofSx7bmFtZTpcInBhZHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOm8ubGVuZ3RofSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuc3RyaWRlcy5sZW5ndGh9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LmRpbGF0aW9ucy5sZW5ndGh9XTtZZSh0LFMpO2xldCBUPWw/NDoxLEE9eWUoZVswXS5kYXRhVHlwZSksQz1FKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCxoPT09Mz8xOmgpLFA9RShcIldcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgsVCksRD1bQyxQXSxSPU0oXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoLFQpLEg9XCJcIjtpZih4KXtsZXQgVj1FKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxUKTtELnB1c2goViksSCs9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogYXJyYXk8dTMyLCA1PikgLT4gJHtsP2B2ZWM0PCR7QX0+YDpBfSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbJHthP3EoXCJjb29yZHNcIiw0LDUpOnEoXCJjb29yZHNcIiwxLDUpfSR7bD9cIi8gNFwiOlwiXCJ9XTtcbiAgICAgICAgfWB9bGV0IEw9QWUoaCxBKSxyZT1LZSh0LEwsQSk7cmV0dXJuYFxuICAgICAgICAgICAgJHtIfVxuICAgICAgICAgICAgZm4gZ2V0WChkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7Qy5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbiBnZXRXKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHtQLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAke3YucmVnaXN0ZXJVbmlmb3JtcyhTKS5kZWNsYXJlVmFyaWFibGVzKC4uLkQsUil9XG4gICAgICAgICAgJHt2Lm1haW5TdGFydCgpfVxuICAgICAgICAgICR7di5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgICAgIGxldCBjb29yZHMgPSAke1Iub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIGxldCBiYXRjaCA9ICR7cShcImNvb3Jkc1wiLDAsQy5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCBkMiA9ICR7YT9xKFwiY29vcmRzXCIsQy5yYW5rLTEsQy5yYW5rKTpxKFwiY29vcmRzXCIsMSxDLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhGUkNDb3JuZXIgPSB2ZWMzPHUzMj4oJHthP3EoXCJjb29yZHNcIiwxLEMucmFuayk6cShcImNvb3Jkc1wiLDIsQy5yYW5rKX0sXG4gICAgICAgICAgICAgICR7YT9xKFwiY29vcmRzXCIsMixDLnJhbmspOnEoXCJjb29yZHNcIiwzLEMucmFuayl9LFxuICAgICAgICAgICAgICAke2E/cShcImNvb3Jkc1wiLDMsQy5yYW5rKTpxKFwiY29vcmRzXCIsNCxDLnJhbmspfSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICAgICAgICAgICAgbGV0IHhGQ29ybmVyID0geEZSQ0Nvcm5lci54O1xuICAgICAgICAgICAgICBsZXQgeFJDb3JuZXIgPSB4RlJDQ29ybmVyLnk7XG4gICAgICAgICAgICAgIGxldCB4Q0Nvcm5lciA9IHhGUkNDb3JuZXIuejtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVkgPSAke2E/cShcInVuaWZvcm1zLnhfc2hhcGVcIiwxLEMucmFuayk6cShcInVuaWZvcm1zLnhfc2hhcGVcIiwyLEMucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlWiA9ICR7YT9xKFwidW5pZm9ybXMueF9zaGFwZVwiLDIsQy5yYW5rKTpxKFwidW5pZm9ybXMueF9zaGFwZVwiLDMsQy5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVXID0gJHthP3EoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMyxDLnJhbmspOnEoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsNCxDLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVUgPSAke2E/cShcInVuaWZvcm1zLnhfc2hhcGVcIiw0LEMucmFuayk6cShcInVuaWZvcm1zLnhfc2hhcGVcIiwxLEMucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gKHhTaGFwZVUgLyA0KSAqIDQ7XG4gICAgICAgICAgICAgIGxldCBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IHhTaGFwZVUgJSA0O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IDAuMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgd0YgPSAwdTsgd0YgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd0YrKykge1xuICAgICAgICAgICAgICAgIGxldCB4RiA9IHhGQ29ybmVyICsgd0YgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSB4U2hhcGVZKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDB1OyB3UiA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdOyB3UisrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFIgPSB4UkNvcm5lciArIHdSICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSB4U2hhcGVaKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB3QyA9IDB1OyB3QyA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzJdOyB3QysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4QyA9IHhDQ29ybmVyICsgd0MgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0geFNoYXBlVykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwdTsgZDEgPCBpbnB1dERlcHRoTmVhcmVzdFZlYzQ7IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke2E/YGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAyLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDMsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMiwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDMsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR7YT9gdmFsdWUgKz0gZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YDpgdmFsdWUgKz0gZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHthP2BsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICR7YT9gbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke3g/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcylcIjpcIlwifTtcbiAgICAgICAgICAgICAgJHtyZX1cbiAgICAgICAgICAgICAgcmVzdWx0W2dsb2JhbF9pZHhdID0gZjMyKHZhbHVlKTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDb252M0ROYWl2ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7YX07JHtofTske3h9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6dVswXSx5OnVbMV0sejp1WzJdfSxwcm9ncmFtVW5pZm9ybXM6eX0pLGdldFNoYWRlclNvdXJjZTokfX19KTt2YXIgcXUsS3UsanU9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO2FlKCk7eXQoKTtxdT0oZSx0LHIsbik9PntsZXQgbz1lLmxlbmd0aD4yLGk9bz9cInZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdO1wiOlwiXCIsYT1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD10LmZvcm1hdD09PVwiTkhXQ1wiLHA9bD9yWzNdOnJbMV0sbT1wL3QuZ3JvdXAsdT1sJiZtPj00P21lKHApOjEsaD1rLnNpemUocikvdSxfPVt7dHlwZToxMixkYXRhOmh9LHt0eXBlOjEyLGRhdGE6dC5kaWxhdGlvbnN9LHt0eXBlOjEyLGRhdGE6W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dfSx7dHlwZToxMixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX0se3R5cGU6MTIsZGF0YTptfV07amUodCxfKSxfLnB1c2goLi4uTihhLFtkWzBdLGRbMV0sZFsyXSxkWzNdL3VdKSk7bGV0IHk9bz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl07Xy5wdXNoKC4uLk4oW3JbMF0sclsxXSxyWzJdLHJbM10vdV0pKTtsZXQgZz14PT57bGV0ICQ9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgsdSksdj15ZSgkLnR5cGUudGVuc29yKSxTPUtlKHQsJC50eXBlLnZhbHVlLHYpLFQ9RShcInhcIixlWzBdLmRhdGFUeXBlLGEubGVuZ3RoKSxBPUUoXCJ3XCIsZVsxXS5kYXRhVHlwZSxkLmxlbmd0aCx1KSxDPVtULEFdO28mJkMucHVzaChFKFwiYlwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLHUpKTtsZXQgUD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuZGlsYXRpb25zLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInBhZHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwib3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn1dO1llKHQsUCk7bGV0IEQ9bD9gXG4gICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMF07IHdIZWlnaHQrKykge1xuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVsxXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd1dpZHRoKyspIHtcbiAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBpbl9jaGFubmVsX29mZnNldCArIHdJbkNoYW5uZWw7XG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7VC5nZXQoXCJiYXRjaFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIsXCJpbnB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHtBLmdldChcIndIZWlnaHRcIixcIndXaWR0aFwiLFwid0luQ2hhbm5lbFwiLFwib3V0cHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgOmBcbiAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xuICAgICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdIZWlnaHQrKykge1xuICAgICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuXG4gICAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbM107IHdXaWR0aCsrKSB7XG4gICAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbM10pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB4VmFsID0gJHtULmdldChcImJhdGNoXCIsXCJpbnB1dF9jaGFubmVsXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIil9O1xuICAgICAgICAgICAgbGV0IHdWYWwgPSAke0EuZ2V0KFwib3V0cHV0X2NoYW5uZWxcIixcIndJbkNoYW5uZWxcIixcIndIZWlnaHRcIixcIndXaWR0aFwiKX07XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA7cmV0dXJuYFxuICAke3gucmVnaXN0ZXJVbmlmb3JtcyhQKS5kZWNsYXJlVmFyaWFibGVzKC4uLkMsJCl9XG5cbiAgJHt4Lm1haW5TdGFydCgpfVxuICAgICR7eC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7JC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYmF0Y2g6IHUzMiA9IG91dHB1dEluZGljZXNbMF07XG4gICAgbGV0IG91dHB1dF9jaGFubmVsOiB1MzIgPSBvdXRwdXRJbmRpY2VzWyR7bD8zOjF9XTtcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske2w/MToyfV0sIG91dHB1dEluZGljZXNbJHtsPzI6M31dKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuICAgIGxldCBncm91cF9pZDogdTMyID0gb3V0cHV0X2NoYW5uZWwgKiAke3V9IC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICB2YXIgaW5fY2hhbm5lbF9vZmZzZXQgPSBncm91cF9pZCAqIHVuaWZvcm1zLndfc2hhcGVbJHtsPzI6MX1dO1xuXG4gICAgdmFyIHZhbHVlOiAkeyQudHlwZS52YWx1ZX0gPSAkeyQudHlwZS52YWx1ZX0oMCk7XG4gICAgJHtEfVxuICAgICR7aX1cbiAgICAke1N9XG4gICAgJHskLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1fJHt1fWAsaW5wdXREZXBlbmRlbmNpZXM6eX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuP24ocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3JtczpffSksZ2V0U2hhZGVyU291cmNlOmd9fSxLdT0oZSx0LHIsbik9PntsZXQgbz1lLmxlbmd0aD4yLGk9bWUoclszXSksYT1tZShyWzJdKSxkPWsuc2l6ZShyKS9pL2EsbD1bZVswXS5kaW1zWzBdLGVbMF0uZGltc1sxXSxlWzBdLmRpbXNbMl0sZVswXS5kaW1zWzNdL2ldLHA9W2VbMV0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdLGVbMV0uZGltc1szXS9pXSxtPVtyWzBdLHJbMV0sclsyXSxyWzNdL2ldLHU9W3t0eXBlOjEyLGRhdGE6ZH0se3R5cGU6NixkYXRhOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXX0se3R5cGU6NixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX1dO2plKHQsdSksdS5wdXNoKC4uLk4obCxwLG0pKTtsZXQgaD0oYS0xKSp0LnN0cmlkZXNbMV0rcFsxXSxfPXk9PntsZXQgZz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxtLmxlbmd0aCxpKSx4PXllKGcudHlwZS50ZW5zb3IpLCQ9S2UodCxnLnR5cGUudmFsdWUseCksdj1FKFwieFwiLGVbMF0uZGF0YVR5cGUsbC5sZW5ndGgsaSksUz1FKFwid1wiLGVbMV0uZGF0YVR5cGUscC5sZW5ndGgsaSksVD1bdixTXTtvJiZULnB1c2goRShcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxpKSk7bGV0IEE9bz9cInZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdO1wiOlwiXCIsQz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9XTtyZXR1cm4gWWUodCxDKSxgXG4gICR7eS5yZWdpc3RlclVuaWZvcm1zKEMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uVCxnKX1cbiAgJHt5Lm1haW5TdGFydCgpfVxuICAgICR7eS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IHdpZHRoMCA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVszXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWwgPSBnbG9iYWxfaWR4ICUgd2lkdGgwO1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gd2lkdGgwO1xuICAgIGxldCB3aWR0aDEgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMl0gLyAke2F9dTtcbiAgICBsZXQgY29sID0gKGluZGV4MSAlIHdpZHRoMSkgKiAke2F9dTtcbiAgICBpbmRleDEgPSBpbmRleDEgLyB3aWR0aDE7XG4gICAgbGV0IHJvdyA9IGluZGV4MSAlIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG5cbiAgICBsZXQgeF9jb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHJvdyksIGkzMihjb2wpKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuXG4gICAgdmFyIHhfdmFsczogYXJyYXk8JHt2LnR5cGUudmFsdWV9LCAke2h9PjtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke2cudHlwZS52YWx1ZX0sICR7YX0+O1xuICAgIGxldCBpbnB1dF9jaGFubmVsID0gb3V0cHV0X2NoYW5uZWw7XG4gICAgLy8gVXNlIGNvbnN0YW50IGluc3RlYWQgb2YgdW5pZm9ybSBjYW4gZ2l2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UgZm9yIHcncyBoZWlnaHQvd2lkdGguXG4gICAgZm9yICh2YXIgd19oZWlnaHQ6IHUzMiA9IDB1OyB3X2hlaWdodCA8ICR7cFswXX07IHdfaGVpZ2h0KyspIHtcbiAgICAgIGxldCB4X2hlaWdodCA9IHhfY29ybmVyLnggKyBpMzIod19oZWlnaHQpO1xuICAgICAgaWYgKHhfaGVpZ2h0ID49IDAgJiYgdTMyKHhfaGVpZ2h0KSA8IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke2h9OyBpKyspIHtcbiAgICAgICAgICBsZXQgeF93aWR0aCA9IHhfY29ybmVyLnkgKyBpO1xuICAgICAgICAgIGlmICh4X3dpZHRoID49IDAgJiYgdTMyKHhfd2lkdGgpIDwgdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt2LmdldChcImJhdGNoXCIsXCJ1MzIoeF9oZWlnaHQpXCIsXCJ1MzIoeF93aWR0aClcIixcImlucHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4X3ZhbHNbaV0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHdfd2lkdGg6IHUzMiA9IDB1OyB3X3dpZHRoIDwgJHtwWzFdfTsgd193aWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHdfdmFsID0gJHtTLmdldChcIndfaGVpZ2h0XCIsXCJ3X3dpZHRoXCIsXCIwXCIsXCJvdXRwdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHthfXU7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gZm1hKHhfdmFsc1tpICogdTMyKHVuaWZvcm1zLnN0cmlkZXNbMV0pICsgd193aWR0aF0sIHdfdmFsLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7YX11OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7QX1cbiAgICAgICR7JH1cbiAgICAgICR7Zy5zZXQoXCJiYXRjaFwiLFwicm93XCIsXCJjb2wgKyBpXCIsXCJvdXRwdXRfY2hhbm5lbFwiLFwidmFsdWVcIil9O1xuICAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiR3JvdXBlZENvbnYtVmVjdG9yaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtpfTske2F9OyR7aH07JHtwWzBdfTske3BbMV19YCxpbnB1dERlcGVuZGVuY2llczpvP1tcInJhbmtcIixcInJhbmtcIixcInR5cGVcIl06W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuP24ocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NCl9LHByb2dyYW1Vbmlmb3Jtczp1fSksZ2V0U2hhZGVyU291cmNlOl99fX0pO3ZhciBtZixnbyxmZixibyx5byxZdSxoZixnZixfbyxadT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bmUoKTtWdSgpO0Z1KCk7UXIoKTtqdSgpO3l0KCk7WnIoKTtkdCgpO21mPShlLHQscixuLG8saSk9PntsZXQgYT1lWzBdLGQ9ZS5zbGljZShpPzE6MixpPzM6NCksbD1kLmxlbmd0aCxwPXRbMF0sdT10LnNsaWNlKDIpLm1hcCgoeSxnKT0+eSsoeS0xKSoocltnXS0xKSksXz1kLm1hcCgoeSxnKT0+eStuW2ddK25bZytsXSkubWFwKCh5LGcpPT5NYXRoLmZsb29yKCh5LXVbZ10rb1tnXSkvb1tnXSkpO3JldHVybiBfLnNwbGljZSgwLDAsYSksXy5zcGxpY2UoaT8zOjEsMCxwKSxffSxnbz1bMiwzLDEsMF0sZmY9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoXCJncmVhdGVyIHRoYW4gNUQgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sbj1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihyIT09bil0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzFdLmRpbXNbMF0hPT1lWzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgbz1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMubGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtvfURgKTtpZih0LnN0cmlkZXMubGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7b31EYCk7aWYodC5wYWRzLmxlbmd0aCE9PW8qMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7byoyfURgKTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpfSxibz0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtyLmxlbmd0aDx0WzFdLmRpbXMubGVuZ3RoLTImJnIucHVzaCguLi5BcnJheSh0WzFdLmRpbXMubGVuZ3RoLTItci5sZW5ndGgpLmZpbGwoMCkpO2ZvcihsZXQgaT0yO2k8dFsxXS5kaW1zLmxlbmd0aDsrK2kpcltpLTJdPT09MCYmKHJbaS0yXT10WzFdLmRpbXNbaV0pO2xldCBuPWUucGFkcy5zbGljZSgpO2t0LmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0WzBdLmRpbXMsZS5zdHJpZGVzLGUuZGlsYXRpb25zLHIsbixlLmZvcm1hdD09PVwiTkhXQ1wiLGUuYXV0b1BhZCk7bGV0IG89T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpyLHBhZHM6bn0pLG99LHlvPWU9PntsZXQgdD1LcihlKSxyPWUuZm9ybWF0LG49W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxvPWUuZGlsYXRpb25zLGk9ZS5ncm91cCxhPWUua2VybmVsX3NoYXBlLGQ9ZS5wYWRzLGw9ZS5zdHJpZGVzLHA9ZS53X2lzX2NvbnN0KCk7cmV0dXJue2F1dG9QYWQ6bixmb3JtYXQ6cixkaWxhdGlvbnM6byxncm91cDppLGtlcm5lbFNoYXBlOmEscGFkczpkLHN0cmlkZXM6bCx3SXNDb25zdDpwLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sWXU9KGUsdCxyLG4pPT57bGV0IG89ci5mb3JtYXQ9PT1cIk5IV0NcIixpPW1mKHRbMF0uZGltcyx0WzFdLmRpbXMsci5kaWxhdGlvbnMsci5wYWRzLHIuc3RyaWRlcyxvKTtpZihyLmdyb3VwIT09MSl7bGV0IEM9W3RbMF1dO2lmKG8pe2xldCBEPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sZ28pLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1EKSxDLnB1c2goRCl9ZWxzZSBDLnB1c2godFsxXSk7dC5sZW5ndGg9PT0zJiZDLnB1c2godFsyXSksIWUuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoXCJhbXBlcmVcIikmJm8mJnRbMV0uZGltc1swXT09PXIuZ3JvdXAmJnRbMV0uZGltc1sxXT09PTEmJnIuZGlsYXRpb25zWzBdPT09MSYmci5kaWxhdGlvbnNbMV09PT0xP2UuY29tcHV0ZShLdShDLHIsaSxuKSx7aW5wdXRzOkN9KTplLmNvbXB1dGUocXUoQyxyLGksbikse2lucHV0czpDfSk7cmV0dXJufWxldCBhPXQubGVuZ3RoPT09MyxkPXRbMF0uZGltc1tvPzE6Ml0sbD10WzBdLmRpbXNbbz8yOjNdLHA9dFswXS5kaW1zW28/MzoxXSxtPXRbMV0uZGltc1syXSx1PXRbMV0uZGltc1szXSxoPWlbbz8xOjJdLF89aVtvPzI6M10seT1pW28/MzoxXSxnPW8mJm09PT1kJiZ1PT09bCYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MDtpZihnfHxtPT09MSYmdT09PTEmJnIuZGlsYXRpb25zWzBdPT09MSYmci5kaWxhdGlvbnNbMV09PT0xJiZyLnN0cmlkZXNbMF09PT0xJiZyLnN0cmlkZXNbMV09PT0xJiZyLnBhZHNbMF09PT0wJiZyLnBhZHNbMV09PT0wKXtsZXQgQz1pWzBdLFAsRCxSLEg9W107aWYobyl7bGV0IFY9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoUGUodFsxXSxnbykse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtpZihyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPVYpLGcpe2xldCBLPWQqbCpwO1A9dFswXS5yZXNoYXBlKFsxLEMsS10pLEQ9Vi5yZXNoYXBlKFsxLEsseV0pLFI9WzEsQyx5XX1lbHNlIFA9dFswXS5yZXNoYXBlKFtDLGQqbCxwXSksRD1WLnJlc2hhcGUoWzEscCx5XSksUj1bQyxoKl8seV07SC5wdXNoKFApLEgucHVzaChEKX1lbHNlIFA9dFswXS5yZXNoYXBlKFtDLHAsZCpsXSksRD10WzFdLnJlc2hhcGUoWzEseSxwXSksUj1bQyx5LGgqX10sSC5wdXNoKEQpLEgucHVzaChQKTthJiZILnB1c2godFsyXSk7bGV0IEw9UlsyXSxyZT1IWzBdLmRpbXNbSFswXS5kaW1zLmxlbmd0aC0xXTtMPDgmJnJlPDg/ZS5jb21wdXRlKFlyKEgscixpLFIsbyxuKSx7aW5wdXRzOkh9KTplLmNvbXB1dGUoSnQoSCxyLGksUixvLG4pLHtpbnB1dHM6SH0pO3JldHVybn1sZXQgeD0hMCwkPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sZ28pLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD0kKTtsZXQgdj1bdFswXSwkXTthJiZ2LnB1c2godFsyXSk7bGV0IFM9bz9oKl86eSxUPW8/eTpoKl8sQT1tKnUqcDtlLmNvbXB1dGUoTnUodixyLGksUyxULEEsYSx4LG4pLHtpbnB1dHM6dn0pfSxoZj0oZSx0KT0+e2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCIsbj1bZS5pbnB1dHNbMF0ucmVzaGFwZShyP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07ZS5pbnB1dHMubGVuZ3RoPT09MyYmbi5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgbz1bMCx0LnBhZHNbMF0sMCx0LnBhZHNbMV1dLGk9WzFdLmNvbmNhdCh0LnN0cmlkZXMpLGE9WzFdLmNvbmNhdCh0LmRpbGF0aW9ucyksZD1bMV0uY29uY2F0KHQua2VybmVsU2hhcGUpLGw9Ym8oey4uLnQscGFkczpvLHN0cmlkZXM6aSxkaWxhdGlvbnM6YSxrZXJuZWxTaGFwZTpkfSxuKTtZdShlLG4sbCxwPT5yP1twWzBdLHBbMl0scFszXV06W3BbMF0scFsxXSxwWzNdXSl9LGdmPShlLHQscik9PntsZXQgbj1yLmZvcm1hdD09PVwiTkhXQ1wiP1wiY2hhbm5lbHNMYXN0XCI6XCJjaGFubmVsc0ZpcnN0XCIsbz1ibyhyLHQpLGk9ci5hdXRvUGFkPT09XCJOT1RTRVRcIj9yLnBhZHM6ci5hdXRvUGFkLGE9R3UodFswXS5kaW1zLHRbMV0uZGltcyxyLnN0cmlkZXMsci5kaWxhdGlvbnMsaSwhMSxuKTtlLmNvbXB1dGUoSHUodCxvLGEub3V0U2hhcGUsW2EuZmlsdGVyRGVwdGgsYS5maWx0ZXJIZWlnaHQsYS5maWx0ZXJXaWR0aF0sW2EucGFkSW5mby5mcm9udCxhLnBhZEluZm8udG9wLGEucGFkSW5mby5sZWZ0XSxuKSl9LF9vPShlLHQpPT57aWYoZmYoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zKWhmKGUsdCk7ZWxzZSBpZihlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTUpZ2YoZSxlLmlucHV0cyx0KTtlbHNle2xldCByPWJvKHQsZS5pbnB1dHMpO1l1KGUsZS5pbnB1dHMscil9fX0pO3ZhciBRdSxYdT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO2V0KCk7bmUoKTthZSgpO1F1PShlLHQscik9PntsZXQgbj1lLmxlbmd0aD4yLG89dC5vdXRwdXRTaGFwZSxpPXQuZm9ybWF0PT09XCJOSFdDXCIsYT10Lmdyb3VwLGQ9ZVsxXS5kaW1zLGw9ZFsyXS9hLHA9ZFszXSxtPWk/bWUobCk6MSx1PWk/bWUocCk6MSxoPWk/cD09PTE/bTp1OjEsXz1rLnNpemUobykvdSx5PVtNYXRoLmNlaWwoXy82NCksMSwxXTtzZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7eX1gKTtsZXQgZz1bXCJyYW5rXCIsXCJyYW5rXCJdLHg9W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dLCQ9W3Qua2VybmVsU2hhcGVbaT8xOjJdLHQua2VybmVsU2hhcGVbaT8yOjNdXSx2PVt0LmRpbGF0aW9uc1swXSx0LmRpbGF0aW9uc1sxXV0sUz1bJFswXSsodC5kaWxhdGlvbnNbMF08PTE/MDoodC5rZXJuZWxTaGFwZVtpPzE6Ml0tMSkqKHQuZGlsYXRpb25zWzBdLTEpKSwkWzFdKyh0LmRpbGF0aW9uc1sxXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2k/MjozXS0xKSoodC5kaWxhdGlvbnNbMV0tMSkpXSxUPVtTWzBdLTEtTWF0aC5mbG9vcigodC5wYWRzWzBdK3QucGFkc1syXSkvMiksU1sxXS0xLU1hdGguZmxvb3IoKHQucGFkc1sxXSt0LnBhZHNbM10pLzIpXSxBPVt7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6eH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnZ9LHt0eXBlOjEyLGRhdGE6U30se3R5cGU6NixkYXRhOlR9LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpwfSwuLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMpXTtuJiYoQS5wdXNoKC4uLk4oZVsyXS5kaW1zKSksZy5wdXNoKFwicmFua1wiKSksQS5wdXNoKC4uLk4obykpO2xldCBDPVA9PntsZXQgRD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp4Lmxlbmd0aH0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6JC5sZW5ndGh9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDokLmxlbmd0aH0se25hbWU6XCJlZmZlY3RpdmVfZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOlMubGVuZ3RofSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOlQubGVuZ3RofSx7bmFtZTpcImlucHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifV0sUj15ZShlWzBdLmRhdGFUeXBlKSxIPWk/MToyLEw9aT8yOjMscmU9aT8zOjEsVj1FKFwiV1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxoKSxLPUUoXCJEeVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCxtKSx3ZT1bSyxWXTtuJiZ3ZS5wdXNoKEUoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxbb1tyZV1dLmxlbmd0aCx1KSk7bGV0IGo9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgsdSksUT0oKT0+e2xldCB0ZT1cIlwiO2lmKG09PT0xKXRlKz1gXG4gICAgICAgIGxldCB3X29mZnNldCA9ICR7Vi5pbmRpY2VzVG9PZmZzZXQoYCR7Vi50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsLCB3T3V0Q2hhbm5lbClgKX07XG4gICAgICAgIGxldCB3VmFsdWUgPSAke1YuZ2V0QnlPZmZzZXQoYHdfb2Zmc2V0IC8gJHtofWApfTtcbiAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWUgKiB3VmFsdWU7YDtlbHNlIGlmKHA9PT0xKXRlKz1gXG4gICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7Vi5nZXRCeU9mZnNldChgJHtWLmluZGljZXNUb09mZnNldChgJHtWLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfSAvICR7aH1gKX07XG4gICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyBkb3QoeFZhbHVlLCB3VmFsdWUpO2A7ZWxzZSBmb3IobGV0IGJlPTA7YmU8bTtiZSsrKXRlKz1gXG4gICAgICAgICAgICBsZXQgd1ZhbHVlJHtiZX0gPSAke1YuZ2V0QnlPZmZzZXQoYCR7Vi5pbmRpY2VzVG9PZmZzZXQoYCR7Vi50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsICsgJHtiZX0sIHdPdXRDaGFubmVsKWApfSAvICR7aH1gKX07XG4gICAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZVske2JlfV0gKiB3VmFsdWUke2JlfTtgO3JldHVybiB0ZX0saWU9YFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke2oub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHt1fWApfTtcbiAgICAgICAgICAgIGxldCBiYXRjaCA9ICR7ai5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLDApfTtcbiAgICAgICAgICAgIGxldCBkMSA9ICR7ai5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLHJlKX07XG4gICAgICAgICAgICBsZXQgciA9ICR7ai5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEgpfTtcbiAgICAgICAgICAgIGxldCBjID0gJHtqLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsTCl9O1xuICAgICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgICAgIHZhciBkb3RQcm9kID0gJHtqLnR5cGUudmFsdWV9KDAuMCk7XG4gICAgICAgICAgICB2YXIgd1I6IHUzMiA9IDA7XG4gICAgICAgICAgICBpZiAodW5pZm9ybXMuZGlsYXRpb25zLnggPT0gMSkge1xuICAgICAgICAgICAgICAvLyBNaW5pbXVtIHdSID49IDAgdGhhdCBzYXRpc2ZpZXMgKGR5UkNvcm5lciArIHdSKSAlICh1bmlmb3Jtcy5zdHJpZGVzLngpID09IDBcbiAgICAgICAgICAgICAgd1IgPSB1MzIoKChkeVJDb3JuZXIgKyBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSAtIDEpIC8gaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkpICogaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkgLSBkeVJDb3JuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IHdSIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLng7IHdSID0gd1IgKyAxKSB7XG4gICAgICAgICAgICAgIGlmICh3UiAlIHVuaWZvcm1zLmRpbGF0aW9ucy54ICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZHlSID0gKCR7Un0oZHlSQ29ybmVyKSArICR7Un0od1IpKSAvICR7Un0odW5pZm9ybXMuc3RyaWRlc1swXSk7XG4gICAgICAgICAgICAgIGxldCB3UlBlcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy54IC0gMSAtIHdSIC8gdW5pZm9ybXMuZGlsYXRpb25zLng7XG4gICAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7Un0odW5pZm9ybXMuRHlfc2hhcGVbJHtIfV0pIHx8IGZyYWN0KGR5UikgPiAwLjAgfHxcbiAgICAgICAgICAgICAgICAgIHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG4gICAgICAgICAgICAgIHZhciB3QzogdTMyID0gMDtcbiAgICAgICAgICAgICAgaWYgKHVuaWZvcm1zLmRpbGF0aW9ucy55ID09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBNaW5pbXVtIHdDID49IDAgdGhhdCBzYXRpc2ZpZXMgKGR5Q0Nvcm5lciArIHdDKSAlICh1bmlmb3Jtcy5zdHJpZGVzLnkpID09IDBcbiAgICAgICAgICAgICAgICB3QyA9IHUzMigoKGR5Q0Nvcm5lciArIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpIC0gMSkgLyBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSkgKiBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSAtIGR5Q0Nvcm5lcik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKDsgd0MgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueTsgd0MgPSB3QyArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAod0MgJSB1bmlmb3Jtcy5kaWxhdGlvbnMueSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGR5QyA9ICgke1J9KGR5Q0Nvcm5lcikgKyAke1J9KHdDKSkgLyAke1J9KHVuaWZvcm1zLnN0cmlkZXMueSk7XG4gICAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnkgLSAxIC0gd0MgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueTtcbiAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke1J9KHVuaWZvcm1zLkR5X3NoYXBlWyR7TH1dKSB8fFxuICAgICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wIHx8IHdDUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaWR5QzogdTMyID0gdTMyKGR5Qyk7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IGdyb3VwSWQgKiB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwOyBkMiA9IGQyICsgJHttfSkge1xuICAgICAgICAgICAgICAgICAgbGV0IHhWYWx1ZSA9ICR7aT9LLmdldEJ5T2Zmc2V0KGAke0suaW5kaWNlc1RvT2Zmc2V0KGAke0sudHlwZS5pbmRpY2VzfShiYXRjaCwgaWR5UiwgaWR5QywgaW5wdXRDaGFubmVsKWApfSAvICR7bX1gKTpLLmdldChcImJhdGNoXCIsXCJpbnB1dENoYW5uZWxcIixcImlkeVJcIixcImlkeUNcIil9O1xuICAgICAgICAgICAgICAgICAgJHtRKCl9XG4gICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAke219O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3QyA9IHdDICsgdW5pZm9ybXMuc3RyaWRlcy55IC0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3UiA9IHdSICsgdW5pZm9ybXMuc3RyaWRlc1swXSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kJHtuP2AgKyBiaWFzW2QxIC8gJHt1fV1gOlwiXCJ9O1xuICAgICAgICAgICAgJHtqLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICAgICAgICAgIGA7cmV0dXJuYFxuICAgICR7UC5yZWdpc3RlclVuaWZvcm1zKEQpLmRlY2xhcmVWYXJpYWJsZXMoLi4ud2Usail9XG4gICAgICAke1AubWFpblN0YXJ0KCl9XG4gICAgICAke1AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfTtcbiAgICAke2llfX1gfTtyZXR1cm57bmFtZTpcIkNvbnZUcmFuc3Bvc2UyRFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7bX0ke2h9JHt1fSR7cD09PTF9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe2Rpc3BhdGNoR3JvdXA6e3g6eVswXSx5OnlbMV0sejp5WzJdfSxvdXRwdXRzOlt7ZGltczpyP3Iobyk6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0scHJvZ3JhbVVuaWZvcm1zOkF9KSxnZXRTaGFkZXJTb3VyY2U6Q319fSk7dmFyIGJmLHlmLF9mLEp1LGVkLHdmLHRkLHZmLHJkLG5kPVUoKCk9PntcInVzZSBzdHJpY3RcIjtYdSgpO3l0KCk7ZHQoKTtiZj0oZSx0LHIsbixvLGkpPT4oZS0xKSp0K3IrKG4tMSkqbysxLWkseWY9KGUsdCxyLG4sbyk9PntsZXQgaT1NYXRoLmZsb29yKGUvMik7dD09PVwiU0FNRV9VUFBFUlwiPyhyW25dPWkscltvXT1lLWkpOnQ9PT1cIlNBTUVfTE9XRVJcIiYmKHJbbl09ZS1pLHJbb109aSl9LF9mPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtPWUubGVuZ3RoLTIsdT1wLmxlbmd0aD09PTA7bC5sZW5ndGg8bSYmbC5wdXNoKC4uLkFycmF5KG0tbC5sZW5ndGgpLmZpbGwoMCkpO2xldCBoPWVbMF0sXz10W2Q/MzoxXSpvO2ZvcihsZXQgeT0wLGc9ZS5sZW5ndGgtbS0oZD8xOjApO3k8bTsrK3ksKytnKXtsZXQgeD1lW2ddLCQ9dT94KmFbeV06cFt5XSx2PWJmKHgsYVt5XSxpW3ldLHRbZ10sclt5XSwkKTt5Zih2LG4saSx5LHkrbSksdSYmcC5wdXNoKGFbeV0qKHgtMSkrbFt5XSsodFtnXS0xKSpyW3ldKzEtaVt5XS1pW3krbV0pfXAuc3BsaWNlKDAsMCxoKSxwLnNwbGljZShkPzM6MSwwLF8pfSxKdT0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZihlLmtlcm5lbFNoYXBlLmxlbmd0aD09PTB8fGUua2VybmVsU2hhcGUucmVkdWNlKCh1LGgpPT51KmgsMSk9PT0wKXtyLmxlbmd0aD0wO2ZvcihsZXQgdT0yO3U8dFsxXS5kaW1zLmxlbmd0aDsrK3Upci5wdXNoKHRbMV0uZGltc1t1XSl9bGV0IG49ZS5mb3JtYXQ9PT1cIk5IV0NcIjtyLnNwbGljZSgwLDAsdFsxXS5kaW1zWzBdKSxyLnNwbGljZShuPzM6MSwwLHRbMV0uZGltc1sxXSk7bGV0IG89ZS5wYWRzLnNsaWNlKCksaT1lLm91dHB1dFNoYXBlLnNsaWNlKCksYT1lLm91dHB1dFBhZGRpbmcuc2xpY2UoKSxkPXRbMF0uZGltcyxsPWUuZGlsYXRpb25zLnNsaWNlKCk7aWYobC5yZWR1Y2UoKHUsaCk9PnUraCwwKT09PTApe2xldCB1PXRbMF0uZGltcy5sZW5ndGgtMjtsPW5ldyBBcnJheSh1KS5maWxsKDEpfWxldCBwPWUuc3RyaWRlcy5zbGljZSgpO2lmKHAucmVkdWNlKCh1LGgpPT51K2gsMCk9PT0wKXtsZXQgdT10WzBdLmRpbXMubGVuZ3RoLTI7cD1uZXcgQXJyYXkodSkuZmlsbCgxKX1fZihkLHIsbCxlLmF1dG9QYWQsZS5ncm91cCxvLHAsbixhLGkpO2xldCBtPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obSx7a2VybmVsU2hhcGU6cixwYWRzOm8sb3V0cHV0UGFkZGluZzphLG91dHB1dFNoYXBlOmksZGlsYXRpb25zOmwsc3RyaWRlczpwfSksbX0sZWQ9ZT0+e2xldCB0PUtyKGUpLHI9ZS5mb3JtYXQsbj1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW3R5cGVvZiBlLmF1dG9QYWQ+XCJ1XCI/MDplLmF1dG9QYWRdLG89ZS5kaWxhdGlvbnMsaT1lLmdyb3VwLGE9ZS5rZXJuZWxTaGFwZSxkPWUucGFkcyxsPWUuc3RyaWRlcyxwPWUud0lzQ29uc3QoKSxtPWUub3V0cHV0UGFkZGluZyx1PWUub3V0cHV0U2hhcGU7cmV0dXJue2F1dG9QYWQ6bixmb3JtYXQ6cixkaWxhdGlvbnM6byxncm91cDppLGtlcm5lbFNoYXBlOmEsb3V0cHV0UGFkZGluZzptLG91dHB1dFNoYXBlOnUscGFkczpkLHN0cmlkZXM6bCx3SXNDb25zdDpwLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sd2Y9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sbj1lWzFdLmRpbXNbMF07aWYociE9PW4pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgbz1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsyXS5kaW1zWzBdIT09bykpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBpPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0LmRpbGF0aW9ucy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke2l9RGApO2lmKHQuc3RyaWRlcy5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0LnN0cmlkZXMubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5wYWRzLnJlZHVjZSgobSx1KT0+bSt1LDApPjAmJnQucGFkcy5sZW5ndGghPT1pKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke2kqMn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PWkmJnQub3V0cHV0UGFkZGluZy5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5rZXJuZWxTaGFwZS5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKHQub3V0cHV0U2hhcGUubGVuZ3RoIT09MCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIil9LHRkPShlLHQscixuKT0+e2xldCBvPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sWzIsMywwLDFdKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9byk7bGV0IGk9W3RbMF0sb107dC5sZW5ndGg9PT0zJiZpLnB1c2godFsyXSksZS5jb21wdXRlKFF1KGkscixuKSx7aW5wdXRzOml9KX0sdmY9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG49W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJm4ucHVzaChlLmlucHV0c1syXSk7bGV0IG89dC5rZXJuZWxTaGFwZTsoby5sZW5ndGg9PT0wfHxvWzBdPT09MCkmJihvPVtlLmlucHV0c1sxXS5kaW1zWzJdXSk7bGV0IGk9dC5kaWxhdGlvbnM7KGkubGVuZ3RoPT09MHx8aVswXT09PTApJiYoaT1bMV0pO2xldCBhPXQuc3RyaWRlczsoYS5sZW5ndGg9PT0wfHxhWzBdPT09MCkmJihhPVsxXSk7bGV0IGQ9dC5wYWRzO2QubGVuZ3RoPT09MCYmKGQ9WzAsMF0pLGQ9WzAsZFswXSwwLGRbMV1dLGE9WzFdLmNvbmNhdChhKSxpPVsxXS5jb25jYXQoaSksbz1bMV0uY29uY2F0KG8pO2xldCBsPXQub3V0cHV0UGFkZGluZztsPVswXS5jb25jYXQobCk7bGV0IHA9SnUoey4uLnQscGFkczpkLHN0cmlkZXM6YSxkaWxhdGlvbnM6aSxrZXJuZWxTaGFwZTpvLG91dHB1dFBhZGRpbmc6bH0sbik7dGQoZSxuLHAsbT0+cj9bbVswXSxtWzJdLG1bM11dOlttWzBdLG1bMV0sbVszXV0pfSxyZD0oZSx0KT0+e2lmKHdmKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09Myl2ZihlLHQpO2Vsc2V7bGV0IHI9SnUodCxlLmlucHV0cyk7dGQoZSxlLmlucHV0cyxyKX19fSk7dmFyICRmLG9kLGlkLGFkPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7JGY9KGUsdCxyLG4pPT57bGV0IG89ay5zaXplKHQpLGk9dC5sZW5ndGgsYT1FKFwiaW5wdXRcIixlLGkpLGQ9TShcIm91dHB1dFwiLGUsaSksbD1yLmRhdGFUeXBlPT09Nj9yLmdldEludDMyQXJyYXkoKVswXTpOdW1iZXIoci5nZXRCaWdJbnQ2NEFycmF5KClbMF0pLHA9ay5ub3JtYWxpemVBeGlzKGwsaSksbT11PT57bGV0IGg9YCBpMzIoJHthLmluZGljZXNHZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9KSBgLF89cShcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJ1bmlmb3Jtcy5heGlzXCIsaSkseT1uLnJldmVyc2U/aCsobi5leGNsdXNpdmU/XCIgKyAxXCI6XCJcIik6XCIwXCIsZz1uLnJldmVyc2U/XzpoKyhuLmV4Y2x1c2l2ZT9cIlwiOlwiICsgMVwiKTtyZXR1cm5gXG4gICAgICAgICAgICAgICAgJHt1LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhhLGQpfVxuICAgICAgICAgICAgICAgICR7dS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgICAgICR7dS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgICAgICAgIHZhciBpbnB1dEluZGljZXMgPSAke2Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgICAgICB2YXIgc3VtID0gJHtkLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0IDogaTMyID0gJHt5fTtcbiAgICAgICAgICAgICAgICAgIGxldCBsYXN0IDogaTMyID0gJHtnfTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgOiBpMzIgPSBmaXJzdDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAke2EuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGkpXCIpfTtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgJHthLmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAke2Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJzdW1cIil9O1xuICAgICAgICAgICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkN1bVN1bVwiLHNoYWRlckNhY2hlOntoaW50Om4uY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6cH0sLi4uTih0LHQpXX0pLGdldFNoYWRlclNvdXJjZTptfX0sb2Q9KGUsdCk9PntsZXQgcj1lLmlucHV0c1swXS5kaW1zLG49ZS5pbnB1dHNbMF0uZGF0YVR5cGUsbz1lLmlucHV0c1sxXTtlLmNvbXB1dGUoJGYobixyLG8sdCkse2lucHV0czpbMF19KX0saWQ9ZT0+e2xldCB0PWUuZXhjbHVzaXZlPT09MSxyPWUucmV2ZXJzZT09PTE7cmV0dXJuIGVlKHtleGNsdXNpdmU6dCxyZXZlcnNlOnJ9KX19KTt2YXIgeGYsU2YsVGYsc2QsdWQsZGQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTt4Zj1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEZXB0aFRvU3BhY2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDREIGlucHV0LlwiKX0sU2Y9KGUsdCxyLG4pPT57bGV0IG89W107by5wdXNoKGBmbiBwZXJtKGk6ICR7bi50eXBlLmluZGljZXN9KSAtPiAke3IudHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7ci50eXBlLmluZGljZXN9O2ApO2ZvcihsZXQgaT0wO2k8dDsrK2kpby5wdXNoKHIuaW5kaWNlc1NldChcImFcIixlW2ldLGBpWyR7aX1dYCkpO3JldHVybiBvLnB1c2goXCJyZXR1cm4gYTt9XCIpLG8uam9pbihgXG5gKX0sVGY9KGUsdCk9PntsZXQgcixuLG8saSxhLGQsbD10LmZvcm1hdD09PVwiTkhXQ1wiLHA9dC5ibG9ja3NpemUsbT10Lm1vZGU9PT1cIkRDUlwiO2w/KFtyLG4sbyxpXT1lLmRpbXMsYT1tP1tyLG4sbyxwLHAsaS9wKioyXTpbcixuLG8saS9wKioyLHAscF0sZD1tP1swLDEsMywyLDQsNV06WzAsMSw0LDIsNSwzXSk6KFtyLG4sbyxpXT1bZS5kaW1zWzBdLGUuZGltc1syXSxlLmRpbXNbM10sZS5kaW1zWzFdXSxhPW0/W3IscCxwLGkvcCoqMixuLG9dOltyLGkvcCoqMixwLHAsbixvXSxkPW0/WzAsMyw0LDEsNSwyXTpbMCwxLDQsMiw1LDNdKTtsZXQgdT1lLnJlc2hhcGUoYSksaD11LmRpbXMubGVuZ3RoLF89ZS5kYXRhVHlwZSx5PUUoXCJhXCIsXyxoKSxnPU0oXCJvdXRwdXRcIixfLGgpLHg9JD0+YFxuICAkeyQucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHksZyl9XG5cbiAgJHtTZihkLGgseSxnKX1cblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBpbmRpY2VzID0gJHtnLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XG5cbiAgICAke2cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIseS5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKSl9XG4gIH1gO3JldHVybntuYW1lOlwiRGVwdGhUb1NwYWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ZS5kaW1zfTske3QuYmxvY2tzaXplfTske3QubW9kZX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6JD0+e2xldCB2PWw/W3IsbipwLG8qcCxpL3AqKjJdOltyLGkvcCoqMixuKnAsbypwXSxTPWsuc2l6ZSh2KSxUPXUuZGltcyxBPWsuc29ydEJhc2VkT25QZXJtKFQsZCk7cmV0dXJue291dHB1dHM6W3tkaW1zOnYsZGF0YVR5cGU6JFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKFMvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6U30sLi4uTihULEEpXX19LGdldFNoYWRlclNvdXJjZTp4fX0sc2Q9KGUsdCk9Pnt4ZihlLmlucHV0cyksZS5jb21wdXRlKFRmKGUuaW5wdXRzWzBdLHQpKX0sdWQ9ZT0+ZWUoe2Jsb2Nrc2l6ZTplLmJsb2Nrc2l6ZSxtb2RlOmUubW9kZSxmb3JtYXQ6ZS5mb3JtYXR9KX0pO3ZhciB3byxKcixsZCxJZixDZix2bywkbyxjZCxBZixwZCxtZCxmZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTthZSgpO3dvPVwiW2EtekEtWl18XFxcXC5cXFxcLlxcXFwuXCIsSnI9XCIoXCIrd28rXCIpK1wiLGxkPVwiXlwiK0pyK1wiJFwiLElmPVwiKFwiK0pyK1wiLCkqXCIrSnIsQ2Y9XCJeXCIrSWYrXCIkXCIsdm89Y2xhc3N7Y29uc3RydWN0b3IodD0tMSl7dGhpcy5zeW1ib2xUb0luZGljZXM9bmV3IE1hcCx0aGlzLmlucHV0SW5kZXg9dH1hZGRTeW1ib2wodCxyKXtsZXQgbj10aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQodCk7bj09PXZvaWQgMD9uPVtyXTpuLnB1c2gociksdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHQsbil9fSwkbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIpe3RoaXMuZXF1YXRpb249cjt0aGlzLmhhc0VsbGlwc2lzPSExLHRoaXMuc3ltYm9sVG9JbmZvPW5ldyBNYXAsdGhpcy5saHM9bmV3IEFycmF5LHRoaXMub3V0cHV0RGltcz1bXTtsZXRbbixvXT1yLmluY2x1ZGVzKFwiLT5cIik/ci5zcGxpdChcIi0+XCIsMik6W3IsXCJcIl07aWYoIW4ubWF0Y2goUmVnRXhwKENmKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtpZihuLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChkLGwpPT57bGV0IHA9dFtsXS5kaW1zLnNsaWNlKCk7aWYoIWQubWF0Y2goUmVnRXhwKGxkKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgbT10aGlzLnByb2Nlc3NUZXJtKGQsITAscCxsKTt0aGlzLmxocy5wdXNoKG0pfSksbz09PVwiXCIpbys9Wy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV0uZmlsdGVyKChbZCxsXSk9PmwuY291bnQ9PT0xfHxkPT09XCIuLi5cIikubWFwKChbZF0pPT5kKS5qb2luKFwiXCIpO2Vsc2UgaWYoIW8ubWF0Y2goUmVnRXhwKEpyKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFNcIik7by5tYXRjaChSZWdFeHAod28sXCJnXCIpKT8uZm9yRWFjaChkPT57aWYoZD09PVwiLi4uXCIpdGhpcy5vdXRwdXREaW1zPXRoaXMub3V0cHV0RGltcy5jb25jYXQodGhpcy5lbGxpcHNpc0RpbXMpO2Vsc2V7bGV0IGw9dGhpcy5zeW1ib2xUb0luZm8uZ2V0KGQpO2lmKGw9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFMgc3ltYm9sXCIpO3RoaXMub3V0cHV0RGltcy5wdXNoKGwuZGltVmFsdWUpfX0pLHRoaXMucmhzPXRoaXMucHJvY2Vzc1Rlcm0obywhMSx0aGlzLm91dHB1dERpbXMpfWFkZFN5bWJvbCh0LHIsbil7bGV0IG89dGhpcy5zeW1ib2xUb0luZm8uZ2V0KHQpO2lmKG8hPT12b2lkIDApe2lmKG8uZGltVmFsdWUhPT1yJiZvLmNvdW50IT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb24gbWlzbWF0Y2hcIik7by5jb3VudCsrLG8uaW5wdXRJbmRpY2VzLnB1c2gobil9ZWxzZSBvPXtjb3VudDoxLGRpbVZhbHVlOnIsaW5wdXRJbmRpY2VzOltuXX07dGhpcy5zeW1ib2xUb0luZm8uc2V0KHQsbyl9cHJvY2Vzc1Rlcm0odCxyLG4sbz0tMSl7bGV0IGk9bi5sZW5ndGgsYT0hMSxkPVtdLGw9MDtpZighdC5tYXRjaChSZWdFeHAobGQpKSYmIXImJnQhPT1cIlwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IHA9dC5tYXRjaChSZWdFeHAod28sXCJnXCIpKSxtPW5ldyB2byhvKTtyZXR1cm4gcD8uZm9yRWFjaCgodSxoKT0+e2lmKHU9PT1cIi4uLlwiKXtpZihhKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm1cIik7YT0hMDtsZXQgXz1pLXAubGVuZ3RoKzE7aWYoXzwwKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG91dCBvZiBib3VuZHNcIik7aWYoZD1uLnNsaWNlKGwsbCtfKSx0aGlzLmhhc0VsbGlwc2lzKXtpZih0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGghPT1kLmxlbmd0aHx8dGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSE9PWQudG9TdHJpbmcoKSl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoXCIpfWVsc2UgaWYocil0aGlzLmhhc0VsbGlwc2lzPSEwLHRoaXMuZWxsaXBzaXNEaW1zPWQ7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTXCIpO2ZvcihsZXQgeT0wO3k8ZC5sZW5ndGg7eSsrKXtsZXQgZz1TdHJpbmcuZnJvbUNoYXJDb2RlKFwiMFwiLmNoYXJDb2RlQXQoMCkreSk7bS5hZGRTeW1ib2woZyxoK3kpLHRoaXMuYWRkU3ltYm9sKGcsbltsKytdLG8pfX1lbHNlIG0uYWRkU3ltYm9sKHUsaCsodGhpcy5oYXNFbGxpcHNpcz90aGlzLmVsbGlwc2lzRGltcy5sZW5ndGgtMTowKSksdGhpcy5hZGRTeW1ib2wodSxuW2wrK10sbyl9KSxtfX0sY2Q9ZT0+ZStcIl9tYXhcIixBZj0oZSx0LHIsbik9PntsZXQgaT1lLm1hcChtPT5tLmxlbmd0aCkubWFwKChtLHUpPT5FKGBpbnB1dCR7dX1gLHQsbSkpLGE9ay5zaXplKG4pLGQ9TShcIm91dHB1dFwiLHQsbi5sZW5ndGgpLGw9Wy4uLnIuc3ltYm9sVG9JbmZvLmtleXMoKV0uZmlsdGVyKG09PiFyLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKG0pKSxwPW09PntsZXQgdT1bXSxoPVwidmFyIHByb2QgPSAxLjA7XCIsXz1cInZhciBzdW0gPSAwLjA7XCIseT1cInN1bSArPSBwcm9kO1wiLGc9W10seD1bXSwkPVtdLHY9W10sUz1yLnN5bWJvbFRvSW5mby5zaXplPT09ci5yaHMuc3ltYm9sVG9JbmRpY2VzLnNpemU7ci5zeW1ib2xUb0luZm8uZm9yRWFjaCgoQSxDKT0+e2lmKHIucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoQykpe2xldCBQPXIucmhzLnN5bWJvbFRvSW5kaWNlcy5nZXQoQyk/LlswXTtQIT09dm9pZCAwJiZyLmxocy5mb3JFYWNoKChELFIpPT57aWYoQS5pbnB1dEluZGljZXMuaW5jbHVkZXMoUikpe2xldCBIPUQuc3ltYm9sVG9JbmRpY2VzLmdldChDKTtpZihIPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO0guZm9yRWFjaChMPT57dS5wdXNoKGAke2lbUl0uaW5kaWNlc1NldChgaW5wdXQke1J9SW5kaWNlc2AsTCxkLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsUCkpfWApfSl9fSl9ZWxzZSByLmxocy5mb3JFYWNoKChQLEQpPT57aWYoQS5pbnB1dEluZGljZXMuaW5jbHVkZXMoRCkpe2xldCBSPVAuc3ltYm9sVG9JbmRpY2VzLmdldChDKTtpZihSPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO1IuZm9yRWFjaChIPT57Zy5wdXNoKGAke2lbRF0uaW5kaWNlc1NldChgaW5wdXQke0R9SW5kaWNlc2AsSCxgJHtDfWApfWApfSksdi5wdXNoKGBwcm9kICo9ICR7aVtEXS5nZXRCeUluZGljZXMoYGlucHV0JHtEfUluZGljZXNgKX07YCl9fSkseC5wdXNoKGBmb3IodmFyICR7Q306IHUzMiA9IDA7ICR7Q30gPCB1bmlmb3Jtcy4ke2NkKEMpfTsgJHtDfSsrKSB7YCksJC5wdXNoKFwifVwiKX0pO2xldCBUPVM/Wy4uLnUsYGxldCBzdW0gPSAke2kubWFwKChBLEMpPT5BLmdldEJ5SW5kaWNlcyhgaW5wdXQke0N9SW5kaWNlc2ApKS5qb2luKFwiICogXCIpfTtgXTpbLi4udSxfLC4uLngsLi4uZyxoLC4uLnYseSwuLi4kXTtyZXR1cm5gXG4gICAgICAgICAgICAke20ucmVnaXN0ZXJVbmlmb3JtcyhsLm1hcChBPT4oe25hbWU6YCR7Y2QoQSl9YCx0eXBlOlwidTMyXCJ9KSkpLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLmksZCl9XG5cbiAgICAgICAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgJHtpLm1hcCgoQSxDKT0+YHZhciBpbnB1dCR7Q31JbmRpY2VzOiAke2lbQ10udHlwZS5pbmRpY2VzfTtgKS5qb2luKGBcbmApfVxuICAgICAgICAgICAgJHtULmpvaW4oYFxuYCl9O1xuICAgICAgICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJFaW5zdW1cIixzaGFkZXJDYWNoZTp7aGludDpyLmVxdWF0aW9uLGlucHV0RGVwZW5kZW5jaWVzOmUubWFwKCgpPT5cInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9PntsZXQgbT1sLmZpbHRlcihoPT5yLnN5bWJvbFRvSW5mby5oYXMoaCkpLm1hcChoPT4oe3R5cGU6MTIsZGF0YTpyLnN5bWJvbFRvSW5mby5nZXQoaCk/LmRpbVZhbHVlfHwwfSkpO20ucHVzaCh7dHlwZToxMixkYXRhOmF9KTtsZXQgdT1lLm1hcCgoaCxfKT0+Wy4uLk4oaCldKS5yZWR1Y2UoKGgsXyk9PmguY29uY2F0KF8pLG0pO3JldHVybiB1LnB1c2goLi4uTihuKSkse291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6dH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dX19LGdldFNoYWRlclNvdXJjZTpwfX0scGQ9KGUsdCk9PntsZXQgcj1uZXcgJG8oZS5pbnB1dHMsdC5lcXVhdGlvbiksbj1yLm91dHB1dERpbXMsbz1lLmlucHV0cy5tYXAoKGksYSk9PmkuZGltcyk7ZS5jb21wdXRlKEFmKG8sZS5pbnB1dHNbMF0uZGF0YVR5cGUscixuKSl9LG1kPWU9PntsZXQgdD1lLmVxdWF0aW9uLnJlcGxhY2UoL1xccysvZyxcIlwiKTtyZXR1cm4gZWUoe2VxdWF0aW9uOnR9KX19KTt2YXIga2YsaGQsRWYsUGYsZ2QsYmQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO2FlKCk7a2Y9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuXCIpO2xldCB0PWVbMF0uZGltcyxyPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxuPXIubGVuZ3RoPHQubGVuZ3RoPzA6ci5sZW5ndGgtdC5sZW5ndGgsbz10Lmxlbmd0aDxyLmxlbmd0aD8wOnQubGVuZ3RoLXIubGVuZ3RoO2Zvcig7bjxyLmxlbmd0aCYmbzx0Lmxlbmd0aDsrK24sKytvKWlmKHJbbl0hPT10W29dJiZyW25dIT09MSYmdFtvXSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIHNoYXBlIHRvIGJlIGJyb2FkY2FzdGFibGUgdG8gaW5wdXRcIil9LGhkPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgtdC5sZW5ndGgsbj1bXTtmb3IobGV0IG89MDtvPHI7KytvKW4ucHVzaChlW29dKTtmb3IobGV0IG89MDtvPHQubGVuZ3RoOysrbyluLnB1c2godFtvXT09PTE/ZVtvK3JdOnRbb10pO3JldHVybiBufSxFZj0oZSx0KT0+ZS5sZW5ndGg+dC5sZW5ndGg/aGQoZSx0KTpoZCh0LGUpLFBmPWU9PntsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksbj1FZih0LHIpLG89ZVswXS5kYXRhVHlwZSxpPW89PT05fHxrLnNpemUodCk9PT0xLGE9bz09PTl8fHQubGVuZ3RoPjAmJnRbdC5sZW5ndGgtMV0lND09PTA/NDoxLGQ9aXx8bi5sZW5ndGg+MCYmbltuLmxlbmd0aC0xXSU0PT09MD80OjEsbD1NYXRoLmNlaWwoay5zaXplKG4pL2QpLHA9dT0+e2xldCBoPUUoXCJpbnB1dFwiLG8sdC5sZW5ndGgsYSksXz1NKFwib3V0cHV0XCIsbyxuLmxlbmd0aCxkKSx5O2lmKG89PT05KXtsZXQgZz0oeCwkLHY9XCJcIik9PmBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7JH0gPSAke18ub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAkeyR9dWApfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHskfSA9ICR7aC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7JH1gLF8pfTtcbiAgICAgICAgICBsZXQgaW5kZXgkeyR9ID0gb2Zmc2V0JHskfSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQkeyR9ID0gb2Zmc2V0JHskfSAlIDR1O1xuICAgICAgICAgICR7eH1bJHskfV0gPSAke3Z9KCR7aC5nZXRCeU9mZnNldChgaW5kZXgkeyR9YCl9W2NvbXBvbmVudCR7JH1dKTtcbiAgICAgICAgYDt5PWBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2R9O1xuICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHtnKFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICR7ZyhcImRhdGFcIiwxLFwidTMyXCIpfVxuICAgICAgICAke2coXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgJHtnKFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImRhdGFcIil9XG4gICAgICB9YH1lbHNlIHk9YFxuICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Xy5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2R9YCl9O1xuICAgICAgICBsZXQgaW5wdXRPZmZzZXQgPSAke2guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIsXyl9O1xuICAgICAgICBsZXQgZGF0YSA9ICR7Xy50eXBlLnZhbHVlfSgke2guZ2V0QnlPZmZzZXQoYGlucHV0T2Zmc2V0IC8gJHthfWApfSk7XG4gICAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImRhdGFcIil9XG4gICAgICB9YDtyZXR1cm5gXG4gICAgJHt1LnJlZ2lzdGVyVW5pZm9ybShcInZlY19zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhoLF8pfVxuICAgICR7dS5tYWluU3RhcnQoKX1cbiAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICR7eX1gfSxtPVt7dHlwZToxMixkYXRhOmx9LC4uLk4odCxuKV07cmV0dXJue25hbWU6XCJFeHBhbmRcIixzaGFkZXJDYWNoZTp7aGludDpgJHtuLmxlbmd0aH07JHthfSR7ZH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpwLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczptfSl9fSxnZD1lPT57a2YoZS5pbnB1dHMpLGUuY29tcHV0ZShQZihlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgemYseWQsX2Q9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO2FlKCk7cXIoKTt6Zj1lPT57bGV0IHQ9ZVswXS5kYXRhVHlwZSxyPWsuc2l6ZShlWzBdLmRpbXMpLG49ay5zaXplKGVbMV0uZGltcyksbz1uJTQ9PT0wLGk9YT0+e2xldCBkPUUoXCJ4XCIsdCxbMV0sNCksbD1FKFwiYmlhc1wiLHQsWzFdLDQpLHA9TShcInlcIix0LFsxXSw0KSxtPVt7bmFtZTpcIm91dHB1dF92ZWNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJiaWFzX3NpemVcIix0eXBlOlwidTMyXCJ9XSx1PV89PmBcbiAgICAgIGxldCBiaWFzJHtffV9vZmZzZXQ6IHUzMiA9IChnbG9iYWxfaWR4ICogNCArICR7X30pICUgdW5pZm9ybXMuYmlhc19zaXplO1xuICAgICAgbGV0IGJpYXMke199ID0gJHtsLmdldEJ5T2Zmc2V0KGBiaWFzJHtffV9vZmZzZXQgLyA0YCl9W2JpYXMke199X29mZnNldCAlIDRdO2AsaD1vP2BcbiAgICAgIGxldCBiaWFzID0gJHtsLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5iaWFzX3NpemUgLyA0KVwiKX07YDpgJHt1KDApfSR7dSgxKX0ke3UoMil9JHt1KDMpfVxuICAgICAgbGV0IGJpYXMgPSAke2QudHlwZS52YWx1ZX0oYmlhczAsIGJpYXMxLCBiaWFzMiwgYmlhczMpO2A7cmV0dXJuYCR7YS5yZWdpc3RlclVuaWZvcm1zKG0pLmRlY2xhcmVWYXJpYWJsZXMoZCxsLHApfVxuXG4gICAgJHtwbyhFZSh0KSl9XG5cbiAgICAke2EubWFpblN0YXJ0KEV0KX1cbiAgICAgICR7YS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3ZlY19zaXplXCIpfVxuXG4gICAgICBsZXQgeCA9ICR7ZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICAgJHtofVxuICAgICAgbGV0IHhfaW4gPSB4ICsgYmlhcztcbiAgICAgICR7cC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixtbyhcInhfaW5cIikpfVxuICAgIH1gfTtyZXR1cm57bmFtZTpcIkZhc3RHZWx1V2l0aEJpYXNcIixzaGFkZXJDYWNoZTp7aGludDpgJHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOmksZ2V0UnVuRGF0YTphPT4oe291dHB1dHM6W3tkaW1zOmFbMF0uZGltcyxkYXRhVHlwZTphWzBdLmRhdGFUeXBlfV0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOk1hdGguY2VpbChyLzQpfSx7dHlwZToxMixkYXRhOm59XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChyL0V0LzQpfX0pfX0seWQ9ZT0+e2UuaW5wdXRzLmxlbmd0aDwyfHxrLnNpemUoZS5pbnB1dHNbMV0uZGltcyk9PT0wP2Z1KGUpOmUuY29tcHV0ZSh6ZihlLmlucHV0cykpfX0pO3ZhciBPZixEZix3ZCx2ZCwkZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTthZSgpO09mPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIil9LERmPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVsxXS5kaW1zLG89ci5sZW5ndGgsaT1rLm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLGE9ci5zbGljZSgwKTthLnNwbGljZShpLDEsLi4ubik7bGV0IGQ9cltpXSxsPWVbMF0uZGF0YVR5cGU9PT05PzQ6MSxwPU1hdGguY2VpbChrLnNpemUoYSkvbCksbT1be3R5cGU6MTIsZGF0YTpwfSx7dHlwZTo2LGRhdGE6ZH0se3R5cGU6MTIsZGF0YTppfSwuLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMsYSldLHU9aD0+e2xldCBfPUUoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLGwpLHk9RShcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksZz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCxsKSx4PXY9PntsZXQgUz1uLmxlbmd0aCxUPWB2YXIgaW5kaWNlc0luZGljZXMke3Z9ICA9ICR7eS50eXBlLmluZGljZXN9KDApO2A7Zm9yKGxldCBBPTA7QTxTO0ErKylUKz1gJHtTPjE/YGluZGljZXNJbmRpY2VzJHt2fVske0F9XWA6YGluZGljZXNJbmRpY2VzJHt2fWB9ID0gJHthLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHt2fVt1bmlmb3Jtcy5heGlzICsgJHtBfV1gOmBvdXRwdXRJbmRpY2VzJHt2fWB9O2A7VCs9YFxuICAgICAgICAgIHZhciBpZHgke3Z9ID0gJHt5LmdldEJ5SW5kaWNlcyhgaW5kaWNlc0luZGljZXMke3Z9YCl9O1xuICAgICAgICAgIGlmIChpZHgke3Z9IDwgMCkge1xuICAgICAgICAgICAgaWR4JHt2fSA9IGlkeCR7dn0gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyR7dn0gOiAke18udHlwZS5pbmRpY2VzfTtcbiAgICAgICAgYDtmb3IobGV0IEE9MCxDPTA7QTxvO0ErKylBPT09aT8oVCs9YCR7bz4xP2BkYXRhSW5kaWNlcyR7dn1bJHtBfV1gOmBkYXRhSW5kaWNlcyR7dn1gfSA9IHUzMihpZHgke3Z9KTtgLEMrPVMpOihUKz1gJHtvPjE/YGRhdGFJbmRpY2VzJHt2fVske0F9XWA6YGRhdGFJbmRpY2VzJHt2fWB9ID0gJHthLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHt2fVske0N9XWA6YG91dHB1dEluZGljZXMke3Z9YH07YCxDKyspO3JldHVybiBUfSwkO2lmKGVbMF0uZGF0YVR5cGU9PT05KXtsZXQgdj0oUyxULEE9XCJcIik9PmBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7VH0gPSAke2cub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke1R9dWApfTtcbiAgICAgICAgICAke3goVCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke1R9ID0gJHtfLmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke1R9YCl9O1xuICAgICAgICAgIGxldCBpbmRleCR7VH0gPSBvZmZzZXQke1R9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7VH0gPSBvZmZzZXQke1R9ICUgNHU7XG4gICAgICAgICAgJHtTfVske1R9XSA9ICR7QX0oJHtfLmdldEJ5T2Zmc2V0KGBpbmRleCR7VH1gKX1bY29tcG9uZW50JHtUfV0pO1xuICAgICAgICBgOyQ9YFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7bH07XG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHt2KFwidmFsdWVcIiwwLFwidTMyXCIpfVxuICAgICAgICAke3YoXCJ2YWx1ZVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICR7dihcInZhbHVlXCIsMixcInUzMlwiKX1cbiAgICAgICAgJHt2KFwidmFsdWVcIiwzLFwidTMyXCIpfVxuICAgICAgICAke2cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgICAgIGB9ZWxzZSAkPWBcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtnLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgJHt4KFwiXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Xy5nZXRCeUluZGljZXMoXCJkYXRhSW5kaWNlc1wiKX07XG4gICAgICAke2cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICBgO3JldHVybmBcbiAgICAgICR7aC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoXyx5LGcpfVxuICAgICAgJHtoLm1haW5TdGFydCgpfVxuICAgICAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICR7JH1cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkdhdGhlclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6dX19LHdkPWU9PmVlKHtheGlzOmUuYXhpc30pLHZkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7T2YociksZS5jb21wdXRlKERmKGUuaW5wdXRzLHQpKX19KTt2YXIgQmYseGQsU2QsVGQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO2FlKCk7QmY9KGUsdCxyLG4sbyxpLGEsZCxsKT0+e2xldCBwPVt7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9XSxtPVtpXTtwLnB1c2goLi4uTih0LmRpbXMsbSkpO2xldCB1PWg9PntsZXQgXz1FKFwiaW5kaWNlc19kYXRhXCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSx5PU0oXCJpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFcIiwxMiwxLDEpLGc9W18seV0seD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJiYXRjaF9kaW1zXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImlucHV0X2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOm8ubGVuZ3RofSx7bmFtZTpcInNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpyLmxlbmd0aH0se25hbWU6XCJudW1fc2xpY2VzX3Blcl9iYXRjaFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJpbnB1dF9iYXRjaF9zdHJpZGVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX3NsaWNlX2RpbXNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICR7aC5yZWdpc3RlclVuaWZvcm1zKHgpLmRlY2xhcmVWYXJpYWJsZXMoLi4uZyl9XG4gICR7aC5tYWluU3RhcnQoKX1cbiAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBiYXRjaF9pZHggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMubnVtX3NsaWNlc19wZXJfYmF0Y2g7XG4gICAgbGV0IGJhc2Vfb2Zmc2V0ID0gYmF0Y2hfaWR4ICogdW5pZm9ybXMuaW5wdXRfYmF0Y2hfc3RyaWRlO1xuXG4gICAgbGV0IHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7XG4gICAgdmFyIHJlbGF0aXZlX3NsaWNlX29mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgZGltX2lkeCA9IDB1OyBkaW1faWR4IDwgdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7IGRpbV9pZHggKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGkzMihpbmRpY2VzX2RhdGFbZGltX2lkeCArIHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXRdLngpO1xuICAgICAgbGV0IGlucHV0X2RpbV9pZHggPSB1bmlmb3Jtcy5iYXRjaF9kaW1zICsgZGltX2lkeDtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgJHtvLmxlbmd0aD09PTE/XCJpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltcyk7XCI6XCJpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltc1tpbnB1dF9kaW1faWR4XSk7XCJ9XG4gICAgICB9XG4gICAgICAke3IubGVuZ3RoPT09MT9cInJlbGF0aXZlX3NsaWNlX29mZnNldCArPSBpbmRleCAqIGkzMih1bmlmb3Jtcy5zaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YSk7XCI6XCJyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGFbZGltX2lkeF0pO1wifVxuICAgIH1cblxuICAgIGlucHV0X3NsaWNlX29mZnNldHNfZGF0YVtnbG9iYWxfaWR4XSA9ICBiYXNlX29mZnNldCArIHUzMihyZWxhdGl2ZV9zbGljZV9vZmZzZXQpO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcImNvbXB1dGVTbGljZU9mZnNldHNcIixzaGFkZXJDYWNoZTp7aGludDpgJHtvLmxlbmd0aH1fJHtyLmxlbmd0aH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bSxkYXRhVHlwZTplLmlucHV0c1sxXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTp1fSx7aW5wdXRzOlt0XSxvdXRwdXRzOlstMV19KVswXX0seGQ9KGUsdCk9PntsZXQgcj1lLmlucHV0cyxuPXJbMF0uZGltcyxvPXJbMF0uZGF0YVR5cGUsaT1yWzFdLmRpbXMsYT1pW2kubGVuZ3RoLTFdLGQ9ay5zaXplVG9EaW1lbnNpb24oaSxpLmxlbmd0aC0xKSxsPWsuc2l6ZUZyb21EaW1lbnNpb24obix0LmJhdGNoRGltcythKSxwPWsuc2l6ZVRvRGltZW5zaW9uKG4sdC5iYXRjaERpbXMpLG09ay5zaXplRnJvbURpbWVuc2lvbihuLHQuYmF0Y2hEaW1zKSx1PWQvcCxoPW5ldyBBcnJheShhKSxfPWw7Zm9yKGxldCBUPTA7VDxhOysrVCloW2EtMS1UXT1fLF8qPW5bdC5iYXRjaERpbXMrYS0xLVRdO2xldCB5PUJmKGUsclsxXSxoLHQuYmF0Y2hEaW1zLG4sZCx1LG0sYSksZz10LmJhdGNoRGltcythO2lmKGc+bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5kaWNlcyBtdXN0IG5vdCBiZSBsYXJnZXIgdGhhbiByYW5rIG9mIGlucHV0IHRlbnNvclwiKTtsZXQgeD1pLnNsaWNlKDAsLTEpLmNvbmNhdChuLnNsaWNlKGcpKSwkPWsuc2l6ZSh4KSx2PVt7dHlwZToxMixkYXRhOiR9LHt0eXBlOjEyLGRhdGE6bH0sLi4uTihyWzBdLmRpbXMseS5kaW1zLHgpXSxTPVQ9PntsZXQgQT1FKFwiZGF0YVwiLHJbMF0uZGF0YVR5cGUsclswXS5kaW1zLmxlbmd0aCksQz1FKFwic2xpY2Vfb2Zmc2V0c1wiLDEyLHkuZGltcy5sZW5ndGgpLFA9TShcIm91dHB1dFwiLHJbMF0uZGF0YVR5cGUseC5sZW5ndGgpO3JldHVybmBcbiAgICAgICAgICAke1QucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzbGljZV9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhBLEMsUCl9XG4gICAgICAgICAgICAke1QubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke1QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIGxldCBzbGljZV9vZmZzZXQgPSBzbGljZV9vZmZzZXRzW2dsb2JhbF9pZHggLyB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBkYXRhW3UzMihzbGljZV9vZmZzZXQpICsgZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLnNsaWNlX3NpemVdO1xuICAgICAgICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiR2F0aGVyTkRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6eCxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoJC82NCl9LHByb2dyYW1Vbmlmb3Jtczp2fSksZ2V0U2hhZGVyU291cmNlOlN9LHtpbnB1dHM6W3JbMF0seV19KX0sU2Q9ZT0+KHtiYXRjaERpbXM6ZS5iYXRjaF9kaW1zLGNhY2hlS2V5OlwiXCJ9KX0pO3ZhciBNZixSZixJZCxDZCxBZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTthZSgpO01mPShlLHQpPT57aWYoZS5sZW5ndGg8M3x8ZS5sZW5ndGg+NCl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJCbG9ja1F1YW50aXplZCByZXF1aXJlcyAzIG9yIDQgaW5wdXRzLlwiKTtsZXQgcj1rLm5vcm1hbGl6ZUF4aXModC5xdWFudGl6ZUF4aXMsZVswXS5kaW1zLmxlbmd0aCksbj10LmJsb2NrU2l6ZSxvPWVbMF0saT1lWzJdLGE9ZS5sZW5ndGg9PT00P2VbM106dm9pZCAwO2lmKGkuZGltcy5sZW5ndGghPT1vLmRpbXMubGVuZ3RofHwhby5kaW1zLm1hcCgoZCxsKT0+bD09PXI/TWF0aC5jZWlsKGQvbik9PT1pLmRpbXNbbF06ZD09PWkuZGltc1tsXSkucmVkdWNlKChkLGwpPT5kJiZsLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJTY2FsZXMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBnYXRoZXJBeGlzLlwiKTtpZihhKXtpZihhLmRhdGFUeXBlIT09by5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgdGhlIGlucHV0IHRlbnNvci5cIik7aWYoYS5kaW1zLmxlbmd0aCE9PWkuZGltcy5sZW5ndGh8fCFhLmRpbXMubWFwKChkLGwpPT5kPT09aS5kaW1zW2xdKS5yZWR1Y2UoKGQsbCk9PmQmJmwsITApKXRocm93IG5ldyBFcnJvcihcIlplcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBxdWFudGl6ZUF4aXMuXCIpfX0sUmY9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1lWzFdLmRpbXMsbz1yLmxlbmd0aCxpPWsubm9ybWFsaXplQXhpcyh0LmdhdGhlckF4aXMsbyksYT1rLm5vcm1hbGl6ZUF4aXModC5xdWFudGl6ZUF4aXMsbyksZD1yLnNsaWNlKDApO2Quc3BsaWNlKGksMSwuLi5uKTtsZXQgbD1rLnNpemUoZCkscD1lWzJdLmRhdGFUeXBlLHU9ZVswXS5kYXRhVHlwZT09PTIyLGg9W3t0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6dC5ibG9ja1NpemV9LC4uLk4oLi4uZS5tYXAoKHksZyk9PnkuZGltcyksZCldLF89eT0+e2xldCBnPUUoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSx4PUUoXCJpbnB1dEluZGljZXNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLCQ9RShcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksdj1lLmxlbmd0aD4zP0UoXCJ6ZXJvUG9pbnRcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcy5sZW5ndGgpOnZvaWQgMCxTPU0oXCJvdXRwdXRcIixwLGQubGVuZ3RoKSxUPVtnLHgsJF07diYmVC5wdXNoKHYpO2xldCBBPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInF1YW50aXplX2F4aXNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZ2F0aGVyX2F4aXNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmxvY2tfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgICAgICAgJHt5LnJlZ2lzdGVyVW5pZm9ybXMoQSkuZGVjbGFyZVZhcmlhYmxlcyguLi5ULFMpfVxuICAgICAgICAke3kubWFpblN0YXJ0KCl9XG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7Uy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgdmFyIGluZGljZXNfaW5kaWNlcyA9ICR7eC50eXBlLmluZGljZXN9KDApO1xuICAgICAgICAkeygoKT0+bi5sZW5ndGg+MT9gXG4gICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7bi5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzICsgaVwiKX07XG4gICAgICAgICAgICAke3guaW5kaWNlc1NldChcImluZGljZXNfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICAgIH1gOmBpbmRpY2VzX2luZGljZXMgPSAke1MuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpc1wiKX07YCkoKX07XG4gICAgICAgIHZhciBkYXRhX2luZGljZXMgPSAke2cudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmdhdGhlcl9heGlzOyBpKyspIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAke1MuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgICAke2cuaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleF9mcm9tX2luZGljZXMgPSAke3guZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc19pbmRpY2VzXCIpfTtcbiAgICAgICAgaWYgKGluZGV4X2Zyb21faW5kaWNlcyA8IDApIHtcbiAgICAgICAgICBpbmRleF9mcm9tX2luZGljZXMgKz0gJHtyW2ldfTtcbiAgICAgICAgfVxuICAgICAgICAke2cuaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXNcIixcInUzMihpbmRleF9mcm9tX2luZGljZXMpXCIpfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHVuaWZvcm1zLmdhdGhlcl9heGlzICsgMTsgaSA8ICR7ZC5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAke1MuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsYGkgKyAke24ubGVuZ3RofSAtIDFgKX07XG4gICAgICAgICAgJHtnLmluZGljZXNTZXQoXCJkYXRhX2luZGljZXNcIixcImlcIixcImluZGV4XCIpfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YV9vZmZzZXQgPSAke2cuaW5kaWNlc1RvT2Zmc2V0KFwiZGF0YV9pbmRpY2VzXCIpfTtcbiAgICAgICAgbGV0IGRhdGFfaW5kZXggPSBkYXRhX29mZnNldCAlIDg7XG4gICAgICAgIC8vIENvbnZlcnQgNC1iaXQgcGFja2VkIGRhdGEgdG8gOC1iaXQgcGFja2VkIGRhdGEuXG4gICAgICAgIGxldCBwYWNrZWRfNGJpdF9xdWFudGl6ZWRfZGF0YSA9ICR7Zy5nZXRCeU9mZnNldChcImRhdGFfb2Zmc2V0IC8gOFwiKX07XG4gICAgICAgIGxldCBwYWNrZWRfOGJpdF9xdWFudGl6ZWRfZGF0YSA9IChwYWNrZWRfNGJpdF9xdWFudGl6ZWRfZGF0YSA+PiAoNCAqIChkYXRhX2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YV92ZWMgPSAke3U/XCJ1bnBhY2s0eEk4XCI6XCJ1bnBhY2s0eFU4XCJ9KHUzMihwYWNrZWRfOGJpdF9xdWFudGl6ZWRfZGF0YSkpO1xuICAgICAgICBsZXQgcXVhbnRpemVkX2RhdGEgPSBxdWFudGl6ZWRfZGF0YV92ZWNbZGF0YV9pbmRleCAvIDJdO1xuICAgICAgICB2YXIgc2NhbGVfaW5kaWNlcyA9IGRhdGFfaW5kaWNlcztcbiAgICAgICAgbGV0IHF1YW50aXplX2F4aXNfaW5kZXggPSAkeyQuaW5kaWNlc0dldChcImRhdGFfaW5kaWNlc1wiLFwidW5pZm9ybXMucXVhbnRpemVfYXhpc1wiKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAkeyQuaW5kaWNlc1NldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLnF1YW50aXplX2F4aXNcIixcInF1YW50aXplX2F4aXNfaW5kZXhcIil9O1xuICAgICAgICB2YXIgc2NhbGUgPSAkeyQuZ2V0QnlJbmRpY2VzKFwic2NhbGVfaW5kaWNlc1wiKX07XG4gICAgICAgICR7KCgpPT52P2BcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kaWNlcyA9IHNjYWxlX2luZGljZXM7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X29mZnNldCA9ICR7di5pbmRpY2VzVG9PZmZzZXQoXCJ6ZXJvX3BvaW50X2luZGljZXNcIil9O1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9IHplcm9fcG9pbnRfb2Zmc2V0ICUgODtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID0gJHt2LmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9vZmZzZXQgLyA4XCIpfTtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF84Yml0X3plcm9fcG9pbnRzID0gKHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID4+ICg0ICogKHplcm9fcG9pbnRfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHt1P1widW5wYWNrNHhJOFwiOlwidW5wYWNrNHhVOFwifSh1MzIocGFja2VkXzhiaXRfemVyb19wb2ludHMpKTtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X2luZGV4IC8gMl07YDpcInZhciB6ZXJvX3BvaW50ID0gMFwiKSgpfTtcbiAgICAgICAgbGV0IGRlcXVhbnRpemVkX2RhdGEgPSAke0VlKHApfShxdWFudGl6ZWRfZGF0YSAtIHplcm9fcG9pbnQpICogc2NhbGU7XG4gICAgICAgICR7Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImRlcXVhbnRpemVkX2RhdGFcIil9O1xuICAgIH1gfTtyZXR1cm57bmFtZTpcIkdhdGhlckJsb2NrUXVhbnRpemVkXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtlLmZpbHRlcigoeSxnKT0+ZyE9PTEpLm1hcCh5PT55LmRpbXMuam9pbihcIl9cIikpLmpvaW4oXCI7XCIpfWAsaW5wdXREZXBlbmRlbmNpZXM6QXJyYXkuZnJvbSh7bGVuZ3RoOmUubGVuZ3RofSwoeSxnKT0+XCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6cH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6aH0pLGdldFNoYWRlclNvdXJjZTpffX0sSWQ9KGUsdCk9PntsZXQgcj1lLmlucHV0cztNZihyLHQpLGUuY29tcHV0ZShSZihlLmlucHV0cyx0KSl9LENkPWU9PmVlKHtibG9ja1NpemU6ZS5ibG9ja1NpemUsZ2F0aGVyQXhpczplLmdhdGhlckF4aXMscXVhbnRpemVBeGlzOmUucXVhbnRpemVBeGlzfSl9KTt2YXIgVWYsTmYsa2QsRWQsUGQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtVZj1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYW5kXG4gICAgICAgICAgICAgICAgICAgICBpbmRpY2VzIGlucHV0IHRlbnNvcnMgYmUgb2Ygc2FtZSByYW5rLmApfSxOZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWVbMF0uZGF0YVR5cGUsbz1yLmxlbmd0aCxpPWVbMV0uZGltcyxhPWVbMV0uZGF0YVR5cGUsZD1rLm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLGw9cltkXSxwPWkuc2xpY2UoMCksbT1rLnNpemUocCksdT1FKFwiaW5wdXRcIixuLG8pLGg9RShcImluZGljZXNJbnB1dFwiLGEsaS5sZW5ndGgpLF89TShcIm91dHB1dFwiLG4scC5sZW5ndGgpLHk9W3t0eXBlOjEyLGRhdGE6bX0se3R5cGU6NixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6ZH1dO3JldHVybiB5LnB1c2goLi4uTihyLGkscCkpLHtuYW1lOlwiR2F0aGVyRWxlbWVudHNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpwLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnl9KSxnZXRTaGFkZXJTb3VyY2U6JD0+YFxuICAgICAgJHskLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzRGltTGltaXRcIixcImkzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh1LGgsXyl9XG4gICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtfLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICB2YXIgaWR4ID0gJHtoLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHt1LnR5cGUuaW5kaWNlc30ob3V0cHV0SW5kaWNlcyk7XG4gICAgICAke3UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGlkeClcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHt1LmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG5cbiAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9fSxrZD1lPT5lZSh7YXhpczplLmF4aXN9KSxFZD0oZSx0KT0+e2xldCByPWUuaW5wdXRzO1VmKHIpLGUuY29tcHV0ZShOZihlLmlucHV0cyx0KSl9fSk7dmFyIFZmLFdmLHpkLE9kLERkPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO1ZmPWU9PntpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBtaXNzaW5nXCIpO2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IG51bWJlci5cIik7aWYoZS5sZW5ndGg9PT0zJiZlWzJdLmRpbXMubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT1lWzFdLmRhdGFUeXBlfHxlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkXCIpfSxXZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcy5zbGljZSgpLG49ZVsxXS5kaW1zLnNsaWNlKCksW28saSxhXT1Oci5nZXRTaGFwZU9mR2VtbVJlc3VsdChyLHQudHJhbnNBLG4sdC50cmFuc0IsZS5sZW5ndGg9PT0zP2VbMl0uZGltczp2b2lkIDApLGQ9W28saV07aWYoIWQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIGdlbW0gb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IGw9MTYscD1NYXRoLmNlaWwoaS9sKSxtPU1hdGguY2VpbChvL2wpLHU9ITAsaD1rLnNpemUoZCksXz1be3R5cGU6MTIsZGF0YTp1P3A6aH0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MSxkYXRhOnQuYWxwaGF9LHt0eXBlOjEsZGF0YTp0LmJldGF9XSx5PVtcInR5cGVcIixcInR5cGVcIl07ZS5sZW5ndGg9PT0zJiYoXy5wdXNoKC4uLk4oZVsyXS5kaW1zKSkseS5wdXNoKFwicmFua1wiKSksXy5wdXNoKC4uLk4oZCkpO2xldCBnPSQ9PntsZXQgdj1cIlwiO3QudHJhbnNBJiZ0LnRyYW5zQj92PVwidmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOnQudHJhbnNBJiYhdC50cmFuc0I/dj1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIjohdC50cmFuc0EmJnQudHJhbnNCP3Y9XCJ2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW24gKiB1bmlmb3Jtcy5LICsga107XCI6IXQudHJhbnNBJiYhdC50cmFuc0ImJih2PVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltrICogdW5pZm9ybXMuTiArIG5dO1wiKTtsZXQgUz10LmFscGhhPT09MT9cIlwiOlwidmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7XCIsVD1FKFwiYVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zKSxBPUUoXCJiXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLEM9VC50eXBlLnZhbHVlLFA9bnVsbCxEPVtULEFdO2UubGVuZ3RoPT09MyYmKFA9RShcImNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLEQucHVzaChQKSk7bGV0IFI9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZC5sZW5ndGgpO0QucHVzaChSKTtsZXQgSD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAkeyQucmVnaXN0ZXJVbmlmb3JtcyhIKS5kZWNsYXJlVmFyaWFibGVzKC4uLkQpfVxuXG4gICR7JC5tYWluU3RhcnQoKX1cbiAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG0gPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuTjtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5OO1xuXG4gICAgdmFyIHZhbHVlID0gJHtDfSgwKTtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgJHt2fVxuICAgIH1cblxuICAgICR7U31cbiAgICAkeygoKT0+UCE9bnVsbD9gbGV0IGNPZmZzZXQgPSAke1AuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJ2ZWMyKG0sIG4pXCIsUil9OyB2YWx1ZSArPSAke0N9KHVuaWZvcm1zLmJldGEpICogJHtQLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07YDpcIlwiKSgpfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICB9YH0seD0kPT57bGV0IHY9RShcImFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksUz1FKFwiYlwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSxUPW51bGwsQT1bdixTXTtlLmxlbmd0aD09PTMmJihUPUUoXCJjXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxBLnB1c2goVCkpO2xldCBDPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQubGVuZ3RoKTtBLnB1c2goQyk7bGV0IFA9W3tuYW1lOlwibnVtX3RpbGVfblwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifV0sRD1cIlwiLFI9XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/KFI9YFxuICAgICAgdmFyIGNvbCA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5NICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5NICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5OKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1MudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEQ9XCJ2YWx1ZSArPSB0aWxlX2Fba11bbG9jYWxfaWQueV0gKiB0aWxlX2JbbG9jYWxfaWQueF1ba107XCIpOnQudHJhbnNBJiYhdC50cmFuc0I/KFI9YFxuICAgICAgdmFyIGNvbCA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5NICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5NICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuTiArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1MudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEQ9XCJ2YWx1ZSArPSB0aWxlX2Fba11bbG9jYWxfaWQueV0gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07XCIpOiF0LnRyYW5zQSYmdC50cmFuc0I/KFI9YFxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5OKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1MudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEQ9XCJ2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2JbbG9jYWxfaWQueF1ba107XCIpOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYoUj1gXG4gICAgICB2YXIgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTSkge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5OICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5OICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Uy50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGAsRD1cInZhbHVlICs9IHRpbGVfYVtsb2NhbF9pZC55XVtrXSAqIHRpbGVfYltrXVtsb2NhbF9pZC54XTtcIik7bGV0IEg9dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IHVuaWZvcm1zLmFscGhhO1wiO3JldHVybmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoUCkuZGVjbGFyZVZhcmlhYmxlcyguLi5BKX1cbiAgdmFyPHdvcmtncm91cD4gdGlsZV9hOiBhcnJheTxhcnJheTwke3YudHlwZS5zdG9yYWdlfSwgJHtsfT4sICR7bH0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlX2I6IGFycmF5PGFycmF5PCR7Uy50eXBlLnN0b3JhZ2V9LCAke2x9PiwgJHtsfT47XG4gICR7JC5tYWluU3RhcnQoW2wsbCwxXSl9XG4gICAgbGV0IHRpbGVfY29sX3N0YXJ0ID0gKHdvcmtncm91cF9pbmRleCAlIHVuaWZvcm1zLm51bV90aWxlX24pICogJHtsfTtcbiAgICBsZXQgdGlsZV9yb3dfc3RhcnQgPSAod29ya2dyb3VwX2luZGV4IC8gdW5pZm9ybXMubnVtX3RpbGVfbikgKiAke2x9O1xuICAgIGxldCBudW1fdGlsZXMgPSAodW5pZm9ybXMuSyAtIDEpIC8gJHtsfSArIDE7XG4gICAgdmFyIGtfc3RhcnQgPSAwdTtcbiAgICB2YXIgdmFsdWUgPSAke0MudHlwZS52YWx1ZX0oMCk7XG4gICAgZm9yICh2YXIgdDogdTMyID0gMHU7IHQgPCBudW1fdGlsZXM7IHQrKykge1xuICAgICAgJHtSfVxuICAgICAga19zdGFydCA9IGtfc3RhcnQgKyAke2x9O1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8ICR7bH07IGsrKykge1xuICAgICAgICAke0R9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgJHtIfVxuICAgIGxldCBtID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgIGxldCBuID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICR7KCgpPT5UIT1udWxsP2BsZXQgY09mZnNldCA9ICR7VC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcInZlYzIobSwgbilcIixDKX07IHZhbHVlICs9ICR7Qy50eXBlLnZhbHVlfSh1bmlmb3Jtcy5iZXRhKSAqICR7VC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O2A6XCJcIikoKX1cbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIG91dHB1dFttICogdW5pZm9ybXMuTiArIG5dID0gdmFsdWU7XG4gICAgfVxuICB9YH07cmV0dXJuIHU/e25hbWU6XCJHZW1tU2hhcmVkXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOnl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpwKm19LHByb2dyYW1Vbmlmb3JtczpffSksZ2V0U2hhZGVyU291cmNlOnh9OntuYW1lOlwiR2VtbVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczp5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGgvNjQpfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTpnfX0semQ9ZT0+e2xldCB0PWUudHJhbnNBLHI9ZS50cmFuc0Isbj1lLmFscGhhLG89ZS5iZXRhO3JldHVybnt0cmFuc0E6dCx0cmFuc0I6cixhbHBoYTpuLGJldGE6byxjYWNoZUtleTpgJHtlLnRyYW5zQX07JHtlLnRyYW5zQn07JHtlLmFscGhhPT09MX1gfX0sT2Q9KGUsdCk9PntWZihlLmlucHV0cyksZS5jb21wdXRlKFdmKGUuaW5wdXRzLHQpKX19KTt2YXIgbHQsX3QsTnQsVnQsTGYsR2YsSGYsRmYscWYsS2YsamYsWWYsQmQsTWQsUmQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtbbHQsX3QsTnQsVnRdPVswLDEsMiwzXSxMZj1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKFwib25seSA0LUQgdGVuc29yIGlzIHN1cHBvcnRlZC5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIHRvIGdyaWQgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoLTIhPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0xXSl0aHJvdyBuZXcgRXJyb3IoYGxhc3QgZGltZW5zaW9uIG9mIGdyaWQgbXVzdCBiZSBlcXVhbCB0byAke2VbMF0uZGltcy5sZW5ndGgtMn1gKTtpZihlWzBdLmRpbXNbMF0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwiZ3JpZCBiYXRjaCBzaXplIG11c3QgbWF0Y2ggaW5wdXQgYmF0Y2ggc2l6ZVwiKX0sR2Y9YFxuICBmbiBnc19nZXRfY3ViaWNfY29lZmZzKHg6IGYzMikgLT4gdmVjNDxmMzI+IHtcbiAgICBsZXQgY3ViaWNfYWxwaGEgPSAtMC43NWY7XG4gICAgbGV0IHhfYWJzID0gYWJzKHgpO1xuICAgIHZhciBjb2VmZnM6IHZlYzQ8ZjMyPjtcbiAgICBjb2VmZnNbMF0gPSAoKChjdWJpY19hbHBoYSAqICh4X2FicyArIDEpIC0gNSAqIGN1YmljX2FscGhhKSAqICh4X2FicyArIDEpICsgOCAqIGN1YmljX2FscGhhKSAqICh4X2FicyArIDEpIC0gNCAqIGN1YmljX2FscGhhKTtcbiAgICBjb2VmZnNbMV0gPSAoKChjdWJpY19hbHBoYSArIDIpICogeF9hYnMgLSAoY3ViaWNfYWxwaGEgKyAzKSkgKiB4X2FicyAqIHhfYWJzICsgMSk7XG4gICAgY29lZmZzWzJdID0gKCgoY3ViaWNfYWxwaGEgKyAyKSAqICgxIC0geF9hYnMpIC0gKGN1YmljX2FscGhhICsgMykpICogKDEgLSB4X2FicykgKiAoMSAtIHhfYWJzKSArIDEpO1xuICAgIGNvZWZmc1szXSA9ICgoKGN1YmljX2FscGhhICogKDIgLSB4X2FicykgLSA1ICogY3ViaWNfYWxwaGEpICogKDIgLSB4X2FicykgKyA4ICogY3ViaWNfYWxwaGEpICogKDIgLSB4X2FicykgLSA0ICogY3ViaWNfYWxwaGEpO1xuICAgIHJldHVybiBjb2VmZnM7XG4gIH1cbmAsSGY9ZT0+YFxuICBmbiBnc19iaWN1YmljX2ludGVycG9sYXRlKHA6IG1hdDR4NDwke2V9PiwgeDogZjMyLCB5OiBmMzIpIC0+ICR7ZX0ge1xuICAgIHZhciB2OiB2ZWM0PGYzMj47XG4gICAgdmFyIGNvZWZmcyA9IGdzX2dldF9jdWJpY19jb2VmZnMoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHZbaV0gPSBjb2VmZnNbMF0gKiBwW2ldWzBdICsgY29lZmZzWzFdICogcFtpXVsxXSArIGNvZWZmc1syXSAqIHBbaV1bMl0gKyBjb2VmZnNbM10gKiBwW2ldWzNdO1xuICAgIH1cbiAgICBjb2VmZnMgPSBnc19nZXRfY3ViaWNfY29lZmZzKHkpO1xuICAgIGxldCBwaXhlbCA9ICR7ZX0oY29lZmZzWzBdICogdlswXSArIGNvZWZmc1sxXSAqIHZbMV0gKyBjb2VmZnNbMl0gKiB2WzJdICsgY29lZmZzWzNdICogdlszXSk7XG4gICAgcmV0dXJuIHBpeGVsO1xuICB9XG5gLEZmPWU9PmBcbiAgZm4gZ3NfZGVub3JtYWxpemUobjogZjMyLCBsZW5ndGg6IGkzMikgLT4gZjMyIHtcbiAgICAke2UuYWxpZ25Db3JuZXJzPT09MD9gXG4gICAgLy8gYWxpZ25Db3JuZXJzOiBmYWxzZSA9PiBbLTEsIDFdIHRvIFstMC41LCBsZW5ndGggLSAwLjVdXG4gICAgcmV0dXJuICgobiArIDEuMCkgKiBmMzIobGVuZ3RoKSAtIDEuMCkgLyAyLjA7XG4gICAgYDpgXG4gICAgLy8gYWxpZ25Db3JuZXJzOiB0cnVlID0+IFstMSwgMV0gdG8gWzAsIGxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIChuICsgMS4wKSAvIDIuMCAqIChmMzIobGVuZ3RoIC0gMSkpO1xuICAgIGB9XG4gIH1cbmAscWY9ZT0+YFxuICAke2UucGFkZGluZ01vZGU9PT1cInJlZmxlY3Rpb25cIj9gXG4gICAgICBmbiBnc19yZWZsZWN0KHg6IGkzMiwgeF9taW46IGYzMiwgeF9tYXg6IGYzMikgLT4gdTMyIHtcbiAgICAgICAgdmFyIGR4ID0gMC4wO1xuICAgICAgICB2YXIgZnggPSBmMzIoeCk7XG4gICAgICAgIGxldCByYW5nZSA9IHhfbWF4IC0geF9taW47XG4gICAgICAgIGlmIChmeCA8IHhfbWluKSB7XG4gICAgICAgICAgZHggPSB4X21pbiAtIGZ4O1xuICAgICAgICAgIGxldCBuID0gdTMyKGR4IC8gcmFuZ2UpO1xuICAgICAgICAgIGxldCByID0gZHggLSBmMzIobikgKiByYW5nZTtcbiAgICAgICAgICBpZiAobiAlIDIgPT0gMCkge1xuICAgICAgICAgICAgZnggPSB4X21pbiArIHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ4ID0geF9tYXggLSByO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmeCA+IHhfbWF4KSB7XG4gICAgICAgICAgZHggPSBmeCAtIHhfbWF4O1xuICAgICAgICAgIGxldCBuID0gdTMyKGR4IC8gcmFuZ2UpO1xuICAgICAgICAgIGxldCByID0gZHggLSBmMzIobikgKiByYW5nZTtcbiAgICAgICAgICBpZiAobiAlIDIgPT0gMCkge1xuICAgICAgICAgICAgZnggPSB4X21heCAtIHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ4ID0geF9taW4gKyByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdTMyKGZ4KTtcbiAgICAgIH1gOlwiXCJ9XG5gLEtmPShlLHQscik9PmBcbiAgZm4gcGl4ZWxfYXRfZ3JpZChyOiBpMzIsIGM6IGkzMiwgSDogaTMyLCBXOiBpMzIsIGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgYm9yZGVyOiB2ZWM0PGYzMj4pIC0+ICR7dH0ge1xuICAgICB2YXIgcGl4ZWwgPSAke3R9KDApO1xuICAgICB2YXIgaW5kaWNlcyA9IHZlYzQ8dTMyPigwKTtcbiAgICAgaW5kaWNlc1ske2x0fV0gPSBiYXRjaDtcbiAgICAgaW5kaWNlc1ske190fV0gPSBjaGFubmVsO2ArKCgpPT57c3dpdGNoKHIucGFkZGluZ01vZGUpe2Nhc2VcInplcm9zXCI6cmV0dXJuYFxuICAgICAgICAgIGlmIChyID49IDAgJiYgciA8IEggJiYgYyA+PTAgJiYgYyA8IFcpIHtcbiAgICAgICAgICAgIGluZGljZXNbJHtOdH1dID0gdTMyKHIpO1xuICAgICAgICAgICAgaW5kaWNlc1ske1Z0fV0gPSB1MzIoYyk7XG4gICAgICAgICAgfVxuICAgICAgICBgO2Nhc2VcImJvcmRlclwiOnJldHVybmBcbiAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IHUzMihjbGFtcChyLCAwLCBIIC0gMSkpO1xuICAgICAgICAgIGluZGljZXNbJHtWdH1dID0gdTMyKGNsYW1wKGMsIDAsIFcgLSAxKSk7XG4gICAgICAgIGA7Y2FzZVwicmVmbGVjdGlvblwiOnJldHVybmBcbiAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IGdzX3JlZmxlY3QociwgYm9yZGVyWzFdLCBib3JkZXJbM10pO1xuICAgICAgICAgIGluZGljZXNbJHtWdH1dID0gZ3NfcmVmbGVjdChjLCBib3JkZXJbMF0sIGJvcmRlclsyXSk7XG4gICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcgbW9kZSAke3IucGFkZGluZ01vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK2BcbiAgICByZXR1cm4gJHtlLmdldEJ5SW5kaWNlcyhcImluZGljZXNcIil9O1xuICB9XG5gLGpmPShlLHQscik9PigoKT0+e3N3aXRjaChyLm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHBpeGVsX2F0X2dyaWQoaTMyKHJvdW5kKHkpKSwgaTMyKHJvdW5kKHgpKSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtfdH1dLCBib3JkZXIpO1xuICAgICAgICBgO2Nhc2VcImJpbGluZWFyXCI6cmV0dXJuYFxuICAgICAgICAgIGxldCB4MSA9IGkzMihmbG9vcih4KSk7XG4gICAgICAgICAgbGV0IHkxID0gaTMyKGZsb29yKHkpKTtcbiAgICAgICAgICBsZXQgeDIgPSB4MSArIDE7XG4gICAgICAgICAgbGV0IHkyID0geTEgKyAxO1xuXG4gICAgICAgICAgbGV0IHAxMSA9IHBpeGVsX2F0X2dyaWQoeTEsIHgxLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske190fV0sIGJvcmRlcik7XG4gICAgICAgICAgbGV0IHAxMiA9IHBpeGVsX2F0X2dyaWQoeTEsIHgyLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske190fV0sIGJvcmRlcik7XG4gICAgICAgICAgbGV0IHAyMSA9IHBpeGVsX2F0X2dyaWQoeTIsIHgxLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske190fV0sIGJvcmRlcik7XG4gICAgICAgICAgbGV0IHAyMiA9IHBpeGVsX2F0X2dyaWQoeTIsIHgyLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske190fV0sIGJvcmRlcik7XG5cbiAgICAgICAgICBsZXQgZHgyID0gJHt0fShmMzIoeDIpIC0geCk7XG4gICAgICAgICAgbGV0IGR4MSA9ICR7dH0oeCAtIGYzMih4MSkpO1xuICAgICAgICAgIGxldCBkeTIgPSAke3R9KGYzMih5MikgLSB5KTtcbiAgICAgICAgICBsZXQgZHkxID0gJHt0fSh5IC0gZjMyKHkxKSk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGR5MiAqIChkeDIgKiBwMTEgKyBkeDEgKiBwMTIpICsgZHkxICogKGR4MiAqIHAyMSArIGR4MSAqIHAyMik7XG4gICAgICAgIGA7Y2FzZVwiYmljdWJpY1wiOnJldHVybmBcbiAgICAgICAgICBsZXQgeDAgPSBpMzIoZmxvb3IoeCkpIC0gMTtcbiAgICAgICAgICBsZXQgeTAgPSBpMzIoZmxvb3IoeSkpIC0gMTtcbiAgICAgICAgICB2YXIgcDogbWF0NHg0PCR7dH0+O1xuICAgICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgNDsgaCsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IDQ7IHcrKykge1xuICAgICAgICAgICAgICBwW2hdW3ddID0gcGl4ZWxfYXRfZ3JpZChoICsgeTAsIHcgKyB4MCwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtfdH1dLCBib3JkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBkeCA9IHggLSBmMzIoeDAgKyAxKTtcbiAgICAgICAgICBsZXQgZHkgPSB5IC0gZjMyKHkwICsgMSk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGdzX2JpY3ViaWNfaW50ZXJwb2xhdGUocCwgZHgsIGR5KTtcbiAgICAgICAgYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbW9kZSAke3IubW9kZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrYCR7ZS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInJlc3VsdFwiKX1gLFlmPShlLHQpPT57bGV0IHI9RShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLG49W2VbMV0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdXSxvPUUoXCJncmlkXCIsZVsxXS5kYXRhVHlwZSxuLmxlbmd0aCwyKSxpPVtlWzBdLmRpbXNbMF0sZVswXS5kaW1zWzFdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl1dO3QuZm9ybWF0PT09XCJOSFdDXCImJihpPVtlWzBdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXSxlWzBdLmRpbXNbM11dLFtsdCxfdCxOdCxWdF09WzAsMywxLDJdKTtsZXQgYT1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxpLmxlbmd0aCksZD1yLnR5cGUudmFsdWUsbD1rLnNpemUoaSkscD1be3R5cGU6MTIsZGF0YTpsfSwuLi5OKGVbMF0uZGltcyxuLGkpXSxtPXU9PmBcbiAgJHt1LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhyLG8sYSl9XG4gICR7R2Z9XG4gICR7SGYoZCl9XG4gICR7RmYodCl9XG4gICR7cWYodCl9XG4gICR7S2YocixkLHQpfVxuXG4gICR7dS5tYWluU3RhcnQoKX1cbiAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgbGV0IEhfaW4gPSBpMzIodW5pZm9ybXMueF9zaGFwZVske050fV0pO1xuICAgICAgbGV0IFdfaW4gPSBpMzIodW5pZm9ybXMueF9zaGFwZVske1Z0fV0pO1xuXG4gICAgICAke3QuYWxpZ25Db3JuZXJzPT09MD9gXG4gICAgICBsZXQgeF9taW4gPSAtMC41O1xuICAgICAgbGV0IHhfbWF4ID0gZjMyKFdfaW4pIC0gMC41O1xuICAgICAgbGV0IHlfbWluID0gLTAuNTtcbiAgICAgIGxldCB5X21heCA9IGYzMihIX2luKSAtIDAuNTtcbiAgICAgIGA6YFxuICAgICAgbGV0IHhfbWluID0gMC4wO1xuICAgICAgbGV0IHhfbWF4ID0gZjMyKFdfaW4pIC0gMS4wO1xuICAgICAgbGV0IHlfbWluID0gMC4wO1xuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMS4wO1xuICAgICAgYH07XG4gICAgICBsZXQgYm9yZGVyID0gdmVjNDxmMzI+KHhfbWluLCB5X21pbiwgeF9tYXgsIHlfbWF4KTtcblxuICAgICAgbGV0IGluZGljZXMgPSAke2Eub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICB2YXIgZ3JpZF9pbmRpY2VzID0gdmVjMzx1MzI+KGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7TnR9XSwgaW5kaWNlc1ske1Z0fV0pO1xuICAgICAgbGV0IG54eSA9ICR7by5nZXRCeUluZGljZXMoXCJncmlkX2luZGljZXNcIil9O1xuICAgICAgdmFyIHggPSBnc19kZW5vcm1hbGl6ZShmMzIobnh5WzBdKSwgV19pbik7XG4gICAgICB2YXIgeSA9IGdzX2Rlbm9ybWFsaXplKGYzMihueHlbMV0pLCBIX2luKTtcblxuICAgICAgJHtqZihhLGQsdCl9XG4gIH1gO3JldHVybntuYW1lOlwiR3JpZFNhbXBsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOnU9PntsZXQgaD1rLnNpemUoaSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6dVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGgvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH19LGdldFNoYWRlclNvdXJjZTptfX0sQmQ9KGUsdCk9PntMZihlLmlucHV0cyksZS5jb21wdXRlKFlmKGUuaW5wdXRzLHQpKX0sTWQ9ZT0+ZWUoe2FsaWduQ29ybmVyczplLmFsaWduX2Nvcm5lcnMsbW9kZTplLm1vZGUscGFkZGluZ01vZGU6ZS5wYWRkaW5nX21vZGUsZm9ybWF0OmUuZm9ybWF0fSl9KTt2YXIgTWUsWGYsTmQsVWQsSmYsZXIsVmQseG89VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7VXIoKTtIcigpO2FlKCk7ZHQoKTtNZT0oZSx0KT0+ZS5sZW5ndGg+dCYmZVt0XS5kaW1zLmxlbmd0aD4wP2VbdF06dm9pZCAwLFhmPShlLHQpPT57bGV0IHI9ZVswXSxuPU1lKGUsMSksbz1NZShlLDIpLGk9TWUoZSwzKSxhPU1lKGUsNCksZD1NZShlLDUpLGw9TWUoZSw2KSxwPU1lKGUsNyk7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIklucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnNcIik7bGV0IG09ci5kaW1zWzBdLHU9ci5kaW1zWzFdLGg9ci5kaW1zLmxlbmd0aD09PTM/ci5kaW1zWzJdOnQubnVtSGVhZHMqci5kaW1zWzRdLF89dSx5PTAsZz0wLHg9TWF0aC5mbG9vcihoL3QubnVtSGVhZHMpO2lmKGwmJnAmJmsuc2l6ZShsLmRpbXMpJiZrLnNpemUocC5kaW1zKSl7aWYobC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihsLmRpbXNbMF0hPT1tfHxsLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxsLmRpbXNbM10hPT14KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7aWYocC5kaW1zWzBdIT09bXx8cC5kaW1zWzFdIT09dC5udW1IZWFkc3x8cC5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7aWYobC5kaW1zWzJdIT09cC5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKScpO2lmKHAuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTt5PWwuZGltc1syXSxnPWwuZGltc1syXX1lbHNlIGlmKGwmJmsuc2l6ZShsLmRpbXMpfHxwJiZrLnNpemUocC5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0ICQ7aWYobiYmay5zaXplKG4uZGltcyk+MCl7aWYoci5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtpZihuLmRpbXMubGVuZ3RoPDN8fG4uZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1uLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO2lmKG4uZGltcy5sZW5ndGg9PT0zKXtpZihuLmRpbXNbMl0hPT1yLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChoaWRkZW5fc2l6ZSknKTskPTIsXz1uLmRpbXNbMV19ZWxzZSBpZihuLmRpbXMubGVuZ3RoPT09NSl7aWYobi5kaW1zWzJdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09Mnx8bi5kaW1zWzRdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7aWYobyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7JD01LF89bi5kaW1zWzFdfWVsc2V7aWYobi5kaW1zWzFdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTskPTAsXz1uLmRpbXNbMl19fWVsc2V7aWYoci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtpZihyLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT0zKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpOyQ9M31pZihpJiZrLnNpemUoaS5kaW1zKT4wKXtpZihpLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24nKTtpZihuJiZuLmRpbXMubGVuZ3RoPT09NSYmbi5kaW1zWzNdPT09Mil0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YuXCIpfWxldCB2PXkrXyxTPTA7aWYoYSYmay5zaXplKGEuZGltcyk+MCl7Uz04O2xldCBQPWEuZGltczt0aHJvdyBQLmxlbmd0aD09PTE/UFswXT09PW0/Uz0xOlBbMF09PT0zKm0rMiYmKFM9Myk6UC5sZW5ndGg9PT0yJiZQWzBdPT09bSYmUFsxXT09PXYmJihTPTUpLFM9PT04P25ldyBFcnJvcignSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk6bmV3IEVycm9yKFwiTWFzayBub3Qgc3VwcG9ydGVkXCIpfWxldCBUPSExLEE9aDtpZihvJiZrLnNpemUoby5kaW1zKT4wKXtpZihvLmRpbXMubGVuZ3RoIT09MyYmby5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO2lmKHIuZGltc1swXSE9PW8uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtpZihvLmRpbXMubGVuZ3RoPT09Myl7aWYoXyE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMl19ZWxzZXtpZihfIT09by5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtBPW8uZGltc1sxXSpvLmRpbXNbM10sVD0hMH19bGV0IEM9ITE7aWYoYSYmay5zaXplKGEuZGltcyk+MCl0aHJvdyBuZXcgRXJyb3IoXCJLZXkgcGFkZGluZyBtYXNrIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZCYmay5zaXplKGQuZGltcyk+MCl7aWYoZC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImF0dGVudGlvbl9iaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihkLmRpbXNbMF0hPT1tfHxkLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxkLmRpbXNbMl0hPT11fHxkLmRpbXNbM10hPT12KXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKX1yZXR1cm57YmF0Y2hTaXplOm0sc2VxdWVuY2VMZW5ndGg6dSxwYXN0U2VxdWVuY2VMZW5ndGg6eSxrdlNlcXVlbmNlTGVuZ3RoOl8sdG90YWxTZXF1ZW5jZUxlbmd0aDp2LG1heFNlcXVlbmNlTGVuZ3RoOmcsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTpoLHZIaWRkZW5TaXplOkEsaGVhZFNpemU6eCx2SGVhZFNpemU6TWF0aC5mbG9vcihBL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTpTLHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczpDLHBhc3NQYXN0SW5LdjpULHFrdkZvcm1hdDokfX0sTmQ9ZT0+ZWUoey4uLmV9KSxVZD1lZSh7cGVybTpbMCwyLDEsM119KSxKZj0oZSx0LHIsbixvLGksYSk9PntsZXQgZD1bbixvLGldLGw9ay5zaXplKGQpLHA9W3t0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOml9XSxtPXU9PntsZXQgaD1NKFwicWt2X3dpdGhfYmlhc1wiLHQuZGF0YVR5cGUsZCksXz1FKFwicWt2XCIsdC5kYXRhVHlwZSxkKSx5PUUoXCJiaWFzXCIsci5kYXRhVHlwZSxkKSxnPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfb2Zmc2V0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke3UucmVnaXN0ZXJVbmlmb3JtcyhnKS5kZWNsYXJlVmFyaWFibGVzKF8seSxoKX1cbiAgJHt1Lm1haW5TdGFydCgpfVxuICAgICR7dS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGJpYXNfb2Zmc2V0X2lkeCA9IChnbG9iYWxfaWR4ICUgdW5pZm9ybXMuaGlkZGVuX3NpemUpICsgdW5pZm9ybXMuYmlhc19vZmZzZXQ7XG5cbiAgICBxa3Zfd2l0aF9iaWFzW2dsb2JhbF9pZHhdID0gcWt2W2dsb2JhbF9pZHhdICsgYmlhc1tiaWFzX29mZnNldF9pZHhdO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIk11bHRpSGVhZEF0dGVudGlvbkFkZEJpYXNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTptfSx7aW5wdXRzOlt0LHJdLG91dHB1dHM6Wy0xXX0pWzBdfSxlcj0oZSx0LHIsbixvLGksYSxkKT0+e2xldCBsPWk7aWYoYSYmay5zaXplKGEuZGltcyk+MCl7aWYobj09PTEpdGhyb3cgbmV3IEVycm9yKFwiQWRkQmlhc1Jlc2hhcGUgaXMgbm90IGltcGxlbWVudGVkLiBQbGVhc2UgZXhwb3J0IHlvdXIgbW9kZWwgd2l0aCBwYWNrZWQgUUtWIG9yIEtWXCIpO3JldHVybiBsPUpmKGUsaSxhLHQsbixyKm8sZCksbD1sLnJlc2hhcGUoW3QsbixyLG9dKSxyPT09MXx8bj09PTE/bDplLmNvbXB1dGUoUGUobCxVZC5wZXJtKSx7aW5wdXRzOltsXSxvdXRwdXRzOlstMV19KVswXX1lbHNlIHJldHVybiBpLmRpbXMubGVuZ3RoPT09MyYmKGw9aS5yZXNoYXBlKFt0LG4scixvXSkpLHI9PT0xfHxuPT09MT9sOmUuY29tcHV0ZShQZShsLFVkLnBlcm0pLHtpbnB1dHM6W2xdLG91dHB1dHM6Wy0xXX0pWzBdfSxWZD0oZSx0KT0+e2xldCByPVhmKGUuaW5wdXRzLHQpLG49ZS5pbnB1dHNbMF0sbz1NZShlLmlucHV0cywxKSxpPU1lKGUuaW5wdXRzLDIpLGE9TWUoZS5pbnB1dHMsMyksZD1NZShlLmlucHV0cyw0KSxsPU1lKGUuaW5wdXRzLDUpLHA9TWUoZS5pbnB1dHMsNiksbT1NZShlLmlucHV0cyw3KTtpZihuLmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtpZihvPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgdT1vJiZpJiZvLmRpbXMubGVuZ3RoPT09NCYmaS5kaW1zLmxlbmd0aD09PTQsaD1lcihlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5zZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLG4sYSwwKTtpZih1KXJldHVybiBVdChlLGgsbyxpLGQsdm9pZCAwLHAsbSxsLHIpO2lmKCFvfHwhaSl0aHJvdyBuZXcgRXJyb3IoXCJrZXkgYW5kIHZhbHVlIG11c3QgYmUgcHJvdmlkZWRcIik7bGV0IF89ZXIoZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIua3ZTZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLG8sYSxyLmhpZGRlblNpemUpLHk9ZXIoZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIua3ZTZXF1ZW5jZUxlbmd0aCxyLnZIZWFkU2l6ZSxpLGEsMipyLmhpZGRlblNpemUpO1V0KGUsaCxfLHksZCx2b2lkIDAscCxtLGwscil9fSk7dmFyIGVoLHRoLHJoLG5oLFNvLFdkLExkLFRvPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7ZWg9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpfSx0aD0oZSx0KT0+e2xldCByPVtdLG49dC5udW1PdXRwdXRzO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobz0+ci5wdXNoKE51bWJlcihvKSkpLG49ci5sZW5ndGgpLGVlKHtudW1PdXRwdXRzOm4sYXhpczp0LmF4aXMsc3BsaXRTaXplczpyfSl9LHJoPWU9PmBcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9dTsgaSArPSAxdSApIHtcbiAgICBpZiAoaW5kZXggPCAke3EoXCJ1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXNcIixcImlcIixlKX0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtlfXU7XG59YCxuaD1lPT57bGV0IHQ9ZS5sZW5ndGgscj1bXTtmb3IobGV0IG49MDtuPHQ7KytuKXtsZXQgbz1lW25dLnNldEJ5SW5kaWNlcyhcImluZGljZXNcIixcImlucHV0W2dsb2JhbF9pZHhdXCIpO3Q9PT0xP3IucHVzaChvKTpuPT09MD9yLnB1c2goYGlmIChvdXRwdXRfbnVtYmVyID09ICR7bn11KSB7ICR7b30gfWApOm49PT10LTE/ci5wdXNoKGBlbHNlIHsgJHtvfSB9YCk6ci5wdXNoKGBlbHNlIGlmIChvdXRwdXRfbnVtYmVyID09ICR7bn0pIHsgJHtvfSB9YCl9cmV0dXJuYFxuICAgICAgZm4gd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXI6IHUzMiwgaW5kaWNlczogJHtlWzBdLnR5cGUuaW5kaWNlc30sIGdsb2JhbF9pZHg6IHUzMikge1xuICAgICAgICAke3Iuam9pbihgXG5gKX1cbiAgICAgIH1gfSxTbz0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWsuc2l6ZShyKSxvPWVbMF0uZGF0YVR5cGUsaT1rLm5vcm1hbGl6ZUF4aXModC5heGlzLHIubGVuZ3RoKSxhPW5ldyBBcnJheSh0Lm51bU91dHB1dHMpLGQ9RShcImlucHV0XCIsbyxyLmxlbmd0aCksbD1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxwPVtdLG09W10sdT0wLGg9W3t0eXBlOjEyLGRhdGE6bn1dO2ZvcihsZXQgeT0wO3k8dC5udW1PdXRwdXRzO3krKyl7dSs9dC5zcGxpdFNpemVzW3ldLGxbeV09dTtsZXQgZz1yLnNsaWNlKCk7Z1tpXT10LnNwbGl0U2l6ZXNbeV0sbS5wdXNoKGcpLGFbeV09TShgb3V0cHV0JHt5fWAsbyxnLmxlbmd0aCkscC5wdXNoKHtkaW1zOm1beV0sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pfWgucHVzaCh7dHlwZToxMixkYXRhOmx9LC4uLk4ociwuLi5tKSk7bGV0IF89eT0+YFxuICAke3kucmVnaXN0ZXJVbmlmb3JtKFwiaW5wdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNpemVfaW5fc3BsaXRfYXhpc1wiLFwidTMyXCIsbC5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXMoZCwuLi5hKX1cbiAgJHtyaChsLmxlbmd0aCl9XG4gICR7bmgoYSl9XG5cbiAgJHt5Lm1haW5TdGFydCgpfVxuICAgICR7eS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMuaW5wdXRfc2l6ZVwiKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIHZhciBpbmRleCA9ICR7ZC5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGkpfTtcbiAgICBsZXQgb3V0cHV0X251bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4KTtcbiAgICBpZiAob3V0cHV0X251bWJlciAhPSAwKSB7XG4gICAgICBpbmRleCAtPSAke3EoXCJ1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXNcIixcIm91dHB1dF9udW1iZXIgLSAxdVwiLGwubGVuZ3RoKX07XG4gICAgICAke2QuaW5kaWNlc1NldChcImluZGljZXNcIixpLFwiaW5kZXhcIil9O1xuICAgIH1cbiAgICB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlciwgaW5kaWNlcywgZ2xvYmFsX2lkeCk7XG4gIH1gO3JldHVybntuYW1lOlwiU3BsaXRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpfLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpwLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfSxwcm9ncmFtVW5pZm9ybXM6aH0pfX0sV2Q9KGUsdCk9PntlaChlLmlucHV0cyk7bGV0IHI9ZS5pbnB1dHMubGVuZ3RoPT09MT90OnRoKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShTbyhlLmlucHV0cyxyKSx7aW5wdXRzOlswXX0pfSxMZD1lPT57bGV0IHQ9ZS5heGlzLHI9ZS5zcGxpdFNpemVzLG49ZS5udW1PdXRwdXRzPDA/ci5sZW5ndGg6ZS5udW1PdXRwdXRzO2lmKG4hPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJudW1PdXRwdXRzIGFuZCBzcGxpdFNpemVzIGxlbmdoIG11c3QgYmUgZXF1YWxcIik7cmV0dXJuIGVlKHtheGlzOnQsbnVtT3V0cHV0czpuLHNwbGl0U2l6ZXM6cn0pfX0pO3ZhciBvaCxpaCxHZCxIZCxGZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eGUoKTtIcigpO3hvKCk7VG8oKTtkdCgpO29oPShlLHQpPT57aWYodC5kb1JvdGFyeSl0aHJvdyBuZXcgRXJyb3IoXCJHcm91cFF1ZXJyeUF0dGVudGlvbiBkb19yb3RhcnkgYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5kb1JvdGFyeSYmZS5sZW5ndGg8PTcpdGhyb3cgbmV3IEVycm9yKFwiY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW5wdXRzIGFyZSByZXF1aXJlZCBpZiBkb19yb3RhcnkgaXMgc3BlY2lmaWVkXCIpO2xldCByPWVbMF0sbj1lWzFdLG89ZVsyXSxpPWVbM10sYT1lWzRdO2lmKHQubG9jYWxXaW5kb3dTaXplIT09LTEpdGhyb3cgbmV3IEVycm9yKFwiTG9jYWwgYXR0ZW50aW9uIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5zb2Z0Y2FwIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0Y2FwIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5yb3RhcnlJbnRlcmxlYXZlZCE9PTApdGhyb3cgbmV3IEVycm9yKFwiUm90YXJ5IGludGVybGVhdmVkIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5zbW9vdGhTb2Z0bWF4KXRocm93IG5ldyBFcnJvcihcIlNtb290aCBzb2Z0bWF4IGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIklucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnNcIik7bGV0IGQ9ITEsbD1yLmRpbXNbMF0scD1yLmRpbXNbMV0sbT1yLmRpbXMubGVuZ3RoPT09Mz9kP3IuZGltc1syXS8zOnIuZGltc1syXTp0Lm51bUhlYWRzKnIuZGltc1s0XSx1PXAsaD0wLF89IW58fG4uZGltcy5sZW5ndGg9PT0wLHk9TWF0aC5mbG9vcihfP20vKHQubnVtSGVhZHMrMip0Lmt2TnVtSGVhZHMpOm0vdC5udW1IZWFkcyk7XyYmKG09eSp0Lm51bUhlYWRzKTtsZXQgZz1pJiZpLmRpbXMubGVuZ3RoIT09MCx4PWEmJmEuZGltcy5sZW5ndGghPT0wO2lmKGcmJmkuZGltcy5sZW5ndGg9PT00JiZpLmRpbXNbMF09PT1sJiZpLmRpbXNbMV0hPT10Lmt2TnVtSGVhZHMmJmkuZGltc1syXT09PXQua3ZOdW1IZWFkcyYmaS5kaW1zWzNdPT09eSl0aHJvdyBuZXcgRXJyb3IoXCJCU05IIHBhc3RLZXkvcGFzdFZhbHVlIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZyYmeCl7aWYoaS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihhLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aD1pLmRpbXNbMl19ZWxzZSBpZihnfHx4KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBiZSBib3RoIHByZXNlbnQgb3IgYm90aCBhYnNlbnQnKTtsZXQgdj0xO2lmKG4mJm4uZGltcy5sZW5ndGg+MCl7aWYoci5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtpZihuLmRpbXMubGVuZ3RoPDN8fG4uZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1uLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO2lmKG4uZGltcy5sZW5ndGg9PT0zKXtpZihyLmRpbXNbMl0lbi5kaW1zWzJdIT09MCl0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiAyIG9mIFwicXVlcnlcIiBzaG91bGQgYmUgYSBtdWx0aXBsZSBvZiBcImtleVwiJyk7dT1uLmRpbXNbMV19ZWxzZSBpZihuLmRpbXMubGVuZ3RoPT09NSl7aWYobi5kaW1zWzJdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09Mnx8bi5kaW1zWzRdIT09eSl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7aWYobyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7dT1uLmRpbXNbMV19ZWxzZXtpZihuLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxuLmRpbXNbM10hPT15KXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpO3U9bi5kaW1zWzJdfX1lbHNle2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGVtcHR5Jyk7aWYoci5kaW1zLmxlbmd0aD09PTUmJihyLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT0zKSl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTt2PTN9bGV0IFM9MCxUPSExLEE9dC5rdk51bUhlYWRzP3kqdC5rdk51bUhlYWRzOm07aWYobyYmby5kaW1zLmxlbmd0aD4wKXtpZihvLmRpbXMubGVuZ3RoIT09MyYmby5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO2lmKHIuZGltc1swXSE9PW8uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtpZihvLmRpbXMubGVuZ3RoPT09Myl7aWYodSE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMl19ZWxzZXtpZih1IT09by5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMV0qby5kaW1zWzNdLFQ9ITB9fWxldCBDPWUubGVuZ3RoPjQ/ZVs1XTp2b2lkIDA7aWYoQyYmQy5kaW1zLmxlbmd0aCE9PTEmJkMuZGltc1swXSE9PWwpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInNlcWxlbnNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uIGFuZCB0aGUgc2FtZSBkaW0gMCBhcyBiYXRjaF9zaXplJyk7bGV0IFA9LTEsRD0tMSxSPSExO3JldHVybntiYXRjaFNpemU6bCxzZXF1ZW5jZUxlbmd0aDpwLHBhc3RTZXF1ZW5jZUxlbmd0aDpoLGt2U2VxdWVuY2VMZW5ndGg6dSx0b3RhbFNlcXVlbmNlTGVuZ3RoOlAsbWF4U2VxdWVuY2VMZW5ndGg6RCxpbnB1dEhpZGRlblNpemU6MCxoaWRkZW5TaXplOm0sdkhpZGRlblNpemU6QSxoZWFkU2l6ZTp5LHZIZWFkU2l6ZTpNYXRoLmZsb29yKEEvdC5rdk51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGt2TnVtSGVhZHM6dC5rdk51bUhlYWRzLG5SZXBzOnQubnVtSGVhZHMvdC5rdk51bUhlYWRzLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ITEsbWFza1R5cGU6UyxzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6UixwYXNzUGFzdEluS3Y6VCxxa3ZGb3JtYXQ6dn19LGloPWVlKHtwZXJtOlswLDIsMSwzXX0pLEdkPShlLHQscik9PntsZXQgbj10LG89ci5rdk51bUhlYWRzO3JldHVybiB0LmRpbXMubGVuZ3RoPT09MyYmci5rdlNlcXVlbmNlTGVuZ3RoIT09MCYmKG49dC5yZXNoYXBlKFtyLmJhdGNoU2l6ZSxyLmt2U2VxdWVuY2VMZW5ndGgsbyxyLmhlYWRTaXplXSksbj1lLmNvbXB1dGUoUGUobixpaC5wZXJtKSx7aW5wdXRzOltuXSxvdXRwdXRzOlstMV19KVswXSksbn0sSGQ9KGUsdCk9PntsZXQgcj1vaChlLmlucHV0cyx0KTtpZihlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIFFLViBpcyBub3QgaW1wbGVtZW50ZWRcIik7aWYoZS5pbnB1dHNbMV0/LmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2xldCBuPWUuaW5wdXRzWzBdLG89ZS5pbnB1dHNbMV0mJmUuaW5wdXRzWzFdLmRpbXMubGVuZ3RoPjA/ZS5pbnB1dHNbMV06dm9pZCAwLGk9ZS5pbnB1dHNbMl0mJmUuaW5wdXRzWzJdLmRpbXMubGVuZ3RoPjA/ZS5pbnB1dHNbMl06dm9pZCAwLGE9ZS5pbnB1dHNbM10mJmUuaW5wdXRzWzNdLmRpbXMubGVuZ3RoIT09MD9lLmlucHV0c1szXTp2b2lkIDAsZD1lLmlucHV0c1s0XSYmZS5pbnB1dHNbNF0uZGltcy5sZW5ndGghPT0wP2UuaW5wdXRzWzRdOnZvaWQgMCxsPWUuaW5wdXRzLmxlbmd0aD40P2UuaW5wdXRzWzVdOnZvaWQgMCxwPWUuaW5wdXRzLmxlbmd0aD41P2UuaW5wdXRzWzZdOnZvaWQgMCxtPXIua3ZOdW1IZWFkcz9yLmt2TnVtSGVhZHM6ci5udW1IZWFkcyx1PWVlKHtheGlzOjIsbnVtT3V0cHV0czozLHNwbGl0U2l6ZXM6W3IubnVtSGVhZHMqci5oZWFkU2l6ZSxtKnIuaGVhZFNpemUsbSpyLmhlYWRTaXplXX0pLFtoLF8seV09IW8mJiFpP2UuY29tcHV0ZShTbyhbbl0sdSkse2lucHV0czpbbl0sb3V0cHV0czpbLTEsLTEsLTFdfSk6W24sbyxpXSxnPWVyKGUsci5iYXRjaFNpemUsci5udW1IZWFkcyxyLnNlcXVlbmNlTGVuZ3RoLHIuaGVhZFNpemUsaCx2b2lkIDAsMCk7VXQoZSxnLEdkKGUsXyxyKSxHZChlLHksciksdm9pZCAwLHZvaWQgMCxhLGQsdm9pZCAwLHIsbCxwKX19KTt2YXIgcWQsYWgsc2gsS2QsamQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO2R0KCk7YWUoKTtxZD0oZSx0LHIsbixvLGksYSxkKT0+e2xldCBsPW1lKGkpLHA9bD09PTE/XCJmMzJcIjpgdmVjJHtsfWZgLG09bD09PTE/XCJ2ZWMyZlwiOmBtYXQyeCR7bH1mYCx1PW8qYSxoPTY0O3U9PT0xJiYoaD0yNTYpO2xldCBfPVtvLGEsaS9sXSx5PVtvLGEsMl0sZz1bXCJyYW5rXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdLHg9W107eC5wdXNoKC4uLk4oXyx5KSk7bGV0ICQ9dj0+e2xldCBTPUUoXCJ4XCIsdC5kYXRhVHlwZSwzLGwpLFQ9RShcInNjYWxlXCIsci5kYXRhVHlwZSxyLmRpbXMpLEE9RShcImJpYXNcIixuLmRhdGFUeXBlLG4uZGltcyksQz1NKFwib3V0cHV0XCIsMSwzLDIpLFA9W1MsVCxBLENdO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZCA6IGFycmF5PCR7bX0sICR7aH0+O1xuICBjb25zdCB3b3JrZ3JvdXBfc2l6ZSA9ICR7aH11O1xuICAke3YuZGVjbGFyZVZhcmlhYmxlcyguLi5QKX1cbiAgJHt2Lm1haW5TdGFydChoKX1cbiAgICBsZXQgYmF0Y2ggPSB3b3JrZ3JvdXBfaW5kZXggLyB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBjaGFubmVsID0gd29ya2dyb3VwX2luZGV4ICUgdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgaGlnaHQgPSB1bmlmb3Jtcy54X3NoYXBlWzJdO1xuICAgIC8vIGluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeVxuICAgIHZhciBzdW0gPSAke3B9KDApO1xuICAgIHZhciBzcXVhcmVkX3N1bSA9ICR7cH0oMCk7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsX2lkeDsgaCA8IGhpZ2h0OyBoICs9IHdvcmtncm91cF9zaXplKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke3B9KCR7Uy5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX0pO1xuICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgc3F1YXJlZF9zdW0gKz0gdmFsdWUgKiB2YWx1ZTtcbiAgICB9XG4gICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gJHttfShzdW0sIHNxdWFyZWRfc3VtKTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cF9zaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJTaXplKSB7XG4gICAgICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSA9IHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSArIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4ICsgY3VyclNpemVdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBpZiAobG9jYWxfaWR4ID09IDApIHtcbiAgICAgIGxldCBzdW1fZmluYWwgPSAke3FlKFwid29ya2dyb3VwX3NoYXJlZFswXVswXVwiLGwpfSAvIGYzMihoaWdodCAqICR7bH0pO1xuICAgICAgbGV0IHNxdWFyZWRfc3VtX2ZpbmFsID0gJHtxZShcIndvcmtncm91cF9zaGFyZWRbMF1bMV1cIixsKX0gLyBmMzIoaGlnaHQgKiAke2x9KTtcblxuICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoc3F1YXJlZF9zdW1fZmluYWwgLSBzdW1fZmluYWwgKiBzdW1fZmluYWwgKyBmMzIoJHtkfSkpO1xuICAgICAgbGV0IGNoYW5uZWxfc2NhbGUgPSBpbnZfc3RkX2RldiAqIGYzMihzY2FsZVtjaGFubmVsXSk7XG4gICAgICBsZXQgY2hhbm5lbF9zaGlmdCA9IGYzMihiaWFzW2NoYW5uZWxdKSAtIHN1bV9maW5hbCAqIGNoYW5uZWxfc2NhbGU7XG4gICAgICBvdXRwdXRbd29ya2dyb3VwX2luZGV4XSA9IHZlYzJmKGNoYW5uZWxfc2NhbGUsIGNoYW5uZWxfc2hpZnQpO1xuICAgIH1cbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1Db21wdXRlQ2hhbm5lbFNjYWxlU2hpZnRcIixzaGFkZXJDYWNoZTp7aGludDpgJHtsfTske2R9OyR7aH1gLGlucHV0RGVwZW5kZW5jaWVzOmd9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6eSxkYXRhVHlwZToxfV0sZGlzcGF0Y2hHcm91cDp7eDp1fSxwcm9ncmFtVW5pZm9ybXM6eH0pLGdldFNoYWRlclNvdXJjZTokfSx7aW5wdXRzOlt0LHIsbl0sb3V0cHV0czpbLTFdfSlbMF19LGFoPShlLHQscik9PntsZXQgbj10WzBdLmRpbXMsbz1uLGk9MixhPW5bMF0sZD1uWzFdLGw9ay5zaXplRnJvbURpbWVuc2lvbihuLGkpLHA9bWUobCksbT1rLnNpemUobykvcCx1PXFkKGUsdFswXSx0WzFdLHRbMl0sYSxsLGQsci5lcHNpbG9uKSxoPVthLGQsbC9wXSxfPVthLGRdLHk9W1widHlwZVwiLFwibm9uZVwiXSxnPXg9PntsZXQgJD1FKFwieFwiLHRbMF0uZGF0YVR5cGUsaC5sZW5ndGgscCksdj1FKFwic2NhbGVfc2hpZnRcIiwxLF8ubGVuZ3RoLDIpLFM9TShcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUsaC5sZW5ndGgscCksVD1bJCx2LFNdO3JldHVybmBcbiAgJHt4LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyguLi5UKX1cbiAgJHt4Lm1haW5TdGFydCgpfVxuICAke3guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgICAgbGV0IGNoYW5uZWwgPSBvdXRwdXRJbmRpY2VzWzFdO1xuICAgICAgbGV0IHNjYWxlX3NoaWZ0ID0gJHt2LmdldEJ5SW5kaWNlcyhcInZlYzI8dTMyPihiYXRjaCwgY2hhbm5lbClcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHskLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX0gKiAke1MudHlwZS52YWx1ZX0oc2NhbGVfc2hpZnQueCkgKyAke1MudHlwZS52YWx1ZX0oc2NhbGVfc2hpZnQueSk7XG4gICAgICAke1Muc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gIH1gfTtlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHtwfWAsaW5wdXREZXBlbmRlbmNpZXM6eX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOnRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOm19LC4uLk4oaCxfLGgpXX0pLGdldFNoYWRlclNvdXJjZTpnfSx7aW5wdXRzOlt0WzBdLHVdfSl9LHNoPShlLHQscik9PntsZXQgbj10WzBdLmRpbXMsbz1uLGk9blswXSxhPW5bbi5sZW5ndGgtMV0sZD1rLnNpemVGcm9tRGltZW5zaW9uKG4sMSkvYSxsPW1lKGEpLHA9ay5zaXplKG8pL2wsbT1be3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOk1hdGguZmxvb3IoYS9sKX1dLHU9W1widHlwZVwiLFwidHlwZVwiXSxoPSExLF89WzAsbi5sZW5ndGgtMV07Zm9yKGxldCAkPTA7JDxuLmxlbmd0aC0yOyQrKyloPWh8fG5bJCsxXSE9PTEsXy5wdXNoKCQrMSk7aD1oJiZuW24ubGVuZ3RoLTFdIT09MTtsZXQgeT1oP2UuY29tcHV0ZShQZShlLmlucHV0c1swXSxfKSx7aW5wdXRzOltlLmlucHV0c1swXV0sb3V0cHV0czpbLTFdfSlbMF06ZS5pbnB1dHNbMF0ucmVzaGFwZShBcnJheS5mcm9tKHtsZW5ndGg6bi5sZW5ndGh9LCgkLHYpPT5uW19bdl1dKSksZz1xZChlLHksdFsxXSx0WzJdLGksZCxhLHIuZXBzaWxvbikseD0kPT57bGV0IHY9eWUodFswXS5kYXRhVHlwZSksUz1sPT09MT9cInZlYzJmXCI6YG1hdCR7bH14MmZgLFQ9UD0+e2xldCBEPVA9PT0wP1wieFwiOlwieVwiLFI9bD09PTE/XCJmMzJcIjpgdmVjJHtsfWZgO3N3aXRjaChsKXtjYXNlIDE6cmV0dXJuYCR7dn0oJHtSfShzY2FsZS4ke0R9KSlgO2Nhc2UgMjpyZXR1cm5gdmVjMjwke3Z9Pigke1J9KHNjYWxlWzBdLiR7RH0sIHNjYWxlWzFdLiR7RH0pKWA7Y2FzZSA0OnJldHVybmB2ZWM0PCR7dn0+KCR7Un0oc2NhbGVbMF0uJHtEfSwgc2NhbGVbMV0uJHtEfSwgc2NhbGVbMl0uJHtEfSwgc2NhbGVbM10uJHtEfSkpYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBjb21wb2VudHMgJHtsfWApfX0sQT1FKFwiaW5wdXRcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcyxsKSxDPU0oXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLG8sbCk7cmV0dXJuYFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHtBLnR5cGUuc3RvcmFnZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlX2lucHV0IDogYXJyYXk8JHtTfT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtDLnR5cGUuc3RvcmFnZX0+O1xuICBzdHJ1Y3QgVW5pZm9ybXMge0g6IHUzMiwgQyA6IHUzMn07XG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO1xuXG4gICR7JC5tYWluU3RhcnQoKX1cbiAgICBsZXQgY3VycmVudF9pbWFnZV9udW1iZXIgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLkMgKiB1bmlmb3Jtcy5IKTtcbiAgICBsZXQgY3VycmVudF9jaGFubmVsX251bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xuXG4gICAgbGV0IHNjYWxlX29mZnNldCA9IGN1cnJlbnRfaW1hZ2VfbnVtYmVyICogdW5pZm9ybXMuQyArIGN1cnJlbnRfY2hhbm5lbF9udW1iZXI7XG4gICAgbGV0IHNjYWxlID0gc2NhbGVfaW5wdXRbc2NhbGVfb2Zmc2V0XTtcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBmbWEoaW5wdXRbZ2xvYmFsX2lkeF0sICR7VCgwKX0sICR7VCgxKX0pO1xuICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uTkhXQ1wiLHNoYWRlckNhY2hlOntoaW50OmAke2x9YCxpbnB1dERlcGVuZGVuY2llczp1fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pLGdldFNoYWRlclNvdXJjZTp4fSx7aW5wdXRzOlt0WzBdLGddfSl9LEtkPShlLHQpPT57dC5mb3JtYXQ9PT1cIk5IV0NcIj9zaChlLGUuaW5wdXRzLHQpOmFoKGUsZS5pbnB1dHMsdCl9fSk7dmFyIHVoLGRoLFlkLFpkPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO3VoPWU9PntpZighZXx8ZS5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuXCIpfSxkaD0oZSx0LHIpPT57bGV0IG49dC5zaW1wbGlmaWVkLG89ZVswXS5kaW1zLGk9ZVsxXSxhPSFuJiZlWzJdLGQ9byxsPWsubm9ybWFsaXplQXhpcyh0LmF4aXMsby5sZW5ndGgpLHA9ay5zaXplVG9EaW1lbnNpb24obyxsKSxtPWsuc2l6ZUZyb21EaW1lbnNpb24obyxsKSx1PWsuc2l6ZShpLmRpbXMpLGg9YT9rLnNpemUoYS5kaW1zKTowO2lmKHUhPT1tfHxhJiZoIT09bSl0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke219LlxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHt1fSBhbmQgYmlhcyBzaXplIG9mICR7aH1gKTtsZXQgXz1bXTtmb3IobGV0IEE9MDtBPG8ubGVuZ3RoOysrQSlBPGw/Xy5wdXNoKG9bQV0pOl8ucHVzaCgxKTtsZXQgeT1tZShtKSxnPVtcInR5cGVcIixcInR5cGVcIl0seD1be3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6bX0se3R5cGU6MTIsZGF0YTpNYXRoLmZsb29yKG0veSl9LHt0eXBlOjEsZGF0YTp0LmVwc2lsb259XTthJiZnLnB1c2goXCJ0eXBlXCIpO2xldCAkPXI+MSx2PXI+MixTPUE9PntsZXQgQz15ZShlWzBdLmRhdGFUeXBlKSxQPVtFKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHkpLEUoXCJzY2FsZVwiLGkuZGF0YVR5cGUsaS5kaW1zLHkpXTthJiZQLnB1c2goRShcImJpYXNcIixhLmRhdGFUeXBlLGEuZGltcyx5KSksUC5wdXNoKE0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQseSkpLCQmJlAucHVzaChNKFwibWVhbl9kYXRhX291dHB1dFwiLDEsXykpLHYmJlAucHVzaChNKFwiaW52X3N0ZF9vdXRwdXRcIiwxLF8pKTtsZXQgRD1be25hbWU6XCJub3JtX2NvdW50XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm5vcm1fc2l6ZVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJub3JtX3NpemVfdmVjdG9yaXplZFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAke0EucmVnaXN0ZXJVbmlmb3JtcyhEKS5kZWNsYXJlVmFyaWFibGVzKC4uLlApfVxuICAke0EubWFpblN0YXJ0KCl9XG4gICAgJHtBLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5ub3JtX2NvdW50XCIpfVxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgdmFyIG1lYW5fdmVjdG9yID0gJHtzbyhcImYzMlwiLHkpfTtcbiAgICB2YXIgbWVhbl9zcXVhcmVfdmVjdG9yID0gJHtzbyhcImYzMlwiLHkpfTtcblxuICAgIGZvciAodmFyIGg6IHUzMiA9IDB1OyBoIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGgrKykge1xuICAgICAgbGV0IHZhbHVlID0gJHtQdChDLHksXCJ4W2ggKyBvZmZzZXRdXCIpfTtcbiAgICAgIG1lYW5fdmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhbl9zcXVhcmVfdmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtxZShcIm1lYW5fdmVjdG9yXCIseSl9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xuICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7cWUoXCJtZWFuX3NxdWFyZV92ZWN0b3JcIix5KX0gLyB1bmlmb3Jtcy5ub3JtX3NpemUgJHtuP1wiXCI6XCItIG1lYW4gKiBtZWFuXCJ9ICsgdW5pZm9ybXMuZXBzaWxvbik7XG5cbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xuICAgICAgbGV0IGYzMmlucHV0ID0gJHtQdChDLHksXCJ4W2ogKyBvZmZzZXRdXCIpfTtcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7UHQoQyx5LFwic2NhbGVbal1cIil9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHtQWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAke24/XCJcIjpcIi0gbWVhblwifSkgKiBpbnZfc3RkX2RldiAqIGYzMnNjYWxlXG4gICAgICAgICR7YT9gKyAke1B0KEMseSxcImJpYXNbal1cIil9YDpcIlwifVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAkeyQ/XCJtZWFuX2RhdGFfb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhblwiOlwiXCJ9O1xuICAgICR7dj9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXZcIjpcIlwifTtcbiAgfWB9LFQ9W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiAkJiZULnB1c2goe2RpbXM6XyxkYXRhVHlwZToxfSksdiYmVC5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6MX0pLHtuYW1lOlwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eX07JHtyfTske259YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnh9KSxnZXRTaGFkZXJTb3VyY2U6U319LFlkPShlLHQpPT57dWgoZS5pbnB1dHMpLGUuY29tcHV0ZShkaChlLmlucHV0cyx0LGUub3V0cHV0Q291bnQpKX19KTt2YXIgbGgsUWQsWGQ9VSgoKT0+e1widXNlIHN0cmljdFwiO25lKCk7WnIoKTtRcigpO2xoPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMV0hPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKX0sUWQ9ZT0+e2xoKGUuaW5wdXRzKTtsZXQgdD10dC5jYWxjU2hhcGUoZS5pbnB1dHNbMF0uZGltcyxlLmlucHV0c1sxXS5kaW1zLCEwKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCByPXRbdC5sZW5ndGgtMV0sbj1lLmlucHV0c1swXS5kaW1zW2UuaW5wdXRzWzBdLmRpbXMubGVuZ3RoLTFdO2lmKHI8OCYmbjw4KWUuY29tcHV0ZShZcihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwifSx0KSk7ZWxzZXtsZXQgbz10W3QubGVuZ3RoLTJdLGk9ay5zaXplKGUuaW5wdXRzWzBdLmRpbXMuc2xpY2UoMCwtMikpLGE9ay5zaXplKGUuaW5wdXRzWzFdLmRpbXMuc2xpY2UoMCwtMikpO2lmKGkhPT0xJiZvPT09MSYmYT09PTEpe2xldCBkPWUuaW5wdXRzWzBdLnJlc2hhcGUoWzEsaSxuXSksbD1lLmlucHV0c1sxXS5yZXNoYXBlKFsxLG4scl0pLHA9WzEsaSxyXSxtPVtkLGxdO2UuY29tcHV0ZShKdChtLHthY3RpdmF0aW9uOlwiXCJ9LHQscCkse2lucHV0czptfSl9ZWxzZSBlLmNvbXB1dGUoSnQoZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIn0sdCkpfX19KTt2YXIgY2gscGgsbWgsSmQsZWwsdGw9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtjaD0oZSx0KT0+e2lmKGUubGVuZ3RoPDN8fGUubGVuZ3RoPjQpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsTkJpdHMgcmVxdWlyZXMgMyBvciA0IGlucHV0c1wiKTtsZXQgcj1lWzBdLG49ci5kaW1zLmxlbmd0aDtpZihyLmRpbXNbbi0xXSE9PXQuayl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGFzdCBkaW0gb2YgaW5wdXQgc2hhcGUgZG9lcyBub3QgbWF0Y2ggdGhlIGsgdmFsdWVcIik7bGV0IG89TWF0aC5mbG9vcigodC5rK3QuYmxvY2tTaXplLTEpL3QuYmxvY2tTaXplKSxpPXQuYmxvY2tTaXplLzgqdC5iaXRzLGE9ZVsxXTtpZighay5hcmVFcXVhbChhLmRpbXMsW3QubixvLGldKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGlucHV0cyBtdXN0IGJlIDNEIHRlbnNvciB3aXRoIHNoYXBlIE4gWCBuQmxvY2tzUGVyQ29sIFggYmxvYlNpemVcIik7bGV0IGw9ZVsyXS5kaW1zO2lmKGsuc2l6ZShsKSE9PXQubipvKXRocm93IG5ldyBFcnJvcihcInNjYWxlcyBpbnB1dCBzaXplIGVycm9yLlwiKTtpZihlLmxlbmd0aD09PTQpe2xldCBtPWVbM10uZGltcyx1PXQuYml0cz40P3QubipvOnQubipNYXRoLmZsb29yKChvKzEpLzIpO2lmKGsuc2l6ZShtKSE9PXUpdGhyb3cgbmV3IEVycm9yKFwiemVyb1BvaW50cyBpbnB1dCBzaXplIGVycm9yLlwiKX19LHBoPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ci5sZW5ndGgsbz1yW24tMl0saT10LmssYT10Lm4sZD1yLnNsaWNlKDAsbi0yKSxsPWsuc2l6ZShkKSxtPWVbMV0uZGltc1syXS80LHU9ZVswXS5kYXRhVHlwZSxoPW1lKHQuayksXz1tZShtKSx5PW1lKGEpLGc9ZC5jb25jYXQoW28sYV0pLHg9bz4xJiZhL3klMj09PTA/MjoxLCQ9ay5zaXplKGcpL3kveCx2PTY0LFM9W10sVD1bbCxvLGkvaF0sQT1rLmNvbnZlcnRTaGFwZShlWzFdLmRpbXMpLnNsaWNlKCk7QS5zcGxpY2UoLTEsMSxtL18pLFMucHVzaCguLi5OKFQpKSxTLnB1c2goLi4uTihBKSksUy5wdXNoKC4uLk4oZVsyXS5kaW1zKSksZS5sZW5ndGg9PT00JiZTLnB1c2goLi4uTihrLmNvbnZlcnRTaGFwZShlWzNdLmRpbXMpKSk7bGV0IEM9W2wsbyxhL3ldO1MucHVzaCguLi5OKEMpKTtsZXQgUD1EPT57bGV0IFI9VC5sZW5ndGgsSD1FKFwiYVwiLGVbMF0uZGF0YVR5cGUsUixoKSxMPUUoXCJiXCIsMTIsQS5sZW5ndGgsXykscmU9RShcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksVj1bSCxMLHJlXSxLPWUubGVuZ3RoPT09ND9FKFwiemVyb19wb2ludHNcIiwxMixlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDA7SyYmVi5wdXNoKEspO2xldCB3ZT1DLmxlbmd0aCxqPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHdlLHkpLFE9eWUoZVswXS5kYXRhVHlwZSksaWU9KCgpPT57c3dpdGNoKGgpe2Nhc2UgMTpyZXR1cm5gYXJyYXk8JHtRfSwgOD5gO2Nhc2UgMjpyZXR1cm5gbWF0NHgyPCR7UX0+YDtjYXNlIDQ6cmV0dXJuYG1hdDJ4NDwke1F9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7aH0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSkoKSx0ZT0oKT0+e2xldCB2ZT1gXG4gICAgICAgICAgLy8gcmV1c2UgYSBkYXRhXG4gICAgICAgICAgICB2YXIgaW5wdXRfb2Zmc2V0ID0gJHtILmluZGljZXNUb09mZnNldChgJHtILnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgd29yZF9vZmZzZXQpYCl9O1xuICAgICAgICAgICAgdmFyIGFfZGF0YTogJHtpZX07XG4gICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgJHs4L2h9OyBqKyspIHtcbiAgICAgICAgICAgICAgYV9kYXRhW2pdID0gJHtILmdldEJ5T2Zmc2V0KFwiaW5wdXRfb2Zmc2V0XCIpfTtcbiAgICAgICAgICAgICAgaW5wdXRfb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgYDtmb3IobGV0IGRlPTA7ZGU8eSp4O2RlKyspdmUrPWBcbiAgICAgICAgICAgIGJfdmFsdWUgPSAke189PT0xP2BiJHtkZX1fZGF0YWA6YGIke2RlfV9kYXRhW2ldYH07XG4gICAgICAgICAgICBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfcXVhbnRpemVkX3ZhbHVlcyA9ICR7aWV9KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjR9LChXLFkpPT5gJHtRfShiX3ZhbHVlX2xvd2VyWyR7WX1dKSwgJHtRfShiX3ZhbHVlX3VwcGVyWyR7WX1dKWApLmpvaW4oXCIsIFwiKX0pO1xuICAgICAgICAgICAgYl9kZXF1YW50aXplZF92YWx1ZXMgPSAkeygoKT0+aD09PTE/YCR7aWV9KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjh9LChXLFkpPT5gKGJfcXVhbnRpemVkX3ZhbHVlc1ske1l9XSAtICR7Sz9gemVyb19wb2ludCR7ZGV9YDpcInplcm9fcG9pbnRcIn0pICogc2NhbGUke2RlfWApLmpvaW4oXCIsIFwiKX0pO2A6YChiX3F1YW50aXplZF92YWx1ZXMgLSAke2llfSgke0FycmF5KDgpLmZpbGwoYCR7Sz9gemVyb19wb2ludCR7ZGV9YDpcInplcm9fcG9pbnRcIn1gKS5qb2luKFwiLFwiKX0pKSAqIHNjYWxlJHtkZX07YCkoKX07XG4gICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkLnggKiAke3h9ICsgJHtNYXRoLmZsb29yKGRlL3kpfV0ke3k+MT9gWyR7ZGUleX1dYDpcIlwifSArPSAke0FycmF5LmZyb20oe2xlbmd0aDo4L2h9LChXLFkpPT5gJHtoPT09MT9gYV9kYXRhWyR7WX1dICogYl9kZXF1YW50aXplZF92YWx1ZXNbJHtZfV1gOmBkb3QoYV9kYXRhWyR7WX1dLCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske1l9XSlgfWApLmpvaW4oXCIgKyBcIil9O1xuICAgICAgICAgIGA7cmV0dXJuIHZlfSxiZT0oKT0+e2xldCB2ZT1gXG4gICAgICAgICAgICB2YXIgY29sX2luZGV4ID0gY29sICogJHt5fTtcbiAgICAgICAgICAgICR7Sz9gXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX2NvdW50OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkX2luZGV4OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX29mZnNldDogdTMyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYml0c19vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMjtgOmBcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHplcm8gcG9pbnQgaXMgOCBmb3IgdW5zaWduZWQgNC1iaXQgcXVhbnRpemF0aW9uLlxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke1F9KDgpO2B9XG4gICAgICAgICAgICBgO2ZvcihsZXQgZGU9MDtkZTx5Kng7ZGUrKyl2ZSs9YFxuICAgICAgICAgICAgbGV0IHNjYWxlJHtkZX0gPSAke3JlLmdldEJ5T2Zmc2V0KFwiY29sX2luZGV4ICogbkJsb2Nrc1BlckNvbCArIGJsb2NrXCIpfTtcbiAgICAgICAgICAgICR7Sz9gXG4gICAgICAgICAgICB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBjb2xfaW5kZXggKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgPj4gMHgxdSk7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgemVyb19wb2ludF9iaXRzX29mZnNldCA9ICh6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0IDw8IDMpICsgKHplcm9fcG9pbnRfbmliYmxlX29mZnNldCA8PCAyKTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZCA9ICR7Sy5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfd29yZF9pbmRleFwiKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50JHtkZX0gPSAke1F9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YDpcIlwifVxuICAgICAgICAgICAgY29sX2luZGV4ICs9IDE7YDtyZXR1cm4gdmV9LE9lPSgpPT57bGV0IHZlPWBjb2xfaW5kZXggPSBjb2wgKiAke3l9O2A7Zm9yKGxldCBkZT0wO2RlPHkqeDtkZSsrKXZlKz1gXG4gICAgICAgICAgICBsZXQgYiR7ZGV9X2RhdGEgPSAke0wuZ2V0QnlJbmRpY2VzKGAke0wudHlwZS5pbmRpY2VzfShjb2xfaW5kZXgsIGJsb2NrLCB3b3JkKWApfTtcbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7cmV0dXJuIHZlKz1gXG4gICAgICAgICAgICB2YXIgYl92YWx1ZTogdTMyO1xuICAgICAgICAgICAgbGV0IGJfbWFzazogdTMyID0gMHgwRjBGMEYwRnU7XG4gICAgICAgICAgICB2YXIgYl92YWx1ZV9sb3dlcjogdmVjNDx1MzI+O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfdXBwZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3F1YW50aXplZF92YWx1ZXM6ICR7aWV9O1xuICAgICAgICAgICAgdmFyIGJfZGVxdWFudGl6ZWRfdmFsdWVzOiAke2llfTtgLHZlfTtyZXR1cm5gXG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQ6IGFycmF5PCR7ai50eXBlLnZhbHVlfSwgJHt4KnZ9PjtcbiAgICAgICAgJHtELmRlY2xhcmVWYXJpYWJsZXMoLi4uVixqKX1cbiAgICAgICAgJHtELm1haW5TdGFydChbdiwxLDFdKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2oub2Zmc2V0VG9JbmRpY2VzKGAoZ2xvYmFsX2lkeCAvICR7dn0pICogJHt4fWApfTtcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xuICAgICAgICAgIGxldCBuQmxvY2tzUGVyQ29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcblxuICAgICAgICAgIGZvciAodmFyIGJsb2NrID0gbG9jYWxfaWQueDsgYmxvY2sgPCBuQmxvY2tzUGVyQ29sOyBibG9jayArPSAke3Z9KSB7XG4gICAgICAgICAgICAvL3Byb2Nlc3Mgb25lIGJsb2NrXG4gICAgICAgICAgICB2YXIgd29yZF9vZmZzZXQ6IHUzMiA9IGJsb2NrICogJHt0LmJsb2NrU2l6ZS9ofTtcbiAgICAgICAgICAgICR7YmUoKX1cbiAgICAgICAgICAgIGZvciAodmFyIHdvcmQ6IHUzMiA9IDA7IHdvcmQgPCAke219OyB3b3JkICs9ICR7X30pIHtcbiAgICAgICAgICAgICAgJHtPZSgpfVxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtffTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgJHt0ZSgpfVxuICAgICAgICAgICAgICAgIHdvcmRfb2Zmc2V0ICs9ICR7OC9ofTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgICBpZiAobG9jYWxfaWQueCA8ICR7eH0pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7ai50eXBlLnZhbHVlfSA9ICR7ai50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgIHZhciB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldDogdTMyID0gbG9jYWxfaWQueDtcbiAgICAgICAgICAgIGZvciAodmFyIGI6IHUzMiA9IDB1OyBiIDwgJHt2fXU7IGIrKykge1xuICAgICAgICAgICAgICBvdXRwdXRfdmFsdWUgKz0gd29ya2dyb3VwX3NoYXJlZFt3b3JrZ3JvdXBfc2hhcmVkX29mZnNldF07XG4gICAgICAgICAgICAgIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0ICs9ICR7eH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke2ouc2V0QnlJbmRpY2VzKGAke2oudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBjb2wgKyBsb2NhbF9pZC54KWAsXCJvdXRwdXRfdmFsdWVcIil9O1xuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiTWF0TXVsTkJpdHNcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmJsb2NrU2l6ZX07JHt0LmJpdHN9OyR7aH07JHtffTske3l9OyR7eH07JHt2fWAsaW5wdXREZXBlbmRlbmNpZXM6QXJyYXkoZS5sZW5ndGgpLmZpbGwoXCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmcsZGF0YVR5cGU6dX1dLGRpc3BhdGNoR3JvdXA6e3g6JH0scHJvZ3JhbVVuaWZvcm1zOlN9KSxnZXRTaGFkZXJTb3VyY2U6UH19LG1oPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ci5sZW5ndGgsbz1yW24tMl0saT10LmssYT10Lm4sZD1yLnNsaWNlKDAsbi0yKSxsPWsuc2l6ZShkKSxtPWVbMV0uZGltc1syXS80LHU9ZVswXS5kYXRhVHlwZSxoPW1lKHQuayksXz1tZShtKSx5PWQuY29uY2F0KFtvLGFdKSxnPTEyOCx4PWElOD09PTA/ODphJTQ9PT0wPzQ6MSwkPWcveCx2PSQqXyo4LFM9di9oLFQ9di90LmJsb2NrU2l6ZSxBPWsuc2l6ZSh5KS94LEM9W10sUD1bbCxvLGkvaF0sRD1rLmNvbnZlcnRTaGFwZShlWzFdLmRpbXMpLnNsaWNlKCk7RC5zcGxpY2UoLTEsMSxtL18pLEMucHVzaCguLi5OKFApKSxDLnB1c2goLi4uTihEKSksQy5wdXNoKC4uLk4oZVsyXS5kaW1zKSksZS5sZW5ndGg9PT00JiZDLnB1c2goLi4uTihrLmNvbnZlcnRTaGFwZShlWzNdLmRpbXMpKSk7bGV0IFI9W2wsbyxhXTtDLnB1c2goLi4uTihSKSk7bGV0IEg9TD0+e2xldCByZT1QLmxlbmd0aCxWPUUoXCJhXCIsZVswXS5kYXRhVHlwZSxyZSxoKSxLPUUoXCJiXCIsMTIsRC5sZW5ndGgsXyksd2U9RShcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksaj1bVixLLHdlXSxRPWUubGVuZ3RoPT09ND9FKFwiemVyb19wb2ludHNcIiwxMixlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDA7USYmai5wdXNoKFEpO2xldCBpZT1SLmxlbmd0aCx0ZT1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxpZSksYmU9eWUoZVswXS5kYXRhVHlwZSksT2U9KCk9Pntzd2l0Y2goaCl7Y2FzZSAxOnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtiZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAyXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAzXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7YmV9PihzdWJfYVt3b3JkX29mZnNldCArIDRdLCBzdWJfYVt3b3JkX29mZnNldCArIDVdLCBzdWJfYVt3b3JkX29mZnNldCArIDZdLCBzdWJfYVt3b3JkX29mZnNldCArIDddKTtgO2Nhc2UgMjpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7YmV9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0pO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke2JlfT4oc3ViX2Fbd29yZF9vZmZzZXQgKyAyXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAzXSk7YDtjYXNlIDQ6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gc3ViX2Fbd29yZF9vZmZzZXRdO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gc3ViX2Fbd29yZF9vZmZzZXQgKyAxXTtgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2h9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX07cmV0dXJuYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiBzdWJfYTogYXJyYXk8JHtWLnR5cGUudmFsdWV9LCAke1N9PjtcbiAgICAgICAgdmFyPHdvcmtncm91cD4gaW50ZXJfcmVzdWx0czogYXJyYXk8YXJyYXk8JHt0ZS50eXBlLnZhbHVlfSwgJHskfT4sICR7eH0+O1xuICAgICAgICAke0wuZGVjbGFyZVZhcmlhYmxlcyguLi5qLHRlKX1cbiAgICAgICAgJHtMLm1haW5TdGFydChbJCx4LDFdKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke3RlLm9mZnNldFRvSW5kaWNlcyhgd29ya2dyb3VwX2luZGV4ICogJHt4fWApfTtcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xuICAgICAgICAgIGxldCBuX2Jsb2Nrc19wZXJfY29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcbiAgICAgICAgICBsZXQgbnVtX3RpbGVzID0gIChuX2Jsb2Nrc19wZXJfY29sIC0gMSkgLyAke1R9ICsgMTtcblxuICAgICAgICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgICAgICAgIGZvciAodmFyIHRpbGU6IHUzMiA9IDA7IHRpbGUgPCBudW1fdGlsZXM7IHRpbGUgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGFfY29sX3N0YXJ0ID0gdGlsZSAqICR7U307XG4gICAgICAgICAgICAvLyBsb2FkIG9uZSB0aWxlIEEgZGF0YSBpbnRvIHNoYXJlZCBtZW1vcnkuXG4gICAgICAgICAgICBmb3IgKHZhciBhX29mZnNldCA9IGxvY2FsX2lkeDsgYV9vZmZzZXQgPCAke1N9OyBhX29mZnNldCArPSAke2d9KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBsZXQgYV9jb2wgPSBhX2NvbF9zdGFydCArIGFfb2Zmc2V0O1xuICAgICAgICAgICAgICBpZiAoYV9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzJdKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3ViX2FbYV9vZmZzZXRdID0gJHtWLmdldEJ5SW5kaWNlcyhgJHtWLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgYV9jb2wpYCl9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1Yl9hW2Ffb2Zmc2V0XSA9ICR7Vi50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICAgICAvLyBlYWNoIHRocmVhZCBwcm9jZXNzIG9uZSBibG9ja1xuICAgICAgICAgICAgbGV0IGJfcm93ID0gY29sICsgbG9jYWxfaWQueTtcbiAgICAgICAgICAgIGxldCBibG9jayA9IHRpbGUgKiAke1R9ICsgbG9jYWxfaWQueDtcbiAgICAgICAgICAgICR7UT9gXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5fYmxvY2tzX3Blcl9jb2wgKyAxKSAvIDI7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlX2NvdW50ID0gYl9yb3cgKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgPj4gMHgxdSk7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkX2luZGV4ID0gemVyb19wb2ludF9ieXRlX2NvdW50ID4+IDB4MnU7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlX29mZnNldCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCAmIDB4M3U7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9uaWJibGVfb2Zmc2V0OiB1MzIgPSBibG9jayAmIDB4MXU7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9iaXRzX29mZnNldCA9ICh6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0IDw8IDMpICsgKHplcm9fcG9pbnRfbmliYmxlX29mZnNldCA8PCAyKTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3dvcmQgPSAke1EuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X3dvcmRfaW5kZXhcIil9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7YmV9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YDpgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtiZX0oOCk7YH1cbiAgICAgICAgICAgIGxldCBzY2FsZSA9ICR7d2UuZ2V0QnlPZmZzZXQoXCJiX3JvdyAqIG5fYmxvY2tzX3Blcl9jb2wgKyBibG9ja1wiKX07XG4gICAgICAgICAgICBsZXQgYl9kYXRhID0gJHtLLmdldEJ5SW5kaWNlcyhgJHtLLnR5cGUuaW5kaWNlc30oYl9yb3csIGJsb2NrLCAwKWApfTtcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldCA9IGxvY2FsX2lkLnggKiAke3QuYmxvY2tTaXplL2h9O1xuICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7X307IGkrKykge1xuICAgICAgICAgICAgICAke09lKCl9XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlID0gJHtfPT09MT9cImJfZGF0YVwiOlwiYl9kYXRhW2ldXCJ9O1xuICAgICAgICAgICAgICBsZXQgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIDB4MEYwRjBGMEZ1KTtcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgMHgwRjBGMEYwRnUpO1xuICAgICAgICAgICAgICBsZXQgYl9xdWFudGl6ZWRfdmFsdWVzID0gbWF0Mng0PCR7YmV9Pigke0FycmF5LmZyb20oe2xlbmd0aDo0fSwodmUsZGUpPT5gJHtiZX0oYl92YWx1ZV9sb3dlclske2RlfV0pLCAke2JlfShiX3ZhbHVlX3VwcGVyWyR7ZGV9XSlgKS5qb2luKFwiLCBcIil9KTtcbiAgICAgICAgICAgICAgbGV0IGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gKGJfcXVhbnRpemVkX3ZhbHVlcyAtIG1hdDJ4NDwke2JlfT4oJHtBcnJheSg4KS5maWxsKFwiemVyb19wb2ludFwiKS5qb2luKFwiLFwiKX0pKSAqIHNjYWxlO1xuICAgICAgICAgICAgICBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdICs9ICR7QXJyYXkuZnJvbSh7bGVuZ3RoOjJ9LCh2ZSxkZSk9PmAke2Bkb3QoYV9kYXRhJHtkZX0sIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7ZGV9XSlgfWApLmpvaW4oXCIgKyBcIil9O1xuICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezgvaH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkeCA8ICR7eH0pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7dGUudHlwZS52YWx1ZX0gPSAke3RlLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDB1OyBiIDwgJHskfTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkeF1bYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sICsgbG9jYWxfaWR4IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAke3RlLnNldEJ5SW5kaWNlcyhgJHt0ZS50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkeClgLFwib3V0cHV0X3ZhbHVlXCIpfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiQmxvY2t3aXNlTWF0TXVsTkJpdHMzMlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske2h9OyR7X307JHskfTske3h9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6eSxkYXRhVHlwZTp1fV0sZGlzcGF0Y2hHcm91cDp7eDpBfSxwcm9ncmFtVW5pZm9ybXM6Q30pLGdldFNoYWRlclNvdXJjZTpIfX0sSmQ9KGUsdCk9PntjaChlLmlucHV0cyx0KSx0LmJsb2NrU2l6ZT09PTMyJiZlLmFkYXB0ZXJJbmZvLmlzVmVuZG9yKFwiaW50ZWxcIikmJmUuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoXCJnZW4tMTJscFwiKT9lLmNvbXB1dGUobWgoZS5pbnB1dHMsdCkpOmUuY29tcHV0ZShwaChlLmlucHV0cyx0KSl9LGVsPWU9PmVlKGUpfSk7dmFyIGZoLGhoLGdoLGJoLHloLF9oLHdoLHZoLHJsLG5sPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO2ZoPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gZmV3IGlucHV0c1wiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTEwKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGUgbXVzdCBiZSBmbG9hdCBvciBmbG9hdDE2LlwiKTtpZihlLmxlbmd0aD49Mil7bGV0IHQ9ZVswXS5kaW1zLmxlbmd0aCoyPT09ZVsxXS5kaW1zWzBdO2lmKGUubGVuZ3RoPT09NCYmKHQ9ZVszXS5kaW1zWzBdKjI9PT1lWzFdLmRpbXNbMF0pLCF0KXRocm93IG5ldyBFcnJvcihcIlRoZSBwYWRzIHNob3VsZCBiZSBhIDFEIHRlbnNvciBvZiBzaGFwZSBbMiAqIGlucHV0X3JhbmtdIG9yIFsyICogbnVtX2F4ZXNdLlwiKX19LGhoPShlLHQscik9PntsZXQgbj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pbis9YFxuICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtxKFwidW5pZm9ybXMucGFkc1wiLG8scil9O1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7cShcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke3EoXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgIHZhbHVlID0gJHtlLnR5cGUudmFsdWV9KHVuaWZvcm1zLmNvbnN0YW50X3ZhbHVlKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAke259XG4gICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICBgfSxnaD0oZSx0LHIpPT57bGV0IG49XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKW4rPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke3EoXCJ1bmlmb3Jtcy5wYWRzXCIsbyxyKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gLWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxldCBfMm5fMSA9IDIgKiAoaTMyKCR7cShcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkgLSAxKTtcbiAgICAgICAgICAgICAgICAgIGsgPSBrICUgXzJuXzE7XG4gICAgICAgICAgICAgICAgICBpZihrID49IGkzMigke3EoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7cShcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke259XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LGJoPShlLHQscik9PntsZXQgbj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pbis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7cShcInVuaWZvcm1zLnBhZHNcIixvLHIpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtxKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgayA9IGkzMigke3EoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtxKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7bn1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0seWg9KGUsdCxyKT0+e2xldCBuPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbyluKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtxKFwidW5pZm9ybXMucGFkc1wiLG8scil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkgIHtcbiAgICAgICAgICAgICAgICAgIGsgKz0gaTMyKCR7cShcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtxKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgayAtPSBpMzIoJHtxKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtxKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7bn1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0sX2g9KGUsdCxyKT0+e3N3aXRjaChyLm1vZGUpe2Nhc2UgMDpyZXR1cm4gaGgoZSx0LHIucGFkcy5sZW5ndGgpO2Nhc2UgMTpyZXR1cm4gZ2goZSx0LHIucGFkcy5sZW5ndGgpO2Nhc2UgMjpyZXR1cm4gYmgoZSx0LHIucGFkcy5sZW5ndGgpO2Nhc2UgMzpyZXR1cm4geWgoZSx0LHIucGFkcy5sZW5ndGgpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0sd2g9KGUsdCk9PntsZXQgcj1rLnBhZFNoYXBlKGVbMF0uZGltcy5zbGljZSgpLHQucGFkcyksbj1lWzBdLmRpbXMsbz1rLnNpemUociksaT1be3R5cGU6MTIsZGF0YTpvfSx7dHlwZTo2LGRhdGE6dC5wYWRzfV0sYT1lLmxlbmd0aD49MyYmZVsyXS5kYXRhO3QubW9kZT09PTAmJmkucHVzaCh7dHlwZTphP2VbMl0uZGF0YVR5cGU6MSxkYXRhOnQudmFsdWV9KSxpLnB1c2goLi4uTihlWzBdLmRpbXMscikpO2xldCBkPVtcInJhbmtcIl0sbD1wPT57bGV0IG09TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgpLHU9RShcInhcIixlWzBdLmRhdGFUeXBlLG4ubGVuZ3RoKSxoPXUudHlwZS52YWx1ZSxfPV9oKG0sbi5sZW5ndGgsdCkseT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDp0LnBhZHMubGVuZ3RofV07cmV0dXJuIHQubW9kZT09PTAmJnkucHVzaCh7bmFtZTpcImNvbnN0YW50X3ZhbHVlXCIsdHlwZTphP2g6XCJmMzJcIn0pLGBcbiAgICAgICAgICAgICR7cC5yZWdpc3RlclVuaWZvcm1zKHkpLmRlY2xhcmVWYXJpYWJsZXModSxtKX1cbiAgICAgICAgICAgICR7cC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7cC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHttLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAke2h9KDApO1xuICAgICAgICAgICAgJHtffVxuICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlBhZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QubW9kZX0ke2F9YCxpbnB1dERlcGVuZGVuY2llczpkfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGsuc2l6ZShyKS82NCl9LHByb2dyYW1Vbmlmb3JtczppfSksZ2V0U2hhZGVyU291cmNlOmx9fSx2aD0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCByPWVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLG49ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YT9lWzJdLmRhdGFUeXBlPT09MTA/ZVsyXS5nZXRVaW50MTZBcnJheSgpWzBdOmVbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06MCxvPWVbMF0uZGltcy5sZW5ndGgsaT1uZXcgSW50MzJBcnJheSgyKm8pLmZpbGwoMCk7aWYoZS5sZW5ndGg+PTQpe2xldCBkPWVbM10uZ2V0QmlnSW50NjRBcnJheSgpO2ZvcihsZXQgbD0wO2w8ZC5sZW5ndGg7bCsrKWlbTnVtYmVyKGRbbF0pXT1OdW1iZXIocltsXSksaVtOdW1iZXIoZFtsXSkrb109TnVtYmVyKHJbbCtkLmxlbmd0aF0pfWVsc2Ugci5mb3JFYWNoKChkLGwpPT5pW051bWJlcihsKV09TnVtYmVyKGQpKTtsZXQgYT1bXTtyZXR1cm4gaS5mb3JFYWNoKGQ9PmEucHVzaChkKSkse21vZGU6dC5tb2RlLHZhbHVlOm4scGFkczphfX1lbHNlIHJldHVybiB0fSxybD0oZSx0KT0+e2ZoKGUuaW5wdXRzKTtsZXQgcj12aChlLmlucHV0cyx0KTtlLmNvbXB1dGUod2goZS5pbnB1dHMscikse2lucHV0czpbMF19KX19KTt2YXIgZW4sb2wsaWwsYWwsc2wsJGgseGgsdWwsZGwsbGwsY2wscGwsbWwsZmwsaGwsZ2wsYmwseWwsX2wsd2w9VSgoKT0+e1widXNlIHN0cmljdFwiO0xlKCk7SigpO25lKCk7YWUoKTtlbj1lPT57aWYoX2Uud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiYoIWV8fGUubGVuZ3RoIT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC5cIil9LG9sPShlLHQscik9PntsZXQgbj10LmZvcm1hdD09PVwiTkhXQ1wiLG89ZS5kaW1zLnNsaWNlKCk7biYmby5zcGxpY2UoMSwwLG8ucG9wKCkpO2xldCBpPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJkaWxhdGlvbnNcIiksYT10Lmtlcm5lbFNoYXBlLnNsaWNlKCksZD10LnN0cmlkZXMuc2xpY2UoKSxsPWk/dC5kaWxhdGlvbnMuc2xpY2UoKTpbXSxwPXQucGFkcy5zbGljZSgpO2t0LmFkanVzdFBvb2xBdHRyaWJ1dGVzKHIsbyxhLGQsbCxwKTtsZXQgbT1rdC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKHIsbyxkLGwsYSxwLHQuYXV0b1BhZCksdT1PYmplY3QuYXNzaWduKHt9LHQpO2k/T2JqZWN0LmFzc2lnbih1LHtrZXJuZWxTaGFwZTphLHN0cmlkZXM6ZCxwYWRzOnAsZGlsYXRpb25zOmwsY2FjaGVLZXk6dC5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24odSx7a2VybmVsU2hhcGU6YSxzdHJpZGVzOmQscGFkczpwLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTtsZXQgaD1tLnNsaWNlKCk7cmV0dXJuIGgucHVzaChoLnNwbGljZSgxLDEpWzBdKSxbdSxuP2g6bV19LGlsPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixuPWsuc2l6ZShlKSxvPWsuc2l6ZSh0Lmtlcm5lbFNoYXBlKSxpPVt7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6b31dLGE9W3tuYW1lOlwib3V0cHV0U2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcInUzMlwifV07aWYodC5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2xldCBkPXQua2VybmVsU2hhcGVbdC5rZXJuZWxTaGFwZS5sZW5ndGgtMV0sbD10LnN0cmlkZXNbdC5zdHJpZGVzLmxlbmd0aC0xXSxwPXQucGFkc1t0LnBhZHMubGVuZ3RoLzItMV0sbT10LnBhZHNbdC5wYWRzLmxlbmd0aC0xXSx1PSEhKHArbSk7aS5wdXNoKHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6bX0pLGEucHVzaCh7bmFtZTpcImt3XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN3XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInB3U3RhcnRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicHdFbmRcIix0eXBlOlwidTMyXCJ9KTtsZXQgaD0hMTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCBfPXQua2VybmVsU2hhcGVbdC5rZXJuZWxTaGFwZS5sZW5ndGgtMl0seT10LnN0cmlkZXNbdC5zdHJpZGVzLmxlbmd0aC0yXSxnPXQucGFkc1t0LnBhZHMubGVuZ3RoLzItMl0seD10LnBhZHNbdC5wYWRzLmxlbmd0aC0yXTtoPSEhKGcreCksaS5wdXNoKHt0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTp5fSx7dHlwZToxMixkYXRhOmd9LHt0eXBlOjEyLGRhdGE6eH0pLGEucHVzaCh7bmFtZTpcImtoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInNoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBoU3RhcnRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGhFbmRcIix0eXBlOlwidTMyXCJ9KX1yZXR1cm5baSxhLCEwLHUsaF19ZWxzZXtpZihyKXRocm93IG5ldyBFcnJvcihcIlBvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LlwiKTtsZXQgZD1rLmNvbXB1dGVTdHJpZGVzKHQua2VybmVsU2hhcGUpO2kucHVzaCh7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6dC5wYWRzfSx7dHlwZToxMixkYXRhOnQuc3RyaWRlc30pLGEucHVzaCh7bmFtZTpcImtlcm5lbFN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOmQubGVuZ3RofSx7bmFtZTpcInBhZHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQucGFkcy5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5zdHJpZGVzLmxlbmd0aH0pO2xldCBsPXQucGFkcy5yZWR1Y2UoKHAsbSk9PnArbSk7cmV0dXJuW2ksYSwhIWwsITEsITFdfX0sYWw9KGUsdCxyLG4sbyxpLGEsZCxsLHAsbSx1KT0+e2xldCBoPW8uZm9ybWF0PT09XCJOSFdDXCIsXz10LnR5cGUudmFsdWUseT1NKFwib3V0cHV0XCIsdC50eXBlLnRlbnNvcixuKTtpZihvLmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7bGV0IGc9XCJcIix4PVwiXCIsJD1cIlwiLHY9ci0oaD8yOjEpO2lmKG0/Zz1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske3Z9XSA9IGluZGljZXNbJHt2fV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7dn1dIDwgMCB8fCB4SW5kaWNlc1ske3Z9XVxuICAgICAgICAgICAgICAgICAgICAgID49IHVuaWZvcm1zLnhfc2hhcGVbJHt2fV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgICAgICB9YDpnPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmt3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7dn1dID0gaW5kaWNlc1ske3Z9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgJHtpfVxuICAgICAgICAgICAgICAgIH1gLG8ua2VybmVsU2hhcGUubGVuZ3RoPT09Mil7bGV0IFQ9ci0oaD8zOjIpO3U/eD1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske1R9XSA9IGluZGljZXNbJHtUfV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7VH1dIDwgMCB8fCB4SW5kaWNlc1ske1R9XSA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7VH1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCArPSBpMzIodW5pZm9ybXMua3cpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYDp4PWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7VH1dID0gaW5kaWNlc1ske1R9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgYCwkPWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtcyhsKS5kZWNsYXJlVmFyaWFibGVzKHQseSl9XG5cbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtffSgke2R9KTtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XG4gICAgICAgICAgICAgICR7eH1cbiAgICAgICAgICAgICAgJHtnfVxuICAgICAgICAgICAgICAkeyR9XG4gICAgICAgICAgICAgICR7YX1cblxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gfWVsc2V7aWYoaCl0aHJvdyBuZXcgRXJyb3IoXCJQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC5cIik7bGV0IGc9by5rZXJuZWxTaGFwZS5sZW5ndGgseD1vLnBhZHMubGVuZ3RoLCQ9XCJcIjtyZXR1cm4gcD8kPWBcbiAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbal0gPj0gdW5pZm9ybXMueF9zaGFwZVtqXSkge1xuICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgJHtpfVxuICAgICAgICAgICAgICB9YDokPWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICBgLGBcbiAgICAgICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKGwpLmRlY2xhcmVWYXJpYWJsZXModCx5KX1cblxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAgICAgdmFyIG9mZnNldHM6IGFycmF5PHUzMiwgJHtnfT47XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtffSgke2R9KTtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XG4gICAgICAgICAgICAgIHZhciBpc1BhZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua2VybmVsU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDB1OyBqIDwgJHtnLTF9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXRzW2pdID0gb2Zmc2V0IC8gJHtxKFwidW5pZm9ybXMua2VybmVsU3RyaWRlc1wiLFwialwiLGcpfTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBvZmZzZXRzW2pdICogJHtxKFwidW5pZm9ybXMua2VybmVsU3RyaWRlc1wiLFwialwiLGcpfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1ske2ctMX1dID0gb2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gJHtyLWd9dTsgaiA8ICR7cn11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzW2pdID0gaW5kaWNlc1tqXSAqICR7cShcInVuaWZvcm1zLnN0cmlkZXNcIixgaiAtICR7ci1nfXVgLGcpfVxuICAgICAgICAgICAgICAgICAgICArIG9mZnNldHNbaiAtICR7ci1nfXVdIC0gJHtxKFwidW5pZm9ybXMucGFkc1wiLFwiaiAtIDJ1XCIseCl9O1xuICAgICAgICAgICAgICAgICAgJHskfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7YX1cblxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gfX0sc2w9ZT0+YCR7ZS5mb3JtYXR9OyR7ZS5jZWlsTW9kZX07JHtlLmF1dG9QYWR9OyR7ZS5rZXJuZWxTaGFwZS5sZW5ndGh9YCwkaD1lPT5gJHtzbChlKX07JHtlLmNvdW50SW5jbHVkZVBhZH1gLHhoPWU9PmAke3NsKGUpfTske2Uuc3RvcmFnZU9yZGVyfTske2UuZGlsYXRpb25zfWAsdWw9ZT0+KHtmb3JtYXQ6ZS5mb3JtYXQsYXV0b1BhZDpbXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLGNlaWxNb2RlOmUuY2VpbF9tb2RlLGtlcm5lbFNoYXBlOmUua2VybmVsX3NoYXBlLHN0cmlkZXM6ZS5zdHJpZGVzLHBhZHM6ZS5wYWRzfSksZGw9KGUsdCxyLG4pPT57bGV0W28saV09b2wodCxuLHIpLGE9RShcInhcIix0LmRhdGFUeXBlLHQuZGltcy5sZW5ndGgpLGQ9YS50eXBlLnZhbHVlLGw9XCJ2YWx1ZSArPSB4X3ZhbDtcIixwPVwiXCI7by5jb3VudEluY2x1ZGVQYWQ/cCs9YHZhbHVlIC89ICR7ZH0odW5pZm9ybXMua2VybmVsU2l6ZSk7YDpwKz1gdmFsdWUgLz0gJHtkfShpMzIodW5pZm9ybXMua2VybmVsU2l6ZSkgLSBwYWQpO2A7bGV0W20sdSxoLF8seV09aWwoaSxvKTttLnB1c2goLi4uTih0LmRpbXMsaSkpO2xldCBnPVtcInJhbmtcIl07cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpgJHtuLmNhY2hlS2V5fTske2h9OyR7X307JHt5fWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChrLnNpemUoaSkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pLGdldFNoYWRlclNvdXJjZTp4PT5hbCh4LGEsdC5kaW1zLmxlbmd0aCxpLmxlbmd0aCxvLGwscCwwLHUsaCxfLHkpfX0sbGw9ZT0+e2xldCB0PWUuY291bnRfaW5jbHVkZV9wYWQhPT0wLHI9dWwoZSk7aWYoci5jZWlsTW9kZSE9PTApdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbFwiKTtsZXQgbj17Y291bnRJbmNsdWRlUGFkOnQsLi4ucixjYWNoZUtleTpcIlwifTtyZXR1cm57Li4ubixjYWNoZUtleTokaChuKX19LGNsPShlLHQpPT57ZW4oZS5pbnB1dHMpLGUuY29tcHV0ZShkbChcIkF2ZXJhZ2VQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSxwbD17YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXSxzdG9yYWdlT3JkZXI6MCxkaWxhdGlvbnM6W119LG1sPWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4ucGwsY2FjaGVLZXk6dH19LGZsPShlLHQpPT57ZW4oZS5pbnB1dHMpLGUuY29tcHV0ZShkbChcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfSxobD0oZSx0LHIsbik9PntsZXRbbyxpXT1vbCh0LG4sciksYT1gXG4gICAgICB2YWx1ZSA9IG1heCh4X3ZhbCwgdmFsdWUpO1xuICAgIGAsZD1cIlwiLGw9RShcInhcIix0LmRhdGFUeXBlLHQuZGltcy5sZW5ndGgpLHA9W1wicmFua1wiXSxbbSx1LGgsXyx5XT1pbChpLG8pO3JldHVybiBtLnB1c2goLi4uTih0LmRpbXMsaSkpLHtuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bi5jYWNoZUtleX07JHtofTske199OyR7eX1gLGlucHV0RGVwZW5kZW5jaWVzOnB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoay5zaXplKGkpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6Zz0+YWwoZyxsLHQuZGltcy5sZW5ndGgsaS5sZW5ndGgsbyxhLGQsdC5kYXRhVHlwZT09PTEwPy02NTUwNDotMWU1LHUsaCxfLHkpfX0sZ2w9KGUsdCk9PntlbihlLmlucHV0cyksZS5jb21wdXRlKGhsKFwiTWF4UG9vbFwiLGUuaW5wdXRzWzBdLCExLHQpKX0sYmw9ZT0+e2xldCB0PWUuc3RvcmFnZV9vcmRlcixyPWUuZGlsYXRpb25zLG49dWwoZSk7aWYodCE9PTApdGhyb3cgbmV3IEVycm9yKFwiY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7aWYobi5jZWlsTW9kZSE9PTApdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2xldCBvPXtzdG9yYWdlT3JkZXI6dCxkaWxhdGlvbnM6ciwuLi5uLGNhY2hlS2V5OlwiXCJ9O3JldHVybnsuLi5vLGNhY2hlS2V5OnhoKG8pfX0seWw9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi5wbCxjYWNoZUtleTp0fX0sX2w9KGUsdCk9PntlbihlLmlucHV0cyksZS5jb21wdXRlKGhsKFwiR2xvYmFsTWF4UG9vbFwiLGUuaW5wdXRzWzBdLCEwLHQpKX19KTt2YXIgVGgsSWgsdmwsJGwseGw9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtUaD0oZSx0KT0+e2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiRGVxdWFudGl6ZUxpbmVhciByZXF1aXJlcyAyIG9yIDMgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMV0uZGltcz09PWVbMl0uZGltcyl0aHJvdyBuZXcgRXJyb3IoXCJ4LXNjYWxlIGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzBdLmRhdGFUeXBlPT09NiYmZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbiB0aGUgY2FzZSBvZiBkZXF1YW50aXppbmcgaW50MzIgdGhlcmUgaXMgbm8gemVybyBwb2ludC5cIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTAmJmVbMV0uZGltcy5sZW5ndGghPT0xJiZlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBpbnB1dCBtdXN0IGJlIGEgc2NhbGFyLCBhIDFEIHRlbnNvciwgb3IgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IuXCIpO2lmKGUubGVuZ3RoPjIpe2lmKGVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsuXCIpO2lmKCFlWzFdLmRpbXMubWFwKChyLG4pPT5yPT09ZVsyXS5kaW1zW25dKS5yZWR1Y2UoKHIsbik9PnImJm4sITApKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuXCIpfWlmKHQuYmxvY2tTaXplPjApe2lmKGVbMV0uZGltcy5sZW5ndGg9PT0wfHxlWzFdLmRpbXMubGVuZ3RoPT09MSYmZVsxXS5kaW1zWzBdPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJibG9ja1NpemUgbXVzdCBiZSBzZXQgb25seSBmb3IgYmxvY2sgcXVhbnRpemF0aW9uLlwiKTtpZighZVsxXS5kaW1zLm1hcCgobyxpKT0+aT09PXQuYXhpc3x8bz09PWVbMF0uZGltc1tpXSkucmVkdWNlKChvLGkpPT5vJiZpLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uLCBzY2FsZSBpbnB1dCBzaGFwZSB0byBtYXRjaCB0aGUgaW5wdXQgc2hhcGUgZXhjZXB0IGZvciB0aGUgYXhpc1wiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uIHRoZSBzY2FsZSBpbnB1dCByYW5rIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHggcmFuay5cIik7bGV0IHI9ZVswXS5kaW1zW3QuYXhpc10sbj1lWzFdLmRpbXNbdC5heGlzXTtpZih0LmJsb2NrU2l6ZTxNYXRoLmNlaWwoci9uKXx8dC5ibG9ja1NpemU+TWF0aC5jZWlsKHIvKG4tMSktMSkpdGhyb3cgbmV3IEVycm9yKFwiYmxvY2tTaXplIG11c3QgYmUgd2l0aCBpbiB0aGUgcmFuZ2UgW2NlaWwoZEkgLyBTaSksIGNlaWwoZEkgLyAoU2kgLSAxKSAtIDEpXS5cIil9fSxJaD0oZSx0KT0+e2xldCByPWsubm9ybWFsaXplQXhpcyh0LmF4aXMsZVswXS5kaW1zLmxlbmd0aCksbj1lWzBdLmRhdGFUeXBlLG89bj09PTMsaT1lWzBdLmRpbXMsYT1lWzFdLmRhdGFUeXBlLGQ9ay5zaXplKGkpLGw9bj09PTN8fG49PT0yLHA9bD9bTWF0aC5jZWlsKGsuc2l6ZShlWzBdLmRpbXMpLzQpXTplWzBdLmRpbXMsbT1lWzFdLmRpbXMsdT1lLmxlbmd0aD4yP2VbMl06dm9pZCAwLGg9dT9sP1tNYXRoLmNlaWwoay5zaXplKHUuZGltcykvNCldOnUuZGltczp2b2lkIDAsXz1tLmxlbmd0aD09PTB8fG0ubGVuZ3RoPT09MSYmbVswXT09PTEseT1fPT09ITEmJm0ubGVuZ3RoPT09MSxnPW1lKGQpLHg9XyYmKCFsfHxnPT09NCksJD14P2c6MSx2PXgmJiFsP2c6MSxTPUUoXCJpbnB1dFwiLGw/MTI6bixwLmxlbmd0aCx2KSxUPUUoXCJzY2FsZVwiLGEsbS5sZW5ndGgpLEE9dT9FKFwiemVyb19wb2ludFwiLGw/MTI6bixoLmxlbmd0aCk6dm9pZCAwLEM9TShcIm91dHB1dFwiLGEsaS5sZW5ndGgsJCksUD1bUyxUXTtBJiZQLnB1c2goQSk7bGV0IEQ9W3AsbV07dSYmRC5wdXNoKGgpO2xldCBSPVt7dHlwZToxMixkYXRhOmQvJH0se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOnQuYmxvY2tTaXplfSwuLi5OKC4uLkQsaSldLEg9TD0+e2xldCByZT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJheGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJsb2NrX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICAgICAke0wucmVnaXN0ZXJVbmlmb3JtcyhyZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5QLEMpfVxuICAgICAgJHtMLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7TC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtDLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgLy8gU2V0IGlucHV0IHhcbiAgICAgICAgICAkeygoKT0+bD9gXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSAke1MuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4IC8gNFwiKX07XG4gICAgICAgICAgICBsZXQgeF92ZWMgPSAke28/XCJ1bnBhY2s0eEk4KGlucHV0KVwiOlwidW5wYWNrNHhVOChpbnB1dClcIn07XG4gICAgICAgICAgICBsZXQgeF92YWx1ZSA9ICR7JD09PTE/XCJ4X3ZlY1tnbG9iYWxfaWR4ICUgNF1cIjpcInhfdmVjXCJ9O2A6YGxldCB4X3ZhbHVlID0gJHtTLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07YCkoKX07XG5cbiAgICAgICAgICAvLyBTZXQgc2NhbGUgaW5wdXRcbiAgICAgICAgICAkeygoKT0+Xz9gbGV0IHNjYWxlX3ZhbHVlPSAke1QuZ2V0QnlPZmZzZXQoXCIwXCIpfWA6eT9gXG4gICAgICAgICAgICBsZXQgc2NhbGVfaW5kZXggPSAke0MuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtULmdldEJ5T2Zmc2V0KFwic2NhbGVfaW5kZXhcIil9O2A6YFxuICAgICAgICAgICAgdmFyIHNjYWxlX2luZGljZXM6ICR7VC50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAke1QuaW5kaWNlc0dldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9IC8gdW5pZm9ybXMuYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgICR7VC5pbmRpY2VzU2V0KFwic2NhbGVfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwiaW5kZXhcIil9O1xuICAgICAgICAgICAgbGV0IHNjYWxlX3ZhbHVlPSAke1QuZ2V0QnlJbmRpY2VzKFwic2NhbGVfaW5kaWNlc1wiKX07YCkoKX07XG5cbiAgICAgICAgICAvLyBTZXQgemVyby1wb2ludCBpbnB1dFxuICAgICAgICAgICR7KCgpPT5BP18/bD9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke0EuZ2V0QnlPZmZzZXQoXCIwXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAgJHtvP1widW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KVwiOlwidW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KVwifTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZT0gemVyb19wb2ludF92ZWNbMF1gOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeU9mZnNldChcIjBcIil9YDp5P2w/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gJHtDLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke0EuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X2luZGV4IC8gNFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X2luZGV4ICUgNF1gOmBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7Qy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9pbmRleFwiKX07YDpsP2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke1QuaW5kaWNlc1RvT2Zmc2V0KFwic2NhbGVfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke0EuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X29mZnNldCAvIDRcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X29mZnNldCAlIDRdO2A6YGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtBLmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O2A6YGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtsP28/XCJpMzJcIjpcInUzMlwiOlMudHlwZS52YWx1ZX0oMCk7YCkoKX07XG4gICAgICAvLyBDb21wdXRlIGFuZCB3cml0ZSBvdXRwdXRcbiAgICAgICR7Qy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixgJHtDLnR5cGUudmFsdWV9KHhfdmFsdWUgLSB6ZXJvX3BvaW50X3ZhbHVlKSAqIHNjYWxlX3ZhbHVlYCl9O1xuICAgICAgfWB9O3JldHVybntuYW1lOlwiRGVxdWFudGl6ZUxpbmVhclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6QT9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpILGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTphfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC8kLzY0KSx5OjEsejoxfSxwcm9ncmFtVW5pZm9ybXM6Un0pfX0sdmw9KGUsdCk9PntUaChlLmlucHV0cyx0KSxlLmNvbXB1dGUoSWgoZS5pbnB1dHMsdCkpfSwkbD1lPT5lZSh7YXhpczplLmF4aXMsYmxvY2tTaXplOmUuYmxvY2tTaXplfSl9KTt2YXIgQ2gsQWgsU2wsVGw9VSgoKT0+e1widXNlIHN0cmljdFwiO0xlKCk7SigpO2FlKCk7Q2g9KGUsdCxyKT0+e2xldCBuPWU9PT10LG89ZTx0JiZyPDAsaT1lPnQmJnI+MDtpZihufHxvfHxpKXRocm93IG5ldyBFcnJvcihcIlJhbmdlIHRoZXNlIGlucHV0cycgY29udGVudHMgYXJlIGludmFsaWQuXCIpfSxBaD0oZSx0LHIsbik9PntsZXQgbz1NYXRoLmFicyhNYXRoLmNlaWwoKHQtZSkvcikpLGk9W29dLGE9byxkPVt7dHlwZToxMixkYXRhOmF9LHt0eXBlOm4sZGF0YTplfSx7dHlwZTpuLGRhdGE6cn0sLi4uTihpKV0sbD1wPT57bGV0IG09TShcIm91dHB1dFwiLG4saS5sZW5ndGgpLHU9bS50eXBlLnZhbHVlLGg9W3tuYW1lOlwib3V0cHV0U2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdGFydFwiLHR5cGU6dX0se25hbWU6XCJkZWx0YVwiLHR5cGU6dX1dO3JldHVybmBcbiAgICAgICAgJHtwLnJlZ2lzdGVyVW5pZm9ybXMoaCkuZGVjbGFyZVZhcmlhYmxlcyhtKX1cbiAgICAgICAgJHtwLm1haW5TdGFydCgpfVxuICAgICAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHVuaWZvcm1zLnN0YXJ0ICsgJHt1fShnbG9iYWxfaWR4KSAqIHVuaWZvcm1zLmRlbHRhO1xuICAgICAgfWB9O3JldHVybntuYW1lOlwiUmFuZ2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHtufWB9LGdldFNoYWRlclNvdXJjZTpsLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTpufV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9LHByb2dyYW1Vbmlmb3JtczpkfSl9fSxTbD1lPT57bGV0IHQ9MCxyPTAsbj0wO2UuaW5wdXRzWzBdLmRhdGFUeXBlPT09Nj8odD1lLmlucHV0c1swXS5nZXRJbnQzMkFycmF5KClbMF0scj1lLmlucHV0c1sxXS5nZXRJbnQzMkFycmF5KClbMF0sbj1lLmlucHV0c1syXS5nZXRJbnQzMkFycmF5KClbMF0pOmUuaW5wdXRzWzBdLmRhdGFUeXBlPT09MSYmKHQ9ZS5pbnB1dHNbMF0uZ2V0RmxvYXQzMkFycmF5KClbMF0scj1lLmlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxuPWUuaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdKSxfZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJkNoKHQscixuKSxlLmNvbXB1dGUoQWgodCxyLG4sZS5pbnB1dHNbMF0uZGF0YVR5cGUpLHtpbnB1dHM6W119KX19KTt2YXIga2gsRWgsSWwsQ2wsQWw9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtraD0oZSx0LHIsbik9PntpZihlIT09XCJub25lXCImJm4hPT1cImkzMlwiJiZuIT09XCJ1MzJcIiYmbiE9PVwiZjMyXCIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke259IGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCByZWR1Y3Rpb24gJHtlfS5gKTtsZXQgbz1ge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgbG9vcCB7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWVGMzIgPWAsaT1gO1xuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gYml0Y2FzdDxpMzI+KG5ld1ZhbHVlRjMyKTtcbiAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBhdG9taWNDb21wYXJlRXhjaGFuZ2VXZWFrKCYke3R9LCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgcmVzLmV4Y2hhbmdlZCB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByZXMub2xkX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfWA7c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm5gJHt0fT0ke3J9O2A7Y2FzZVwiYWRkXCI6cmV0dXJuIG49PT1cImkzMlwifHxuPT09XCJ1MzJcIj9gYXRvbWljQWRkKCYke3R9LCBiaXRjYXN0PCR7bn0+KCR7cn0pKTtgOmBcbiAgICAgICAgICAgICAgJHtvfWJpdGNhc3Q8JHtufT4ob2xkVmFsdWUpICsgKCR7cn0pJHtpfWA7Y2FzZVwibWF4XCI6cmV0dXJuIG49PT1cImkzMlwifHxuPT09XCJ1MzJcIj9gYXRvbWljTWF4KCYke3R9LCBiaXRjYXN0PCR7bn0+KCR7cn0pKTtgOmBcbiAgICAgICAgICAgICAgICAke299bWF4KGJpdGNhc3Q8ZjMyPihvbGRWYWx1ZSksICgke3J9KSkke2l9YDtjYXNlXCJtaW5cIjpyZXR1cm4gbj09PVwiaTMyXCJ8fG49PT1cInUzMlwiP2BhdG9taWNNaW4oJiR7dH0sIGJpdGNhc3Q8JHtufT4oJHtyfSkpO2A6YCR7b31taW4oYml0Y2FzdDwke259PihvbGRWYWx1ZSksICgke3J9KSkke2l9YDtjYXNlXCJtdWxcIjpyZXR1cm5gJHtvfShiaXRjYXN0PCR7bn0+KG9sZFZhbHVlKSAqICgke3J9KSkke2l9YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgUmVkdWN0aW9uICR7ZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LEVoPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVsxXS5kaW1zLG89cixpPTEsYT1NYXRoLmNlaWwoay5zaXplKG4pL2kpLGQ9bltuLmxlbmd0aC0xXSxsPWsuc2l6ZUZyb21EaW1lbnNpb24ocixkKSxwPVt7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfSwuLi5OKGVbMV0uZGltcyxlWzJdLmRpbXMsbyldLG09dT0+e2xldCBoPUUoXCJpbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxfPUUoXCJ1cGRhdGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLGkpLHk9dC5yZWR1Y3Rpb24hPT1cIm5vbmVcIiYmdC5yZWR1Y3Rpb24hPT1cIlwiP3RzKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCk6TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgsaSk7cmV0dXJuYFxuICAgICAgJHt1LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwibGFzdF9pbmRleF9kaW1lbnNpb25cIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJudW1fdXBkYXRlc19lbGVtZW50c1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoaCxfLHkpfVxuICAgICAgJHt1Lm1haW5TdGFydCgpfVxuICAgICAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICB2YXIgZGF0YV9vZmZzZXQgPSAwdTtcbiAgbGV0IGluZGljZXNfc3RhcnQgPSB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbiAqIGdsb2JhbF9pZHg7XG4gIGxldCBpbmRpY2VzX2VuZCA9IGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbjtcbiAgZm9yICh2YXIgaSA9IGluZGljZXNfc3RhcnQ7IGkgPCBpbmRpY2VzX2VuZDsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gaTMyKGluZGljZXNbaV0ueCk7XG4gICAgJHtlWzBdLmRpbXMubGVuZ3RoPT09MT9gXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXM7XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZTtgOmBcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlc1tpIC0gaW5kaWNlc19zdGFydF07XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVtpIC0gaW5kaWNlc19zdGFydCArIHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uXTtgfVxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBpZiAoaW5kZXggPj0gaTMyKGRpbV92YWx1ZSkpIHtcbiAgICAgICAgaW5kZXggPSBpMzIoZGltX3ZhbHVlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbmRleCA8IC1pMzIoZGltX3ZhbHVlKSkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCArPSBpMzIoZGltX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGF0YV9vZmZzZXQgKz0gdTMyKCh1MzIoaW5kZXgpICogZWxlbWVudF9jb3VudF9kaW0pKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwdTsgaSA8IHVuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzOyBpKyspIHtcbiAgICBsZXQgdmFsdWUgPSB1cGRhdGVzW3VuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzICogZ2xvYmFsX2lkeCArIGldO1xuICAgICR7a2godC5yZWR1Y3Rpb24sXCJvdXRwdXRbZGF0YV9vZmZzZXQgKyBpXVwiLFwidmFsdWVcIix5LnR5cGUudmFsdWUpfVxuICB9XG5cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlNjYXR0ZXJORFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7dC5yZWR1Y3Rpb259YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTptfX0sSWw9ZT0+ZWUoe3JlZHVjdGlvbjplLnJlZHVjdGlvbn0pLENsPShlLHQpPT57ZS5jb21wdXRlKEVoKGUuaW5wdXRzLHQpLHtpbnB1dHM6W2UuaW5wdXRzWzFdLGUuaW5wdXRzWzJdXSxvdXRwdXRzOltdfSl9fSk7dmFyIFBoLHpoLE9oLGtsLERoLEJoLE1oLFJoLFVoLE5oLFZoLFdoLEVsLExoLEdoLEhoLEZoLHFoLFBsLHpsLE9sPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7UGg9KGUsdCk9PntpZihlLmV2ZXJ5KHI9PnI+MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmVcIil9KSksZS5sZW5ndGg+MCl7aWYodC5tb2RlPT09XCJsaW5lYXJcIil7aWYoIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09M3x8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVsxXT09PTF8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbM109PT0xfHxlLmxlbmd0aD09PTUmJmVbMF09PT0xJiZlWzFdPT09MSkpdGhyb3cgbmV3IEVycm9yKGBGb3IgbGluZWFyIG1vZGUsIFJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgdG8gYmUgMkQsIDNELCA0RCB3aXRoIGVpdGhlciB0d28gb3V0ZXJtb3N0IG9yIG9uZSBpbm5lcm1vc3QgYW5kXG4gICAgICAgICAgICBvbmUgb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxLCBvciA1RCB3aXRoIHR3byBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDFgKX1lbHNlIGlmKHQubW9kZT09PVwiY3ViaWNcIiYmIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgY3ViaWMgbW9kZVwiKX19LHpoPShlLHQscik9Pnt0LmV2ZXJ5KG89Pm8+PTAmJm88cnx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGF4ZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlIGFuZCBsZXNzIHRoYW4gcmFua1wiKX0pKTtsZXQgbj1uZXcgQXJyYXkocikuZmlsbCgxKTtyZXR1cm4gdC5mb3JFYWNoKChvLGkpPT5uW29dPWVbaV0pLG59LE9oPShlLHQscixuLG8saSk9PntsZXRbYSxkLGxdPXI+MTA/WzEsMiwzXTpbLTEsZS5sZW5ndGg+MT8xOi0xLC0xXSxwPWVbMF0uZGltcy5sZW5ndGg7aWYoYT4wJiZlLmxlbmd0aD5hJiZlW2FdLmRpbXMubGVuZ3RoPjApZVthXS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKG09PmkucHVzaChtKSk7ZWxzZSBpZih0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIil0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgUm9JIGlucHV0IHRvIGJlIHNwZWNpZmllZCB3aGVuIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGlzIHRmQ3JvcEFuZFJlc2l6ZVwiKTtpZihkPjAmJmUubGVuZ3RoPmQmJmVbZF0uZGltcy5sZW5ndGg9PT0xJiZlW2RdLmRpbXNbMF0+MCl7aWYoZVtkXS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKG09Pm4ucHVzaChtKSksbi5sZW5ndGghPT0wJiZuLmxlbmd0aCE9PXAmJnI+PTE4JiZuLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cFwiKTtQaChuLHQpLHQuYXhlcy5sZW5ndGg+MCYmemgobix0LmF4ZXMscCkuZm9yRWFjaCgobSx1KT0+blt1XT1tKX1pZihsPjAmJmUubGVuZ3RoPmwmJmVbbF0uZGltcy5sZW5ndGg9PT0xJiZlW2xdLmRpbXNbMF0+MCYmKGVbbF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobT0+by5wdXNoKE51bWJlcihtKSkpLG8ubGVuZ3RoIT09MCYmby5sZW5ndGghPT1wJiZyPj0xOCYmby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2l6ZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7aWYodC5heGVzLmxlbmd0aD4wKXtpZihuLmxlbmd0aCE9PTAmJm4ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNjYWxlc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO2lmKG8ubGVuZ3RoIT09MCYmby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2l6ZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIHJhbmsgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpfWlmKHR5cGVvZiBuPFwidVwiJiZ0eXBlb2YgbzxcInVcIiYmbi5sZW5ndGg+MCYmby5sZW5ndGg+cCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkXCIpfSxrbD0oZSx0LHIsbik9PmBcbiAgLy8gVGhlIHdob2xlIHBhcnQgYW5kIHRoZSBmcmFjdGlvbmFsIHBhcnQgYXJlIGNhbGN1bGF0ZWQgc2VwYXJhdGVseSBkdWUgdG8gaW5hY2N1cmFjeSBvZiBmbG9hdGluZ1xuICAvLyBwb2ludCBkaXZpc2lvbi4gQXMgYW4gZXhhbXBsZSwgZjMyKDIxKSAvIGYzMig3KSBtYXkgZXZhbHVhdGUgdG8gMi45OS4uLiBpbnN0ZWFkIG9mIDMsIGNhdXNpbmcgYW5cbiAgLy8gb2Zmc2V0LWJ5LW9uZSBlcnJvciBsYXRlciBpbiBmbG9vcigpLlxuICBsZXQgYmlnID0gKCR7ZX0pICogKCR7dH0pO1xuICBsZXQgd2hvbGUgPSAke259KGJpZyAvICgke3J9KSk7XG4gIGxldCBmcmFjdCA9ICR7bn0oYmlnICUgKCR7cn0pKSAvICR7bn0oJHtyfSk7XG4gIHJldHVybiB3aG9sZSArIGZyYWN0O1xuYCxEaD0oZSx0KT0+YGZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogdTMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogdTMyLFxuICAgICBsZW5ndGhPcmlnaW5hbDogdTMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gJHt0fSB7IGArKCgpPT57c3dpdGNoKGUpe2Nhc2VcImFzeW1tZXRyaWNcIjpyZXR1cm5gXG4gICAgICAgICAgaWYgKHhTY2FsZSA8IDEuMCB8fCBmbG9vcih4U2NhbGUpICE9IHhTY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuICR7dH0oeFJlc2l6ZWQpIC8gJHt0fSh4U2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAke2tsKFwieFJlc2l6ZWRcIixcImxlbmd0aE9yaWdpbmFsXCIsXCJsZW5ndGhSZXNpemVkXCIsdCl9XG4gICAgICAgICAgfVxuICAgICAgICBgO2Nhc2VcInB5dG9yY2hfaGFsZl9waXhlbFwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkgLSAwLjU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwidGZfaGFsZl9waXhlbF9mb3Jfbm5cIjpyZXR1cm5gcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSk7YDtjYXNlXCJhbGlnbl9jb3JuZXJzXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICR7a2woXCJ4UmVzaXplZFwiLFwibGVuZ3RoT3JpZ2luYWwgLSAxXCIsXCJsZW5ndGhSZXNpemVkIC0gMVwiLHQpfVxuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwidGZfY3JvcF9hbmRfcmVzaXplXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHt0fShyb2lTdGFydCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCR7dH0oeFJlc2l6ZWQpICogJHt0fShyb2lFbmQgLSByb2lTdGFydCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICR7dH0obGVuZ3RoUmVzaXplZCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqICR7dH0ocm9pU3RhcnQgKyByb2lFbmQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwiaGFsZl9waXhlbF9zeW1tZXRyaWNcIjpyZXR1cm5gY29uc3Qgb3V0cHV0V2lkdGggPSAke3R9eFNjYWxlICogJHt0fShsZW5ndGhSZXNpemVkKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSAke3R9KGxlbmd0aFJlc2l6ZWQpIC8gb3V0cHV0V2lkdGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAke3R9KGxlbmd0aE9yaWdpbmFsKSAvIDI7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBjZW50ZXIgKiAoMSAtIGFkanVzdG1lbnQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArICgoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpKSAtIDAuNTtgO2Nhc2VcImhhbGZfcGl4ZWxcIjpyZXR1cm5gcmV0dXJuICgoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpKSAtIDAuNTtgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBDb29yZGluYXRlIHRyYW5zZm9ybSBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsQmg9KGUsdCxyKT0+YGZuIGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbCh4T3JpZ2luYWw6ICR7cn0sIGlzRG93blNhbXBsZTogYm9vbCkgLT4gJHtyfSB7YCsoKCk9Pntzd2l0Y2goZSl7Y2FzZVwicm91bmRfcHJlZmVyX2NlaWxcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICB9XCI7Y2FzZVwiZmxvb3JcIjpyZXR1cm5cInJldHVybiBmbG9vcih4T3JpZ2luYWwpO1wiO2Nhc2VcImNlaWxcIjpyZXR1cm5cInJldHVybiBjZWlsKHhPcmlnaW5hbCk7XCI7Y2FzZVwicm91bmRfcHJlZmVyX2Zsb29yXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcInNpbXBsZVwiOmRlZmF1bHQ6aWYodDwxMSlyZXR1cm5cImlmIChpc0Rvd25TYW1wbGUpICAgICAgICAgICAgICAgICAgICAgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhPcmlnaW5hbDsgICAgICAgICAgICAgICAgICAgICB9XCI7dGhyb3cgbmV3IEVycm9yKGBOZWFyZXN0IG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIixNaD0oZSx0LHIpPT57bGV0IG49bmV3IEFycmF5KHIpLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShyKS5maWxsKDEpKSxvPWUubGVuZ3RoPT09MD9uOmUuc2xpY2UoKTtyZXR1cm4gdC5sZW5ndGg+MD8odC5mb3JFYWNoKChpLGEpPT57bltpXT1vW2FdLG5bYStyXT1vW3QubGVuZ3RoK2FdfSksbik6b30sUmg9KGUsdCxyLG4pPT57bGV0IG89W107aWYoci5sZW5ndGg+MClpZihuLmxlbmd0aD4wKXtpZihlLmZvckVhY2goaT0+by5wdXNoKGkpKSxNYXRoLm1heCguLi5uKT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzIGlzIG91dCBvZiBib3VuZFwiKTtuLmZvckVhY2goKGksYSk9Pm9baV09clthXSl9ZWxzZSByLmZvckVhY2goaT0+by5wdXNoKGkpKTtlbHNle2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgZWl0aGVyIHNjYWxlcyBvciBzaXplcy5cIik7bz1lLm1hcCgoaSxhKT0+TWF0aC5yb3VuZChpKnRbYV0pKX1yZXR1cm4gb30sVWg9KGUsdCxyKT0+e2xldCBuPSgoKT0+e3N3aXRjaChyLmtlZXBBc3BlY3RSYXRpb1BvbGljeSl7Y2FzZVwibm90X2xhcmdlclwiOnJldHVybiByLmF4ZXMubGVuZ3RoPjA/TWF0aC5taW4oLi4uci5heGVzLm1hcChpPT50W2ldKSxOdW1iZXIuTUFYX1ZBTFVFKTpNYXRoLm1pbiguLi50LE51bWJlci5NQVhfVkFMVUUpO2Nhc2VcIm5vdF9zbWFsbGVyXCI6cmV0dXJuIHIuYXhlcy5sZW5ndGg+MD9NYXRoLm1heCguLi5yLmF4ZXMubWFwKGk9PnRbaV0pLE51bWJlci5NSU5fVkFMVUUpOk1hdGgubWF4KC4uLnQsTnVtYmVyLk1JTl9WQUxVRSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEtlZXAgYXNwZWN0IHJhdGlvIHBvbGljeSAke3Iua2VlcEFzcGVjdFJhdGlvUG9saWN5fSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKTt0LmZpbGwoMSwwLHQubGVuZ3RoKTtsZXQgbz1lLnNsaWNlKCk7cmV0dXJuIHIuYXhlcy5sZW5ndGg+MD8oci5heGVzLmZvckVhY2goaT0+dFtpXT1uKSxyLmF4ZXMuZm9yRWFjaChpPT5vW2ldPU1hdGgucm91bmQoZVtpXSp0W2ldKSkpOih0LmZpbGwobiwwLHQubGVuZ3RoKSxvLmZvckVhY2goKGksYSk9Pm9bYV09TWF0aC5yb3VuZChpKnRbYV0pKSksb30sTmg9KGUsdCxyLG4sbyk9PmBcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGFycmF5PCR7ZS50eXBlLnZhbHVlfSwgJHtyLmxlbmd0aH0+IHtcbiAgICAgIHZhciBvcmlnaW5hbF9pbmRpY2VzOiBhcnJheTwke2UudHlwZS52YWx1ZX0sICR7ci5sZW5ndGh9PjtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7ZS5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgc2NhbGUgPSAke3EoXCJ1bmlmb3Jtcy5zY2FsZXNcIixcImlcIixuKX07XG4gICAgICAgIHZhciByb2lfbG93ID0gJHtxKFwidW5pZm9ybXMucm9pXCIsXCJpXCIsbyl9O1xuICAgICAgICB2YXIgcm9pX2hpID0gJHtxKFwidW5pZm9ybXMucm9pXCIsYGkgKyAke3QubGVuZ3RofWAsbyl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9ICR7ZS50eXBlLnZhbHVlfShvdXRwdXRfaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtxKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIix0Lmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7cShcInVuaWZvcm1zLm91dHB1dF9zaGFwZVwiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsIHNjYWxlLCBvdXRwdXRfc2hhcGVfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbF9pbmRpY2VzO1xuICAgIH1gLFZoPShlLHQscixuLG8saSxhKT0+YFxuICAgIGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtuLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRleDogdTMyO1xuICAgICAgICB2YXIgc2NhbGUgPSAke3EoXCJ1bmlmb3Jtcy5zY2FsZXNcIixcImlcIixvKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm9pX2xvdyA9ICR7cShcInVuaWZvcm1zLnJvaVwiLFwiaVwiLGkpfTtcbiAgICAgICAgICB2YXIgcm9pX2hpID0gJHtxKFwidW5pZm9ybXMucm9pXCIsYGkgKyAke3IubGVuZ3RofWAsaSl9O1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtxKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7cShcInVuaWZvcm1zLm91dHB1dF9zaGFwZVwiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgdmFyIG9yaWdpbmFsX2lkeCA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsIHNjYWxlLCBvdXRwdXRfc2hhcGVfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XG4gICAgICAgICAgaWYgKCEke2F9IHx8IChvcmlnaW5hbF9pZHggPj0gMCAmJiBvcmlnaW5hbF9pZHggPCAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSkpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+ICR7dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pIC0gMSkpIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlIDwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2luZGV4XCIpfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgfWAsV2g9KGUsdCk9PmBcbiAgICBmbiBjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSkgLT4gYm9vbCB7XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3QubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dF9pbmRleCA9ICR7ZS5pbmRpY2VzR2V0KFwiaW5wdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgIGlmIChpbnB1dF9pbmRleCA8IDAgfHwgaW5wdXRfaW5kZXggPj0gJHtxKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIix0Lmxlbmd0aCl9KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9YCxFbD0oZSx0LHIsbik9PmUucmFuaz5uP2BcbiAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIix0LFwiY2hhbm5lbFwiKX07XG4gICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIscixcImJhdGNoXCIpfTtcbmA6XCJcIixMaD0oZSx0LHIsbixvKT0+e2xldFthLGQsbCxwXT1yLmxlbmd0aD09PTI/Wy0xLDAsMSwtMV06WzAsMiwzLDFdLG09ZS50eXBlLnZhbHVlO3JldHVybmBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgcm93OiB1MzIsIGNvbDogdTMyKSAtPiAke219IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGQsYG1heCgwLCBtaW4ocm93LCAke3JbZF19IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsbCxgbWF4KDAsIG1pbihjb2wsICR7cltsXX0gLSAxKSlgKX07XG4gICAgICAke0VsKGUscCxhLDIpfVxuICAgICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICB9XG5cbiAgICBmbiBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke219IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgcm93OiR7bX0gPSBvcmlnaW5hbEluZGljZXNbJHtkfV07XG4gICAgICB2YXIgY29sOiR7bX0gPSBvcmlnaW5hbEluZGljZXNbJHtsfV07XG4gICAgICAke24/YGlmIChyb3cgPCAwIHx8IHJvdyA+ICgke3JbZF19IC0gMSkgfHwgY29sIDwgMCB8fCBjb2wgPiAoJHtyW2xdfSAtIDEpKSB7XG4gICAgICAgIHJldHVybiAke299O1xuICAgICAgfWA6XCJcIn07XG4gICAgICByb3cgPSBtYXgoMCwgbWluKHJvdywgJHtyW2RdfSAtIDEpKTtcbiAgICAgIGNvbCA9IG1heCgwLCBtaW4oY29sLCAke3JbbF19IC0gMSkpO1xuICAgICAgdmFyIHJvdzE6IHUzMiA9IHUzMihyb3cpO1xuICAgICAgdmFyIGNvbDE6IHUzMiA9IHUzMihjb2wpO1xuICAgICAgdmFyIHJvdzI6IHUzMiA9IHUzMihyb3cgKyAxKTtcbiAgICAgIHZhciBjb2wyOiB1MzIgPSB1MzIoY29sICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtyLmxlbmd0aD4yP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7cH1dKWA6XCIwXCJ9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtyLmxlbmd0aD4yP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7YX1dKWA6XCIwXCJ9O1xuICAgICAgdmFyIHgxMTogJHttfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDEpO1xuICAgICAgdmFyIHgxMjogJHttfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDIpO1xuICAgICAgdmFyIHgyMTogJHttfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDEpO1xuICAgICAgdmFyIHgyMjogJHttfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDIpO1xuICAgICAgdmFyIGR4MTogJHttfSA9IGFicyhyb3cgLSAke219KHJvdzEpKTtcbiAgICAgIHZhciBkeDI6ICR7bX0gPSBhYnMoJHttfShyb3cyKSAtIHJvdyk7XG4gICAgICB2YXIgZHkxOiAke219ID0gYWJzKGNvbCAtICR7bX0oY29sMSkpO1xuICAgICAgdmFyIGR5MjogJHttfSA9IGFicygke219KGNvbDIpIC0gY29sKTtcbiAgICAgIGlmIChyb3cxID09IHJvdzIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoY29sMSA9PSBjb2wyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTEgKiBkeDIgKiBkeTIgKyB4MTIgKiBkeDIgKiBkeTEgKyB4MjEgKiBkeDEgKiBkeTIgKyB4MjIgKiBkeDEgKiBkeTEpO1xuICAgIH1gfSxHaD0oZSx0LHIsbixvLGksYSxkLGwscCk9PntsZXQgbT1yLmxlbmd0aD09PTIsdT0hMCxbaCxfXT1tP1swLDFdOnU/WzIsM106WzEsMl0seT1lLnR5cGUudmFsdWUsZz14PT57bGV0ICQ9eD09PWg/XCJyb3dcIjpcImNvbFwiO3JldHVybmBcbiAgICAgIGZuICR7JH1DdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30sIG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHt5fSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke3QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIseCl9O1xuICAgICAgICB2YXIgb3JpZ2luYWxJZHg6ICR7eX0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCAke29beF19LFxuICAgICAgICAke25beF19LCAke3JbeF19LCAke2lbeF19LCAke2lbeF19ICsgJHtyLmxlbmd0aH0pO1xuICAgICAgICB2YXIgZnJhY3RPcmlnaW5hbElkeDogJHt5fSA9IG9yaWdpbmFsSWR4IC0gZmxvb3Iob3JpZ2luYWxJZHgpO1xuICAgICAgICB2YXIgY29lZnMgPSBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhmcmFjdE9yaWdpbmFsSWR4KTtcblxuICAgICAgICBpZiAoJHtkfSAmJiAob3JpZ2luYWxJZHggPCAwIHx8IG9yaWdpbmFsSWR4ID4gKCR7clt4XX0gLSAxKSkpIHtcbiAgICAgICAgICByZXR1cm4gJHtsfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YTogYXJyYXk8JHt5fSwgND4gPSBhcnJheTwke3l9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICBmb3IgKHZhciBpOiBpMzIgPSAtMTsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHZhciAkeyR9OiAke3l9ID0gb3JpZ2luYWxJZHggKyAke3l9KGkpO1xuICAgICAgICAgIGlmICgkeyR9IDwgMCB8fCAkeyR9ID49ICR7clt4XX0pIHtcbiAgICAgICAgICAgICR7KCgpPT5wP2Bjb2Vmc1tpICsgMV0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtgOmQ/YHJldHVybiAke2x9O2A6YCR7JH0gPSBtYXgoMCwgbWluKCR7JH0sICR7clt4XX0gLSAxKSk7YCkoKX07XG4gICAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlc19jb3B5OiAke2UudHlwZS5pbmRpY2VzfSA9IGlucHV0X2luZGljZXM7XG4gICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzX2NvcHlcIix4LGB1MzIoJHskfSlgKX07XG4gICAgICAgICAgZGF0YVtpICsgMV0gPSAke3g9PT1oP2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc19jb3B5XCIpOlwicm93Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXNfY29weSwgb3V0cHV0X2luZGljZXMpXCJ9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdWJpY0ludGVycG9sYXRpb24xRChkYXRhLCBjb2Vmcyk7XG4gICAgICB9YH07cmV0dXJuYFxuICAgICR7ZyhoKX07XG4gICAgJHtnKF8pfTtcbiAgZm4gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoczogJHt5fSkgLT4gYXJyYXk8JHt5fSwgND4ge1xuICAgIHZhciBhYnNTID0gYWJzKHMpO1xuICAgIHZhciBjb2VmZnM6IGFycmF5PCR7eX0sIDQ+ID0gYXJyYXk8JHt5fSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICB2YXIgb25lTWludXNBYnNTOiAke3l9ID0gMS4wIC0gYWJzUztcbiAgICB2YXIgdHdvTWludXNBYnNTOiAke3l9ID0gMi4wIC0gYWJzUztcbiAgICB2YXIgb25lUGx1c0Fic1M6ICR7eX0gPSAxLjAgKyBhYnNTO1xuICAgIGNvZWZmc1swXSA9ICgoJHthfSAqIG9uZVBsdXNBYnNTIC0gNSAqICR7YX0pICogb25lUGx1c0Fic1MgKyA4ICogJHthfSkgKiBvbmVQbHVzQWJzUyAtIDQgKiAke2F9O1xuICAgIGNvZWZmc1sxXSA9ICgoJHthfSArIDIpICogYWJzUyAtICgke2F9ICsgMykpICogYWJzUyAqIGFic1MgKyAxO1xuICAgIGNvZWZmc1syXSA9ICgoJHthfSArIDIpICogb25lTWludXNBYnNTIC0gKCR7YX0gKyAzKSkgKiBvbmVNaW51c0Fic1MgKiBvbmVNaW51c0Fic1MgKyAxO1xuICAgIGNvZWZmc1szXSA9ICgoJHthfSAqIHR3b01pbnVzQWJzUyAtIDUgKiAke2F9KSAqIHR3b01pbnVzQWJzUyArIDggKiAke2F9KSAqIHR3b01pbnVzQWJzUyAtIDQgKiAke2F9O1xuICAgIHJldHVybiBjb2VmZnM7XG4gIH1cblxuICBmbiBjdWJpY0ludGVycG9sYXRpb24xRCh4OiBhcnJheTwke3l9LCA0PiwgY29lZnM6IGFycmF5PCR7eX0sIDQ+KSAtPiAke3l9IHtcbiAgICB2YXIgY29lZnNTdW06ICR7eX0gPSBjb2Vmc1swXSArIGNvZWZzWzFdICsgY29lZnNbMl0gKyBjb2Vmc1szXTtcbiAgICByZXR1cm4gKHhbMF0gKiBjb2Vmc1swXSArIHhbMV0gKiBjb2Vmc1sxXSsgeFsyXSAqIGNvZWZzWzJdKyB4WzNdICogY29lZnNbM10pIC8gY29lZnNTdW07XG4gIH1cblxuICBmbiBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7eX0ge1xuICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgIHJldHVybiBjb2xDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlcywgb3V0cHV0X2luZGljZXMpO1xuICB9XG4gICAgYH0sSGg9KGUsdCxyLG4sbyk9PntsZXRbYSxkLGwscCxtXT1yLmxlbmd0aD09PTM/Wy0xLDAsMSwyLC0xXTpbMCwyLDMsNCwxXSx1PWUudHlwZS52YWx1ZTtyZXR1cm5gXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGRlcHRoOnUzMiwgaGVpZ2h0OiB1MzIsIHdpZHRoOiB1MzIpIC0+ICR7dX0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCxgbWF4KDAsIG1pbihkZXB0aCwgJHtyW2RdfSAtIDEpKWApfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGwsYG1heCgwLCBtaW4oaGVpZ2h0LCAke3JbbF19IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIscCxgbWF4KDAsIG1pbih3aWR0aCwgJHtyW3BdfSAtIDEpKWApfTtcbiAgICAgICR7RWwoZSxtLGEsMyl9XG4gICAgICByZXR1cm4gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgIH1cblxuICAgIGZuIHRyaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke3V9IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgZGVwdGg6JHt1fSA9IG9yaWdpbmFsSW5kaWNlc1ske2R9XTtcbiAgICAgIHZhciBoZWlnaHQ6JHt1fSA9IG9yaWdpbmFsSW5kaWNlc1ske2x9XTtcbiAgICAgIHZhciB3aWR0aDoke3V9ID0gb3JpZ2luYWxJbmRpY2VzWyR7cH1dO1xuICAgICAgJHtuP2BpZiAoZGVwdGggPCAwIHx8IGRlcHRoID4gKCR7cltkXX0gLSAxKSB8fCBoZWlnaHQgPCAwIHx8IGhlaWdodCA+ICgke3JbbF19IC0gMSkgfHwgd2lkdGggPCAwIHx8ICh3aWR0aCA+ICR7cltwXX0gLSAxKSkge1xuICAgICAgcmV0dXJuICR7b307XG4gICAgICAgIH1gOlwiXCJ9O1xuXG4gICAgZGVwdGggPSBtYXgoMCwgbWluKGRlcHRoLCAke3JbZF19IC0gMSkpO1xuICAgICAgaGVpZ2h0ID0gbWF4KDAsIG1pbihoZWlnaHQsICR7cltsXX0gLSAxKSk7XG4gICAgICB3aWR0aCA9IG1heCgwLCBtaW4od2lkdGgsICR7cltwXX0gLSAxKSk7XG4gICAgICB2YXIgZGVwdGgxOiB1MzIgPSB1MzIoZGVwdGgpO1xuICAgICAgdmFyIGhlaWdodDE6IHUzMiA9IHUzMihoZWlnaHQpO1xuICAgICAgdmFyIHdpZHRoMTogdTMyID0gdTMyKHdpZHRoKTtcbiAgICAgIHZhciBkZXB0aDI6IHUzMiA9IHUzMihkZXB0aCArIDEpO1xuICAgICAgdmFyIGhlaWdodDI6IHUzMiA9IHUzMihoZWlnaHQgKyAxKTtcbiAgICAgIHZhciB3aWR0aDI6IHUzMiA9IHUzMih3aWR0aCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7ci5sZW5ndGg+Mz9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske219XSlgOlwiMFwifTtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7ci5sZW5ndGg+Mz9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske2F9XSlgOlwiMFwifTtcblxuICAgICAgdmFyIHgxMTE6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMSk7XG4gICAgICB2YXIgeDExMjogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MTIxOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDEpO1xuICAgICAgdmFyIHgxMjI6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMik7XG4gICAgICB2YXIgeDIxMTogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjEyOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgyMjE6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMSk7XG4gICAgICB2YXIgeDIyMjogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciBkeDE6ICR7dX0gPSBhYnMoZGVwdGggLSAke3V9KGRlcHRoMSkpO1xuICAgICAgdmFyIGR4MjogJHt1fSA9IGFicygke3V9KGRlcHRoMikgLSBkZXB0aCk7XG4gICAgICB2YXIgZHkxOiAke3V9ID0gYWJzKGhlaWdodCAtICR7dX0oaGVpZ2h0MSkpO1xuICAgICAgdmFyIGR5MjogJHt1fSA9IGFicygke3V9KGhlaWdodDIpIC0gaGVpZ2h0KTtcbiAgICAgIHZhciBkejE6ICR7dX0gPSBhYnMod2lkdGggLSAke3V9KHdpZHRoMSkpO1xuICAgICAgdmFyIGR6MjogJHt1fSA9IGFicygke3V9KHdpZHRoMikgLSB3aWR0aCk7XG4gICAgICBpZiAoZGVwdGgxID09IGRlcHRoMikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHQxID09IGhlaWdodDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGgxID09IHdpZHRoMikge1xuICAgICAgICBkejEgPSAwLjU7XG4gICAgICAgIGR6MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExMSAqIGR4MiAqIGR5MiAqIGR6MiArIHgxMTIgKiBkeDIgKiBkeTIgKiBkejEgKyB4MTIxICogZHgyICogZHkxICpkejIgKyB4MTIyICogZHgyICogZHkxICogZHoxICtcbiAgICAgICAgICAgICAgeDIxMSAqIGR4MSAqIGR5MiAqIGR6MiArIHgyMTIgKiBkeDEgKiBkeTIgKiBkejEgKyB4MjIxICogZHgxICogZHkxICpkejIgKyB4MjIyICogZHgxICogZHkxICogZHoxKTtcbiAgICB9YH0sRmg9KGUsdCxyLG4sbyxpKT0+e2xldCBhPWUuZGltcyxkPU1oKGksdC5heGVzLGEubGVuZ3RoKSxsPVJoKGEsbixvLHQuYXhlcykscD1uLnNsaWNlKCk7bi5sZW5ndGg9PT0wJiYocD1hLm1hcCgodixTKT0+dj09PTA/MTpsW1NdL3YpLHQua2VlcEFzcGVjdFJhdGlvUG9saWN5IT09XCJzdHJldGNoXCImJihsPVVoKGEscCx0KSkpO2xldCBtPU0oXCJvdXRwdXRcIixlLmRhdGFUeXBlLGwubGVuZ3RoKSx1PUUoXCJpbnB1dFwiLGUuZGF0YVR5cGUsYS5sZW5ndGgpLGg9ay5zaXplKGwpLF89YS5sZW5ndGg9PT1sLmxlbmd0aCYmYS5ldmVyeSgodixTKT0+dj09PWxbU10pLHk9dC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIsZz10LmV4dHJhcG9sYXRpb25WYWx1ZSx4PXUudHlwZS52YWx1ZSwkPXY9PmBcbiAgICAgICR7Xz9cIlwiOmBcbiAgICAgICR7RGgodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSx4KX07XG4gICAgICAkeygoKT0+e3N3aXRjaCh0Lm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gXG4gICAgICAgICAgICAgICR7V2godSxhKX07XG4gICAgICAgICAgICAgICR7QmgodC5uZWFyZXN0TW9kZSxyLHgpfTtcbiAgICAgICAgICAgICAgJHtWaCh1LG0sYSxsLHAubGVuZ3RoLGQubGVuZ3RoLHkpfTtcbiAgICAgICAgICAgICAgYDtjYXNlXCJsaW5lYXJcIjpyZXR1cm5gXG4gICAgICAgICAgICAgICR7TmgobSxhLGwscC5sZW5ndGgsZC5sZW5ndGgpfTtcbiAgICAgICAgICAgICAgJHsoKCk9PntpZihhLmxlbmd0aD09PTJ8fGEubGVuZ3RoPT09NClyZXR1cm5gJHtMaCh1LG0sYSx5LGcpfWA7aWYoYS5sZW5ndGg9PT0zfHxhLmxlbmd0aD09PTUpcmV0dXJuYCR7SGgodSxtLGEseSxnKX1gO3Rocm93IEVycm9yKFwiTGluZWFyIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIsIDMsIDQgYW5kIDUgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS5cIil9KSgpfTtcbiAgICAgICAgICAgIGA7Y2FzZVwiY3ViaWNcIjpyZXR1cm5gXG4gICAgICAgICAgICAkeygoKT0+e2lmKGEubGVuZ3RoPT09Mnx8YS5sZW5ndGg9PT00KXJldHVybmAke0doKHUsbSxhLGwscCxkLHQuY3ViaWNDb2VmZkEseSx0LmV4dHJhcG9sYXRpb25WYWx1ZSx0LmV4Y2x1ZGVPdXRzaWRlKX1gO3Rocm93IEVycm9yKFwiQ3ViaWMgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiBhbmQgNCBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLlwiKX0pKCl9O1xuICAgICAgICAgICAgYDtkZWZhdWx0OnRocm93IEVycm9yKFwiSW52YWxpZCByZXNpemUgbW9kZVwiKX19KSgpfTtcbiAgICAgIGB9XG4gICAgICAke3YucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzY2FsZXNcIixcImYzMlwiLHAubGVuZ3RoKS5yZWdpc3RlclVuaWZvcm0oXCJyb2lcIixcImYzMlwiLGQubGVuZ3RoKS5kZWNsYXJlVmFyaWFibGVzKHUsbSl9XG4gICAgICAke3YubWFpblN0YXJ0KCl9XG4gICAgICAgICR7di5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICR7Xz9cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1wiOmBcbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHttLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHt1LnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzKSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt1LmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3QuZXh0cmFwb2xhdGlvblZhbHVlfTtcbiAgICAgICAgICAgICAgICB9YDtjYXNlXCJsaW5lYXJcIjpyZXR1cm5gb3V0cHV0W2dsb2JhbF9pZHhdID0gJHthLmxlbmd0aD09PTJ8fGEubGVuZ3RoPT09ND9cImJpbGluZWFySW50ZXJwb2xhdGlvblwiOlwidHJpbGluZWFySW50ZXJwb2xhdGlvblwifShvdXRwdXRfaW5kaWNlcyk7YDtjYXNlXCJjdWJpY1wiOnJldHVyblwib3V0cHV0W2dsb2JhbF9pZHhdID0gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXMpO1wiO2RlZmF1bHQ6dGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2l6ZSBtb2RlOiAke3QubW9kZX1gKX19KSgpfTtcbmB9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlJlc2l6ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9fCR7cn18JHtwLmxlbmd0aD4wP3QubW9kZT09PVwiY3ViaWNcIj9wOnAubGVuZ3RoOlwiXCJ9fCR7by5sZW5ndGg+MD9vOlwiXCJ9fCR7ZC5sZW5ndGg+MD9kOlwiXCJ9fCR7X318JHt0Lm1vZGU9PT1cIm5lYXJlc3RcIj9hLmxlbmd0aDphfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOiQsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChoLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmh9LHt0eXBlOjEsZGF0YTpwfSx7dHlwZToxLGRhdGE6ZH0sLi4uTihhLGwpXX0pfX0scWg9ZT0+e2xldCB0PWUuY3VzdG9tRGF0YUJ1ZmZlcjtyZXR1cm4gbmV3IFVpbnQzMkFycmF5KHQsdC5ieXRlT2Zmc2V0LDEpWzBdfSxQbD0oZSx0KT0+e2xldCByPVtdLG49W10sbz1bXSxpPXFoKGUpO2lmKHQuYW50aWFsaWFzIT09MCl0aHJvdyBFcnJvcihcIk9ubHkgZGVmYXVsdCB2YWx1ZSAoMCkgZm9yIEFudGlhbGlhcyBhdHRyaWJ1dGUgaXMgc3VwcG9ydGVkXCIpO09oKGUuaW5wdXRzLHQsaSxyLG4sbyksZS5jb21wdXRlKEZoKGUuaW5wdXRzWzBdLHQsaSxyLG4sbykse2lucHV0czpbMF19KX0semw9ZT0+e2xldCB0PWUuYW50aWFsaWFzLHI9ZS5heGVzLG49ZS5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSxvPWUuY3ViaWNDb2VmZkEsaT1lLmV4Y2x1ZGVPdXRzaWRlIT09MCxhPWUuZXh0cmFwb2xhdGlvblZhbHVlLGQ9ZS5rZWVwQXNwZWN0UmF0aW9Qb2xpY3ksbD1lLm1vZGUscD1lLm5lYXJlc3RNb2RlPT09XCJcIj9cInNpbXBsZVwiOmUubmVhcmVzdE1vZGU7cmV0dXJuIGVlKHthbnRpYWxpYXM6dCxheGVzOnIsY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6bixjdWJpY0NvZWZmQTpvLGV4Y2x1ZGVPdXRzaWRlOmksZXh0cmFwb2xhdGlvblZhbHVlOmEsa2VlcEFzcGVjdFJhdGlvUG9saWN5OmQsbW9kZTpsLG5lYXJlc3RNb2RlOnB9KX19KTt2YXIgS2gsamgsRGwsQmw9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtLaD0oZSx0KT0+e2xldFtyLG4sbyxpXT1lLHtudW1IZWFkczphLHJvdGFyeUVtYmVkZGluZ0RpbTpkfT10O2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICd4JyBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zLCBnb3QgJHtyLmRpbXMubGVuZ3RofWApO2lmKCFrLmFyZUVxdWFsKG4uZGltcyxbXSkmJiFrLmFyZUVxdWFsKG4uZGltcyxbMV0pJiZuLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMCwgMSwgb3IgMiBkaW1lbnNpb25zLCBnb3QgJHtuLmRpbXMubGVuZ3RofWApO2lmKG8uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke28uZGltcy5sZW5ndGh9YCk7aWYoaS5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnc2luX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7aS5kaW1zLmxlbmd0aH1gKTtpZighay5hcmVFcXVhbChvLmRpbXMsaS5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dHMgJ2Nvc19jYWNoZScgYW5kICdzaW5fY2FjaGUnIGFyZSBleHBlY3RlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpO2lmKGQ+MCYmYT09PTApdGhyb3cgbmV3IEVycm9yKFwibnVtX2hlYWRzIG11c3QgYmUgcHJvdmlkZWQgaWYgcm90YXJ5X2VtYmVkZGluZ19kaW0gaXMgc3BlY2lmaWVkXCIpO2xldCBsPXIuZGltc1swXSxwPXIuZGltc1tyLmRpbXMubGVuZ3RoLTJdLG09by5kaW1zWzBdLHU9ay5zaXplRnJvbURpbWVuc2lvbihyLmRpbXMsMSkvcCxoPWQ9PT0wP28uZGltc1sxXSoyOnUvYTtpZihkPmgpdGhyb3cgbmV3IEVycm9yKFwicm90YXJ5X2VtYmVkZGluZ19kaW0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gaGVhZF9zaXplXCIpO2lmKG4uZGltcy5sZW5ndGg9PT0yKXtpZihsIT09bi5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDAgc2hvdWxkIGJlIG9mIHNpemUgYmF0Y2hfc2l6ZSwgZ290ICR7bi5kaW1zWzBdfWApO2lmKHAhPT1uLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMSBzaG91bGQgYmUgb2Ygc2l6ZSBzZXF1ZW5jZV9sZW5ndGgsIGdvdCAke24uZGltc1sxXX1gKX1pZihoLzIhPT1vLmRpbXNbMV0mJmQvMiE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdjb3NfY2FjaGUnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBzYW1lIGFzIGhlYWRfc2l6ZSAvIDIgb3Igcm90YXJ5X2VtYmVkZGluZ19kaW0gLyAyLCBnb3QgJHtvLmRpbXNbMV19YCk7aWYocD5tKXRocm93IG5ldyBFcnJvcihcIlVwZGF0aW5nIGNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGluIFJvdGFyeUVtYmVkZGluZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZFwiKX0samg9KGUsdCk9PntsZXR7aW50ZXJsZWF2ZWQ6cixudW1IZWFkczpuLHJvdGFyeUVtYmVkZGluZ0RpbTpvLHNjYWxlOml9PXQsYT1lWzBdLmRpbXNbMF0sZD1rLnNpemVGcm9tRGltZW5zaW9uKGVbMF0uZGltcywxKSxsPWVbMF0uZGltc1tlWzBdLmRpbXMubGVuZ3RoLTJdLHA9ZC9sLG09ZVsyXS5kaW1zWzFdLHU9bz09PTA/bSoyOnAvbixoPW5ldyBBcnJheShhLGwscC91LHUtbSksXz1rLmNvbXB1dGVTdHJpZGVzKGgpLHk9W3t0eXBlOjEsZGF0YTppfSx7dHlwZToxMixkYXRhOmh9LHt0eXBlOjEyLGRhdGE6X30sLi4uZVswXS5kaW1zLmxlbmd0aD09PTM/bmV3IEFycmF5KHt0eXBlOjEyLGRhdGE6W2QscCx1LDFdfSk6W10sLi4uZVswXS5kaW1zLmxlbmd0aD09PTQ/bmV3IEFycmF5KHt0eXBlOjEyLGRhdGE6W2QsdSxsKnUsMV19KTpbXSwuLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMsZVsyXS5kaW1zLGVbM10uZGltcyxlWzBdLmRpbXMpXSxnPXg9PntsZXQgJD1FKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLHY9RShcInBvc2l0aW9uX2lkc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksUz1FKFwiY29zX2NhY2hlXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxUPUUoXCJzaW5fY2FjaGVcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcy5sZW5ndGgpLEE9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCk7cmV0dXJuIHgucmVnaXN0ZXJVbmlmb3Jtcyhbe25hbWU6XCJzY2FsZVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJnbG9iYWxfc2hhcGVcIix0eXBlOlwidTMyXCIsbGVuZ3RoOmgubGVuZ3RofSx7bmFtZTpcImdsb2JhbF9zdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpfLmxlbmd0aH0se25hbWU6XCJpbnB1dF9vdXRwdXRfc3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Xy5sZW5ndGh9XSksYFxuICAgICAgICAke3guZGVjbGFyZVZhcmlhYmxlcygkLHYsUyxULEEpfVxuXG4gICAgICAgICR7eC5tYWluU3RhcnQoRXQpfVxuICAgICAgICAgIGxldCBoYWxmX3JvdGFyeV9lbWJfZGltID0gdW5pZm9ybXMuJHtTLm5hbWV9X3NoYXBlWzFdO1xuICAgICAgICAgIGxldCBic25oID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLmdsb2JhbF9zdHJpZGVzICUgdW5pZm9ybXMuZ2xvYmFsX3NoYXBlO1xuICAgICAgICAgIGxldCBzaXplID0gdW5pZm9ybXMuZ2xvYmFsX3NoYXBlWzBdICogdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXNbMF07XG4gICAgICAgICAgJHt4Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJzaXplXCIpfVxuXG4gICAgICAgICAgaWYgKGJzbmhbM10gPCBoYWxmX3JvdGFyeV9lbWJfZGltKSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25faWRzX2lkeCA9XG4gICAgICAgICAgICAgICAgJHt2LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwiYnNuaC54eVwiLE0oXCJcIix2LnR5cGUudGVuc29yLDIpKX07XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25faWQgPVxuICAgICAgICAgICAgICAgIHUzMigke3YuZ2V0QnlPZmZzZXQoXCJwb3NpdGlvbl9pZHNfaWR4XCIpfSkgKyBzZWxlY3QoMCwgYnNuaFsxXSwgcG9zaXRpb25faWRzX2lkeCA9PSAwKTtcbiAgICAgICAgICAgIGxldCBpID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIHNlbGVjdCgwLCBic25oWzNdLCAke3J9KTtcbiAgICAgICAgICAgIGxldCBqID0gaSArIHNlbGVjdChoYWxmX3JvdGFyeV9lbWJfZGltLCAxLCAke3J9KTtcbiAgICAgICAgICAgIGxldCByZSA9ICR7JC5nZXRCeU9mZnNldChcImlcIil9ICogJHtTLmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfSAtXG4gICAgICAgICAgICAgICAgJHskLmdldEJ5T2Zmc2V0KFwialwiKX0gKiAke1QuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9O1xuICAgICAgICAgICAgJHtBLnNldEJ5T2Zmc2V0KFwiaVwiLFwicmVcIil9XG4gICAgICAgICAgICBsZXQgaW0gPSAkeyQuZ2V0QnlPZmZzZXQoXCJpXCIpfSAqICR7VC5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX0gK1xuICAgICAgICAgICAgICAgICR7JC5nZXRCeU9mZnNldChcImpcIil9ICogJHtTLmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfTtcbiAgICAgICAgICAgICR7QS5zZXRCeU9mZnNldChcImpcIixcImltXCIpfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgayA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBoYWxmX3JvdGFyeV9lbWJfZGltO1xuICAgICAgICAgICAgJHtBLnNldEJ5T2Zmc2V0KFwia1wiLCQuZ2V0QnlPZmZzZXQoXCJrXCIpKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlJvdGFyeUVtYmVkZGluZ1wiLHNoYWRlckNhY2hlOntoaW50OmVlKHtpbnRlcmxlYXZlZDpyfSkuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOmcsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczplWzBdLmRpbXMsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGsuc2l6ZShoKS9FdCl9LHByb2dyYW1Vbmlmb3Jtczp5fSl9fSxEbD0oZSx0KT0+e0toKGUuaW5wdXRzLHQpLGUuY29tcHV0ZShqaChlLmlucHV0cyx0KSl9fSk7dmFyIFloLFpoLE1sLFJsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO1loPWU9PntpZighZXx8ZS5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuXCIpO2xldCB0PWVbMF0scj1lWzFdLG49ZVsyXTtpZih0LmRhdGFUeXBlIT09ci5kYXRhVHlwZXx8dC5kYXRhVHlwZSE9PW4uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlXCIpO2lmKHQuZGltcy5sZW5ndGghPT0zJiZ0LmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIDJEIG9yIDNEXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgYmUgMkQgb3IgM0RcIik7bGV0IG89dC5kaW1zW3QuZGltcy5sZW5ndGgtMV0saT10LmRpbXNbdC5kaW1zLmxlbmd0aC0yXTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMl0hPT1pKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dFwiKTtpZihuLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGJlIDFEXCIpO2lmKG4uZGltc1tuLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoZS5sZW5ndGg+Myl7bGV0IGE9ZVszXTtpZihhLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgYmUgMURcIik7aWYoYS5kaW1zW2EuZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfWlmKGUubGVuZ3RoPjQpe2xldCBhPWVbNF07aWYoYS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGJlIDFEXCIpO2lmKGEuZGltc1thLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX19LFpoPShlLHQscixuKT0+e2xldCBvPXQuc2ltcGxpZmllZCxpPWVbMF0uZGltcyxhPWsuc2l6ZShpKSxkPWksbD1hLHA9aS5zbGljZSgtMSlbMF0sbT1uP2kuc2xpY2UoMCwtMSkuY29uY2F0KDEpOltdLHU9IW8mJmUubGVuZ3RoPjMsaD1lLmxlbmd0aD40LF89biYmcj4xLHk9biYmcj4yLGc9cj4zLHg9NjQsJD1tZShwKSx2PVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6JH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6dC5lcHNpbG9ufV0sUz1BPT57bGV0IEM9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiY29tcG9uZW50c1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV0sUD1bRShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcywkKSxFKFwic2tpcFwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLCQpLEUoXCJnYW1tYVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLCQpXTt1JiZQLnB1c2goRShcImJldGFcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcywkKSksaCYmUC5wdXNoKEUoXCJiaWFzXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsJCkpLFAucHVzaChNKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLCQpKSxfJiZQLnB1c2goTShcIm1lYW5fb3V0cHV0XCIsMSxtKSkseSYmUC5wdXNoKE0oXCJpbnZfc3RkX291dHB1dFwiLDEsbSkpLGcmJlAucHVzaChNKFwiaW5wdXRfc2tpcF9iaWFzX3N1bVwiLGVbMF0uZGF0YVR5cGUsZCwkKSk7bGV0IEQ9eWUoZVswXS5kYXRhVHlwZSksUj15ZSgxLCQpO3JldHVybmBcblxuICAgICAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoQykuZGVjbGFyZVZhcmlhYmxlcyguLi5QKX1cbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zaGFyZWQgOiBhcnJheTwke1J9LCAke3h9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7Un0sICR7eH0+O1xuXG4gICAgICAke0EubWFpblN0YXJ0KFt4LDEsMV0pfVxuICAgICAgICBsZXQgaXggPSBsb2NhbF9pZC54O1xuICAgICAgICBsZXQgaXkgPSBnbG9iYWxfaWQueCAvICR7eH07XG5cbiAgICAgICAgbGV0IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ6IHUzMiA9IHVuaWZvcm1zLmhpZGRlbl9zaXplIC8gdW5pZm9ybXMuY29tcG9uZW50cztcbiAgICAgICAgdmFyIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLyAke3h9O1xuICAgICAgICBsZXQgb2Zmc2V0ID0gaXggKiBzdHJpZGUgKyBpeSAqIGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgICAgIGxldCBvZmZzZXQxZCA9IHN0cmlkZSAqIGl4O1xuICAgICAgICBpZiAoaXggPT0gJHt4LTF9KSB7XG4gICAgICAgICAgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAtIHN0cmlkZSAqIGl4O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIGxldCBza2lwX3ZhbHVlID0gc2tpcFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgYmlhc192YWx1ZSA9ICR7aD9cImJpYXNbb2Zmc2V0MWQgKyBpXVwiOkQrXCIoMC4wKVwifTtcbiAgICAgICAgICBsZXQgaW5wdXRfdmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XG4gICAgICAgICAgJHtnP1wiaW5wdXRfc2tpcF9iaWFzX3N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlO1wiOlwiXCJ9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7UHQoRCwkLFwidmFsdWVcIil9O1xuICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZTtcbiAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZSAqIGYzMl92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZV9zaXplIDogdTMyID0gJHt4fTtcbiAgICAgICAgZm9yICh2YXIgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMTsgIGN1cnJfc2l6ZSA+IDA7IGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2Vfc2l6ZSA9IGN1cnJfc2l6ZSArIChyZWR1Y2Vfc2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChpeCA8IGN1cnJfc2l6ZSkge1xuICAgICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gc3VtX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcbiAgICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gc3VtX3NxdWFyZWRfc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3VtID0gc3VtX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IHNxdWFyZV9zdW0gPSBzdW1fc3F1YXJlZF9zaGFyZWRbMF07XG4gICAgICAgIGxldCBtZWFuID0gJHtxZShcInN1bVwiLCQpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSk7XG4gICAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7cWUoXCJzcXVhcmVfc3VtXCIsJCl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKSAke28/XCJcIjpcIi0gbWVhbiAqIG1lYW5cIn0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcbiAgICAgICAgJHtfP1wibWVhbl9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuO1wiOlwiXCJ9XG4gICAgICAgICR7eT9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXY7XCI6XCJcIn1cblxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSAob3V0cHV0W29mZnNldCArIGldICR7bz9cIlwiOmAtICR7RH0obWVhbilgfSkgKlxuICAgICAgICAgICAgJHtEfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXG4gICAgICAgICAgICAke3U/XCIrIGJldGFbb2Zmc2V0MWQgKyBpXVwiOlwiXCJ9O1xuICAgICAgICB9XG4gICAgICB9YH0sVD1be2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuIHI+MSYmVC5wdXNoKHtkaW1zOm0sZGF0YVR5cGU6MX0pLHI+MiYmVC5wdXNoKHtkaW1zOm0sZGF0YVR5cGU6MX0pLHI+MyYmVC5wdXNoKHtkaW1zOmksZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pLHtuYW1lOlwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAkeyR9OyR7X307JHt5fTske2d9YCxpbnB1dERlcGVuZGVuY2llczplLm1hcCgoQSxDKT0+XCJ0eXBlXCIpfSxnZXRTaGFkZXJTb3VyY2U6UyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsL3ApfSxwcm9ncmFtVW5pZm9ybXM6dn0pfX0sTWw9KGUsdCk9PntZaChlLmlucHV0cyk7bGV0IG49WzBdO2Uub3V0cHV0Q291bnQ+MSYmbi5wdXNoKC0zKSxlLm91dHB1dENvdW50PjImJm4ucHVzaCgtMyksZS5vdXRwdXRDb3VudD4zJiZuLnB1c2goMyksZS5jb21wdXRlKFpoKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCwhMSkse291dHB1dHM6bn0pfX0pO3ZhciBRaCx0bixYaCxVbCxKaCxlZyxObCxWbCxXbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTthZSgpO1FoPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7aWYodC5heGVzLmxlbmd0aCE9PTApe2lmKHQuYXhlcy5sZW5ndGghPT10LnN0YXJ0cy5sZW5ndGh8fHQuYXhlcy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMsIHN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpfWVsc2UgaWYodC5zdGFydHMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtlLnNsaWNlKDEpLmZvckVhY2goKHIsbik9PntpZihlW24rMV0uZGF0YVR5cGUhPT02JiZlW24rMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtufSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCl9KX0sdG49KGUsdCk9PntsZXQgcj1bXTtpZihlLmxlbmd0aD50KWlmKGVbdF0uZGF0YVR5cGU9PT03KWVbdF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobj0+ci5wdXNoKE51bWJlcihuKSkpO2Vsc2UgaWYoZVt0XS5kYXRhVHlwZT09PTYpZVt0XS5nZXRJbnQzMkFycmF5KCkuZm9yRWFjaChuPT5yLnB1c2goTnVtYmVyKG4pKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7dH0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApO3JldHVybiByfSxYaD0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCByPXRuKGUsMSksbj10bihlLDIpLG89dG4oZSwzKTtyZXR1cm4gby5sZW5ndGg9PT0wJiYobz1bLi4uQXJyYXkoZVswXS5kaW1zLmxlbmd0aCkua2V5cygpXSksZWUoe3N0YXJ0czpyLGVuZHM6bixheGVzOm99KX1lbHNlIHJldHVybiB0fSxVbD0oZSx0LHIsbixvKT0+e2xldCBpPWU7cmV0dXJuIGU8MCYmKGkrPXJbblt0XV0pLG9bdF08MD9NYXRoLm1heCgwLE1hdGgubWluKGkscltuW3RdXS0xKSk6TWF0aC5tYXgoMCxNYXRoLm1pbihpLHJbblt0XV0pKX0sSmg9KGUsdCxyKT0+YGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgdmFyIGNhcnJ5ID0gMHU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9ICR7ci5sZW5ndGh9OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlucHV0X3NoYXBlX2kgPSAke3EoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RlcHNfaSA9ICR7cShcInVuaWZvcm1zLnN0ZXBzXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzaWduc19pID0gJHtxKFwidW5pZm9ybXMuc2lnbnNcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0YXJ0c19pID0gJHtxKFwidW5pZm9ybXMuc3RhcnRzXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke3QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgICAgIHZhciBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleCAqIHN0ZXBzX2kgKyBzdGFydHNfaSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBpbnB1dF9pbmRleCAvIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X2luZGV4ICUgaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlmIChzaWduc19pIDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSBpbnB1dF9pbmRleCAtIDF1ICsgc3RhcnRzX2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2luZGV4XCIpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgICB9YCxlZz0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWsuc2l6ZShyKSxvPXQuYXhlcy5sZW5ndGg+MD9rLm5vcm1hbGl6ZUF4ZXModC5heGVzLHIubGVuZ3RoKTpbLi4uQXJyYXkoci5sZW5ndGgpLmtleXMoKV0saT10bihlLDQpO2kuZm9yRWFjaCgkPT4kIT09MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwic3RlcCBjYW5ub3QgYmUgMFwiKX0pKSxpLmxlbmd0aD09PTAmJihpPUFycmF5KG8ubGVuZ3RoKS5maWxsKDEpKTtsZXQgYT10LnN0YXJ0cy5tYXAoKCQsdik9PlVsKCQsdixyLG8saSkpLGQ9dC5lbmRzLm1hcCgoJCx2KT0+VWwoJCx2LHIsbyxpKSk7aWYoby5sZW5ndGghPT1hLmxlbmd0aHx8by5sZW5ndGghPT1kLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCwgZW5kcyBhbmQgYXhlcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcIik7aWYoby5sZW5ndGghPT1yLmxlbmd0aClmb3IobGV0ICQ9MDskPHIubGVuZ3RoOysrJClvLmluY2x1ZGVzKCQpfHwoYS5zcGxpY2UoJCwwLDApLGQuc3BsaWNlKCQsMCxyWyRdKSxpLnNwbGljZSgkLDAsMSkpO2xldCBsPWkubWFwKCQ9Pk1hdGguc2lnbigkKSk7aS5mb3JFYWNoKCgkLHYsUyk9PntpZigkPDApe2xldCBUPShkW3ZdLWFbdl0pLyQsQT1hW3ZdLEM9QStUKmlbdl07YVt2XT1DLGRbdl09QSxTW3ZdPS0kfX0pO2xldCBwPXIuc2xpY2UoMCk7by5mb3JFYWNoKCgkLHYpPT57cFskXT1NYXRoLmNlaWwoKGRbJF0tYVskXSkvaVskXSl9KTtsZXQgbT17ZGltczpwLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9LHU9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUscC5sZW5ndGgpLGg9RShcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSxfPWsuc2l6ZShwKSx5PVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RhcnRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDphLmxlbmd0aH0se25hbWU6XCJzaWduc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6bC5sZW5ndGh9LHtuYW1lOlwic3RlcHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOmkubGVuZ3RofV0sZz1be3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjYsZGF0YTpsfSx7dHlwZToxMixkYXRhOml9LC4uLk4oZVswXS5kaW1zLHApXSx4PSQ9PmBcbiAgICAgICR7JC5yZWdpc3RlclVuaWZvcm1zKHkpLmRlY2xhcmVWYXJpYWJsZXMoaCx1KX1cbiAgICAgICAgJHtKaChoLHUscil9XG4gICAgICAgICR7JC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHt1Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgIGxldCBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAke3Uuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsaC5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpKX1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiU2xpY2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHtsLmxlbmd0aH1fJHthLmxlbmd0aH1fJHtpLmxlbmd0aH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTp4LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbbV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobi82NCl9LHByb2dyYW1Vbmlmb3JtczpnfSl9fSxObD0oZSx0KT0+e1FoKGUuaW5wdXRzLHQpO2xldCByPVhoKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShlZyhlLmlucHV0cyxyKSx7aW5wdXRzOlswXX0pfSxWbD1lPT57bGV0IHQ9ZS5zdGFydHMscj1lLmVuZHMsbj1lLmF4ZXM7cmV0dXJuIGVlKHtzdGFydHM6dCxlbmRzOnIsYXhlczpufSl9fSk7dmFyIHRnLHJnLExsLEdsLEhsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2R0KCk7YWUoKTt0Zz1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0bWF4IG9wIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxyZz0oZSx0KT0+e2xldCByPWUuaW5wdXRzWzBdLG49ci5kaW1zLG89ay5zaXplKG4pLGk9bi5sZW5ndGgsYT1rLm5vcm1hbGl6ZUF4aXModC5heGlzLGkpLGQ9YTxuLmxlbmd0aC0xLGwscD1bXTtkPyhwPUFycmF5LmZyb20oe2xlbmd0aDppfSwoUCxEKT0+RCkscFthXT1pLTEscFtpLTFdPWEsbD1lLmNvbXB1dGUoUGUocixwKSx7aW5wdXRzOltyXSxvdXRwdXRzOlstMV19KVswXSk6bD1yO2xldCBtPWwuZGltcyx1PW1baS0xXSxoPW8vdSxfPW1lKHUpLHk9dS9fLGc9NjQ7aD09PTEmJihnPTI1Nik7bGV0IHg9KFAsRCk9PkQ9PT00P2BtYXgobWF4KCR7UH0ueCwgJHtQfS55KSwgbWF4KCR7UH0ueiwgJHtQfS53KSlgOkQ9PT0yP2BtYXgoJHtQfS54LCAke1B9LnkpYDpEPT09Mz9gbWF4KG1heCgke1B9LngsICR7UH0ueSksICR7UH0ueilgOlAsJD1FKFwieFwiLGwuZGF0YVR5cGUsbC5kaW1zLF8pLHY9TShcInJlc3VsdFwiLGwuZGF0YVR5cGUsbC5kaW1zLF8pLFM9JC50eXBlLnZhbHVlLFQ9eWUobC5kYXRhVHlwZSk9PT1cImYzMlwiP2B2YXIgdGhyZWFkTWF4ID0gJHtTfSgtMy40MDI4MjNlKzM4Zik7YDpgdmFyIHRocmVhZE1heCA9ICR7U30oLTY1NTA0LjBoKTtgLEE9UD0+YFxuICAgICAgdmFyPHdvcmtncm91cD4gcm93TWF4U2hhcmVkIDogJHtTfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7U307XG4gICAgICB2YXI8d29ya2dyb3VwPiB0aHJlYWRTaGFyZWQgOiBhcnJheTwke1N9LCAke2d9PjtcblxuICAgICAgZm4gZ2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIpIC0+ICR7U30ge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXR1cm4geFtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGZuIHNldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyLCB2YWx1ZTogJHtTfSkge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAke1AucmVnaXN0ZXJVbmlmb3JtKFwicGFja2VkQ29sc1wiLFwiaTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoJCx2KX1cbiAgICAgICR7UC5tYWluU3RhcnQoZyl9XG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkeCk7XG4gICAgICAgIGxldCBsaW5kZXggPSBpMzIobG9jYWxfaWR4KTtcbiAgICAgICAgY29uc3Qgd2cgPSAke2d9O1xuICAgICAgICBsZXQgcm93ID0gZ2luZGV4IC8gd2c7XG4gICAgICAgIGxldCBjb2xzID0gdW5pZm9ybXMucGFja2VkQ29scztcbiAgICAgICAgbGV0IHJvd19zdHJpZGUgOiBpMzIgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3MgbWF4XG4gICAgICAgICR7VH1cbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSk7XG4gICAgICAgICAgdGhyZWFkTWF4ID0gbWF4KHRocmVhZE1heCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPCBjb2xzKSB7XG4gICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRNYXg7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKGNvbHMsIHdnKTtcbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgcmVkdWNlU2l6ZSA9IGN1cnJTaXplICsgKHJlZHVjZVNpemUgJiAxKTtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gbWF4KHRocmVhZFNoYXJlZFtsaW5kZXhdLCB0aHJlYWRTaGFyZWRbbGluZGV4ICsgcmVkdWNlU2l6ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93TWF4U2hhcmVkID0gJHtTfSgke3goXCJ0aHJlYWRTaGFyZWRbMF1cIixfKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIHN1bVxuICAgICAgICB2YXIgdGhyZWFkU3VtID0gJHtTfSgwLjApO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCBzdWJFeHAgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKTtcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU3VtO1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSB3ZyA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHtTfSgke3FlKFwidGhyZWFkU2hhcmVkWzBdXCIsXyl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHJvd1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpIC8gcm93U3VtU2hhcmVkO1xuICAgICAgICAgIHNldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1gLEM9ZS5jb21wdXRlKHtuYW1lOlwiU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke199OyR7Z31gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bSxkYXRhVHlwZTpsLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpofSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjYsZGF0YTp5fV19KSxnZXRTaGFkZXJTb3VyY2U6QX0se2lucHV0czpbbF0sb3V0cHV0czpbZD8tMTowXX0pWzBdO2QmJmUuY29tcHV0ZShQZShDLHApLHtpbnB1dHM6W0NdfSl9LExsPShlLHQpPT57dGcoZS5pbnB1dHMpLHJnKGUsdCl9LEdsPWU9PmVlKHtheGlzOmUuYXhpc30pfSk7dmFyIEZsLG5nLG9nLGlnLHFsLEtsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO0ZsPWU9PkFycmF5LmZyb20oZS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxuZz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTEwJiZlWzBdLmRhdGFUeXBlIT09NiYmZVswXS5kYXRhVHlwZSE9PTEyKXRocm93IG5ldyBFcnJvcihcIlRpbGUgb25seSBzdXBwb3J0IGZsb2F0LCBmbG9hdDE2LCBpbnQzMiwgYW5kIHVpbnQzMiBkYXRhIHR5cGVzXCIpO2lmKGVbMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGVcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIDEtRFwiKTtpZihGbChlWzFdKS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBoYXZlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIHJhbmsgb2YgaW5wdXQgZGF0YSB0ZW5zb3JcIil9LG9nPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pci5wdXNoKGVbbl0qdFtuXSk7cmV0dXJuIHJ9LGlnPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49dD8/RmwoZVsxXSksbz1vZyhyLG4pLGk9ay5zaXplKG8pLGE9ZVswXS5kYXRhVHlwZSxkPUUoXCJpbnB1dFwiLGEsci5sZW5ndGgpLGw9TShcIm91dHB1dFwiLGEsby5sZW5ndGgpLHA9bT0+YFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7ZC5pbmRpY2VzKC4uLnIpfTtcbiAgICAgICR7bS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZCxsKX1cbiAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2wub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtkLnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2RpbV9pID0gJHtkLmluZGljZXNHZXQoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiKX07XG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke2wuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfSAgJSBpbnB1dF9kaW1faTtcblxuICAgICAgICAke2QuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2RpbV92YWx1ZVwiKX1cbiAgICAgIH1cbiAgICAgICR7bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixkLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIikpfVxuICAgIH1gO3JldHVybntuYW1lOlwiVGlsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke259YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6aX0sLi4uTihlWzBdLmRpbXMsbyldfSksZ2V0U2hhZGVyU291cmNlOnB9fSxxbD1lPT57bmcoZS5pbnB1dHMpLGUuY29tcHV0ZShpZyhlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgYWcsc2csamwsWWw9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO2FlKCk7YWc9KGUsdCxyLG4sbyk9PntsZXQgaT1NKFwib3V0cHV0X2RhdGFcIixvLHIubGVuZ3RoLDQpLGE9RShcImFfZGF0YVwiLHRbMV0uZGF0YVR5cGUsdFsxXS5kaW1zLmxlbmd0aCw0KSxkPUUoXCJiX2RhdGFcIix0WzJdLmRhdGFUeXBlLHRbMl0uZGltcy5sZW5ndGgsNCksbD1FKFwiY19kYXRhXCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMubGVuZ3RoLDQpLHAsbT0odSxoLF8pPT5gc2VsZWN0KCR7aH0sICR7dX0sICR7X30pYDtpZighbilwPWkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbShhLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxsLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7bGV0IHU9KGgsXyx5PVwiXCIpPT57bGV0IGc9YGFfZGF0YVtpbmRleF9hJHtffV1bY29tcG9uZW50X2Eke199XWAseD1gYl9kYXRhW2luZGV4X2Ike199XVtjb21wb25lbnRfYiR7X31dYCwkPWBib29sKGNfZGF0YVtpbmRleF9jJHtffV0gJiAoMHhmZnUgPDwgKGNvbXBvbmVudF9jJHtffSAqIDgpKSlgO3JldHVybmBcbiAgICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyR7X30gPSAke2kub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke199dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYSR7X30gPSAke2EuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtffWAsaSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9iJHtffSA9ICR7ZC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCxpKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Mke199ID0gJHtsLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7X31gLGkpfTtcbiAgICAgICAgICAgIGxldCBpbmRleF9hJHtffSA9IG9mZnNldF9hJHtffSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Ike199ID0gb2Zmc2V0X2Ike199IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYyR7X30gPSBvZmZzZXRfYyR7X30gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYSR7X30gPSBvZmZzZXRfYSR7X30gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYiR7X30gPSBvZmZzZXRfYiR7X30gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYyR7X30gPSBvZmZzZXRfYyR7X30gJSA0dTtcbiAgICAgICAgICAgICR7aH1bJHtffV0gPSAke3l9KCR7bShnLHgsJCl9KTtcbiAgICAgICAgICBgfTtvPT09OT9wPWBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHt1KFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3UoXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgICAgICR7dShcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt1KFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICAgICBvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOnA9YFxuICAgICAgICAgICAgJHt1KFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cbiAgICAgICAgICAgICR7dShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMSl9XG4gICAgICAgICAgICAke3UoXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHt1KFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cbiAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybShcInZlY19zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhsLGEsZCxpKX1cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAke3B9XG4gICAgICB9YH0sc2c9ZT0+e2xldCB0PWVbMV0uZGltcyxyPWVbMl0uZGltcyxuPWVbMF0uZGltcyxvPWVbMV0uZGF0YVR5cGUsaT0hKGsuYXJlRXF1YWwodCxyKSYmay5hcmVFcXVhbChyLG4pKSxhPXQsZD1rLnNpemUodCk7aWYoaSl7bGV0IHA9dHQuY2FsY1NoYXBlKHR0LmNhbGNTaGFwZSh0LHIsITEpLG4sITEpO2lmKCFwKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7YT1wLGQ9ay5zaXplKGEpfWxldCBsPU1hdGguY2VpbChkLzQpO3JldHVybntuYW1lOlwiV2hlcmVcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOnA9PmFnKHAsZSxhLGksbyksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6bH0sLi4uTihuLHQscixhKV19KX19LGpsPWU9PntlLmNvbXB1dGUoc2coZS5pbnB1dHMpKX19KTt2YXIgWmwsUWw9VSgoKT0+e1widXNlIHN0cmljdFwiO0VzKCk7SHIoKTtPcygpO0JzKCk7d3UoKTtQdSgpO0R1KCk7WnUoKTtuZCgpO2FkKCk7ZGQoKTtmZCgpO2JkKCk7X2QoKTskZCgpO1RkKCk7QWQoKTtQZCgpO0RkKCk7UmQoKTtGZCgpO2pkKCk7WmQoKTtYZCgpO3RsKCk7eG8oKTtubCgpO3dsKCk7eGwoKTtUbCgpO0FsKCk7THIoKTtPbCgpO0JsKCk7UmwoKTtXbCgpO0hsKCk7VG8oKTtLbCgpO2R0KCk7cXIoKTtZbCgpO1psPW5ldyBNYXAoW1tcIkFic1wiLFtNc11dLFtcIkFjb3NcIixbUnNdXSxbXCJBY29zaFwiLFtVc11dLFtcIkFkZFwiLFt2dV1dLFtcIkFyZ01heFwiLFtrcyxsb11dLFtcIkFyZ01pblwiLFtBcyxsb11dLFtcIkFzaW5cIixbTnNdXSxbXCJBc2luaFwiLFtWc11dLFtcIkF0YW5cIixbV3NdXSxbXCJBdGFuaFwiLFtMc11dLFtcIkF0dGVudGlvblwiLFtQc11dLFtcIkF2ZXJhZ2VQb29sXCIsW2NsLGxsXV0sW1wiQmF0Y2hOb3JtYWxpemF0aW9uXCIsW3pzXV0sW1wiQmlhc0FkZFwiLFtEc11dLFtcIkJpYXNTcGxpdEdlbHVcIixbX3VdXSxbXCJDYXN0XCIsW0hzLEdzXV0sW1wiQ2VpbFwiLFtxc11dLFtcIkNsaXBcIixbRnNdXSxbXCJDb25jYXRcIixbenUsT3VdXSxbXCJDb252XCIsW19vLHlvXV0sW1wiQ29udlRyYW5zcG9zZVwiLFtyZCxlZF1dLFtcIkNvc1wiLFtLc11dLFtcIkNvc2hcIixbanNdXSxbXCJDdW1TdW1cIixbb2QsaWRdXSxbXCJEZXB0aFRvU3BhY2VcIixbc2QsdWRdXSxbXCJEZXF1YW50aXplTGluZWFyXCIsW3ZsLCRsXV0sW1wiRGl2XCIsWyR1XV0sW1wiRWluc3VtXCIsW3BkLG1kXV0sW1wiRWx1XCIsW1lzLFF0XV0sW1wiRXF1YWxcIixbeHVdXSxbXCJFcmZcIixbWnNdXSxbXCJFeHBcIixbUXNdXSxbXCJFeHBhbmRcIixbZ2RdXSxbXCJGYXN0R2VsdVwiLFt5ZF1dLFtcIkZsb29yXCIsW1hzXV0sW1wiRnVzZWRDb252XCIsW19vLHlvXV0sW1wiR2F0aGVyXCIsW3ZkLHdkXV0sW1wiR2F0aGVyRWxlbWVudHNcIixbRWQsa2RdXSxbXCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLFtJZCxDZF1dLFtcIkdhdGhlck5EXCIsW3hkLFNkXV0sW1wiR2VsdVwiLFtKc11dLFtcIkdlbW1cIixbT2QsemRdXSxbXCJHbG9iYWxBdmVyYWdlUG9vbFwiLFtmbCxtbF1dLFtcIkdsb2JhbE1heFBvb2xcIixbX2wseWxdXSxbXCJHcmVhdGVyXCIsW0N1XV0sW1wiR3JlYXRlck9yRXF1YWxcIixba3VdXSxbXCJHcmlkU2FtcGxlXCIsW0JkLE1kXV0sW1wiR3JvdXBRdWVyeUF0dGVudGlvblwiLFtIZF1dLFtcIkhhcmRTaWdtb2lkXCIsW3N1LGF1XV0sW1wiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsW0tkXV0sW1wiTGF5ZXJOb3JtYWxpemF0aW9uXCIsW1lkXV0sW1wiTGVha3lSZWx1XCIsW2V1LFF0XV0sW1wiTGVzc1wiLFtBdV1dLFtcIkxlc3NPckVxdWFsXCIsW0V1XV0sW1wiTG9nXCIsW2d1XV0sW1wiTWF0TXVsXCIsW1FkXV0sW1wiTWF0TXVsTkJpdHNcIixbSmQsZWxdXSxbXCJNYXhQb29sXCIsW2dsLGJsXV0sW1wiTXVsXCIsW1N1XV0sW1wiTXVsdGlIZWFkQXR0ZW50aW9uXCIsW1ZkLE5kXV0sW1wiTmVnXCIsW3J1XV0sW1wiTm90XCIsW3R1XV0sW1wiUGFkXCIsW3JsXV0sW1wiUG93XCIsW1R1XV0sW1wiUXVpY2tHZWx1XCIsW2J1LFF0XV0sW1wiUmFuZ2VcIixbU2xdXSxbXCJSZWNpcHJvY2FsXCIsW251XV0sW1wiUmVkdWNlTWluXCIsWyRzXV0sW1wiUmVkdWNlTWVhblwiLFtic11dLFtcIlJlZHVjZU1heFwiLFt2c11dLFtcIlJlZHVjZVN1bVwiLFtTc11dLFtcIlJlZHVjZVByb2RcIixbeHNdXSxbXCJSZWR1Y2VMMVwiLFt5c11dLFtcIlJlZHVjZUwyXCIsW19zXV0sW1wiUmVkdWNlTG9nU3VtXCIsW0lzXV0sW1wiUmVkdWNlTG9nU3VtRXhwXCIsW3dzXV0sW1wiUmVkdWNlU3VtU3F1YXJlXCIsW1RzXV0sW1wiUmVsdVwiLFtvdV1dLFtcIlJlc2l6ZVwiLFtQbCx6bF1dLFtcIlJvdGFyeUVtYmVkZGluZ1wiLFtEbF1dLFtcIlNjYXR0ZXJORFwiLFtDbCxJbF1dLFtcIlNpZ21vaWRcIixbaXVdXSxbXCJTaW5cIixbdXVdXSxbXCJTaW5oXCIsW2R1XV0sW1wiU2xpY2VcIixbTmwsVmxdXSxbXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsW01sXV0sW1wiU3BsaXRcIixbV2QsTGRdXSxbXCJTcXJ0XCIsW2x1XV0sW1wiU29mdG1heFwiLFtMbCxHbF1dLFtcIlN1YlwiLFtJdV1dLFtcIlRhblwiLFtjdV1dLFtcIlRhbmhcIixbbXVdXSxbXCJUaHJlc2hvbGRlZFJlbHVcIixbaHUsUXRdXSxbXCJUaWxlXCIsW3FsXV0sW1wiVHJhbnNwb3NlXCIsW29zLGlzXV0sW1wiV2hlcmVcIixbamxdXV0pfSk7dmFyIHJuLFhsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtMZSgpO2V0KCk7YWUoKTtybj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnJlcG89bmV3IE1hcCx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMX1nZXRBcnRpZmFjdCh0KXtyZXR1cm4gdGhpcy5yZXBvLmdldCh0KX1zZXRBcnRpZmFjdCh0LHIpe3RoaXMucmVwby5zZXQodCxyKX1ydW4odCxyLG4sbyxpKXtOZSh0LnByb2dyYW1JbmZvLm5hbWUpO2xldCBhPXRoaXMuYmFja2VuZC5kZXZpY2UsZD10aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMik7bGV0IGw9W107Zm9yKGxldCBtIG9mIHIpbC5wdXNoKHtiaW5kaW5nOmwubGVuZ3RoLHJlc291cmNlOntidWZmZXI6bS5idWZmZXJ9fSk7Zm9yKGxldCBtIG9mIG4pbC5wdXNoKHtiaW5kaW5nOmwubGVuZ3RoLHJlc291cmNlOntidWZmZXI6bS5idWZmZXJ9fSk7aSYmbC5wdXNoKHtiaW5kaW5nOmwubGVuZ3RoLHJlc291cmNlOml9KTtsZXQgcD1hLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OnQuY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOmwsbGFiZWw6dC5wcm9ncmFtSW5mby5uYW1lfSk7aWYodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiKXtsZXQgbT17a2VybmVsSWQ6dGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxJZCxjb21wdXRlUGlwZWxpbmU6dC5jb21wdXRlUGlwZWxpbmUsYmluZEdyb3VwOnAsZGlzcGF0Y2hHcm91cDpvfTt0aGlzLmJhY2tlbmQuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpLnB1c2gobSl9ZC5zZXRQaXBlbGluZSh0LmNvbXB1dGVQaXBlbGluZSksZC5zZXRCaW5kR3JvdXAoMCxwKSxkLmRpc3BhdGNoV29ya2dyb3VwcyguLi5vKSx0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzEpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKywodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyfHx0aGlzLmJhY2tlbmQucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIikmJnRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlciYmdGhpcy5iYWNrZW5kLmZsdXNoKCksQmUodC5wcm9ncmFtSW5mby5uYW1lKX1kaXNwb3NlKCl7fWJ1aWxkKHQscil7TmUodC5uYW1lKTtsZXQgbj10aGlzLmJhY2tlbmQuZGV2aWNlLG89W107W3tmZWF0dXJlOlwic2hhZGVyLWYxNlwiLGV4dGVuc2lvbjpcImYxNlwifSx7ZmVhdHVyZTpcInN1Ymdyb3Vwc1wiLGV4dGVuc2lvbjpcInN1Ymdyb3Vwc1wifSx7ZmVhdHVyZTpcInN1Ymdyb3Vwcy1mMTZcIixleHRlbnNpb246XCJzdWJncm91cHNfZjE2XCJ9XS5mb3JFYWNoKHU9PntuLmZlYXR1cmVzLmhhcyh1LmZlYXR1cmUpJiZvLnB1c2goYGVuYWJsZSAke3UuZXh0ZW5zaW9ufTtgKX0pO2xldCBhPXJzKHIsdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMpLGQ9dC5nZXRTaGFkZXJTb3VyY2UoYSksbD1gJHtvLmpvaW4oYFxuYCl9XG4ke2EuYWRkaXRpb25hbEltcGxlbWVudGF0aW9uc31cbiR7ZH1gLHA9bi5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6bCxsYWJlbDp0Lm5hbWV9KTtzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdICR7dC5uYW1lfSBzaGFkZXIgY29kZTogJHtsfWApO2xldCBtPW4uY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHtjb21wdXRlOnttb2R1bGU6cCxlbnRyeVBvaW50OlwibWFpblwifSxsYXlvdXQ6XCJhdXRvXCIsbGFiZWw6dC5uYW1lfSk7cmV0dXJuIEJlKHQubmFtZSkse3Byb2dyYW1JbmZvOnQsY29tcHV0ZVBpcGVsaW5lOm0sdW5pZm9ybVZhcmlhYmxlc0luZm86YS52YXJpYWJsZXNJbmZvfX1ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZSh0KXtsZXQgcj10eXBlb2YgdD09XCJudW1iZXJcIj90OnQueCxuPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC55fHwxLG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnp8fDEsaT10aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtpZihyPD1pJiZuPD1pJiZvPD1pKXJldHVybltyLG4sb107bGV0IGE9cipuKm8sZD1NYXRoLmNlaWwoTWF0aC5zcXJ0KGEpKTtpZihkPmkpe2lmKGQ9TWF0aC5jZWlsKE1hdGguY2JydChhKSksZD5pKXRocm93IG5ldyBFcnJvcihcIlRvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS5cIik7cmV0dXJuW2QsZCxkXX1lbHNlIHJldHVybltkLGQsMV19fX0pO3ZhciB1ZyxkZyxJbyxDbyxubixKbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7TGUoKTtKKCk7ZXQoKTtYbigpO1hhKCk7UWwoKTtYbCgpO3VnPShlLHQpPT57aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke3QubGVuZ3RofSBpcyBub3QgZXF1YWwgdG8gaW5wdXRUZW5zb3JzIGxlbmd0aCAke2UubGVuZ3RofS5gKTtsZXQgcj1bXTtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbil7bGV0IG89ZVtuXS5kYXRhVHlwZTtzd2l0Y2godFtuXSl7Y2FzZVwibm9uZVwiOntyLnB1c2goXCJcIik7YnJlYWt9Y2FzZVwidHlwZVwiOntyLnB1c2goYCR7b31gKTticmVha31jYXNlXCJyYW5rXCI6e2xldCBpPWVbbl0uZGltcy5sZW5ndGg7ci5wdXNoKGAke299OyR7aX1gKTticmVha31jYXNlXCJkaW1zXCI6e2xldCBpPWVbbl0uZGltcy5qb2luKFwiLFwiKTtyLnB1c2goYCR7b307JHtpfWApO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBpbnB1dCBkZXBlbmRlbmN5OiAke3Rbbl19YCl9fXJldHVybiByLmpvaW4oXCJ8XCIpfSxkZz0oZSx0LHIpPT57bGV0IG49ZS5uYW1lO3JldHVybiBlLnNoYWRlckNhY2hlPy5oaW50JiYobis9XCJbXCIrZS5zaGFkZXJDYWNoZS5oaW50K1wiXVwiKSxuKz1cIjpcIityK2A6JHt1Zyh0LGUuc2hhZGVyQ2FjaGU/LmlucHV0RGVwZW5kZW5jaWVzPz9uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwoXCJkaW1zXCIpKX1gLG59LElvPWNsYXNze2NvbnN0cnVjdG9yKHQpe3QmJih0aGlzLmFyY2hpdGVjdHVyZT10LmFyY2hpdGVjdHVyZSx0aGlzLnZlbmRvcj10LnZlbmRvcil9aXNBcmNoaXRlY3R1cmUodCl7cmV0dXJuIHRoaXMuYXJjaGl0ZWN0dXJlPT09dH1pc1ZlbmRvcih0KXtyZXR1cm4gdGhpcy52ZW5kb3I9PT10fX0sQ289Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5zdWJncm91cHNTdXBwb3J0ZWQ9dC5mZWF0dXJlcy5oYXMoXCJzdWJncm91cHNcIiksdGhpcy5zdWJncm91cHNGMTZTdXBwb3J0ZWQ9dC5mZWF0dXJlcy5oYXMoXCJzdWJncm91cHNcIik7bGV0IHI9dC5saW1pdHM7IXRoaXMuc3ViZ3JvdXBzU3VwcG9ydGVkfHwhci5taW5TdWJncm91cFNpemV8fCFyLm1heFN1Ymdyb3VwU2l6ZT90aGlzLnN1Ymdyb3VwU2l6ZVJhbmdlPXZvaWQgMDp0aGlzLnN1Ymdyb3VwU2l6ZVJhbmdlPVtyLm1pblN1Ymdyb3VwU2l6ZSxyLm1heFN1Ymdyb3VwU2l6ZV19fSxubj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuY3VycmVudFNlc3Npb25JZD1udWxsO3RoaXMuY3VycmVudEtlcm5lbElkPW51bGw7dGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsO3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGw7dGhpcy5tYXhEaXNwYXRjaE51bWJlcj0xNjt0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wO3RoaXMucGVuZGluZ0tlcm5lbHM9W107dGhpcy5wZW5kaW5nUXVlcmllcz1uZXcgTWFwO3RoaXMuc2Vzc2lvblN0YXR1cz1cImRlZmF1bHRcIjt0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3Q9bmV3IE1hcDt0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHM9bmV3IE1hcDt0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nPW5ldyBNYXB9Z2V0IGN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCl7aWYodGhpcy5jdXJyZW50S2VybmVsSWQ9PT1udWxsKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCk6IGN1cnJlbnRLZXJuZWxJZCBpcyBudWxsLiAoc2hvdWxkIG5vdCBoYXBwZW4pXCIpO2xldCB0PXRoaXMua2VybmVsQ3VzdG9tRGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO3JldHVybiB0fHwodD17fSx0aGlzLmtlcm5lbEN1c3RvbURhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLHQpKSx0fWFzeW5jIGluaXRpYWxpemUodCxyKXt0aGlzLmVudj10O2xldCBuPVtdLG89e3JlcXVpcmVkTGltaXRzOnttYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemU6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplLG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uLG1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZTpyLmxpbWl0cy5tYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemUsbWF4QnVmZmVyU2l6ZTpyLmxpbWl0cy5tYXhCdWZmZXJTaXplLG1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cDpyLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVYOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVk6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWjpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVp9LHJlcXVpcmVkRmVhdHVyZXM6bn0saT1hPT5yLmZlYXR1cmVzLmhhcyhhKSYmbi5wdXNoKGEpJiYhMDtpKFwiY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzXCIpfHxpKFwidGltZXN0YW1wLXF1ZXJ5XCIpLGkoXCJzaGFkZXItZjE2XCIpLGkoXCJzdWJncm91cHNcIikmJmkoXCJzdWJncm91cHMtZjE2XCIpLHRoaXMuZGV2aWNlPWF3YWl0IHIucmVxdWVzdERldmljZShvKSx0aGlzLmRldmljZUluZm89bmV3IENvKHRoaXMuZGV2aWNlKSx0aGlzLmFkYXB0ZXJJbmZvPW5ldyBJbyhyLmluZm98fGF3YWl0IHIucmVxdWVzdEFkYXB0ZXJJbmZvKCkpLHRoaXMuZ3B1RGF0YU1hbmFnZXI9UWEodGhpcyksdGhpcy5wcm9ncmFtTWFuYWdlcj1uZXcgcm4odGhpcyksdGhpcy5rZXJuZWxzPW5ldyBNYXAsdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YT1uZXcgTWFwLHRoaXMua2VybmVsQ3VzdG9tRGF0YT1uZXcgTWFwLE1yKHQubG9nTGV2ZWwsISF0LmRlYnVnKSx0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvcj1hPT57YS5lcnJvciBpbnN0YW5jZW9mIEdQVVZhbGlkYXRpb25FcnJvciYmY29uc29sZS5lcnJvcihgQW4gdW5jYXVnaHQgV2ViR1BVIHZhbGlkYXRpb24gZXJyb3Igd2FzIHJhaXNlZDogJHthLmVycm9yLm1lc3NhZ2V9YCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsXCJkZXZpY2VcIix7dmFsdWU6dGhpcy5kZXZpY2Usd3JpdGFibGU6ITEsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LFwiYWRhcHRlclwiLHt2YWx1ZTpyLHdyaXRhYmxlOiExLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExfSksdGhpcy5zZXRRdWVyeVR5cGUoKX1kaXNwb3NlKCl7dHlwZW9mIHRoaXMucXVlcnlTZXQ8XCJ1XCImJnRoaXMucXVlcnlTZXQuZGVzdHJveSgpLHRoaXMuZ3B1RGF0YU1hbmFnZXIuZGlzcG9zZSgpfWdldENvbW1hbmRFbmNvZGVyKCl7cmV0dXJuIHRoaXMuY29tbWFuZEVuY29kZXJ8fCh0aGlzLmNvbW1hbmRFbmNvZGVyPXRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCkpLHRoaXMuY29tbWFuZEVuY29kZXJ9Z2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCl7aWYoIXRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKXtsZXQgdD10aGlzLmdldENvbW1hbmRFbmNvZGVyKCkscj17fTt0aGlzLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCImJihyLnRpbWVzdGFtcFdyaXRlcz17cXVlcnlTZXQ6dGhpcy5xdWVyeVNldCxiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4OnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIsZW5kT2ZQYXNzV3JpdGVJbmRleDp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzF9KSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj10LmJlZ2luQ29tcHV0ZVBhc3Mocil9cmV0dXJuIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyfWVuZENvbXB1dGVQYXNzKCl7dGhpcy5jb21wdXRlUGFzc0VuY29kZXImJih0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsKX1mbHVzaCgpe2lmKCF0aGlzLmNvbW1hbmRFbmNvZGVyKXJldHVybjtOZSgpLHRoaXMuZW5kQ29tcHV0ZVBhc3MoKTtsZXQgdDt0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiYodGhpcy5jb21tYW5kRW5jb2Rlci5yZXNvbHZlUXVlcnlTZXQodGhpcy5xdWVyeVNldCwwLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIsdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIsMCksdD10aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMio4LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfSksdGhpcy5wZW5kaW5nUXVlcmllcy5zZXQodCx0aGlzLnBlbmRpbmdLZXJuZWxzKSx0aGlzLnBlbmRpbmdLZXJuZWxzPVtdLHRoaXMuY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyLDAsdCwwLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIqOCkpLHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbdGhpcy5jb21tYW5kRW5jb2Rlci5maW5pc2goKV0pLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVmcmVzaFBlbmRpbmdCdWZmZXJzKCksdGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTAsdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdC5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpLnRoZW4oKCk9PntsZXQgcj1uZXcgQmlnVWludDY0QXJyYXkodC5nZXRNYXBwZWRSYW5nZSgpKSxuPXRoaXMucGVuZGluZ1F1ZXJpZXMuZ2V0KHQpO2ZvcihsZXQgbz0wO288ci5sZW5ndGgvMjtvKyspe2xldCBpPW5bb10sYT1pLmtlcm5lbElkLGQ9dGhpcy5rZXJuZWxzLmdldChhKSxsPWQua2VybmVsVHlwZSxwPWQua2VybmVsTmFtZSxtPWkucHJvZ3JhbU5hbWUsdT1pLmlucHV0VGVuc29yVmlld3MsaD1pLm91dHB1dFRlbnNvclZpZXdzLF89cltvKjJdLHk9cltvKjIrMV07dHlwZW9mIHRoaXMucXVlcnlUaW1lQmFzZT5cInVcIiYmKHRoaXMucXVlcnlUaW1lQmFzZT1fKTtsZXQgZz1OdW1iZXIoXy10aGlzLnF1ZXJ5VGltZUJhc2UpLHg9TnVtYmVyKHktdGhpcy5xdWVyeVRpbWVCYXNlKTtpZighTnVtYmVyLmlzU2FmZUludGVnZXIoZyl8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcih4KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2VcIik7aWYodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ub25kYXRhKXRoaXMuZW52LndlYmdwdS5wcm9maWxpbmcub25kYXRhKHt2ZXJzaW9uOjEsaW5wdXRzTWV0YWRhdGE6dS5tYXAoJD0+KHtkaW1zOiQuZGltcyxkYXRhVHlwZTpidCgkLmRhdGFUeXBlKX0pKSxvdXRwdXRzTWV0YWRhdGE6aC5tYXAoJD0+KHtkaW1zOiQuZGltcyxkYXRhVHlwZTpidCgkLmRhdGFUeXBlKX0pKSxrZXJuZWxJZDphLGtlcm5lbFR5cGU6bCxrZXJuZWxOYW1lOnAscHJvZ3JhbU5hbWU6bSxzdGFydFRpbWU6ZyxlbmRUaW1lOnh9KTtlbHNle2xldCAkPVwiXCI7dS5mb3JFYWNoKChTLFQpPT57JCs9YGlucHV0WyR7VH1dOiBbJHtTLmRpbXN9XSB8ICR7YnQoUy5kYXRhVHlwZSl9LCBgfSk7bGV0IHY9XCJcIjtoLmZvckVhY2goKFMsVCk9Pnt2Kz1gb3V0cHV0WyR7VH1dOiBbJHtTLmRpbXN9XSB8ICR7YnQoUy5kYXRhVHlwZSl9LCBgfSksY29uc29sZS5sb2coYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7YX18JHtsfXwke3B9fCR7bX1cIiAkeyR9JHt2fWV4ZWN1dGlvbiB0aW1lOiAke3gtZ30gbnNgKX1fcihcIkdQVVwiLGAke219Ojoke199Ojoke3l9YCl9dC51bm1hcCgpLHRoaXMucGVuZGluZ1F1ZXJpZXMuZGVsZXRlKHQpfSksQmUoKX1ydW4odCxyLG4sbyxpLGEpe05lKHQubmFtZSk7bGV0IGQ9W107Zm9yKGxldCBTPTA7UzxyLmxlbmd0aDsrK1Mpe2xldCBUPXJbU10uZGF0YTtpZihUPT09MCljb250aW51ZTtsZXQgQT10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChUKTtpZighQSl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBpbnB1dDogJHtUfWApO2QucHVzaChBKX1sZXR7b3V0cHV0czpsLGRpc3BhdGNoR3JvdXA6cCxwcm9ncmFtVW5pZm9ybXM6bX09dC5nZXRSdW5EYXRhKHIpLHU9bi5sZW5ndGg9PT0wP2wubWFwKChTLFQpPT5UKTpuO2lmKHUubGVuZ3RoIT09bC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc2l6ZSAke3UubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvICR7bC5sZW5ndGh9LmApO2xldCBoPVtdLF89W107Zm9yKGxldCBTPTA7UzxsLmxlbmd0aDsrK1Mpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHVbU10pfHx1W1NdPC0zfHx1W1NdPj1hKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvdXRwdXQgaW5kZXg6ICR7dVtTXX1gKTtpZih1W1NdPT09LTMpY29udGludWU7bGV0IFQ9dVtTXT09PS0xLEE9dVtTXT09PS0yLEM9VHx8QT9pKGxbU10uZGF0YVR5cGUsbFtTXS5kaW1zKTpvKHVbU10sbFtTXS5kYXRhVHlwZSxsW1NdLmRpbXMpO2lmKGgucHVzaChDKSxDLmRhdGE9PT0wKWNvbnRpbnVlO2xldCBQPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KEMuZGF0YSk7aWYoIVApdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3Igb3V0cHV0OiAke0MuZGF0YX1gKTtpZihUJiZ0aGlzLnRlbXBvcmFyeURhdGEucHVzaChQKSxBKXtsZXQgRD10aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7RHx8KEQ9W10sdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsRCkpLEQucHVzaChQKX1fLnB1c2goUCl9aWYoZC5sZW5ndGghPT1yLmxlbmd0aHx8Xy5sZW5ndGghPT1oLmxlbmd0aCl7aWYoXy5sZW5ndGg9PT0wKXJldHVybiBCZSh0Lm5hbWUpLGg7dGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtICR7dC5uYW1lfSBoYXMgemVyby1zaXplZCB0ZW5zb3IocykgaW4gaW5wdXRzIG9yIG91dHB1dHMuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBub3cuYCl9bGV0IHk7aWYobSl7bGV0IFM9MCxUPVtdO20uZm9yRWFjaChEPT57bGV0IFI9dHlwZW9mIEQuZGF0YT09XCJudW1iZXJcIj9bRC5kYXRhXTpELmRhdGE7aWYoUi5sZW5ndGg9PT0wKXJldHVybjtsZXQgSD1ELnR5cGU9PT0xMD8yOjQsTCxyZTtELnR5cGU9PT0xMD8ocmU9Ui5sZW5ndGg+ND8xNjpSLmxlbmd0aD4yPzg6Ui5sZW5ndGgqSCxMPVIubGVuZ3RoPjQ/MTY6SCpSLmxlbmd0aCk6KHJlPVIubGVuZ3RoPD0yP1IubGVuZ3RoKkg6MTYsTD0xNiksUz1NYXRoLmNlaWwoUy9yZSkqcmUsVC5wdXNoKFMpO2xldCBWPUQudHlwZT09PTEwPzg6NDtTKz1SLmxlbmd0aD40P01hdGguY2VpbChSLmxlbmd0aC9WKSpMOlIubGVuZ3RoKkh9KTtsZXQgQT0xNjtTPU1hdGguY2VpbChTL0EpKkE7bGV0IEM9bmV3IEFycmF5QnVmZmVyKFMpO20uZm9yRWFjaCgoRCxSKT0+e2xldCBIPVRbUl0sTD10eXBlb2YgRC5kYXRhPT1cIm51bWJlclwiP1tELmRhdGFdOkQuZGF0YTtpZihELnR5cGU9PT02KW5ldyBJbnQzMkFycmF5KEMsSCxMLmxlbmd0aCkuc2V0KEwpO2Vsc2UgaWYoRC50eXBlPT09MTIpbmV3IFVpbnQzMkFycmF5KEMsSCxMLmxlbmd0aCkuc2V0KEwpO2Vsc2UgaWYoRC50eXBlPT09MTApbmV3IFVpbnQxNkFycmF5KEMsSCxMLmxlbmd0aCkuc2V0KEwpO2Vsc2UgaWYoRC50eXBlPT09MSluZXcgRmxvYXQzMkFycmF5KEMsSCxMLmxlbmd0aCkuc2V0KEwpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHR5cGU6ICR7YnQoRC50eXBlKX1gKX0pO2xldCBQPXRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKFMsR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7dGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoUC5idWZmZXIsMCxDLDAsUyksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKFAuaWQpLHk9e29mZnNldDowLHNpemU6UyxidWZmZXI6UC5idWZmZXJ9fWxldCBnPXRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUocCkseD1nWzFdPT09MSYmZ1syXT09PTEsJD1kZyh0LHIseCksdj10aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KCQpO2lmKHZ8fCh2PXRoaXMucHJvZ3JhbU1hbmFnZXIuYnVpbGQodCxnKSx0aGlzLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KCQsdiksc2UoXCJpbmZvXCIsKCk9PmBbYXJ0aWZhY3RdIGtleTogJHskfSwgcHJvZ3JhbU5hbWU6ICR7dC5uYW1lfWApKSxtJiZ2LnVuaWZvcm1WYXJpYWJsZXNJbmZvKXtpZihtLmxlbmd0aCE9PXYudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZXMgY291bnQgbWlzbWF0Y2g6IGV4cGVjdCAke3YudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RofSwgZ290ICR7bS5sZW5ndGh9IGluIHByb2dyYW0gXCIke3YucHJvZ3JhbUluZm8ubmFtZX1cIi5gKTtmb3IobGV0IFM9MDtTPG0ubGVuZ3RoO1MrKyl7bGV0IFQ9bVtTXSxBPVQudHlwZSxDPXR5cGVvZiBULmRhdGE9PVwibnVtYmVyXCI/MTpULmRhdGEubGVuZ3RoLFtQLERdPXYudW5pZm9ybVZhcmlhYmxlc0luZm9bU107aWYoQSE9PVB8fEMhPT1EKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZSAke1N9IG1pc21hdGNoOiBleHBlY3QgdHlwZSAke1B9IHdpdGggc2l6ZSAke0R9LCBnb3QgdHlwZSAke0F9IHdpdGggc2l6ZSAke0N9IGluIHByb2dyYW0gXCIke3YucHJvZ3JhbUluZm8ubmFtZX1cIi5gKX19aWYoc2UoXCJpbmZvXCIsKCk9PmBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7dC5uYW1lfVwiIChrZXk9JHskfSkgd2l0aCAke2dbMF19eCR7Z1sxXX14JHtnWzJdfWApLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCJ8fHRoaXMuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCIpe2xldCBTPXtrZXJuZWxJZDp0aGlzLmN1cnJlbnRLZXJuZWxJZCxwcm9ncmFtTmFtZTp2LnByb2dyYW1JbmZvLm5hbWUsaW5wdXRUZW5zb3JWaWV3czpyLG91dHB1dFRlbnNvclZpZXdzOmh9O3RoaXMucGVuZGluZ0tlcm5lbHMucHVzaChTKSx0aGlzLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiJiZ0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCkucHVzaChTKX1yZXR1cm4gdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4odixkLF8sZyx5KSxCZSh0Lm5hbWUpLGh9dXBsb2FkKHQscil7dGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQodCxyKX1tZW1jcHkodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweSh0LHIpfWFzeW5jIGRvd25sb2FkKHQscil7YXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZCh0LHIpfWFsbG9jKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0KS5pZH1mcmVlKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodCl9Y3JlYXRlS2VybmVsKHQscixuLG8pe2xldCBpPVpsLmdldCh0KTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7dH1gKTtsZXQgYT17a2VybmVsVHlwZTp0LGtlcm5lbE5hbWU6byxrZXJuZWxFbnRyeTppWzBdLGF0dHJpYnV0ZXM6W2lbMV0sbl19O3RoaXMua2VybmVscy5zZXQocixhKX1yZWxlYXNlS2VybmVsKHQpe2xldCByPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHQpO2lmKHIpe2ZvcihsZXQgbiBvZiByKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShuLmlkKTt0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZSh0KX10aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKHQpLHRoaXMua2VybmVscy5kZWxldGUodCl9Y29tcHV0ZUtlcm5lbCh0LHIsbil7bGV0IG89dGhpcy5rZXJuZWxzLmdldCh0KTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHt0fWApO2xldCBpPW8ua2VybmVsVHlwZSxhPW8ua2VybmVsTmFtZSxkPW8ua2VybmVsRW50cnksbD1vLmF0dHJpYnV0ZXM7aWYodGhpcy5jdXJyZW50S2VybmVsSWQhPT1udWxsKXRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7aX1dICR7YX1cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTt0aGlzLmN1cnJlbnRLZXJuZWxJZD10LGxbMF0mJihsWzFdPWxbMF0obFsxXSksbFswXT12b2lkIDApLHNlKFwiaW5mb1wiLCgpPT5gW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske2l9XSAke2F9XCIuLi5gKTtsZXQgcD10aGlzLmVudi5kZWJ1Zzt0aGlzLnRlbXBvcmFyeURhdGE9W107dHJ5e3JldHVybiBwJiZ0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZShcInZhbGlkYXRpb25cIiksZChyLGxbMV0pLDB9Y2F0Y2gobSl7cmV0dXJuIG4ucHVzaChQcm9taXNlLnJlc29sdmUoYFtXZWJHUFVdIEtlcm5lbCBcIlske2l9XSAke2F9XCIgZmFpbGVkLiAke219YCkpLDF9ZmluYWxseXtwJiZuLnB1c2godGhpcy5kZXZpY2UucG9wRXJyb3JTY29wZSgpLnRoZW4obT0+bT9gR1BVIHZhbGlkYXRpb24gZXJyb3IgZm9yIGtlcm5lbCBcIlske2l9XSAke2F9XCI6ICR7bS5tZXNzYWdlfWA6bnVsbCkpO2ZvcihsZXQgbSBvZiB0aGlzLnRlbXBvcmFyeURhdGEpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKG0uaWQpO3RoaXMudGVtcG9yYXJ5RGF0YT1bXSx0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsfX1yZWdpc3RlckJ1ZmZlcih0LHIsbixvKXtsZXQgaT10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtpfHwoaT1uZXcgTWFwLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHQsaSkpO2xldCBhPWkuZ2V0KHIpLGQ9dGhpcy5ncHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG4sbyxhKTtyZXR1cm4gaS5zZXQocixbZCxuXSksZH11bnJlZ2lzdGVyQnVmZmVycyh0KXtsZXQgcj10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtyJiYoci5mb3JFYWNoKG49PnRoaXMuZ3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG5bMF0pKSx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmRlbGV0ZSh0KSl9Z2V0QnVmZmVyKHQpe2xldCByPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHt0fWApO3JldHVybiByLmJ1ZmZlcn1jcmVhdGVEb3dubG9hZGVyKHQscixuKXtyZXR1cm4gYXN5bmMoKT0+e2xldCBvPWF3YWl0IHJvKHRoaXMsdCxyKTtyZXR1cm4gUnIoby5idWZmZXIsbil9fXdyaXRlVGltZXN0YW1wKHQpe3RoaXMucXVlcnlUeXBlPT09XCJpbnNpZGUtcGFzc2VzXCImJnRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLndyaXRlVGltZXN0YW1wKHRoaXMucXVlcnlTZXQsdCl9c2V0UXVlcnlUeXBlKCl7dGhpcy5xdWVyeVR5cGU9XCJub25lXCIsKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm1vZGU9PT1cImRlZmF1bHRcInx8KHR5cGVvZiB0aGlzLmVudi50cmFjZT5cInVcIj90aGlzLmVudi53YXNtLnRyYWNlOnRoaXMuZW52LnRyYWNlKSkmJih0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIik/dGhpcy5xdWVyeVR5cGU9XCJpbnNpZGUtcGFzc2VzXCI6dGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwidGltZXN0YW1wLXF1ZXJ5XCIpJiYodGhpcy5xdWVyeVR5cGU9XCJhdC1wYXNzZXNcIiksdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdHlwZW9mIHRoaXMucXVlcnlTZXQ+XCJ1XCImJih0aGlzLnF1ZXJ5U2V0PXRoaXMuZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KHt0eXBlOlwidGltZXN0YW1wXCIsY291bnQ6dGhpcy5tYXhEaXNwYXRjaE51bWJlcioyfSksdGhpcy5xdWVyeVJlc29sdmVCdWZmZXI9dGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMubWF4RGlzcGF0Y2hOdW1iZXIqMio4LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLlFVRVJZX1JFU09MVkV9KSkpfWNhcHR1cmVCZWdpbigpe3NlKFwiaW5mb1wiLFwiY2FwdHVyZUJlZ2luXCIpLHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJjYXB0dXJpbmdcIn1jYXB0dXJlRW5kKCl7c2UoXCJpbmZvXCIsXCJjYXB0dXJlRW5kXCIpLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCJ9cmVwbGF5KCl7c2UoXCJpbmZvXCIsXCJyZXBsYXlcIiksdGhpcy5zZXNzaW9uU3RhdHVzPVwicmVwbGF5aW5nXCI7bGV0IHQ9dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLHI9dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLG49dC5sZW5ndGg7dGhpcy5wZW5kaW5nS2VybmVscz1bXTtmb3IobGV0IG89MDtvPG47bysrKXtsZXQgaT10aGlzLmdldENvbXB1dGVQYXNzRW5jb2RlcigpLGE9dFtvXTt0aGlzLndyaXRlVGltZXN0YW1wKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIpLGkuc2V0UGlwZWxpbmUoYS5jb21wdXRlUGlwZWxpbmUpLGkuc2V0QmluZEdyb3VwKDAsYS5iaW5kR3JvdXApLGkuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLmEuZGlzcGF0Y2hHcm91cCksdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzEpLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHJbb10pLCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5tYXhEaXNwYXRjaE51bWJlcnx8dGhpcy5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiKSYmdGhpcy5lbmRDb21wdXRlUGFzcygpLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLm1heERpc3BhdGNoTnVtYmVyJiZ0aGlzLmZsdXNoKCl9dGhpcy5mbHVzaCgpLHRoaXMuc2Vzc2lvblN0YXR1cz1cImRlZmF1bHRcIn1vbkNyZWF0ZVNlc3Npb24oKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm9uQ3JlYXRlU2Vzc2lvbigpfW9uUmVsZWFzZVNlc3Npb24odCl7dGhpcy51bnJlZ2lzdGVyQnVmZmVycyh0KSx0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHQpJiZ0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZGVsZXRlKHQpLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5oYXModCkmJnRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5kZWxldGUodCksdGhpcy5ncHVEYXRhTWFuYWdlci5vblJlbGVhc2VTZXNzaW9uKHQpfW9uUnVuU3RhcnQodCl7dGhpcy5jdXJyZW50U2Vzc2lvbklkPXQsdGhpcy5zZXRRdWVyeVR5cGUoKX19fSk7dmFyIGxnLGVjLGNnLHRjLG9uLGFuLEFvLHJjLG5jPVUoKCk9PntcInVzZSBzdHJpY3RcIjtldCgpO2xnPTEsZWM9KCk9PmxnKyssY2c9bmV3IE1hcChbW1wiZmxvYXQzMlwiLDMyXSxbXCJmbG9hdDE2XCIsMTZdLFtcImludDMyXCIsMzJdLFtcInVpbnQzMlwiLDMyXSxbXCJpbnQ2NFwiLDY0XSxbXCJ1aW50NjRcIiw2NF0sW1wiaW50OFwiLDhdLFtcInVpbnQ4XCIsOF0sW1wiaW50NFwiLDRdLFtcInVpbnQ0XCIsNF1dKSx0Yz0oZSx0KT0+e2xldCByPWNnLmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUuXCIpO3JldHVybiB0Lmxlbmd0aD4wP01hdGguY2VpbCh0LnJlZHVjZSgobixvKT0+bipvKSpyLzgpOjB9LG9uPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbklkPXQuc2Vzc2lvbklkLHRoaXMubWxDb250ZXh0PXQuY29udGV4dCx0aGlzLm1sVGVuc29yPXQudGVuc29yLHRoaXMuZGF0YVR5cGU9dC5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlPXQuc2hhcGV9Z2V0IHRlbnNvcigpe3JldHVybiB0aGlzLm1sVGVuc29yfWdldCB0eXBlKCl7cmV0dXJuIHRoaXMuZGF0YVR5cGV9Z2V0IHNoYXBlKCl7cmV0dXJuIHRoaXMudGVuc29yU2hhcGV9Z2V0IGJ5dGVMZW5ndGgoKXtyZXR1cm4gdGModGhpcy5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlKX1kZXN0cm95KCl7c2UoXCJ2ZXJib3NlXCIsKCk9PlwiW1dlYk5OXSBUZW5zb3JXcmFwcGVyLmRlc3Ryb3lcIiksdGhpcy5tbFRlbnNvci5kZXN0cm95KCl9d3JpdGUodCl7dGhpcy5tbENvbnRleHQud3JpdGVUZW5zb3IodGhpcy5tbFRlbnNvcix0KX1hc3luYyByZWFkKHQpe3JldHVybiB0P3RoaXMubWxDb250ZXh0LnJlYWRUZW5zb3IodGhpcy5tbFRlbnNvcix0KTp0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpfWNhblJldXNlVGVuc29yKHQscixuKXtyZXR1cm4gdGhpcy5tbENvbnRleHQ9PT10JiZ0aGlzLmRhdGFUeXBlPT09ciYmdGhpcy50ZW5zb3JTaGFwZS5sZW5ndGg9PT1uLmxlbmd0aCYmdGhpcy50ZW5zb3JTaGFwZS5ldmVyeSgobyxpKT0+bz09PW5baV0pfX0sYW49Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLnRlbnNvck1hbmFnZXI9dDt0aGlzLndyYXBwZXI9cn1nZXQgdGVuc29yV3JhcHBlcigpe3JldHVybiB0aGlzLndyYXBwZXJ9cmVsZWFzZVRlbnNvcigpe3RoaXMudGVuc29yV3JhcHBlciYmKHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMudGVuc29yV3JhcHBlciksdGhpcy53cmFwcGVyPXZvaWQgMCl9YXN5bmMgZW5zdXJlVGVuc29yKHQscixuLG8pe2lmKHRoaXMud3JhcHBlcil7aWYodGhpcy53cmFwcGVyLmNhblJldXNlVGVuc29yKHQscixuKSlyZXR1cm4gdGhpcy53cmFwcGVyLnRlbnNvcjtpZihvKXtpZih0aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCE9PXRjKHIsbikpdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkgZGF0YSB0byB0ZW5zb3Igd2l0aCBkaWZmZXJlbnQgc2l6ZS5cIik7dGhpcy5hY3RpdmVVcGxvYWQ9bmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy53cmFwcGVyLnJlYWQoKSl9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy53cmFwcGVyKX1sZXQgaT10eXBlb2YgTUxUZW5zb3JVc2FnZT5cInVcIj92b2lkIDA6TUxUZW5zb3JVc2FnZS5SRUFEfE1MVGVuc29yVXNhZ2UuV1JJVEU7cmV0dXJuIHRoaXMud3JhcHBlcj1hd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZ2V0Q2FjaGVkVGVuc29yKHIsbixpLCEwLCEwKSxvJiZ0aGlzLmFjdGl2ZVVwbG9hZCYmKHRoaXMud3JhcHBlci53cml0ZSh0aGlzLmFjdGl2ZVVwbG9hZCksdGhpcy5hY3RpdmVVcGxvYWQ9dm9pZCAwKSx0aGlzLndyYXBwZXIudGVuc29yfXVwbG9hZCh0KXtpZih0aGlzLndyYXBwZXIpaWYodC5ieXRlTGVuZ3RoPT09dGhpcy53cmFwcGVyLmJ5dGVMZW5ndGgpe3RoaXMud3JhcHBlci53cml0ZSh0KTtyZXR1cm59ZWxzZSBzZShcInZlcmJvc2VcIiwoKT0+XCJEYXRhIHNpemUgZG9lcyBub3QgbWF0Y2ggdGVuc29yIHNpemUuIFJlbGVhc2luZyB0ZW5zb3IuXCIpLHRoaXMucmVsZWFzZVRlbnNvcigpO3RoaXMuYWN0aXZlVXBsb2FkP3RoaXMuYWN0aXZlVXBsb2FkLnNldCh0KTp0aGlzLmFjdGl2ZVVwbG9hZD1uZXcgVWludDhBcnJheSh0KX1hc3luYyBkb3dubG9hZCh0KXtpZih0aGlzLmFjdGl2ZVVwbG9hZClpZih0KXt0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/bmV3IFVpbnQ4QXJyYXkodCkuc2V0KHRoaXMuYWN0aXZlVXBsb2FkKTpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKS5zZXQodGhpcy5hY3RpdmVVcGxvYWQpO3JldHVybn1lbHNlIHJldHVybiB0aGlzLmFjdGl2ZVVwbG9hZC5idWZmZXI7aWYoIXRoaXMud3JhcHBlcil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaGFzIG5vdCBiZWVuIGNyZWF0ZWQuXCIpO3JldHVybiB0P3RoaXMud3JhcHBlci5yZWFkKHQpOnRoaXMud3JhcHBlci5yZWFkKCl9fSxBbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnRlbnNvclRyYWNrZXJzQnlJZD1uZXcgTWFwO3RoaXMuZnJlZVRlbnNvcnM9W107dGhpcy5leHRlcm5hbFRlbnNvcnM9bmV3IFNldH1yZXNlcnZlVGVuc29ySWQoKXtsZXQgdD1lYygpO3JldHVybiB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5zZXQodCxuZXcgYW4odGhpcykpLHR9cmVsZWFzZVRlbnNvcklkKHQpe2xldCByPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtyJiYodGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZGVsZXRlKHQpLHIudGVuc29yV3JhcHBlciYmdGhpcy5yZWxlYXNlVGVuc29yKHIudGVuc29yV3JhcHBlcikpfWFzeW5jIGVuc3VyZVRlbnNvcih0LHIsbixvKXtzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gVGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ige3RlbnNvcklkOiAke3R9LCBkYXRhVHlwZTogJHtyfSwgc2hhcGU6ICR7bn0sIGNvcHlPbGQ6ICR7b319YCk7bGV0IGk9dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO2lmKCFpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO3JldHVybiBpLmVuc3VyZVRlbnNvcih0aGlzLmJhY2tlbmQuY3VycmVudENvbnRleHQscixuLG8pfXVwbG9hZCh0LHIpe2xldCBuPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtuLnVwbG9hZChyKX1hc3luYyBkb3dubG9hZCh0LHIpe3NlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmRvd25sb2FkIHt0ZW5zb3JJZDogJHt0fSwgZHN0QnVmZmVyOiAke3I/LmJ5dGVMZW5ndGh9fWApO2xldCBuPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtyZXR1cm4gbi5kb3dubG9hZChyKX1yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCl7Zm9yKGxldCByIG9mIHRoaXMuZnJlZVRlbnNvcnMpci5zZXNzaW9uSWQ9PT10JiZyLmRlc3Ryb3koKTt0aGlzLmZyZWVUZW5zb3JzPXRoaXMuZnJlZVRlbnNvcnMuZmlsdGVyKHI9PnIuc2Vzc2lvbklkIT09dCl9cmVnaXN0ZXJUZW5zb3IodCxyLG4sbyl7bGV0IGk9ZWMoKSxhPW5ldyBvbih7c2Vzc2lvbklkOnRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkLGNvbnRleHQ6dCx0ZW5zb3I6cixkYXRhVHlwZTpuLHNoYXBlOm99KTtyZXR1cm4gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KGksbmV3IGFuKHRoaXMsYSkpLHRoaXMuZXh0ZXJuYWxUZW5zb3JzLmFkZChhKSxpfWFzeW5jIGdldENhY2hlZFRlbnNvcih0LHIsbixvLGkpe2xldCBhPXRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkLGQ9dGhpcy5iYWNrZW5kLmN1cnJlbnRDb250ZXh0O2ZvcihsZXRbcCxtXW9mIHRoaXMuZnJlZVRlbnNvcnMuZW50cmllcygpKWlmKG0uY2FuUmV1c2VUZW5zb3IoZCx0LHIpKXtzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gUmV1c2luZyB0ZW5zb3Ige2RhdGFUeXBlOiAke3R9LCBzaGFwZTogJHtyfX1gKTtsZXQgdT10aGlzLmZyZWVUZW5zb3JzLnNwbGljZShwLDEpWzBdO3JldHVybiB1LnNlc3Npb25JZD1hLHV9c2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIE1MQ29udGV4dC5jcmVhdGVUZW5zb3Ige2RhdGFUeXBlOiAke3R9LCBzaGFwZTogJHtyfX1gKTtsZXQgbD1hd2FpdCBkLmNyZWF0ZVRlbnNvcih7ZGF0YVR5cGU6dCxzaGFwZTpyLGRpbWVuc2lvbnM6cix1c2FnZTpuLHdyaXRhYmxlOm8scmVhZGFibGU6aX0pO3JldHVybiBuZXcgb24oe3Nlc3Npb25JZDphLGNvbnRleHQ6ZCx0ZW5zb3I6bCxkYXRhVHlwZTp0LHNoYXBlOnJ9KX1yZWxlYXNlVGVuc29yKHQpe3RoaXMuZXh0ZXJuYWxUZW5zb3JzLmhhcyh0KSYmdGhpcy5leHRlcm5hbFRlbnNvcnMuZGVsZXRlKHQpLHRoaXMuZnJlZVRlbnNvcnMucHVzaCh0KX19LHJjPSguLi5lKT0+bmV3IEFvKC4uLmUpfSk7dmFyIG9jLHBnLHNuLGljPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7Z3QoKTtYbigpO25jKCk7ZXQoKTtvYz1uZXcgTWFwKFtbMSxcImZsb2F0MzJcIl0sWzEwLFwiZmxvYXQxNlwiXSxbNixcImludDMyXCJdLFsxMixcInVpbnQzMlwiXSxbNyxcImludDY0XCJdLFsxMyxcInVpbnQ2NFwiXSxbMjIsXCJpbnQ0XCJdLFsyMSxcInVpbnQ0XCJdLFszLFwiaW50OFwiXSxbMixcInVpbnQ4XCJdLFs5LFwidWludDhcIl1dKSxwZz0oZSx0KT0+e2lmKGU9PT10KXJldHVybiEwO2lmKGU9PT12b2lkIDB8fHQ9PT12b2lkIDApcmV0dXJuITE7bGV0IHI9T2JqZWN0LmtleXMoZSkuc29ydCgpLG49T2JqZWN0LmtleXModCkuc29ydCgpO3JldHVybiByLmxlbmd0aD09PW4ubGVuZ3RoJiZyLmV2ZXJ5KChvLGkpPT5vPT09bltpXSYmZVtvXT09PXRbb10pfSxzbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnRlbnNvck1hbmFnZXI9cmModGhpcyk7dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZD1uZXcgTWFwO3RoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0PW5ldyBNYXA7dGhpcy5tbENvbnRleHRDYWNoZT1bXTtNcih0LmxvZ0xldmVsLCEhdC5kZWJ1Zyl9Z2V0IGN1cnJlbnRTZXNzaW9uSWQoKXtpZih0aGlzLmFjdGl2ZVNlc3Npb25JZD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJObyBhY3RpdmUgc2Vzc2lvblwiKTtyZXR1cm4gdGhpcy5hY3RpdmVTZXNzaW9uSWR9b25SdW5TdGFydCh0KXt0aGlzLmFjdGl2ZVNlc3Npb25JZD10fWFzeW5jIGNyZWF0ZU1MQ29udGV4dCh0KXtpZih0IGluc3RhbmNlb2YgR1BVRGV2aWNlKXtsZXQgbj10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChvPT5vLmdwdURldmljZT09PXQpO2lmKG4hPT0tMSlyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZVtuXS5tbENvbnRleHQ7e2xldCBvPWF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KHQpO3JldHVybiB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goe2dwdURldmljZTp0LG1sQ29udGV4dDpvfSksb319ZWxzZSBpZih0PT09dm9pZCAwKXtsZXQgbj10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChvPT5vLm9wdGlvbnM9PT12b2lkIDAmJm8uZ3B1RGV2aWNlPT09dm9pZCAwKTtpZihuIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbl0ubWxDb250ZXh0O3tsZXQgbz1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCgpO3JldHVybiB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goe21sQ29udGV4dDpvfSksb319bGV0IHI9dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobj0+cGcobi5vcHRpb25zLHQpKTtpZihyIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbcl0ubWxDb250ZXh0O3tsZXQgbj1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh0KTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHtvcHRpb25zOnQsbWxDb250ZXh0Om59KSxufX1nZXQgY3VycmVudENvbnRleHQoKXtsZXQgdD10aGlzLmdldE1MQ29udGV4dCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpO2lmKCF0KXRocm93IG5ldyBFcnJvcihgTm8gTUxDb250ZXh0IGZvdW5kIGZvciBzZXNzaW9uICR7dGhpcy5jdXJyZW50U2Vzc2lvbklkfWApO3JldHVybiB0fXJlZ2lzdGVyTUxDb250ZXh0KHQscil7dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5zZXQodCxyKTtsZXQgbj10aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5nZXQocik7bnx8KG49bmV3IFNldCx0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5zZXQocixuKSksbi5hZGQodCl9b25SZWxlYXNlU2Vzc2lvbih0KXtsZXQgcj10aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldCh0KTtpZighcilyZXR1cm47dGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbih0KSx0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmRlbGV0ZSh0KTtsZXQgbj10aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5nZXQocik7aWYobi5kZWxldGUodCksbi5zaXplPT09MCl7dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZGVsZXRlKHIpO2xldCBvPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KGk9PmkubWxDb250ZXh0PT09cik7byE9PS0xJiZ0aGlzLm1sQ29udGV4dENhY2hlLnNwbGljZShvLDEpfX1nZXRNTENvbnRleHQodCl7cmV0dXJuIHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZ2V0KHQpfXJlc2VydmVUZW5zb3JJZCgpe3JldHVybiB0aGlzLnRlbnNvck1hbmFnZXIucmVzZXJ2ZVRlbnNvcklkKCl9cmVsZWFzZVRlbnNvcklkKHQpe3NlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSByZWxlYXNlVGVuc29ySWQge3RlbnNvcklkOiAke3R9fWApLHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29ySWQodCl9YXN5bmMgZW5zdXJlVGVuc29yKHQscixuLG8pe2xldCBpPW9jLmdldChyKTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke3J9YCk7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3IodCxpLG4sbyl9dXBsb2FkVGVuc29yKHQscil7aWYoIVRlKCkuc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yKXRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byB1cGxvYWQgdG8gYSBNTFRlbnNvciB3aGlsZSBzaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IgaXMgZmFsc2VcIik7c2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHVwbG9hZFRlbnNvciB7dGVuc29ySWQ6ICR7dH0sIGRhdGE6ICR7ci5ieXRlTGVuZ3RofX1gKSx0aGlzLnRlbnNvck1hbmFnZXIudXBsb2FkKHQscil9YXN5bmMgZG93bmxvYWRUZW5zb3IodCxyKXtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHQscil9Y3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKHQscil7cmV0dXJuIGFzeW5jKCk9PntsZXQgbj1hd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZG93bmxvYWQodCk7cmV0dXJuIFJyKG4scil9fXJlZ2lzdGVyTUxUZW5zb3IodCxyLG4pe2xldCBvPW9jLmdldChyKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke3J9YCk7bGV0IGk9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlZ2lzdGVyVGVuc29yKHRoaXMuY3VycmVudENvbnRleHQsdCxvLG4pO3JldHVybiBzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVnaXN0ZXJNTFRlbnNvciB7dGVuc29yOiAke3R9LCBkYXRhVHlwZTogJHtvfSwgZGltZW5zaW9uczogJHtufX0gLT4ge3RlbnNvcklkOiAke2l9fWApLGl9cmVnaXN0ZXJNTENvbnN0YW50KHQscixuLG8saSxhKXtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJFeHRlcm5hbCBtb3VudGVkIGZpbGVzIGFyZSBub3QgYXZhaWxhYmxlLlwiKTtsZXQgZD10O3Quc3RhcnRzV2l0aChcIi4vXCIpJiYoZD10LnN1YnN0cmluZygyKSk7bGV0IGw9YS5nZXQoZCk7aWYoIWwpdGhyb3cgbmV3IEVycm9yKGBGaWxlIHdpdGggbmFtZSAke2R9IG5vdCBmb3VuZCBpbiBwcmVsb2FkZWQgZmlsZXMuYCk7aWYocituPmwuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJPdXQgb2YgYm91bmRzOiBkYXRhIG9mZnNldCBhbmQgbGVuZ3RoIGV4Y2VlZCB0aGUgZXh0ZXJuYWwgZmlsZSBkYXRhIHNpemUuXCIpO2xldCBwPWwuc2xpY2UocixyK24pLmJ1ZmZlcixtO3N3aXRjaChpLmRhdGFUeXBlKXtjYXNlXCJmbG9hdDMyXCI6bT1uZXcgRmxvYXQzMkFycmF5KHApO2JyZWFrO2Nhc2VcImZsb2F0MTZcIjptPW5ldyBVaW50MTZBcnJheShwKTticmVhaztjYXNlXCJpbnQzMlwiOm09bmV3IEludDMyQXJyYXkocCk7YnJlYWs7Y2FzZVwidWludDMyXCI6bT1uZXcgVWludDMyQXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50NjRcIjptPW5ldyBCaWdJbnQ2NEFycmF5KHApO2JyZWFrO2Nhc2VcInVpbnQ2NFwiOm09bmV3IEJpZ1VpbnQ2NEFycmF5KHApO2JyZWFrO2Nhc2VcImludDhcIjptPW5ldyBJbnQ4QXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50NFwiOmNhc2VcInVpbnQ0XCI6Y2FzZVwidWludDhcIjptPW5ldyBVaW50OEFycmF5KHApO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7aS5kYXRhVHlwZX0gaW4gY3JlYXRpbmcgV2ViTk4gQ29uc3RhbnQgZnJvbSBleHRlcm5hbCBkYXRhLmApfXJldHVybiBzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVnaXN0ZXJNTENvbnN0YW50IHtkYXRhVHlwZTogJHtpLmRhdGFUeXBlfSwgc2hhcGU6ICR7aS5zaGFwZX19fWApLG8uY29uc3RhbnQoaSxtKX1mbHVzaCgpe319fSk7dmFyIGFjPXt9O0h0KGFjLHtpbml0OigpPT5tZ30pO3ZhciB0cixrbyxtZyxzYz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO0psKCk7ZXQoKTtuZSgpO2ljKCk7dHI9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LHIsbixvKXt0aGlzLm1vZHVsZT10O3RoaXMuZGF0YVR5cGU9cjt0aGlzLmRhdGE9bjt0aGlzLmRpbXM9b31nZXRGbG9hdDMyQXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1rLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEZsb2F0MzJBcnJheTpuZXcgRmxvYXQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0QmlnSW50NjRBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PWsuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgQmlnSW50NjRBcnJheTpuZXcgQmlnSW50NjRBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEludDMyQXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1rLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEludDMyQXJyYXk6bmV3IEludDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRVaW50MTZBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT0xMCYmdGhpcy5kYXRhVHlwZSE9PTQpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9ay5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBVaW50MTZBcnJheTpuZXcgVWludDE2QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1yZXNoYXBlKHQpe2lmKGsuc2l6ZSh0KSE9PWsuc2l6ZSh0aGlzLmRpbXMpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbmV3IHNoYXBlXCIpO3JldHVybiBuZXcgZSh0aGlzLm1vZHVsZSx0aGlzLmRhdGFUeXBlLHRoaXMuZGF0YSx0KX19LGtvPWNsYXNze2NvbnN0cnVjdG9yKHQscixuKXt0aGlzLm1vZHVsZT10O3RoaXMuYmFja2VuZD1yO3RoaXMuY3VzdG9tRGF0YU9mZnNldD0wO3RoaXMuY3VzdG9tRGF0YVNpemU9MDt0aGlzLmFkYXB0ZXJJbmZvPXIuYWRhcHRlckluZm8sdGhpcy5kZXZpY2VJbmZvPXIuZGV2aWNlSW5mbztsZXQgbz10LlBUUl9TSVpFLGk9bi90LlBUUl9TSVpFLGE9bz09PTQ/XCJpMzJcIjpcImk2NFwiO3RoaXMub3BLZXJuZWxDb250ZXh0PU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKTtsZXQgZD1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSk7dGhpcy5vdXRwdXRDb3VudD1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSksdGhpcy5jdXN0b21EYXRhT2Zmc2V0PU51bWJlcih0LmdldFZhbHVlKG8qaSsrLFwiKlwiKSksdGhpcy5jdXN0b21EYXRhU2l6ZT1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSk7bGV0IGw9W107Zm9yKGxldCBwPTA7cDxkO3ArKyl7bGV0IG09TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpLHU9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssXCIqXCIpKSxoPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKSxfPVtdO2ZvcihsZXQgeT0wO3k8aDt5KyspXy5wdXNoKE51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKSk7bC5wdXNoKG5ldyB0cih0LG0sdSxfKSl9dGhpcy5pbnB1dHM9bH1nZXQga2VybmVsQ3VzdG9tRGF0YSgpe3JldHVybiB0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbEN1c3RvbURhdGF9Z2V0IGN1c3RvbURhdGFCdWZmZXIoKXtyZXR1cm4gdGhpcy5tb2R1bGUuSEVBUFU4LnN1YmFycmF5KHRoaXMuY3VzdG9tRGF0YU9mZnNldCx0aGlzLmN1c3RvbURhdGFPZmZzZXQrdGhpcy5jdXN0b21EYXRhU2l6ZSl9Y29tcHV0ZSh0LHIpe2xldCBuPXI/LmlucHV0cz8ubWFwKGQ9PnR5cGVvZiBkPT1cIm51bWJlclwiP3RoaXMuaW5wdXRzW2RdOmQpPz90aGlzLmlucHV0cyxvPXI/Lm91dHB1dHM/P1tdLGk9KGQsbCxwKT0+bmV3IHRyKHRoaXMubW9kdWxlLGwsdGhpcy5vdXRwdXQoZCxwKSxwKSxhPShkLGwpPT57bGV0IHA9QXQoZCxsKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkfWApO2xldCBtPXA+MD90aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHApLmlkOjA7cmV0dXJuIG5ldyB0cih0aGlzLm1vZHVsZSxkLG0sbCl9O3JldHVybiB0aGlzLmJhY2tlbmQucnVuKHQsbixvLGksYSx0aGlzLm91dHB1dENvdW50KX1vdXRwdXQodCxyKXtsZXQgbj10aGlzLm1vZHVsZS5zdGFja1NhdmUoKTt0cnl7bGV0IG89dGhpcy5tb2R1bGUuUFRSX1NJWkUsaT1vPT09ND9cImkzMlwiOlwiaTY0XCIsYT10aGlzLm1vZHVsZS5zdGFja0FsbG9jKCgxK3IubGVuZ3RoKSpvKTt0aGlzLm1vZHVsZS5zZXRWYWx1ZShhLHIubGVuZ3RoLGkpO2ZvcihsZXQgZD0wO2Q8ci5sZW5ndGg7ZCsrKXRoaXMubW9kdWxlLnNldFZhbHVlKGErbyooZCsxKSxyW2RdLGkpO3JldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCh0aGlzLm9wS2VybmVsQ29udGV4dCx0LGEpfWNhdGNoKG8pe3Rocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIGtlcm5lbCdzIG91dHB1dFske3R9XSB3aXRoIGRpbXMgWyR7cn1dLiBJZiB5b3UgYXJlIHJ1bm5pbmcgd2l0aCBwcmUtYWxsb2NhdGVkIG91dHB1dCwgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3V0cHV0IHR5cGUvZGltcyBhcmUgY29ycmVjdC4gRXJyb3I6ICR7b31gKX1maW5hbGx5e3RoaXMubW9kdWxlLnN0YWNrUmVzdG9yZShuKX19fSxtZz1hc3luYyhlLHQscixuKT0+e2xldCBvPXQuanNlcEluaXQ7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgSlNFUC4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQuXCIpO2lmKGU9PT1cIndlYmdwdVwiKXtsZXQgaT1uZXcgbm47YXdhaXQgaS5pbml0aWFsaXplKHIsbiksbyhcIndlYmdwdVwiLFtpLGE9PmkuYWxsb2MoTnVtYmVyKGEpKSxhPT5pLmZyZWUoYSksKGEsZCxsLHA9ITEpPT57aWYocClzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke051bWJlcihhKX0sIGRzdD0ke051bWJlcihkKX0sIHNpemU9JHtOdW1iZXIobCl9YCksaS5tZW1jcHkoTnVtYmVyKGEpLE51bWJlcihkKSk7ZWxzZXtzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5Q3B1VG9HcHU6IGRhdGFPZmZzZXQ9JHtOdW1iZXIoYSl9LCBncHVEYXRhSWQ9JHtOdW1iZXIoZCl9LCBzaXplPSR7TnVtYmVyKGwpfWApO2xldCBtPXQuSEVBUFU4LnN1YmFycmF5KE51bWJlcihhPj4+MCksTnVtYmVyKGE+Pj4wKStOdW1iZXIobCkpO2kudXBsb2FkKE51bWJlcihkKSxtKX19LGFzeW5jKGEsZCxsKT0+e3NlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0NwdTogZ3B1RGF0YUlkPSR7YX0sIGRhdGFPZmZzZXQ9JHtkfSwgc2l6ZT0ke2x9YCksYXdhaXQgaS5kb3dubG9hZChOdW1iZXIoYSksKCk9PnQuSEVBUFU4LnN1YmFycmF5KE51bWJlcihkKT4+PjAsTnVtYmVyKGQrbCk+Pj4wKSl9LChhLGQsbCk9PmkuY3JlYXRlS2VybmVsKGEsTnVtYmVyKGQpLGwsdC5VVEY4VG9TdHJpbmcodC5fSnNlcEdldE5vZGVOYW1lKE51bWJlcihkKSkpKSxhPT5pLnJlbGVhc2VLZXJuZWwoYSksKGEsZCxsLHApPT57c2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwUnVuOiBzZXNzaW9uSGFuZGxlPSR7bH0sIGtlcm5lbD0ke2F9LCBjb250ZXh0RGF0YU9mZnNldD0ke2R9YCk7bGV0IG09bmV3IGtvKHQsaSxOdW1iZXIoZCkpO3JldHVybiBpLmNvbXB1dGVLZXJuZWwoTnVtYmVyKGEpLG0scCl9LCgpPT5pLmNhcHR1cmVCZWdpbigpLCgpPT5pLmNhcHR1cmVFbmQoKSwoKT0+aS5yZXBsYXkoKV0pfWVsc2V7bGV0IGk9bmV3IHNuKHIpO28oXCJ3ZWJublwiLFtpLCgpPT5pLnJlc2VydmVUZW5zb3JJZCgpLGE9PmkucmVsZWFzZVRlbnNvcklkKGEpLGFzeW5jKGEsZCxsLHApPT5pLmVuc3VyZVRlbnNvcihhLGQsbCxwKSwoYSxkKT0+e2kudXBsb2FkVGVuc29yKGEsZCl9LGFzeW5jKGEsZCk9PmkuZG93bmxvYWRUZW5zb3IoYSxkKV0pfX19KTt2YXIgZmcsU3IsVHIsenQsaGcscXQsSXIsQ3IsdWMsQXIsa3IsRXIsRm49VSgoKT0+e1widXNlIHN0cmljdFwiO0dhKCk7RmEoKTtKKCk7Z3QoKTt6cigpO1FuKCk7Zmc9KGUsdCk9PntUZSgpLl9PcnRJbml0KGUsdCkhPT0wJiZjZShcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpfSxTcj1hc3luYyBlPT57ZmcoZS53YXNtLm51bVRocmVhZHMsWXQoZS5sb2dMZXZlbCkpfSxUcj1hc3luYyhlLHQpPT57e2xldCByPShzYygpLGdyKGFjKSkuaW5pdDtpZih0PT09XCJ3ZWJncHVcIil7aWYodHlwZW9mIG5hdmlnYXRvcj5cInVcInx8IW5hdmlnYXRvci5ncHUpdGhyb3cgbmV3IEVycm9yKFwiV2ViR1BVIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTtsZXQgbj1lLndlYmdwdS5hZGFwdGVyO2lmKG4pe2lmKHR5cGVvZiBuLmxpbWl0cyE9XCJvYmplY3RcInx8dHlwZW9mIG4uZmVhdHVyZXMhPVwib2JqZWN0XCJ8fHR5cGVvZiBuLnJlcXVlc3REZXZpY2UhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdQVSBhZGFwdGVyIHNldCBpbiBgZW52LndlYmdwdS5hZGFwdGVyYC4gSXQgbXVzdCBiZSBhIEdQVUFkYXB0ZXIgb2JqZWN0LlwiKX1lbHNle2xldCBvPWUud2ViZ3B1LnBvd2VyUHJlZmVyZW5jZTtpZihvIT09dm9pZCAwJiZvIT09XCJsb3ctcG93ZXJcIiYmbyE9PVwiaGlnaC1wZXJmb3JtYW5jZVwiKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke299XCJgKTtsZXQgaT1lLndlYmdwdS5mb3JjZUZhbGxiYWNrQWRhcHRlcjtpZihpIT09dm9pZCAwJiZ0eXBlb2YgaSE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcmNlRmFsbGJhY2tBZGFwdGVyIHNldHRpbmc6IFwiJHtpfVwiYCk7aWYobj1hd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKHtwb3dlclByZWZlcmVuY2U6byxmb3JjZUZhbGxiYWNrQWRhcHRlcjppfSksIW4pdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IEdQVSBhZGFwdGVyLiBZb3UgbWF5IG5lZWQgdG8gZW5hYmxlIGZsYWcgXCItLWVuYWJsZS11bnNhZmUtd2ViZ3B1XCIgaWYgeW91IGFyZSB1c2luZyBDaHJvbWUuJyl9YXdhaXQgcihcIndlYmdwdVwiLFRlKCksZSxuKX1pZih0PT09XCJ3ZWJublwiKXtpZih0eXBlb2YgbmF2aWdhdG9yPlwidVwifHwhbmF2aWdhdG9yLm1sKXRocm93IG5ldyBFcnJvcihcIldlYk5OIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTthd2FpdCByKFwid2Vibm5cIixUZSgpLGUpfX19LHp0PW5ldyBNYXAsaGc9ZT0+e2xldCB0PVRlKCkscj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgbj10LlBUUl9TSVpFLG89dC5zdGFja0FsbG9jKDIqbik7dC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLG8sbytuKSE9PTAmJmNlKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtsZXQgYT1uPT09ND9cImkzMlwiOlwiaTY0XCI7cmV0dXJuW051bWJlcih0LmdldFZhbHVlKG8sYSkpLE51bWJlcih0LmdldFZhbHVlKG8rbixhKSldfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fSxxdD1lPT57bGV0IHQ9VGUoKSxyPXQuX21hbGxvYyhlLmJ5dGVMZW5ndGgpO2lmKHI9PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHtlLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoZSxyKSxbcixlLmJ5dGVMZW5ndGhdfSxJcj1hc3luYyhlLHQpPT57bGV0IHIsbixvPVRlKCk7QXJyYXkuaXNBcnJheShlKT9bcixuXT1lOmUuYnVmZmVyPT09by5IRUFQVTguYnVmZmVyP1tyLG5dPVtlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoXTpbcixuXT1xdChlKTtsZXQgaT0wLGE9MCxkPTAsbD1bXSxwPVtdLG09W107dHJ5e2lmKFthLGxdPUhhKHQpLHQ/LmV4dGVybmFsRGF0YSYmby5tb3VudEV4dGVybmFsRGF0YSl7bGV0IHY9W107Zm9yKGxldCBTIG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgVD10eXBlb2YgUz09XCJzdHJpbmdcIj9TOlMucGF0aDt2LnB1c2goWnQodHlwZW9mIFM9PVwic3RyaW5nXCI/UzpTLmRhdGEpLnRoZW4oQT0+e28ubW91bnRFeHRlcm5hbERhdGEoVCxBKX0pKX1hd2FpdCBQcm9taXNlLmFsbCh2KX1mb3IobGV0IHYgb2YgdD8uZXhlY3V0aW9uUHJvdmlkZXJzPz9bXSlpZigodHlwZW9mIHY9PVwic3RyaW5nXCI/djp2Lm5hbWUpPT09XCJ3ZWJublwiKXtpZihvLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMSx0eXBlb2YgdiE9XCJzdHJpbmdcIil7bGV0IFQ9dixBPVQ/LmNvbnRleHQsQz1UPy5ncHVEZXZpY2UsUD1UPy5kZXZpY2VUeXBlLEQ9VD8ucG93ZXJQcmVmZXJlbmNlO0E/by5jdXJyZW50Q29udGV4dD1BOkM/by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoQyk6by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoe2RldmljZVR5cGU6UCxwb3dlclByZWZlcmVuY2U6RH0pfWVsc2Ugby5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoKTticmVha31pPWF3YWl0IG8uX09ydENyZWF0ZVNlc3Npb24ocixuLGEpLGk9PT0wJiZjZShcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb24uXCIpLG8uanNlcE9uQ3JlYXRlU2Vzc2lvbj8uKCksby5jdXJyZW50Q29udGV4dCYmKG8uanNlcFJlZ2lzdGVyTUxDb250ZXh0KGksby5jdXJyZW50Q29udGV4dCksby5jdXJyZW50Q29udGV4dD12b2lkIDAsby5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3I9ITApO2xldFt1LGhdPWhnKGkpLF89ISF0Py5lbmFibGVHcmFwaENhcHR1cmUseT1bXSxnPVtdLHg9W107Zm9yKGxldCB2PTA7djx1O3YrKyl7bGV0IFM9by5fT3J0R2V0SW5wdXROYW1lKGksdik7Uz09PTAmJmNlKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLHAucHVzaChTKSx5LnB1c2goby5VVEY4VG9TdHJpbmcoUykpfWZvcihsZXQgdj0wO3Y8aDt2Kyspe2xldCBTPW8uX09ydEdldE91dHB1dE5hbWUoaSx2KTtTPT09MCYmY2UoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLG0ucHVzaChTKTtsZXQgVD1vLlVURjhUb1N0cmluZyhTKTtnLnB1c2goVCk7e2lmKF8mJnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPT09dm9pZCAwKXt4LnB1c2goXCJncHUtYnVmZmVyXCIpO2NvbnRpbnVlfWxldCBBPXR5cGVvZiB0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09XCJzdHJpbmdcIj90LnByZWZlcnJlZE91dHB1dExvY2F0aW9uOnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bVF0/P1wiY3B1XCI7aWYoQSE9PVwiY3B1XCImJkEhPT1cImNwdS1waW5uZWRcIiYmQSE9PVwiZ3B1LWJ1ZmZlclwiJiZBIT09XCJtbC10ZW5zb3JcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtBfS5gKTtpZihfJiZBIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7QX0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO3gucHVzaChBKX19bGV0ICQ9bnVsbDtyZXR1cm4geC5zb21lKHY9PnY9PT1cImdwdS1idWZmZXJcInx8dj09PVwibWwtdGVuc29yXCIpJiYoZD1vLl9PcnRDcmVhdGVCaW5kaW5nKGkpLGQ9PT0wJiZjZShcIkNhbid0IGNyZWF0ZSBJTyBiaW5kaW5nLlwiKSwkPXtoYW5kbGU6ZCxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6eCxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOngubWFwKHY9PlpuKHYpKX0pLHp0LnNldChpLFtpLHAsbSwkLF8sITFdKSxbaSx5LGddfWNhdGNoKHUpe3Rocm93IHAuZm9yRWFjaChoPT5vLl9PcnRGcmVlKGgpKSxtLmZvckVhY2goaD0+by5fT3J0RnJlZShoKSksZCE9PTAmJm8uX09ydFJlbGVhc2VCaW5kaW5nKGQpIT09MCYmY2UoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpLGkhPT0wJiZvLl9PcnRSZWxlYXNlU2Vzc2lvbihpKSE9PTAmJmNlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSx1fWZpbmFsbHl7by5fZnJlZShyKSxhIT09MCYmby5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKGEpIT09MCYmY2UoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksbC5mb3JFYWNoKHU9Pm8uX2ZyZWUodSkpLG8udW5tb3VudEV4dGVybmFsRGF0YT8uKCl9fSxDcj1lPT57bGV0IHQ9VGUoKSxyPXp0LmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldFtuLG8saSxhLGRdPXI7YSYmKGQmJnQuX09ydENsZWFyQm91bmRPdXRwdXRzKGEuaGFuZGxlKSE9PTAmJmNlKFwiQ2FuJ3QgY2xlYXIgYm91bmQgb3V0cHV0cy5cIiksdC5fT3J0UmVsZWFzZUJpbmRpbmcoYS5oYW5kbGUpIT09MCYmY2UoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpKSx0LmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oZSksby5mb3JFYWNoKGw9PnQuX09ydEZyZWUobCkpLGkuZm9yRWFjaChsPT50Ll9PcnRGcmVlKGwpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihuKSE9PTAmJmNlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSx6dC5kZWxldGUoZSl9LHVjPShlLHQscixuLG8saT0hMSk9PntpZighZSl7dC5wdXNoKDApO3JldHVybn1sZXQgYT1UZSgpLGQ9YS5QVFJfU0laRSxsPWVbMF0scD1lWzFdLG09ZVszXSx1LGg7aWYobD09PVwic3RyaW5nXCImJihtPT09XCJncHUtYnVmZmVyXCJ8fG09PT1cIm1sLXRlbnNvclwiKSl0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihpJiZtIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7b30gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtpZihtPT09XCJncHUtYnVmZmVyXCIpe2xldCBnPWVbMl0uZ3B1QnVmZmVyO2g9QXQoanQobCkscCk7bGV0IHg9YS5qc2VwUmVnaXN0ZXJCdWZmZXI7aWYoIXgpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTt1PXgobixvLGcsaCl9ZWxzZSBpZihtPT09XCJtbC10ZW5zb3JcIil7bGV0IGc9ZVsyXS5tbFRlbnNvcjtoPUF0KGp0KGwpLHApO2xldCB4PWEuanNlcFJlZ2lzdGVyTUxUZW5zb3I7aWYoIXgpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7dT14KGcsanQobCkscCl9ZWxzZXtsZXQgZz1lWzJdO2lmKEFycmF5LmlzQXJyYXkoZykpe2g9ZCpnLmxlbmd0aCx1PWEuX21hbGxvYyhoKSxyLnB1c2godSk7Zm9yKGxldCB4PTA7eDxnLmxlbmd0aDt4Kyspe2lmKHR5cGVvZiBnW3hdIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7eH0gaXMgbm90IGEgc3RyaW5nYCk7YS5zZXRWYWx1ZSh1K3gqZCxrZShnW3hdLHIpLFwiKlwiKX19ZWxzZSBoPWcuYnl0ZUxlbmd0aCx1PWEuX21hbGxvYyhoKSxyLnB1c2godSksYS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGcuYnVmZmVyLGcuYnl0ZU9mZnNldCxoKSx1KX1sZXQgXz1hLnN0YWNrU2F2ZSgpLHk9YS5zdGFja0FsbG9jKDQqcC5sZW5ndGgpO3RyeXtwLmZvckVhY2goKHgsJCk9PmEuc2V0VmFsdWUoeSskKmQseCxkPT09ND9cImkzMlwiOlwiaTY0XCIpKTtsZXQgZz1hLl9PcnRDcmVhdGVUZW5zb3IoanQobCksdSxoLHkscC5sZW5ndGgsWm4obSkpO2c9PT0wJiZjZShgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7bn0sIGluZGV4PSR7b30uYCksdC5wdXNoKGcpfWZpbmFsbHl7YS5zdGFja1Jlc3RvcmUoXyl9fSxBcj1hc3luYyhlLHQscixuLG8saSk9PntsZXQgYT1UZSgpLGQ9YS5QVFJfU0laRSxsPXp0LmdldChlKTtpZighbCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXQgcD1sWzBdLG09bFsxXSx1PWxbMl0saD1sWzNdLF89bFs0XSx5PWxbNV0sZz10Lmxlbmd0aCx4PW4ubGVuZ3RoLCQ9MCx2PVtdLFM9W10sVD1bXSxBPVtdLEM9YS5zdGFja1NhdmUoKSxQPWEuc3RhY2tBbGxvYyhnKmQpLEQ9YS5zdGFja0FsbG9jKGcqZCksUj1hLnN0YWNrQWxsb2MoeCpkKSxIPWEuc3RhY2tBbGxvYyh4KmQpO3RyeXthLmpzZXBPblJ1blN0YXJ0Py4ocCksWyQsdl09TGEoaSk7Zm9yKGxldCBWPTA7VjxnO1YrKyl1YyhyW1ZdLFMsQSxlLHRbVl0sXyk7Zm9yKGxldCBWPTA7Vjx4O1YrKyl1YyhvW1ZdLFQsQSxlLGcrbltWXSxfKTtmb3IobGV0IFY9MDtWPGc7VisrKWEuc2V0VmFsdWUoUCtWKmQsU1tWXSxcIipcIiksYS5zZXRWYWx1ZShEK1YqZCxtW3RbVl1dLFwiKlwiKTtmb3IobGV0IFY9MDtWPHg7VisrKWEuc2V0VmFsdWUoUitWKmQsVFtWXSxcIipcIiksYS5zZXRWYWx1ZShIK1YqZCx1W25bVl1dLFwiKlwiKTtpZihoJiYheSl7bGV0e2hhbmRsZTpWLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczpLLG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6d2V9PWg7aWYobS5sZW5ndGghPT1nKXRocm93IG5ldyBFcnJvcihgaW5wdXQgY291bnQgZnJvbSBmZWVkcyAoJHtnfSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsJ3MgaW5wdXQgY291bnQgKCR7bS5sZW5ndGh9KS5gKTtmb3IobGV0IGo9MDtqPGc7aisrKXtsZXQgUT10W2pdO2F3YWl0IGEuX09ydEJpbmRJbnB1dChWLG1bUV0sU1tqXSkhPT0wJiZjZShgQ2FuJ3QgYmluZCBpbnB1dFske2p9XSBmb3Igc2Vzc2lvbj0ke2V9LmApfWZvcihsZXQgaj0wO2o8eDtqKyspe2xldCBRPW5bal07b1tqXT8uWzNdP2EuX09ydEJpbmRPdXRwdXQoVix1W1FdLFRbal0sMCkhPT0wJiZjZShgQ2FuJ3QgYmluZCBwcmUtYWxsb2NhdGVkIG91dHB1dFske2p9XSBmb3Igc2Vzc2lvbj0ke2V9LmApOmEuX09ydEJpbmRPdXRwdXQoVix1W1FdLDAsd2VbUV0pIT09MCYmY2UoYENhbid0IGJpbmQgb3V0cHV0WyR7an1dIHRvICR7S1tqXX0gZm9yIHNlc3Npb249JHtlfS5gKX16dC5zZXQoZSxbcCxtLHUsaCxfLCEwXSl9bGV0IEw7aD9MPWF3YWl0IGEuX09ydFJ1bldpdGhCaW5kaW5nKHAsaC5oYW5kbGUseCxSLCQpOkw9YXdhaXQgYS5fT3J0UnVuKHAsRCxQLGcsSCx4LFIsJCksTCE9PTAmJmNlKFwiZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuXCIpO2xldCByZT1bXTtmb3IobGV0IFY9MDtWPHg7VisrKXtsZXQgSz1OdW1iZXIoYS5nZXRWYWx1ZShSK1YqZCxcIipcIikpO2lmKEs9PT1UW1ZdKXtyZS5wdXNoKG9bVl0pO2NvbnRpbnVlfWxldCB3ZT1hLnN0YWNrU2F2ZSgpLGo9YS5zdGFja0FsbG9jKDQqZCksUT0hMSxpZSx0ZT0wO3RyeXthLl9PcnRHZXRUZW5zb3JEYXRhKEssaixqK2QsaisyKmQsaiszKmQpIT09MCYmY2UoYENhbid0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEgb24gaW5kZXggJHtWfS5gKTtsZXQgT2U9ZD09PTQ/XCJpMzJcIjpcImk2NFwiLHZlPU51bWJlcihhLmdldFZhbHVlKGosT2UpKTt0ZT1hLmdldFZhbHVlKGorZCxcIipcIik7bGV0IGRlPWEuZ2V0VmFsdWUoaitkKjIsXCIqXCIpLFc9TnVtYmVyKGEuZ2V0VmFsdWUoaitkKjMsT2UpKSxZPVtdO2ZvcihsZXQgcGU9MDtwZTxXO3BlKyspWS5wdXNoKE51bWJlcihhLmdldFZhbHVlKGRlK3BlKmQsT2UpKSk7YS5fT3J0RnJlZShkZSkhPT0wJiZjZShcIkNhbid0IGZyZWUgbWVtb3J5IGZvciB0ZW5zb3IgZGltcy5cIik7bGV0IGhlPVkucmVkdWNlKChwZSxJZSk9PnBlKkllLDEpO2llPWJ0KHZlKTtsZXQgRGU9aD8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW25bVl1dO2lmKGllPT09XCJzdHJpbmdcIil7aWYoRGU9PT1cImdwdS1idWZmZXJcInx8RGU9PT1cIm1sLXRlbnNvclwiKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2xldCBwZT1bXTtmb3IobGV0IEllPTA7SWU8aGU7SWUrKyl7bGV0IEhlPWEuZ2V0VmFsdWUodGUrSWUqZCxcIipcIiksbW49YS5nZXRWYWx1ZSh0ZSsoSWUrMSkqZCxcIipcIiksd3Q9SWU9PT1oZS0xP3ZvaWQgMDptbi1IZTtwZS5wdXNoKGEuVVRGOFRvU3RyaW5nKEhlLHd0KSl9cmUucHVzaChbaWUsWSxwZSxcImNwdVwiXSl9ZWxzZSBpZihEZT09PVwiZ3B1LWJ1ZmZlclwiJiZoZT4wKXtsZXQgcGU9YS5qc2VwR2V0QnVmZmVyO2lmKCFwZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7bGV0IEllPXBlKHRlKSxIZT1BdCh2ZSxoZSk7aWYoSGU9PT12b2lkIDB8fCFEcihpZSkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7aWV9YCk7UT0hMCxyZS5wdXNoKFtpZSxZLHtncHVCdWZmZXI6SWUsZG93bmxvYWQ6YS5qc2VwQ3JlYXRlRG93bmxvYWRlcihJZSxIZSxpZSksZGlzcG9zZTooKT0+e2EuX09ydFJlbGVhc2VUZW5zb3IoSykhPT0wJiZjZShcIkNhbid0IHJlbGVhc2UgdGVuc29yLlwiKX19LFwiZ3B1LWJ1ZmZlclwiXSl9ZWxzZSBpZihEZT09PVwibWwtdGVuc29yXCImJmhlPjApe2xldCBwZT1hLmpzZXBFbnN1cmVUZW5zb3I7aWYoIXBlKXRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7aWYoQXQodmUsaGUpPT09dm9pZCAwfHwhQnIoaWUpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2llfWApO2xldCBIZT1hd2FpdCBwZSh0ZSx2ZSxZLCExKTtRPSEwLHJlLnB1c2goW2llLFkse21sVGVuc29yOkhlLGRvd25sb2FkOmEuanNlcENyZWF0ZU1MVGVuc29yRG93bmxvYWRlcih0ZSxpZSksZGlzcG9zZTooKT0+e2EuanNlcFJlbGVhc2VUZW5zb3JJZCh0ZSksYS5fT3J0UmVsZWFzZVRlbnNvcihLKX19LFwibWwtdGVuc29yXCJdKX1lbHNle2xldCBwZT1PcihpZSksSWU9bmV3IHBlKGhlKTtuZXcgVWludDhBcnJheShJZS5idWZmZXIsSWUuYnl0ZU9mZnNldCxJZS5ieXRlTGVuZ3RoKS5zZXQoYS5IRUFQVTguc3ViYXJyYXkodGUsdGUrSWUuYnl0ZUxlbmd0aCkpLHJlLnB1c2goW2llLFksSWUsXCJjcHVcIl0pfX1maW5hbGx5e2Euc3RhY2tSZXN0b3JlKHdlKSxpZT09PVwic3RyaW5nXCImJnRlJiZhLl9mcmVlKHRlKSxRfHxhLl9PcnRSZWxlYXNlVGVuc29yKEspfX1yZXR1cm4gaCYmIV8mJihhLl9PcnRDbGVhckJvdW5kT3V0cHV0cyhoLmhhbmRsZSkhPT0wJiZjZShcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpLHp0LnNldChlLFtwLG0sdSxoLF8sITFdKSkscmV9ZmluYWxseXthLnN0YWNrUmVzdG9yZShDKSxTLmZvckVhY2goTD0+YS5fT3J0UmVsZWFzZVRlbnNvcihMKSksVC5mb3JFYWNoKEw9PmEuX09ydFJlbGVhc2VUZW5zb3IoTCkpLEEuZm9yRWFjaChMPT5hLl9mcmVlKEwpKSwkIT09MCYmYS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoJCksdi5mb3JFYWNoKEw9PmEuX2ZyZWUoTCkpfX0sa3I9ZT0+e2xldCB0PVRlKCkscj16dC5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCBuPXJbMF0sbz10Ll9PcnRFbmRQcm9maWxpbmcobik7bz09PTAmJmNlKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKG8pfSxFcj1lPT57bGV0IHQ9W107Zm9yKGxldCByIG9mIGUpe2xldCBuPXJbMl07IUFycmF5LmlzQXJyYXkobikmJlwiYnVmZmVyXCJpbiBuJiZ0LnB1c2gobi5idWZmZXIpfXJldHVybiB0fX0pO3ZhciBPdCxHZSxycixkbixsbix1bixFbyxQbyxXdCxMdCxiZyxkYyxsYyxjYyxwYyxtYyxmYyxoYyx6bz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7TGUoKTtGbigpO2d0KCk7JHIoKTtPdD0oKT0+ISFfZS53YXNtLnByb3h5JiZ0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIscnI9ITEsZG49ITEsbG49ITEsUG89bmV3IE1hcCxXdD0oZSx0KT0+e2xldCByPVBvLmdldChlKTtyP3IucHVzaCh0KTpQby5zZXQoZSxbdF0pfSxMdD0oKT0+e2lmKHJyfHwhZG58fGxufHwhR2UpdGhyb3cgbmV3IEVycm9yKFwid29ya2VyIG5vdCByZWFkeVwiKX0sYmc9ZT0+e3N3aXRjaChlLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6cnI9ITEsZS5kYXRhLmVycj8obG49ITAsRW9bMV0oZS5kYXRhLmVycikpOihkbj0hMCxFb1swXSgpKSx1biYmKFVSTC5yZXZva2VPYmplY3RVUkwodW4pLHVuPXZvaWQgMCk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOmNhc2VcImNvcHktZnJvbVwiOmNhc2VcImNyZWF0ZVwiOmNhc2VcInJlbGVhc2VcIjpjYXNlXCJydW5cIjpjYXNlXCJlbmQtcHJvZmlsaW5nXCI6e2xldCB0PVBvLmdldChlLmRhdGEudHlwZSk7ZS5kYXRhLmVycj90LnNoaWZ0KClbMV0oZS5kYXRhLmVycik6dC5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrfWRlZmF1bHQ6fX0sZGM9YXN5bmMoKT0+e2lmKCFkbil7aWYocnIpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRXYXNtKCknIGRldGVjdGVkLlwiKTtpZihsbil0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO2lmKHJyPSEwLE90KCkpcmV0dXJuIG5ldyBQcm9taXNlKChlLHQpPT57R2U/LnRlcm1pbmF0ZSgpLE5hKCkudGhlbigoW3Isbl0pPT57dHJ5e0dlPW4sR2Uub25lcnJvcj1pPT50KGkpLEdlLm9ubWVzc2FnZT1iZyxFbz1bZSx0XTtsZXQgbz17dHlwZTpcImluaXQtd2FzbVwiLGluOl9lfTshby5pbi53YXNtLndhc21QYXRocyYmKHJ8fGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpKSYmKG8uaW4ud2FzbS53YXNtUGF0aHM9e3dhc206bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmfSksR2UucG9zdE1lc3NhZ2UobyksdW49cn1jYXRjaChvKXt0KG8pfX0sdCl9KTt0cnl7YXdhaXQgeHIoX2Uud2FzbSksYXdhaXQgU3IoX2UpLGRuPSEwfWNhdGNoKGUpe3Rocm93IGxuPSEwLGV9ZmluYWxseXtycj0hMX19fSxsYz1hc3luYyBlPT57aWYoT3QoKSlyZXR1cm4gTHQoKSxuZXcgUHJvbWlzZSgodCxyKT0+e1d0KFwiaW5pdC1lcFwiLFt0LHJdKTtsZXQgbj17dHlwZTpcImluaXQtZXBcIixpbjp7ZXBOYW1lOmUsZW52Ol9lfX07R2UucG9zdE1lc3NhZ2Uobil9KTthd2FpdCBUcihfZSxlKX0sY2M9YXN5bmMgZT0+T3QoKT8oTHQoKSxuZXcgUHJvbWlzZSgodCxyKT0+e1d0KFwiY29weS1mcm9tXCIsW3Qscl0pO2xldCBuPXt0eXBlOlwiY29weS1mcm9tXCIsaW46e2J1ZmZlcjplfX07R2UucG9zdE1lc3NhZ2UobixbZS5idWZmZXJdKX0pKTpxdChlKSxwYz1hc3luYyhlLHQpPT57aWYoT3QoKSl7aWYodD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG9wdGlvbiBcInByZWZlcnJlZE91dHB1dExvY2F0aW9uXCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7cmV0dXJuIEx0KCksbmV3IFByb21pc2UoKHIsbik9PntXdChcImNyZWF0ZVwiLFtyLG5dKTtsZXQgbz17dHlwZTpcImNyZWF0ZVwiLGluOnttb2RlbDplLG9wdGlvbnM6ey4uLnR9fX0saT1bXTtlIGluc3RhbmNlb2YgVWludDhBcnJheSYmaS5wdXNoKGUuYnVmZmVyKSxHZS5wb3N0TWVzc2FnZShvLGkpfSl9ZWxzZSByZXR1cm4gSXIoZSx0KX0sbWM9YXN5bmMgZT0+e2lmKE90KCkpcmV0dXJuIEx0KCksbmV3IFByb21pc2UoKHQscik9PntXdChcInJlbGVhc2VcIixbdCxyXSk7bGV0IG49e3R5cGU6XCJyZWxlYXNlXCIsaW46ZX07R2UucG9zdE1lc3NhZ2Uobil9KTtDcihlKX0sZmM9YXN5bmMoZSx0LHIsbixvLGkpPT57aWYoT3QoKSl7aWYoci5zb21lKGE9PmFbM10hPT1cImNwdVwiKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3Igb24gR1BVIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtpZihvLnNvbWUoYT0+YSkpdGhyb3cgbmV3IEVycm9yKFwicHJlLWFsbG9jYXRlZCBvdXRwdXQgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtyZXR1cm4gTHQoKSxuZXcgUHJvbWlzZSgoYSxkKT0+e1d0KFwicnVuXCIsW2EsZF0pO2xldCBsPXIscD17dHlwZTpcInJ1blwiLGluOntzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6dCxpbnB1dHM6bCxvdXRwdXRJbmRpY2VzOm4sb3B0aW9uczppfX07R2UucG9zdE1lc3NhZ2UocCxFcihsKSl9KX1lbHNlIHJldHVybiBBcihlLHQscixuLG8saSl9LGhjPWFzeW5jIGU9PntpZihPdCgpKXJldHVybiBMdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57V3QoXCJlbmQtcHJvZmlsaW5nXCIsW3Qscl0pO2xldCBuPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOmV9O0dlLnBvc3RNZXNzYWdlKG4pfSk7a3IoZSl9fSk7dmFyIGdjLHlnLGNuLGJjPVUoKCk9PntcInVzZSBzdHJpY3RcIjtMZSgpO3pvKCk7SigpO3ZyKCk7UW4oKTtnYz0oZSx0KT0+e3N3aXRjaChlLmxvY2F0aW9uKXtjYXNlXCJjcHVcIjpyZXR1cm5bZS50eXBlLGUuZGltcyxlLmRhdGEsXCJjcHVcIl07Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybltlLnR5cGUsZS5kaW1zLHtncHVCdWZmZXI6ZS5ncHVCdWZmZXJ9LFwiZ3B1LWJ1ZmZlclwiXTtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7bWxUZW5zb3I6ZS5tbFRlbnNvcn0sXCJtbC10ZW5zb3JcIl07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHtlLmxvY2F0aW9ufSBmb3IgJHt0KCl9YCl9fSx5Zz1lPT57c3dpdGNoKGVbM10pe2Nhc2VcImNwdVwiOnJldHVybiBuZXcgRmUoZVswXSxlWzJdLGVbMV0pO2Nhc2VcImdwdS1idWZmZXJcIjp7bGV0IHQ9ZVswXTtpZighRHIodCkpdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7bGV0e2dwdUJ1ZmZlcjpyLGRvd25sb2FkOm4sZGlzcG9zZTpvfT1lWzJdO3JldHVybiBGZS5mcm9tR3B1QnVmZmVyKHIse2RhdGFUeXBlOnQsZGltczplWzFdLGRvd25sb2FkOm4sZGlzcG9zZTpvfSl9Y2FzZVwibWwtdGVuc29yXCI6e2xldCB0PWVbMF07aWYoIUJyKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgTUxUZW5zb3IgdGVuc29yYCk7bGV0e21sVGVuc29yOnIsZG93bmxvYWQ6bixkaXNwb3NlOm99PWVbMl07cmV0dXJuIEZlLmZyb21NTFRlbnNvcihyLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpuLGRpc3Bvc2U6b30pfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZVszXX1gKX19LGNuPWNsYXNze2FzeW5jIGZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHQpe3JldHVybiBjYyhhd2FpdCBadCh0KSl9YXN5bmMgbG9hZE1vZGVsKHQscil7TmUoKTtsZXQgbjt0eXBlb2YgdD09XCJzdHJpbmdcIj8hMT9uPWF3YWl0IFp0KHQpOm49YXdhaXQgdGhpcy5mZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KTpuPXQsW3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzXT1hd2FpdCBwYyhuLHIpLEJlKCl9YXN5bmMgZGlzcG9zZSgpe3JldHVybiBtYyh0aGlzLnNlc3Npb25JZCl9YXN5bmMgcnVuKHQscixuKXtOZSgpO2xldCBvPVtdLGk9W107T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaChoPT57bGV0IF89aFswXSx5PWhbMV0sZz10aGlzLmlucHV0TmFtZXMuaW5kZXhPZihfKTtpZihnPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke199J2ApO28ucHVzaCh5KSxpLnB1c2goZyl9KTtsZXQgYT1bXSxkPVtdO09iamVjdC5lbnRyaWVzKHIpLmZvckVhY2goaD0+e2xldCBfPWhbMF0seT1oWzFdLGc9dGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKF8pO2lmKGc9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke199J2ApO2EucHVzaCh5KSxkLnB1c2goZyl9KTtsZXQgbD1vLm1hcCgoaCxfKT0+Z2MoaCwoKT0+YGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbaVtfXV19XCJgKSkscD1hLm1hcCgoaCxfKT0+aD9nYyhoLCgpPT5gb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW2RbX11dfVwiYCk6bnVsbCksbT1hd2FpdCBmYyh0aGlzLnNlc3Npb25JZCxpLGwsZCxwLG4pLHU9e307Zm9yKGxldCBoPTA7aDxtLmxlbmd0aDtoKyspdVt0aGlzLm91dHB1dE5hbWVzW2RbaF1dXT1hW2hdPz95ZyhtW2hdKTtyZXR1cm4gQmUoKSx1fXN0YXJ0UHJvZmlsaW5nKCl7fWVuZFByb2ZpbGluZygpe2hjKHRoaXMuc2Vzc2lvbklkKX19fSk7dmFyIF9jPXt9O0h0KF9jLHtPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZDooKT0+cG4saW5pdGlhbGl6ZUZsYWdzOigpPT55Yyx3YXNtQmFja2VuZDooKT0+X2d9KTt2YXIgeWMscG4sX2csd2M9VSgoKT0+e1widXNlIHN0cmljdFwiO0xlKCk7em8oKTtiYygpO3ljPSgpPT57aWYoKHR5cGVvZiBfZS53YXNtLmluaXRUaW1lb3V0IT1cIm51bWJlclwifHxfZS53YXNtLmluaXRUaW1lb3V0PDApJiYoX2Uud2FzbS5pbml0VGltZW91dD0wKSxfZS53YXNtLnNpbWQ9PT0hMSYmY29uc29sZS53YXJuKCdEZXByZWNhdGVkIHByb3BlcnR5IFwiZW52Lndhc20uc2ltZFwiIGlzIHNldCB0byBmYWxzZS4gbm9uLVNJTUQgYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLCBhbmQgdGhpcyBzZXR0aW5nIHdpbGwgYmUgaWdub3JlZC4nKSx0eXBlb2YgX2Uud2FzbS5wcm94eSE9XCJib29sZWFuXCImJihfZS53YXNtLnByb3h5PSExKSx0eXBlb2YgX2Uud2FzbS50cmFjZSE9XCJib29sZWFuXCImJihfZS53YXNtLnRyYWNlPSExKSx0eXBlb2YgX2Uud2FzbS5udW1UaHJlYWRzIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihfZS53YXNtLm51bVRocmVhZHMpfHxfZS53YXNtLm51bVRocmVhZHM8PTApaWYodHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQpX2Uud2FzbS5udW1UaHJlYWRzPTE7ZWxzZXtsZXQgZT10eXBlb2YgbmF2aWdhdG9yPlwidVwiP1VuKFwibm9kZTpvc1wiKS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O19lLndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgoZXx8MSkvMikpfX0scG49Y2xhc3N7YXN5bmMgaW5pdCh0KXt5YygpLGF3YWl0IGRjKCksYXdhaXQgbGModCl9YXN5bmMgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIodCxyKXtsZXQgbj1uZXcgY247cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQsciksUHJvbWlzZS5yZXNvbHZlKG4pfX0sX2c9bmV3IHBufSk7TGUoKTtMZSgpO0xlKCk7dmFyIElhPVwiMS4yMS4wLWRldi4yMDI1MDIwNi1kOTgxYjE1M2QzXCI7dmFyICQxPUhuO3tsZXQgZT0od2MoKSxncihfYykpLndhc21CYWNrZW5kO1R0KFwid2ViZ3B1XCIsZSw1KSxUdChcIndlYm5uXCIsZSw1KSxUdChcImNwdVwiLGUsMTApLFR0KFwid2FzbVwiLGUsMTApfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZS52ZXJzaW9ucyxcIndlYlwiLHt2YWx1ZTpJYSxlbnVtZXJhYmxlOiEwfSk7ZXhwb3J0e0ZwIGFzIEluZmVyZW5jZVNlc3Npb24sX3IgYXMgVFJBQ0UsTmUgYXMgVFJBQ0VfRlVOQ19CRUdJTixCZSBhcyBUUkFDRV9GVU5DX0VORCxGZSBhcyBUZW5zb3IsJDEgYXMgZGVmYXVsdCxfZSBhcyBlbnYsVHQgYXMgcmVnaXN0ZXJCYWNrZW5kfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ydC53ZWJncHUuYnVuZGxlLm1pbi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?bd86\n"));

/***/ })

}]);