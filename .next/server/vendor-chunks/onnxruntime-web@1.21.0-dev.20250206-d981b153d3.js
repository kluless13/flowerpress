"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/onnxruntime-web@1.21.0-dev.20250206-d981b153d3";
exports.ids = ["vendor-chunks/onnxruntime-web@1.21.0-dev.20250206-d981b153d3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm ***!
  \**********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort-wasm-simd-threaded.jsep.7aa09142.wasm";

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs?53f5":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs ***!
  \******************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort.node.min.8ced9e8e.mjs";

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs?866d":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.InferenceSession),\n/* harmony export */   TRACE: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_BEGIN),\n/* harmony export */   TRACE_FUNC_END: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_END),\n/* harmony export */   Tensor: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor),\n/* harmony export */   \"default\": () => (/* binding */ Cr),\n/* harmony export */   env: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env),\n/* harmony export */   registerBackend: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.registerBackend)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/* harmony import */ var onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! onnxruntime-common */ \"(ssr)/./node_modules/.pnpm/onnxruntime-common@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-common/dist/esm/index.js\");\n/*!\n * ONNX Runtime Web v1.21.0-dev.20250206-d981b153d3\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst require=(0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs\");\nvar ue=Object.defineProperty;var pt=Object.getOwnPropertyDescriptor;var mt=Object.getOwnPropertyNames;var gt=Object.prototype.hasOwnProperty;var ce=(e=>typeof require<\"u\"?require:typeof Proxy<\"u\"?new Proxy(e,{get:(t,n)=>(typeof require<\"u\"?require:t)[n]}):e)(function(e){if(typeof require<\"u\")return require.apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var A=(e,t)=>()=>(e&&(t=e(e=0)),t);var bt=(e,t)=>{for(var n in t)ue(e,n,{get:t[n],enumerable:!0})},yt=(e,t,n,s)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let r of mt(t))!gt.call(e,r)&&r!==n&&ue(e,r,{get:()=>t[r],enumerable:!(s=pt(t,r))||s.enumerable});return e};var wt=e=>yt(ue({},\"__esModule\",{value:!0}),e);var U,Q=A(()=>{\"use strict\";U=!!(typeof process<\"u\"&&process.versions&&process.versions.node)});var Pe,ht,k,xe,Te,St,Et,Ot,vt,Le,Ie,le=A(()=>{\"use strict\";Q();Pe=U||typeof location>\"u\"?void 0:location.origin,ht=()=>{if(!U)return \"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs\"?.startsWith(\"file:\")?new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.node.min.mjs */ \"(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs?53f5\")).href,Pe).href:\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs\"},k=ht(),xe=()=>{if(k&&!k.startsWith(\"blob:\"))return k.substring(0,k.lastIndexOf(\"/\")+1)},Te=(e,t)=>{try{let n=t??k;return(n?new URL(e,n):new URL(e)).origin===Pe}catch{return!1}},St=(e,t)=>{let n=t??k;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},Et=(e,t)=>`${t??\"./\"}${e}`,Ot=async e=>{let n=await(await fetch(e,{credentials:\"same-origin\"})).blob();return URL.createObjectURL(n)},vt=async e=>(await import(/*webpackIgnore:true*/e)).default,Le=void 0,Ie=async(e,t,n)=>{if(!e&&!t&&Le&&k&&Te(k))return[void 0,Le];{let s=\"ort-wasm-simd-threaded.mjs\",r=e??St(s,t),i=!U&&n&&r&&!Te(r,t),o=i?await Ot(r):r??Et(s,t);return[i?o:void 0,await vt(o)]}}});var fe,de,ee,_e,Tt,Lt,Ae,S,j=A(()=>{\"use strict\";le();de=!1,ee=!1,_e=!1,Tt=()=>{if(typeof SharedArrayBuffer>\"u\")return!1;try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Lt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ae=async e=>{if(de)return Promise.resolve();if(ee)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(_e)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");ee=!0;let t=e.initTimeout,n=e.numThreads;if(!Lt())throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");let s=Tt();n>1&&!s&&(typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+n+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"),e.numThreads=n=1);let r=e.wasmPaths,i=typeof r==\"string\"?r:void 0,o=r?.mjs,a=o?.href??o,c=r?.wasm,d=c?.href??c,w=e.wasmBinary,[l,u]=await Ie(a,i,n>1),b=!1,v=[];if(t>0&&v.push(new Promise(f=>{setTimeout(()=>{b=!0,f()},t)})),v.push(new Promise((f,y)=>{let P={numThreads:n};if(w)P.wasmBinary=w;else if(d||i)P.locateFile=p=>d??i+p;else if(a&&a.indexOf(\"blob:\")!==0)P.locateFile=p=>new URL(p,a).href;else if(l){let p=xe();p&&(P.locateFile=h=>p+h)}u(P).then(p=>{ee=!1,de=!0,fe=p,f(),l&&URL.revokeObjectURL(l)},p=>{ee=!1,_e=!0,y(p)})})),await Promise.race(v),b)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},S=()=>{if(de&&fe)return fe;throw new Error(\"WebAssembly is not initialized yet.\")}});var E,G,g,te=A(()=>{\"use strict\";j();E=(e,t)=>{let n=S(),s=n.lengthBytesUTF8(e)+1,r=n._malloc(s);return n.stringToUTF8(e,r,s),t.push(r),r},G=(e,t,n,s)=>{if(typeof e==\"object\"&&e!==null){if(n.has(e))throw new Error(\"Circular reference in options\");n.add(e)}Object.entries(e).forEach(([r,i])=>{let o=t?t+r:r;if(typeof i==\"object\")G(i,o+\".\",n,s);else if(typeof i==\"string\"||typeof i==\"number\")s(o,i.toString());else if(typeof i==\"boolean\")s(o,i?\"1\":\"0\");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},g=e=>{let t=S(),n=t.stackSave();try{let s=t.PTR_SIZE,r=t.stackAlloc(2*s);t._OrtGetLastError(r,r+s);let i=Number(t.getValue(r,s===4?\"i32\":\"i64\")),o=t.getValue(r+s,\"*\"),a=o?t.UTF8ToString(o):\"\";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(n)}}});var Ce,Be=A(()=>{\"use strict\";j();te();Ce=e=>{let t=S(),n=0,s=[],r=e||{};try{if(e?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof e.logSeverityLevel!=\"number\"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!=\"number\"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(r.terminate=!1);let i=0;return e?.tag!==void 0&&(i=E(e.tag,s)),n=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,i),n===0&&g(\"Can't create run options.\"),e?.extra!==void 0&&G(e.extra,\"\",new WeakSet,(o,a)=>{let c=E(o,s),d=E(a,s);t._OrtAddRunConfigEntry(n,c,d)!==0&&g(`Can't set a run config entry: ${o} - ${a}.`)}),[n,s]}catch(i){throw n!==0&&t._OrtReleaseRunOptions(n),s.forEach(o=>t._free(o)),i}}});var Pt,xt,It,_t,Me,Ue=A(()=>{\"use strict\";j();te();Pt=e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},xt=e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},It=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some(n=>(typeof n==\"string\"?n:n.name)===\"webgpu\")&&(e.enableMemPattern=!1)},_t=(e,t,n)=>{for(let s of t){let r=typeof s==\"string\"?s:s.name;switch(r){case\"webnn\":if(r=\"WEBNN\",typeof s!=\"string\"){let a=s?.deviceType;if(a){let c=E(\"deviceType\",n),d=E(a,n);S()._OrtAddSessionConfigEntry(e,c,d)!==0&&g(`Can't set a session config entry: 'deviceType' - ${a}.`)}}break;case\"webgpu\":if(r=\"JS\",typeof s!=\"string\"){let o=s;if(o?.preferredLayout){if(o.preferredLayout!==\"NCHW\"&&o.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${o.preferredLayout}`);let a=E(\"preferredLayout\",n),c=E(o.preferredLayout,n);S()._OrtAddSessionConfigEntry(e,a,c)!==0&&g(`Can't set a session config entry: 'preferredLayout' - ${o.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${r}`)}let i=E(r,n);S()._OrtAppendExecutionProvider(e,i)!==0&&g(`Can't append execution provider: ${r}.`)}},Me=e=>{let t=S(),n=0,s=[],r=e||{};It(r);try{let i=Pt(r.graphOptimizationLevel??\"all\"),o=xt(r.executionMode??\"sequential\"),a=typeof r.logId==\"string\"?E(r.logId,s):0,c=r.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let d=r.logVerbosityLevel??0;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log verbosity level is not valid: ${d}`);let w=typeof r.optimizedModelFilePath==\"string\"?E(r.optimizedModelFilePath,s):0;if(n=t._OrtCreateSessionOptions(i,!!r.enableCpuMemArena,!!r.enableMemPattern,o,!!r.enableProfiling,0,a,c,d,w),n===0&&g(\"Can't create session options.\"),r.executionProviders&&_t(n,r.executionProviders,s),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let l=E(\"enableGraphCapture\",s),u=E(r.enableGraphCapture.toString(),s);t._OrtAddSessionConfigEntry(n,l,u)!==0&&g(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[l,u]of Object.entries(r.freeDimensionOverrides)){if(typeof l!=\"string\")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof u!=\"number\"||!Number.isInteger(u)||u<0)throw new Error(`free dimension override value must be a non-negative integer: ${u}`);let b=E(l,s);t._OrtAddFreeDimensionOverride(n,b,u)!==0&&g(`Can't set a free dimension override: ${l} - ${u}.`)}return r.extra!==void 0&&G(r.extra,\"\",new WeakSet,(l,u)=>{let b=E(l,s),v=E(u,s);t._OrtAddSessionConfigEntry(n,b,v)!==0&&g(`Can't set a session config entry: ${l} - ${u}.`)}),[n,s]}catch(i){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&g(\"Can't release session options.\"),s.forEach(o=>t._free(o)),i}}});var H,ke,V,De,We,re,ne,Fe,pe=A(()=>{\"use strict\";H=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;case\"int4\":return 22;case\"uint4\":return 21;default:throw new Error(`unsupported data type: ${e}`)}},ke=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";case 22:return\"int4\";case 21:return\"uint4\";default:throw new Error(`unsupported data type: ${e}`)}},V=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],s=typeof t==\"number\"?t:t.reduce((r,i)=>r*i,1);return n>0?Math.ceil(s*n):void 0},De=e=>{switch(e){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},We=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},re=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",ne=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint64\"||e===\"int8\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Fe=e=>{switch(e){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;case\"ml-tensor\":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var q,me=A(()=>{\"use strict\";Q();q=async e=>{if(typeof e==\"string\")if(U)try{let{readFile:t}=ce(\"node:fs/promises\");return new Uint8Array(await t(e))}catch(t){if(t.code===\"ERR_FS_FILE_TOO_LARGE\"){let{createReadStream:n}=ce(\"node:fs\"),s=n(e),r=[];for await(let i of s)r.push(i);return new Uint8Array(Buffer.concat(r))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get(\"Content-Length\"),s=n?parseInt(n,10):0;if(s<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),i;try{i=new ArrayBuffer(s)}catch(a){if(a instanceof RangeError){let c=Math.ceil(s/65536);i=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw a}let o=0;for(;;){let{done:a,value:c}=await r.read();if(a)break;let d=c.byteLength;new Uint8Array(i,o,d).set(c),o+=d}return new Uint8Array(i,0,s)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var At,Ne,je,$,Ct,ge,$e,ze,Re,Ge,He,Ve=A(()=>{\"use strict\";Be();Ue();pe();j();te();me();At=(e,t)=>{S()._OrtInit(e,t)!==0&&g(\"Can't initialize onnxruntime.\")},Ne=async e=>{At(e.wasm.numThreads,We(e.logLevel))},je=async(e,t)=>{},$=new Map,Ct=e=>{let t=S(),n=t.stackSave();try{let s=t.PTR_SIZE,r=t.stackAlloc(2*s);t._OrtGetInputOutputCount(e,r,r+s)!==0&&g(\"Can't get session input/output count.\");let o=s===4?\"i32\":\"i64\";return[Number(t.getValue(r,o)),Number(t.getValue(r+s,o))]}finally{t.stackRestore(n)}},ge=e=>{let t=S(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},$e=async(e,t)=>{let n,s,r=S();Array.isArray(e)?[n,s]=e:e.buffer===r.HEAPU8.buffer?[n,s]=[e.byteOffset,e.byteLength]:[n,s]=ge(e);let i=0,o=0,a=0,c=[],d=[],w=[];try{if([o,c]=Me(t),t?.externalData&&r.mountExternalData){let p=[];for(let h of t.externalData){let x=typeof h==\"string\"?h:h.path;p.push(q(typeof h==\"string\"?h:h.data).then(M=>{r.mountExternalData(x,M)}))}await Promise.all(p)}for(let p of t?.executionProviders??[])if((typeof p==\"string\"?p:p.name)===\"webnn\"){if(r.shouldTransferToMLTensor=!1,typeof p!=\"string\"){let x=p,M=x?.context,J=x?.gpuDevice,Y=x?.deviceType,X=x?.powerPreference;M?r.currentContext=M:J?r.currentContext=await r.jsepCreateMLContext(J):r.currentContext=await r.jsepCreateMLContext({deviceType:Y,powerPreference:X})}else r.currentContext=await r.jsepCreateMLContext();break}i=await r._OrtCreateSession(n,s,o),i===0&&g(\"Can't create a session.\"),r.jsepOnCreateSession?.(),r.currentContext&&(r.jsepRegisterMLContext(i,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[l,u]=Ct(i),b=!!t?.enableGraphCapture,v=[],f=[],y=[];for(let p=0;p<l;p++){let h=r._OrtGetInputName(i,p);h===0&&g(\"Can't get an input name.\"),d.push(h),v.push(r.UTF8ToString(h))}for(let p=0;p<u;p++){let h=r._OrtGetOutputName(i,p);h===0&&g(\"Can't get an output name.\"),w.push(h);let x=r.UTF8ToString(h);f.push(x)}let P=null;return $.set(i,[i,d,w,P,b,!1]),[i,v,f]}catch(l){throw d.forEach(u=>r._OrtFree(u)),w.forEach(u=>r._OrtFree(u)),a!==0&&r._OrtReleaseBinding(a)!==0&&g(\"Can't release IO binding.\"),i!==0&&r._OrtReleaseSession(i)!==0&&g(\"Can't release session.\"),l}finally{r._free(n),o!==0&&r._OrtReleaseSessionOptions(o)!==0&&g(\"Can't release session options.\"),c.forEach(l=>r._free(l)),r.unmountExternalData?.()}},ze=e=>{let t=S(),n=$.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[s,r,i,o,a]=n;o&&(a&&t._OrtClearBoundOutputs(o.handle)!==0&&g(\"Can't clear bound outputs.\"),t._OrtReleaseBinding(o.handle)!==0&&g(\"Can't release IO binding.\")),t.jsepOnReleaseSession?.(e),r.forEach(c=>t._OrtFree(c)),i.forEach(c=>t._OrtFree(c)),t._OrtReleaseSession(s)!==0&&g(\"Can't release session.\"),$.delete(e)},Re=(e,t,n,s,r,i=!1)=>{if(!e){t.push(0);return}let o=S(),a=o.PTR_SIZE,c=e[0],d=e[1],w=e[3],l,u;if(c===\"string\"&&(w===\"gpu-buffer\"||w===\"ml-tensor\"))throw new Error(\"String tensor is not supported on GPU.\");if(i&&w!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(w===\"gpu-buffer\"){let f=e[2].gpuBuffer;u=V(H(c),d);let y=o.jsepRegisterBuffer;if(!y)throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');l=y(s,r,f,u)}else if(w===\"ml-tensor\"){let f=e[2].mlTensor;u=V(H(c),d);let y=o.jsepRegisterMLTensor;if(!y)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');l=y(f,H(c),d)}else{let f=e[2];if(Array.isArray(f)){u=a*f.length,l=o._malloc(u),n.push(l);for(let y=0;y<f.length;y++){if(typeof f[y]!=\"string\")throw new TypeError(`tensor data at index ${y} is not a string`);o.setValue(l+y*a,E(f[y],n),\"*\")}}else u=f.byteLength,l=o._malloc(u),n.push(l),o.HEAPU8.set(new Uint8Array(f.buffer,f.byteOffset,u),l)}let b=o.stackSave(),v=o.stackAlloc(4*d.length);try{d.forEach((y,P)=>o.setValue(v+P*a,y,a===4?\"i32\":\"i64\"));let f=o._OrtCreateTensor(H(c),l,u,v,d.length,Fe(w));f===0&&g(`Can't create tensor for input/output. session=${s}, index=${r}.`),t.push(f)}finally{o.stackRestore(b)}},Ge=async(e,t,n,s,r,i)=>{let o=S(),a=o.PTR_SIZE,c=$.get(e);if(!c)throw new Error(`cannot run inference. invalid session id: ${e}`);let d=c[0],w=c[1],l=c[2],u=c[3],b=c[4],v=c[5],f=t.length,y=s.length,P=0,p=[],h=[],x=[],M=[],J=o.stackSave(),Y=o.stackAlloc(f*a),X=o.stackAlloc(f*a),ie=o.stackAlloc(y*a),Se=o.stackAlloc(y*a);try{o.jsepOnRunStart?.(d),[P,p]=Ce(i);for(let m=0;m<f;m++)Re(n[m],h,M,e,t[m],b);for(let m=0;m<y;m++)Re(r[m],x,M,e,f+s[m],b);for(let m=0;m<f;m++)o.setValue(Y+m*a,h[m],\"*\"),o.setValue(X+m*a,w[t[m]],\"*\");for(let m=0;m<y;m++)o.setValue(ie+m*a,x[m],\"*\"),o.setValue(Se+m*a,l[s[m]],\"*\");let C;C=await o._OrtRun(d,X,Y,f,Se,y,ie,P),C!==0&&g(\"failed to call OrtRun().\");let R=[];for(let m=0;m<y;m++){let N=Number(o.getValue(ie+m*a,\"*\"));if(N===x[m]){R.push(r[m]);continue}let Ee=o.stackSave(),B=o.stackAlloc(4*a),z=!1,T,I=0;try{o._OrtGetTensorData(N,B,B+a,B+2*a,B+3*a)!==0&&g(`Can't access output tensor data on index ${m}.`);let ae=a===4?\"i32\":\"i64\",Z=Number(o.getValue(B,ae));I=o.getValue(B+a,\"*\");let Oe=o.getValue(B+a*2,\"*\"),lt=Number(o.getValue(B+a*3,ae)),D=[];for(let L=0;L<lt;L++)D.push(Number(o.getValue(Oe+L*a,ae)));o._OrtFree(Oe)!==0&&g(\"Can't free memory for tensor dims.\");let W=D.reduce((L,O)=>L*O,1);T=ke(Z);let K=u?.outputPreferredLocations[s[m]];if(T===\"string\"){if(K===\"gpu-buffer\"||K===\"ml-tensor\")throw new Error(\"String tensor is not supported on GPU.\");let L=[];for(let O=0;O<W;O++){let F=o.getValue(I+O*a,\"*\"),ft=o.getValue(I+(O+1)*a,\"*\"),dt=O===W-1?void 0:ft-F;L.push(o.UTF8ToString(F,dt))}R.push([T,D,L,\"cpu\"])}else if(K===\"gpu-buffer\"&&W>0){let L=o.jsepGetBuffer;if(!L)throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');let O=L(I),F=V(Z,W);if(F===void 0||!re(T))throw new Error(`Unsupported data type: ${T}`);z=!0,R.push([T,D,{gpuBuffer:O,download:o.jsepCreateDownloader(O,F,T),dispose:()=>{o._OrtReleaseTensor(N)!==0&&g(\"Can't release tensor.\")}},\"gpu-buffer\"])}else if(K===\"ml-tensor\"&&W>0){let L=o.jsepEnsureTensor;if(!L)throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');if(V(Z,W)===void 0||!ne(T))throw new Error(`Unsupported data type: ${T}`);let F=await L(I,Z,D,!1);z=!0,R.push([T,D,{mlTensor:F,download:o.jsepCreateMLTensorDownloader(I,T),dispose:()=>{o.jsepReleaseTensorId(I),o._OrtReleaseTensor(N)}},\"ml-tensor\"])}else{let L=De(T),O=new L(W);new Uint8Array(O.buffer,O.byteOffset,O.byteLength).set(o.HEAPU8.subarray(I,I+O.byteLength)),R.push([T,D,O,\"cpu\"])}}finally{o.stackRestore(Ee),T===\"string\"&&I&&o._free(I),z||o._OrtReleaseTensor(N)}}return u&&!b&&(o._OrtClearBoundOutputs(u.handle)!==0&&g(\"Can't clear bound outputs.\"),$.set(e,[d,w,l,u,b,!1])),R}finally{o.stackRestore(J),h.forEach(C=>o._OrtReleaseTensor(C)),x.forEach(C=>o._OrtReleaseTensor(C)),M.forEach(C=>o._free(C)),P!==0&&o._OrtReleaseRunOptions(P),p.forEach(C=>o._free(C))}},He=e=>{let t=S(),n=$.get(e);if(!n)throw new Error(\"invalid session id\");let s=n[0],r=t._OrtEndProfiling(s);r===0&&g(\"Can't get an profile file name.\"),t._OrtFree(r)}});var be,qe,Je,Ye,Xe,Ze,Ke,Qe,et,tt,we=A(()=>{\"use strict\";Ve();j();le();be=!1,qe=!1,Je=!1,Ye=async()=>{if(!qe){if(be)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(Je)throw new Error(\"previous call to 'initWasm()' failed.\");be=!0;try{await Ae(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm),await Ne(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env),qe=!0}catch(e){throw Je=!0,e}finally{be=!1}}},Xe=async e=>{await je(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env,e)},Ze=async e=>ge(e),Ke=async(e,t)=>$e(e,t),Qe=async e=>{ze(e)},et=async(e,t,n,s,r,i)=>Ge(e,t,n,s,r,i),tt=async e=>{He(e)}});var ot,Mt,oe,st=A(()=>{\"use strict\";we();pe();Q();me();ot=(e,t)=>{switch(e.location){case\"cpu\":return[e.type,e.dims,e.data,\"cpu\"];case\"gpu-buffer\":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},\"gpu-buffer\"];case\"ml-tensor\":return[e.type,e.dims,{mlTensor:e.mlTensor},\"ml-tensor\"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Mt=e=>{switch(e[3]){case\"cpu\":return new onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor(e[0],e[2],e[1]);case\"gpu-buffer\":{let t=e[0];if(!re(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:s,dispose:r}=e[2];return onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor.fromGpuBuffer(n,{dataType:t,dims:e[1],download:s,dispose:r})}case\"ml-tensor\":{let t=e[0];if(!ne(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:s,dispose:r}=e[2];return onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor.fromMLTensor(n,{dataType:t,dims:e[1],download:s,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},oe=class{async fetchModelAndCopyToWasmMemory(t){return Ze(await q(t))}async loadModel(t,n){(0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_BEGIN)();let s;typeof t==\"string\"?U?s=await q(t):s=await this.fetchModelAndCopyToWasmMemory(t):s=t,[this.sessionId,this.inputNames,this.outputNames]=await Ke(s,n),(0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_END)()}async dispose(){return Qe(this.sessionId)}async run(t,n,s){(0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_BEGIN)();let r=[],i=[];Object.entries(t).forEach(u=>{let b=u[0],v=u[1],f=this.inputNames.indexOf(b);if(f===-1)throw new Error(`invalid input '${b}'`);r.push(v),i.push(f)});let o=[],a=[];Object.entries(n).forEach(u=>{let b=u[0],v=u[1],f=this.outputNames.indexOf(b);if(f===-1)throw new Error(`invalid output '${b}'`);o.push(v),a.push(f)});let c=r.map((u,b)=>ot(u,()=>`input \"${this.inputNames[i[b]]}\"`)),d=o.map((u,b)=>u?ot(u,()=>`output \"${this.outputNames[a[b]]}\"`):null),w=await et(this.sessionId,i,c,a,d,s),l={};for(let u=0;u<w.length;u++)l[this.outputNames[a[u]]]=o[u]??Mt(w[u]);return (0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_END)(),l}startProfiling(){}endProfiling(){tt(this.sessionId)}}});var at={};bt(at,{OnnxruntimeWebAssemblyBackend:()=>se,initializeFlags:()=>it,wasmBackend:()=>Ut});var it,se,Ut,ut=A(()=>{\"use strict\";we();st();it=()=>{if((typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.initTimeout!=\"number\"||onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.initTimeout<0)&&(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.initTimeout=0),onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.simd===!1&&console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.proxy!=\"boolean\"&&(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.proxy=!1),typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.trace!=\"boolean\"&&(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.trace=!1),typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads!=\"number\"||!Number.isInteger(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads)||onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads<=0)if(typeof self<\"u\"&&!self.crossOriginIsolated)onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads=1;else{let e=typeof navigator>\"u\"?ce(\"node:os\").cpus().length:navigator.hardwareConcurrency;onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},se=class{async init(t){it(),await Ye(),await Xe(t)}async createInferenceSessionHandler(t,n){let s=new oe;return await s.loadModel(t,n),Promise.resolve(s)}},Ut=new se});var ve=\"1.21.0-dev.20250206-d981b153d3\";var Cr=onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__;{let e=(ut(),wt(at)).wasmBackend;(0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.registerBackend)(\"cpu\",e,10),(0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.registerBackend)(\"wasm\",e,10)}Object.defineProperty(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.versions,\"web\",{value:ve,enumerable:!0});\n//# sourceMappingURL=ort.node.min.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vb25ueHJ1bnRpbWUtd2ViQDEuMjEuMC1kZXYuMjAyNTAyMDYtZDk4MWIxNTNkMy9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0Lm5vZGUubWluLm1qcz84NjZkIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDLGNBQWMscURBQWEsQ0FBQyx3SkFBZTtBQUM3RSw2QkFBNkIsdUNBQXVDLGtDQUFrQyx1Q0FBdUMsb0VBQW9FLDZDQUE2QyxpQkFBaUIsMkRBQTJELDJEQUEyRCxFQUFFLG1DQUFtQyxlQUFlLHVCQUF1Qix1QkFBdUIsRUFBRSxnQkFBZ0IsZ0dBQWdHLG1EQUFtRCxFQUFFLFVBQVUsa0JBQWtCLGVBQWUsU0FBUyxLQUFLLGVBQWUsYUFBYSxrRUFBa0UsRUFBRSw4Q0FBOEMsYUFBYSxJQUFJLHlEQUF5RCxhQUFhLHdKQUFlLDhCQUE4Qiw4TkFBMkMsZUFBZSx3SkFBZSxDQUFDLGdCQUFnQix3RUFBd0UsWUFBWSxJQUFJLFdBQVcsOENBQThDLE1BQU0sVUFBVSxZQUFZLFdBQVcsSUFBSSx1Q0FBdUMsTUFBTSxRQUFRLGNBQWMsUUFBUSxFQUFFLEVBQUUsZUFBZSwyQkFBMkIsMEJBQTBCLFVBQVUsOEJBQThCLHlGQUF5RiwyQ0FBMkMsZ0dBQWdHLGlDQUFpQyxFQUFFLG9DQUFvQyxhQUFhLEtBQUssMEJBQTBCLHlDQUF5QyxJQUFJLG1PQUFtTyxNQUFNLFVBQVUsU0FBUyxJQUFJLHlLQUF5SyxNQUFNLFVBQVUsY0FBYywrQkFBK0IsK0VBQStFLDRFQUE0RSxNQUFNLG1DQUFtQywwRkFBMEYsV0FBVyw0WEFBNFgsOElBQThJLCtCQUErQixnQkFBZ0IsU0FBUyxJQUFJLDhCQUE4QixPQUFPLGNBQWMsb0JBQW9CLG9DQUFvQyxvRUFBb0UsV0FBVyxXQUFXLHlCQUF5QixjQUFjLCtDQUErQyxLQUFLLGlCQUFpQixFQUFFLHNHQUFzRyxFQUFF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LEVBQUUsa0RBQWtELEtBQUssSUFBSSxVQUFVLHVDQUF1QyxzQkFBc0IscUJBQXFCLG9FQUFFLEdBQUcsTUFBTSxvSkFBb0osa0VBQUUsR0FBRyxnQkFBZ0IsMEJBQTBCLGlCQUFpQixvRUFBRSxHQUFHLGNBQWMsOEJBQThCLCtDQUErQyw0Q0FBNEMsRUFBRSxJQUFJLG9CQUFvQixFQUFFLGNBQWMsOEJBQThCLGdEQUFnRCw2Q0FBNkMsRUFBRSxJQUFJLG9CQUFvQixFQUFFLHNDQUFzQyxzQkFBc0IsMENBQTBDLHVCQUF1QixvREFBb0QsWUFBWSxXQUFXLDZDQUE2QyxPQUFPLGtFQUFFLEtBQUssa0JBQWtCLGVBQWUscUJBQXFCLEVBQUUsVUFBVSxPQUFPLCtFQUErRSxFQUEyQyx1QkFBdUIsYUFBYSxLQUFLLEtBQUssUUFBUSxXQUFXLG1EQUFDLDZCQUE2QixtREFBQyx1QkFBdUIsbURBQUMscUJBQXFCLG1EQUFDLHFLQUFxSyxtREFBQyx5QkFBeUIsbURBQUMsdUJBQXVCLG1EQUFDLHlCQUF5QixtREFBQyx1QkFBdUIsbURBQUMsOENBQThDLG1EQUFDLG1CQUFtQixtREFBQyxrRUFBa0UsbURBQUMsbUJBQW1CLEtBQUsscUZBQXFGLG1EQUFDLGtEQUFrRCxVQUFVLGNBQWMsNEJBQTRCLHlDQUF5QyxhQUFhLGtEQUFrRCxXQUFXLEVBQXdJLHdDQUF3QyxPQUFPLCtDQUFFLEVBQUUsZ0NBQWdDLG1FQUFFLGFBQWEsbUVBQUUsY0FBYyxzQkFBc0IsbURBQUUsaUJBQWlCLHVCQUF1QixFQUF3QjtBQUMva3RCIiwic291cmNlcyI6WyIvVXNlcnMva2x1bGVzcy9mbG93ZXJwcmVzcy9ub2RlX21vZHVsZXMvLnBucG0vb25ueHJ1bnRpbWUtd2ViQDEuMjEuMC1kZXYuMjAyNTAyMDYtZDk4MWIxNTNkMy9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0Lm5vZGUubWluLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE9OTlggUnVudGltZSBXZWIgdjEuMjEuMC1kZXYuMjAyNTAyMDYtZDk4MWIxNTNkM1xuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmltcG9ydHtjcmVhdGVSZXF1aXJlfWZyb21cIm1vZHVsZVwiO2NvbnN0IHJlcXVpcmU9Y3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xudmFyIHVlPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgcHQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgbXQ9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIGd0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIGNlPShlPT50eXBlb2YgcmVxdWlyZTxcInVcIj9yZXF1aXJlOnR5cGVvZiBQcm94eTxcInVcIj9uZXcgUHJveHkoZSx7Z2V0Oih0LG4pPT4odHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0KVtuXX0pOmUpKGZ1bmN0aW9uKGUpe2lmKHR5cGVvZiByZXF1aXJlPFwidVwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJytlKydcIiBpcyBub3Qgc3VwcG9ydGVkJyl9KTt2YXIgQT0oZSx0KT0+KCk9PihlJiYodD1lKGU9MCkpLHQpO3ZhciBidD0oZSx0KT0+e2Zvcih2YXIgbiBpbiB0KXVlKGUsbix7Z2V0OnRbbl0sZW51bWVyYWJsZTohMH0pfSx5dD0oZSx0LG4scyk9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IHIgb2YgbXQodCkpIWd0LmNhbGwoZSxyKSYmciE9PW4mJnVlKGUscix7Z2V0OigpPT50W3JdLGVudW1lcmFibGU6IShzPXB0KHQscikpfHxzLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIHd0PWU9Pnl0KHVlKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciBVLFE9QSgoKT0+e1widXNlIHN0cmljdFwiO1U9ISEodHlwZW9mIHByb2Nlc3M8XCJ1XCImJnByb2Nlc3MudmVyc2lvbnMmJnByb2Nlc3MudmVyc2lvbnMubm9kZSl9KTt2YXIgUGUsaHQsayx4ZSxUZSxTdCxFdCxPdCx2dCxMZSxJZSxsZT1BKCgpPT57XCJ1c2Ugc3RyaWN0XCI7USgpO1BlPVV8fHR5cGVvZiBsb2NhdGlvbj5cInVcIj92b2lkIDA6bG9jYXRpb24ub3JpZ2luLGh0PSgpPT57aWYoIVUpcmV0dXJuIGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwobmV3IFVSTChcIm9ydC5ub2RlLm1pbi5tanNcIixpbXBvcnQubWV0YS51cmwpLmhyZWYsUGUpLmhyZWY6aW1wb3J0Lm1ldGEudXJsfSxrPWh0KCkseGU9KCk9PntpZihrJiYhay5zdGFydHNXaXRoKFwiYmxvYjpcIikpcmV0dXJuIGsuc3Vic3RyaW5nKDAsay5sYXN0SW5kZXhPZihcIi9cIikrMSl9LFRlPShlLHQpPT57dHJ5e2xldCBuPXQ/P2s7cmV0dXJuKG4/bmV3IFVSTChlLG4pOm5ldyBVUkwoZSkpLm9yaWdpbj09PVBlfWNhdGNoe3JldHVybiExfX0sU3Q9KGUsdCk9PntsZXQgbj10Pz9rO3RyeXtyZXR1cm4obj9uZXcgVVJMKGUsbik6bmV3IFVSTChlKSkuaHJlZn1jYXRjaHtyZXR1cm59fSxFdD0oZSx0KT0+YCR7dD8/XCIuL1wifSR7ZX1gLE90PWFzeW5jIGU9PntsZXQgbj1hd2FpdChhd2FpdCBmZXRjaChlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KSkuYmxvYigpO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG4pfSx2dD1hc3luYyBlPT4oYXdhaXQgaW1wb3J0KC8qd2VicGFja0lnbm9yZTp0cnVlKi9lKSkuZGVmYXVsdCxMZT12b2lkIDAsSWU9YXN5bmMoZSx0LG4pPT57aWYoIWUmJiF0JiZMZSYmayYmVGUoaykpcmV0dXJuW3ZvaWQgMCxMZV07e2xldCBzPVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanNcIixyPWU/P1N0KHMsdCksaT0hVSYmbiYmciYmIVRlKHIsdCksbz1pP2F3YWl0IE90KHIpOnI/P0V0KHMsdCk7cmV0dXJuW2k/bzp2b2lkIDAsYXdhaXQgdnQobyldfX19KTt2YXIgZmUsZGUsZWUsX2UsVHQsTHQsQWUsUyxqPUEoKCk9PntcInVzZSBzdHJpY3RcIjtsZSgpO2RlPSExLGVlPSExLF9lPSExLFR0PSgpPT57aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPlwidVwiKXJldHVybiExO3RyeXtyZXR1cm4gdHlwZW9mIE1lc3NhZ2VDaGFubmVsPFwidVwiJiZuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxMdD0oKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxBZT1hc3luYyBlPT57aWYoZGUpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKGVlKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZGV0ZWN0ZWQuXCIpO2lmKF9lKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO2VlPSEwO2xldCB0PWUuaW5pdFRpbWVvdXQsbj1lLm51bVRocmVhZHM7aWYoIUx0KCkpdGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlwiKTtsZXQgcz1UdCgpO24+MSYmIXMmJih0eXBlb2Ygc2VsZjxcInVcIiYmIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCYmY29uc29sZS53YXJuKFwiZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gXCIrbitcIiwgYnV0IHRoaXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGVuYWJsZSBjcm9zc09yaWdpbklzb2xhdGVkIG1vZGUuIFNlZSBodHRwczovL3dlYi5kZXYvY3Jvc3Mtb3JpZ2luLWlzb2xhdGlvbi1ndWlkZS8gZm9yIG1vcmUgaW5mby5cIiksY29uc29sZS53YXJuKFwiV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEZhbGxpbmcgYmFjayB0byBzaW5nbGUtdGhyZWFkaW5nLlwiKSxlLm51bVRocmVhZHM9bj0xKTtsZXQgcj1lLndhc21QYXRocyxpPXR5cGVvZiByPT1cInN0cmluZ1wiP3I6dm9pZCAwLG89cj8ubWpzLGE9bz8uaHJlZj8/byxjPXI/Lndhc20sZD1jPy5ocmVmPz9jLHc9ZS53YXNtQmluYXJ5LFtsLHVdPWF3YWl0IEllKGEsaSxuPjEpLGI9ITEsdj1bXTtpZih0PjAmJnYucHVzaChuZXcgUHJvbWlzZShmPT57c2V0VGltZW91dCgoKT0+e2I9ITAsZigpfSx0KX0pKSx2LnB1c2gobmV3IFByb21pc2UoKGYseSk9PntsZXQgUD17bnVtVGhyZWFkczpufTtpZih3KVAud2FzbUJpbmFyeT13O2Vsc2UgaWYoZHx8aSlQLmxvY2F0ZUZpbGU9cD0+ZD8/aStwO2Vsc2UgaWYoYSYmYS5pbmRleE9mKFwiYmxvYjpcIikhPT0wKVAubG9jYXRlRmlsZT1wPT5uZXcgVVJMKHAsYSkuaHJlZjtlbHNlIGlmKGwpe2xldCBwPXhlKCk7cCYmKFAubG9jYXRlRmlsZT1oPT5wK2gpfXUoUCkudGhlbihwPT57ZWU9ITEsZGU9ITAsZmU9cCxmKCksbCYmVVJMLnJldm9rZU9iamVjdFVSTChsKX0scD0+e2VlPSExLF9lPSEwLHkocCl9KX0pKSxhd2FpdCBQcm9taXNlLnJhY2UodiksYil0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LFM9KCk9PntpZihkZSYmZmUpcmV0dXJuIGZlO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfX0pO3ZhciBFLEcsZyx0ZT1BKCgpPT57XCJ1c2Ugc3RyaWN0XCI7aigpO0U9KGUsdCk9PntsZXQgbj1TKCkscz1uLmxlbmd0aEJ5dGVzVVRGOChlKSsxLHI9bi5fbWFsbG9jKHMpO3JldHVybiBuLnN0cmluZ1RvVVRGOChlLHIscyksdC5wdXNoKHIpLHJ9LEc9KGUsdCxuLHMpPT57aWYodHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsKXtpZihuLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9uc1wiKTtuLmFkZChlKX1PYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbcixpXSk9PntsZXQgbz10P3QrcjpyO2lmKHR5cGVvZiBpPT1cIm9iamVjdFwiKUcoaSxvK1wiLlwiLG4scyk7ZWxzZSBpZih0eXBlb2YgaT09XCJzdHJpbmdcInx8dHlwZW9mIGk9PVwibnVtYmVyXCIpcyhvLGkudG9TdHJpbmcoKSk7ZWxzZSBpZih0eXBlb2YgaT09XCJib29sZWFuXCIpcyhvLGk/XCIxXCI6XCIwXCIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIGl9YCl9KX0sZz1lPT57bGV0IHQ9UygpLG49dC5zdGFja1NhdmUoKTt0cnl7bGV0IHM9dC5QVFJfU0laRSxyPXQuc3RhY2tBbGxvYygyKnMpO3QuX09ydEdldExhc3RFcnJvcihyLHIrcyk7bGV0IGk9TnVtYmVyKHQuZ2V0VmFsdWUocixzPT09ND9cImkzMlwiOlwiaTY0XCIpKSxvPXQuZ2V0VmFsdWUocitzLFwiKlwiKSxhPW8/dC5VVEY4VG9TdHJpbmcobyk6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gRVJST1JfQ09ERTogJHtpfSwgRVJST1JfTUVTU0FHRTogJHthfWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUobil9fX0pO3ZhciBDZSxCZT1BKCgpPT57XCJ1c2Ugc3RyaWN0XCI7aigpO3RlKCk7Q2U9ZT0+e2xldCB0PVMoKSxuPTAscz1bXSxyPWV8fHt9O3RyeXtpZihlPy5sb2dTZXZlcml0eUxldmVsPT09dm9pZCAwKXIubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYodHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dTZXZlcml0eUxldmVsfWApO2lmKGU/LmxvZ1ZlcmJvc2l0eUxldmVsPT09dm9pZCAwKXIubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKHR5cGVvZiBlLmxvZ1ZlcmJvc2l0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nVmVyYm9zaXR5TGV2ZWx9YCk7ZT8udGVybWluYXRlPT09dm9pZCAwJiYoci50ZXJtaW5hdGU9ITEpO2xldCBpPTA7cmV0dXJuIGU/LnRhZyE9PXZvaWQgMCYmKGk9RShlLnRhZyxzKSksbj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKHIubG9nU2V2ZXJpdHlMZXZlbCxyLmxvZ1ZlcmJvc2l0eUxldmVsLCEhci50ZXJtaW5hdGUsaSksbj09PTAmJmcoXCJDYW4ndCBjcmVhdGUgcnVuIG9wdGlvbnMuXCIpLGU/LmV4dHJhIT09dm9pZCAwJiZHKGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwobyxhKT0+e2xldCBjPUUobyxzKSxkPUUoYSxzKTt0Ll9PcnRBZGRSdW5Db25maWdFbnRyeShuLGMsZCkhPT0wJiZnKGBDYW4ndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke299IC0gJHthfS5gKX0pLFtuLHNdfWNhdGNoKGkpe3Rocm93IG4hPT0wJiZ0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyhuKSxzLmZvckVhY2gobz0+dC5fZnJlZShvKSksaX19fSk7dmFyIFB0LHh0LEl0LF90LE1lLFVlPUEoKCk9PntcInVzZSBzdHJpY3RcIjtqKCk7dGUoKTtQdD1lPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSx4dD1lPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0sSXQ9ZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKG49Pih0eXBlb2Ygbj09XCJzdHJpbmdcIj9uOm4ubmFtZSk9PT1cIndlYmdwdVwiKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9LF90PShlLHQsbik9Pntmb3IobGV0IHMgb2YgdCl7bGV0IHI9dHlwZW9mIHM9PVwic3RyaW5nXCI/czpzLm5hbWU7c3dpdGNoKHIpe2Nhc2VcIndlYm5uXCI6aWYocj1cIldFQk5OXCIsdHlwZW9mIHMhPVwic3RyaW5nXCIpe2xldCBhPXM/LmRldmljZVR5cGU7aWYoYSl7bGV0IGM9RShcImRldmljZVR5cGVcIixuKSxkPUUoYSxuKTtTKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGMsZCkhPT0wJiZnKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2RldmljZVR5cGUnIC0gJHthfS5gKX19YnJlYWs7Y2FzZVwid2ViZ3B1XCI6aWYocj1cIkpTXCIsdHlwZW9mIHMhPVwic3RyaW5nXCIpe2xldCBvPXM7aWYobz8ucHJlZmVycmVkTGF5b3V0KXtpZihvLnByZWZlcnJlZExheW91dCE9PVwiTkNIV1wiJiZvLnByZWZlcnJlZExheW91dCE9PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyICdOQ0hXJyBvciAnTkhXQyc6ICR7by5wcmVmZXJyZWRMYXlvdXR9YCk7bGV0IGE9RShcInByZWZlcnJlZExheW91dFwiLG4pLGM9RShvLnByZWZlcnJlZExheW91dCxuKTtTKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGEsYykhPT0wJiZnKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3ByZWZlcnJlZExheW91dCcgLSAke28ucHJlZmVycmVkTGF5b3V0fS5gKX19YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtyfWApfWxldCBpPUUocixuKTtTKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKGUsaSkhPT0wJiZnKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke3J9LmApfX0sTWU9ZT0+e2xldCB0PVMoKSxuPTAscz1bXSxyPWV8fHt9O0l0KHIpO3RyeXtsZXQgaT1QdChyLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/P1wiYWxsXCIpLG89eHQoci5leGVjdXRpb25Nb2RlPz9cInNlcXVlbnRpYWxcIiksYT10eXBlb2Ygci5sb2dJZD09XCJzdHJpbmdcIj9FKHIubG9nSWQscyk6MCxjPXIubG9nU2V2ZXJpdHlMZXZlbD8/MjtpZighTnVtYmVyLmlzSW50ZWdlcihjKXx8YzwwfHxjPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtjfWApO2xldCBkPXIubG9nVmVyYm9zaXR5TGV2ZWw/PzA7aWYoIU51bWJlci5pc0ludGVnZXIoZCl8fGQ8MHx8ZD40KXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZH1gKTtsZXQgdz10eXBlb2Ygci5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPT1cInN0cmluZ1wiP0Uoci5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLHMpOjA7aWYobj10Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhpLCEhci5lbmFibGVDcHVNZW1BcmVuYSwhIXIuZW5hYmxlTWVtUGF0dGVybixvLCEhci5lbmFibGVQcm9maWxpbmcsMCxhLGMsZCx3KSxuPT09MCYmZyhcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuXCIpLHIuZXhlY3V0aW9uUHJvdmlkZXJzJiZfdChuLHIuZXhlY3V0aW9uUHJvdmlkZXJzLHMpLHIuZW5hYmxlR3JhcGhDYXB0dXJlIT09dm9pZCAwKXtpZih0eXBlb2Ygci5lbmFibGVHcmFwaENhcHR1cmUhPVwiYm9vbGVhblwiKXRocm93IG5ldyBFcnJvcihgZW5hYmxlR3JhcGhDYXB0dXJlIG11c3QgYmUgYSBib29sZWFuIHZhbHVlOiAke3IuZW5hYmxlR3JhcGhDYXB0dXJlfWApO2xldCBsPUUoXCJlbmFibGVHcmFwaENhcHR1cmVcIixzKSx1PUUoci5lbmFibGVHcmFwaENhcHR1cmUudG9TdHJpbmcoKSxzKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkobixsLHUpIT09MCYmZyhgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdlbmFibGVHcmFwaENhcHR1cmUnIC0gJHtyLmVuYWJsZUdyYXBoQ2FwdHVyZX0uYCl9aWYoci5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKWZvcihsZXRbbCx1XW9mIE9iamVjdC5lbnRyaWVzKHIuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpe2lmKHR5cGVvZiBsIT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke2x9YCk7aWYodHlwZW9mIHUhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKHUpfHx1PDApdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7dX1gKTtsZXQgYj1FKGwscyk7dC5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlKG4sYix1KSE9PTAmJmcoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke2x9IC0gJHt1fS5gKX1yZXR1cm4gci5leHRyYSE9PXZvaWQgMCYmRyhyLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKGwsdSk9PntsZXQgYj1FKGwscyksdj1FKHUscyk7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KG4sYix2KSE9PTAmJmcoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2x9IC0gJHt1fS5gKX0pLFtuLHNdfWNhdGNoKGkpe3Rocm93IG4hPT0wJiZ0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobikhPT0wJiZnKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpLHMuZm9yRWFjaChvPT50Ll9mcmVlKG8pKSxpfX19KTt2YXIgSCxrZSxWLERlLFdlLHJlLG5lLEZlLHBlPUEoKCk9PntcInVzZSBzdHJpY3RcIjtIPWU9Pntzd2l0Y2goZSl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiAxMDtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztjYXNlXCJpbnQ0XCI6cmV0dXJuIDIyO2Nhc2VcInVpbnQ0XCI6cmV0dXJuIDIxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LGtlPWU9Pntzd2l0Y2goZSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxMDpyZXR1cm5cImZsb2F0MTZcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtjYXNlIDIyOnJldHVyblwiaW50NFwiO2Nhc2UgMjE6cmV0dXJuXCJ1aW50NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LFY9KGUsdCk9PntsZXQgbj1bLTEsNCwxLDEsMiwyLDQsOCwtMSwxLDIsOCw0LDgsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLjUsLjVdW2VdLHM9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0LnJlZHVjZSgocixpKT0+cippLDEpO3JldHVybiBuPjA/TWF0aC5jZWlsKHMqbik6dm9pZCAwfSxEZT1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb20/RmxvYXQxNkFycmF5OlVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSxXZT1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0scmU9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixuZT1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ2NFwifHxlPT09XCJpbnQ4XCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLEZlPWU9Pntzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybiA1O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2V9YCl9fX0pO3ZhciBxLG1lPUEoKCk9PntcInVzZSBzdHJpY3RcIjtRKCk7cT1hc3luYyBlPT57aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpaWYoVSl0cnl7bGV0e3JlYWRGaWxlOnR9PWNlKFwibm9kZTpmcy9wcm9taXNlc1wiKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdChlKSl9Y2F0Y2godCl7aWYodC5jb2RlPT09XCJFUlJfRlNfRklMRV9UT09fTEFSR0VcIil7bGV0e2NyZWF0ZVJlYWRTdHJlYW06bn09Y2UoXCJub2RlOmZzXCIpLHM9bihlKSxyPVtdO2ZvciBhd2FpdChsZXQgaSBvZiBzKXIucHVzaChpKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChyKSl9dGhyb3cgdH1lbHNle2xldCB0PWF3YWl0IGZldGNoKGUpO2lmKCF0Lm9rKXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2V9YCk7bGV0IG49dC5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLHM9bj9wYXJzZUludChuLDEwKTowO2lmKHM8MTA3Mzc0MTgyNClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdC5hcnJheUJ1ZmZlcigpKTt7aWYoIXQuYm9keSl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtsZXQgcj10LmJvZHkuZ2V0UmVhZGVyKCksaTt0cnl7aT1uZXcgQXJyYXlCdWZmZXIocyl9Y2F0Y2goYSl7aWYoYSBpbnN0YW5jZW9mIFJhbmdlRXJyb3Ipe2xldCBjPU1hdGguY2VpbChzLzY1NTM2KTtpPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6YyxtYXhpbXVtOmN9KS5idWZmZXJ9ZWxzZSB0aHJvdyBhfWxldCBvPTA7Zm9yKDs7KXtsZXR7ZG9uZTphLHZhbHVlOmN9PWF3YWl0IHIucmVhZCgpO2lmKGEpYnJlYWs7bGV0IGQ9Yy5ieXRlTGVuZ3RoO25ldyBVaW50OEFycmF5KGksbyxkKS5zZXQoYyksbys9ZH1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaSwwLHMpfX1lbHNlIHJldHVybiBlIGluc3RhbmNlb2YgQmxvYj9uZXcgVWludDhBcnJheShhd2FpdCBlLmFycmF5QnVmZmVyKCkpOmUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6bmV3IFVpbnQ4QXJyYXkoZSl9fSk7dmFyIEF0LE5lLGplLCQsQ3QsZ2UsJGUsemUsUmUsR2UsSGUsVmU9QSgoKT0+e1widXNlIHN0cmljdFwiO0JlKCk7VWUoKTtwZSgpO2ooKTt0ZSgpO21lKCk7QXQ9KGUsdCk9PntTKCkuX09ydEluaXQoZSx0KSE9PTAmJmcoXCJDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKX0sTmU9YXN5bmMgZT0+e0F0KGUud2FzbS5udW1UaHJlYWRzLFdlKGUubG9nTGV2ZWwpKX0samU9YXN5bmMoZSx0KT0+e30sJD1uZXcgTWFwLEN0PWU9PntsZXQgdD1TKCksbj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgcz10LlBUUl9TSVpFLHI9dC5zdGFja0FsbG9jKDIqcyk7dC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLHIscitzKSE9PTAmJmcoXCJDYW4ndCBnZXQgc2Vzc2lvbiBpbnB1dC9vdXRwdXQgY291bnQuXCIpO2xldCBvPXM9PT00P1wiaTMyXCI6XCJpNjRcIjtyZXR1cm5bTnVtYmVyKHQuZ2V0VmFsdWUocixvKSksTnVtYmVyKHQuZ2V0VmFsdWUocitzLG8pKV19ZmluYWxseXt0LnN0YWNrUmVzdG9yZShuKX19LGdlPWU9PntsZXQgdD1TKCksbj10Ll9tYWxsb2MoZS5ieXRlTGVuZ3RoKTtpZihuPT09MCl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7ZS5ieXRlTGVuZ3RofS5gKTtyZXR1cm4gdC5IRUFQVTguc2V0KGUsbiksW24sZS5ieXRlTGVuZ3RoXX0sJGU9YXN5bmMoZSx0KT0+e2xldCBuLHMscj1TKCk7QXJyYXkuaXNBcnJheShlKT9bbixzXT1lOmUuYnVmZmVyPT09ci5IRUFQVTguYnVmZmVyP1tuLHNdPVtlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoXTpbbixzXT1nZShlKTtsZXQgaT0wLG89MCxhPTAsYz1bXSxkPVtdLHc9W107dHJ5e2lmKFtvLGNdPU1lKHQpLHQ/LmV4dGVybmFsRGF0YSYmci5tb3VudEV4dGVybmFsRGF0YSl7bGV0IHA9W107Zm9yKGxldCBoIG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgeD10eXBlb2YgaD09XCJzdHJpbmdcIj9oOmgucGF0aDtwLnB1c2gocSh0eXBlb2YgaD09XCJzdHJpbmdcIj9oOmguZGF0YSkudGhlbihNPT57ci5tb3VudEV4dGVybmFsRGF0YSh4LE0pfSkpfWF3YWl0IFByb21pc2UuYWxsKHApfWZvcihsZXQgcCBvZiB0Py5leGVjdXRpb25Qcm92aWRlcnM/P1tdKWlmKCh0eXBlb2YgcD09XCJzdHJpbmdcIj9wOnAubmFtZSk9PT1cIndlYm5uXCIpe2lmKHIuc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yPSExLHR5cGVvZiBwIT1cInN0cmluZ1wiKXtsZXQgeD1wLE09eD8uY29udGV4dCxKPXg/LmdwdURldmljZSxZPXg/LmRldmljZVR5cGUsWD14Py5wb3dlclByZWZlcmVuY2U7TT9yLmN1cnJlbnRDb250ZXh0PU06Sj9yLmN1cnJlbnRDb250ZXh0PWF3YWl0IHIuanNlcENyZWF0ZU1MQ29udGV4dChKKTpyLmN1cnJlbnRDb250ZXh0PWF3YWl0IHIuanNlcENyZWF0ZU1MQ29udGV4dCh7ZGV2aWNlVHlwZTpZLHBvd2VyUHJlZmVyZW5jZTpYfSl9ZWxzZSByLmN1cnJlbnRDb250ZXh0PWF3YWl0IHIuanNlcENyZWF0ZU1MQ29udGV4dCgpO2JyZWFrfWk9YXdhaXQgci5fT3J0Q3JlYXRlU2Vzc2lvbihuLHMsbyksaT09PTAmJmcoXCJDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLlwiKSxyLmpzZXBPbkNyZWF0ZVNlc3Npb24/LigpLHIuY3VycmVudENvbnRleHQmJihyLmpzZXBSZWdpc3Rlck1MQ29udGV4dChpLHIuY3VycmVudENvbnRleHQpLHIuY3VycmVudENvbnRleHQ9dm9pZCAwLHIuc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yPSEwKTtsZXRbbCx1XT1DdChpKSxiPSEhdD8uZW5hYmxlR3JhcGhDYXB0dXJlLHY9W10sZj1bXSx5PVtdO2ZvcihsZXQgcD0wO3A8bDtwKyspe2xldCBoPXIuX09ydEdldElucHV0TmFtZShpLHApO2g9PT0wJiZnKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLGQucHVzaChoKSx2LnB1c2goci5VVEY4VG9TdHJpbmcoaCkpfWZvcihsZXQgcD0wO3A8dTtwKyspe2xldCBoPXIuX09ydEdldE91dHB1dE5hbWUoaSxwKTtoPT09MCYmZyhcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZS5cIiksdy5wdXNoKGgpO2xldCB4PXIuVVRGOFRvU3RyaW5nKGgpO2YucHVzaCh4KX1sZXQgUD1udWxsO3JldHVybiAkLnNldChpLFtpLGQsdyxQLGIsITFdKSxbaSx2LGZdfWNhdGNoKGwpe3Rocm93IGQuZm9yRWFjaCh1PT5yLl9PcnRGcmVlKHUpKSx3LmZvckVhY2godT0+ci5fT3J0RnJlZSh1KSksYSE9PTAmJnIuX09ydFJlbGVhc2VCaW5kaW5nKGEpIT09MCYmZyhcIkNhbid0IHJlbGVhc2UgSU8gYmluZGluZy5cIiksaSE9PTAmJnIuX09ydFJlbGVhc2VTZXNzaW9uKGkpIT09MCYmZyhcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIiksbH1maW5hbGx5e3IuX2ZyZWUobiksbyE9PTAmJnIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhvKSE9PTAmJmcoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksYy5mb3JFYWNoKGw9PnIuX2ZyZWUobCkpLHIudW5tb3VudEV4dGVybmFsRGF0YT8uKCl9fSx6ZT1lPT57bGV0IHQ9UygpLG49JC5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVsZWFzZSBzZXNzaW9uLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXRbcyxyLGksbyxhXT1uO28mJihhJiZ0Ll9PcnRDbGVhckJvdW5kT3V0cHV0cyhvLmhhbmRsZSkhPT0wJiZnKFwiQ2FuJ3QgY2xlYXIgYm91bmQgb3V0cHV0cy5cIiksdC5fT3J0UmVsZWFzZUJpbmRpbmcoby5oYW5kbGUpIT09MCYmZyhcIkNhbid0IHJlbGVhc2UgSU8gYmluZGluZy5cIikpLHQuanNlcE9uUmVsZWFzZVNlc3Npb24/LihlKSxyLmZvckVhY2goYz0+dC5fT3J0RnJlZShjKSksaS5mb3JFYWNoKGM9PnQuX09ydEZyZWUoYykpLHQuX09ydFJlbGVhc2VTZXNzaW9uKHMpIT09MCYmZyhcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIiksJC5kZWxldGUoZSl9LFJlPShlLHQsbixzLHIsaT0hMSk9PntpZighZSl7dC5wdXNoKDApO3JldHVybn1sZXQgbz1TKCksYT1vLlBUUl9TSVpFLGM9ZVswXSxkPWVbMV0sdz1lWzNdLGwsdTtpZihjPT09XCJzdHJpbmdcIiYmKHc9PT1cImdwdS1idWZmZXJcInx8dz09PVwibWwtdGVuc29yXCIpKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2lmKGkmJnchPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYEV4dGVybmFsIGJ1ZmZlciBtdXN0IGJlIHByb3ZpZGVkIGZvciBpbnB1dC9vdXRwdXQgaW5kZXggJHtyfSB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO2lmKHc9PT1cImdwdS1idWZmZXJcIil7bGV0IGY9ZVsyXS5ncHVCdWZmZXI7dT1WKEgoYyksZCk7bGV0IHk9by5qc2VwUmVnaXN0ZXJCdWZmZXI7aWYoIXkpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTtsPXkocyxyLGYsdSl9ZWxzZSBpZih3PT09XCJtbC10ZW5zb3JcIil7bGV0IGY9ZVsyXS5tbFRlbnNvcjt1PVYoSChjKSxkKTtsZXQgeT1vLmpzZXBSZWdpc3Rlck1MVGVuc29yO2lmKCF5KXRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO2w9eShmLEgoYyksZCl9ZWxzZXtsZXQgZj1lWzJdO2lmKEFycmF5LmlzQXJyYXkoZikpe3U9YSpmLmxlbmd0aCxsPW8uX21hbGxvYyh1KSxuLnB1c2gobCk7Zm9yKGxldCB5PTA7eTxmLmxlbmd0aDt5Kyspe2lmKHR5cGVvZiBmW3ldIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7eX0gaXMgbm90IGEgc3RyaW5nYCk7by5zZXRWYWx1ZShsK3kqYSxFKGZbeV0sbiksXCIqXCIpfX1lbHNlIHU9Zi5ieXRlTGVuZ3RoLGw9by5fbWFsbG9jKHUpLG4ucHVzaChsKSxvLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoZi5idWZmZXIsZi5ieXRlT2Zmc2V0LHUpLGwpfWxldCBiPW8uc3RhY2tTYXZlKCksdj1vLnN0YWNrQWxsb2MoNCpkLmxlbmd0aCk7dHJ5e2QuZm9yRWFjaCgoeSxQKT0+by5zZXRWYWx1ZSh2K1AqYSx5LGE9PT00P1wiaTMyXCI6XCJpNjRcIikpO2xldCBmPW8uX09ydENyZWF0ZVRlbnNvcihIKGMpLGwsdSx2LGQubGVuZ3RoLEZlKHcpKTtmPT09MCYmZyhgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7c30sIGluZGV4PSR7cn0uYCksdC5wdXNoKGYpfWZpbmFsbHl7by5zdGFja1Jlc3RvcmUoYil9fSxHZT1hc3luYyhlLHQsbixzLHIsaSk9PntsZXQgbz1TKCksYT1vLlBUUl9TSVpFLGM9JC5nZXQoZSk7aWYoIWMpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcnVuIGluZmVyZW5jZS4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0IGQ9Y1swXSx3PWNbMV0sbD1jWzJdLHU9Y1szXSxiPWNbNF0sdj1jWzVdLGY9dC5sZW5ndGgseT1zLmxlbmd0aCxQPTAscD1bXSxoPVtdLHg9W10sTT1bXSxKPW8uc3RhY2tTYXZlKCksWT1vLnN0YWNrQWxsb2MoZiphKSxYPW8uc3RhY2tBbGxvYyhmKmEpLGllPW8uc3RhY2tBbGxvYyh5KmEpLFNlPW8uc3RhY2tBbGxvYyh5KmEpO3RyeXtvLmpzZXBPblJ1blN0YXJ0Py4oZCksW1AscF09Q2UoaSk7Zm9yKGxldCBtPTA7bTxmO20rKylSZShuW21dLGgsTSxlLHRbbV0sYik7Zm9yKGxldCBtPTA7bTx5O20rKylSZShyW21dLHgsTSxlLGYrc1ttXSxiKTtmb3IobGV0IG09MDttPGY7bSsrKW8uc2V0VmFsdWUoWSttKmEsaFttXSxcIipcIiksby5zZXRWYWx1ZShYK20qYSx3W3RbbV1dLFwiKlwiKTtmb3IobGV0IG09MDttPHk7bSsrKW8uc2V0VmFsdWUoaWUrbSphLHhbbV0sXCIqXCIpLG8uc2V0VmFsdWUoU2UrbSphLGxbc1ttXV0sXCIqXCIpO2xldCBDO0M9YXdhaXQgby5fT3J0UnVuKGQsWCxZLGYsU2UseSxpZSxQKSxDIT09MCYmZyhcImZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLlwiKTtsZXQgUj1bXTtmb3IobGV0IG09MDttPHk7bSsrKXtsZXQgTj1OdW1iZXIoby5nZXRWYWx1ZShpZSttKmEsXCIqXCIpKTtpZihOPT09eFttXSl7Ui5wdXNoKHJbbV0pO2NvbnRpbnVlfWxldCBFZT1vLnN0YWNrU2F2ZSgpLEI9by5zdGFja0FsbG9jKDQqYSksej0hMSxULEk9MDt0cnl7by5fT3J0R2V0VGVuc29yRGF0YShOLEIsQithLEIrMiphLEIrMyphKSE9PTAmJmcoYENhbid0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEgb24gaW5kZXggJHttfS5gKTtsZXQgYWU9YT09PTQ/XCJpMzJcIjpcImk2NFwiLFo9TnVtYmVyKG8uZ2V0VmFsdWUoQixhZSkpO0k9by5nZXRWYWx1ZShCK2EsXCIqXCIpO2xldCBPZT1vLmdldFZhbHVlKEIrYSoyLFwiKlwiKSxsdD1OdW1iZXIoby5nZXRWYWx1ZShCK2EqMyxhZSkpLEQ9W107Zm9yKGxldCBMPTA7TDxsdDtMKyspRC5wdXNoKE51bWJlcihvLmdldFZhbHVlKE9lK0wqYSxhZSkpKTtvLl9PcnRGcmVlKE9lKSE9PTAmJmcoXCJDYW4ndCBmcmVlIG1lbW9yeSBmb3IgdGVuc29yIGRpbXMuXCIpO2xldCBXPUQucmVkdWNlKChMLE8pPT5MKk8sMSk7VD1rZShaKTtsZXQgSz11Py5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbc1ttXV07aWYoVD09PVwic3RyaW5nXCIpe2lmKEs9PT1cImdwdS1idWZmZXJcInx8Sz09PVwibWwtdGVuc29yXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7bGV0IEw9W107Zm9yKGxldCBPPTA7TzxXO08rKyl7bGV0IEY9by5nZXRWYWx1ZShJK08qYSxcIipcIiksZnQ9by5nZXRWYWx1ZShJKyhPKzEpKmEsXCIqXCIpLGR0PU89PT1XLTE/dm9pZCAwOmZ0LUY7TC5wdXNoKG8uVVRGOFRvU3RyaW5nKEYsZHQpKX1SLnB1c2goW1QsRCxMLFwiY3B1XCJdKX1lbHNlIGlmKEs9PT1cImdwdS1idWZmZXJcIiYmVz4wKXtsZXQgTD1vLmpzZXBHZXRCdWZmZXI7aWYoIUwpdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO2xldCBPPUwoSSksRj1WKFosVyk7aWYoRj09PXZvaWQgMHx8IXJlKFQpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke1R9YCk7ej0hMCxSLnB1c2goW1QsRCx7Z3B1QnVmZmVyOk8sZG93bmxvYWQ6by5qc2VwQ3JlYXRlRG93bmxvYWRlcihPLEYsVCksZGlzcG9zZTooKT0+e28uX09ydFJlbGVhc2VUZW5zb3IoTikhPT0wJiZnKFwiQ2FuJ3QgcmVsZWFzZSB0ZW5zb3IuXCIpfX0sXCJncHUtYnVmZmVyXCJdKX1lbHNlIGlmKEs9PT1cIm1sLXRlbnNvclwiJiZXPjApe2xldCBMPW8uanNlcEVuc3VyZVRlbnNvcjtpZighTCl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO2lmKFYoWixXKT09PXZvaWQgMHx8IW5lKFQpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke1R9YCk7bGV0IEY9YXdhaXQgTChJLFosRCwhMSk7ej0hMCxSLnB1c2goW1QsRCx7bWxUZW5zb3I6Rixkb3dubG9hZDpvLmpzZXBDcmVhdGVNTFRlbnNvckRvd25sb2FkZXIoSSxUKSxkaXNwb3NlOigpPT57by5qc2VwUmVsZWFzZVRlbnNvcklkKEkpLG8uX09ydFJlbGVhc2VUZW5zb3IoTil9fSxcIm1sLXRlbnNvclwiXSl9ZWxzZXtsZXQgTD1EZShUKSxPPW5ldyBMKFcpO25ldyBVaW50OEFycmF5KE8uYnVmZmVyLE8uYnl0ZU9mZnNldCxPLmJ5dGVMZW5ndGgpLnNldChvLkhFQVBVOC5zdWJhcnJheShJLEkrTy5ieXRlTGVuZ3RoKSksUi5wdXNoKFtULEQsTyxcImNwdVwiXSl9fWZpbmFsbHl7by5zdGFja1Jlc3RvcmUoRWUpLFQ9PT1cInN0cmluZ1wiJiZJJiZvLl9mcmVlKEkpLHp8fG8uX09ydFJlbGVhc2VUZW5zb3IoTil9fXJldHVybiB1JiYhYiYmKG8uX09ydENsZWFyQm91bmRPdXRwdXRzKHUuaGFuZGxlKSE9PTAmJmcoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKSwkLnNldChlLFtkLHcsbCx1LGIsITFdKSksUn1maW5hbGx5e28uc3RhY2tSZXN0b3JlKEopLGguZm9yRWFjaChDPT5vLl9PcnRSZWxlYXNlVGVuc29yKEMpKSx4LmZvckVhY2goQz0+by5fT3J0UmVsZWFzZVRlbnNvcihDKSksTS5mb3JFYWNoKEM9Pm8uX2ZyZWUoQykpLFAhPT0wJiZvLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhQKSxwLmZvckVhY2goQz0+by5fZnJlZShDKSl9fSxIZT1lPT57bGV0IHQ9UygpLG49JC5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCBzPW5bMF0scj10Ll9PcnRFbmRQcm9maWxpbmcocyk7cj09PTAmJmcoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuXCIpLHQuX09ydEZyZWUocil9fSk7aW1wb3J0e2VudiBhcyB5ZX1mcm9tXCJvbm54cnVudGltZS1jb21tb25cIjt2YXIgYmUscWUsSmUsWWUsWGUsWmUsS2UsUWUsZXQsdHQsd2U9QSgoKT0+e1widXNlIHN0cmljdFwiO1ZlKCk7aigpO2xlKCk7YmU9ITEscWU9ITEsSmU9ITEsWWU9YXN5bmMoKT0+e2lmKCFxZSl7aWYoYmUpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRXYXNtKCknIGRldGVjdGVkLlwiKTtpZihKZSl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO2JlPSEwO3RyeXthd2FpdCBBZSh5ZS53YXNtKSxhd2FpdCBOZSh5ZSkscWU9ITB9Y2F0Y2goZSl7dGhyb3cgSmU9ITAsZX1maW5hbGx5e2JlPSExfX19LFhlPWFzeW5jIGU9Pnthd2FpdCBqZSh5ZSxlKX0sWmU9YXN5bmMgZT0+Z2UoZSksS2U9YXN5bmMoZSx0KT0+JGUoZSx0KSxRZT1hc3luYyBlPT57emUoZSl9LGV0PWFzeW5jKGUsdCxuLHMscixpKT0+R2UoZSx0LG4scyxyLGkpLHR0PWFzeW5jIGU9PntIZShlKX19KTtpbXBvcnR7VGVuc29yIGFzIGhlLFRSQUNFX0ZVTkNfQkVHSU4gYXMgcnQsVFJBQ0VfRlVOQ19FTkQgYXMgbnR9ZnJvbVwib25ueHJ1bnRpbWUtY29tbW9uXCI7dmFyIG90LE10LG9lLHN0PUEoKCk9PntcInVzZSBzdHJpY3RcIjt3ZSgpO3BlKCk7USgpO21lKCk7b3Q9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuW2UudHlwZSxlLmRpbXMsZS5kYXRhLFwiY3B1XCJdO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7Z3B1QnVmZmVyOmUuZ3B1QnVmZmVyfSxcImdwdS1idWZmZXJcIl07Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse21sVGVuc29yOmUubWxUZW5zb3J9LFwibWwtdGVuc29yXCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZS5sb2NhdGlvbn0gZm9yICR7dCgpfWApfX0sTXQ9ZT0+e3N3aXRjaChlWzNdKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IGhlKGVbMF0sZVsyXSxlWzFdKTtjYXNlXCJncHUtYnVmZmVyXCI6e2xldCB0PWVbMF07aWYoIXJlKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO2xldHtncHVCdWZmZXI6bixkb3dubG9hZDpzLGRpc3Bvc2U6cn09ZVsyXTtyZXR1cm4gaGUuZnJvbUdwdUJ1ZmZlcihuLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpzLGRpc3Bvc2U6cn0pfWNhc2VcIm1sLXRlbnNvclwiOntsZXQgdD1lWzBdO2lmKCFuZSh0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIE1MVGVuc29yIHRlbnNvcmApO2xldHttbFRlbnNvcjpuLGRvd25sb2FkOnMsZGlzcG9zZTpyfT1lWzJdO3JldHVybiBoZS5mcm9tTUxUZW5zb3Iobix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6cyxkaXNwb3NlOnJ9KX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2VbM119YCl9fSxvZT1jbGFzc3thc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KXtyZXR1cm4gWmUoYXdhaXQgcSh0KSl9YXN5bmMgbG9hZE1vZGVsKHQsbil7cnQoKTtsZXQgczt0eXBlb2YgdD09XCJzdHJpbmdcIj9VP3M9YXdhaXQgcSh0KTpzPWF3YWl0IHRoaXMuZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkodCk6cz10LFt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQgS2UocyxuKSxudCgpfWFzeW5jIGRpc3Bvc2UoKXtyZXR1cm4gUWUodGhpcy5zZXNzaW9uSWQpfWFzeW5jIHJ1bih0LG4scyl7cnQoKTtsZXQgcj1bXSxpPVtdO09iamVjdC5lbnRyaWVzKHQpLmZvckVhY2godT0+e2xldCBiPXVbMF0sdj11WzFdLGY9dGhpcy5pbnB1dE5hbWVzLmluZGV4T2YoYik7aWYoZj09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHtifSdgKTtyLnB1c2godiksaS5wdXNoKGYpfSk7bGV0IG89W10sYT1bXTtPYmplY3QuZW50cmllcyhuKS5mb3JFYWNoKHU9PntsZXQgYj11WzBdLHY9dVsxXSxmPXRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihiKTtpZihmPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG91dHB1dCAnJHtifSdgKTtvLnB1c2godiksYS5wdXNoKGYpfSk7bGV0IGM9ci5tYXAoKHUsYik9Pm90KHUsKCk9PmBpbnB1dCBcIiR7dGhpcy5pbnB1dE5hbWVzW2lbYl1dfVwiYCkpLGQ9by5tYXAoKHUsYik9PnU/b3QodSwoKT0+YG91dHB1dCBcIiR7dGhpcy5vdXRwdXROYW1lc1thW2JdXX1cImApOm51bGwpLHc9YXdhaXQgZXQodGhpcy5zZXNzaW9uSWQsaSxjLGEsZCxzKSxsPXt9O2ZvcihsZXQgdT0wO3U8dy5sZW5ndGg7dSsrKWxbdGhpcy5vdXRwdXROYW1lc1thW3VdXV09b1t1XT8/TXQod1t1XSk7cmV0dXJuIG50KCksbH1zdGFydFByb2ZpbGluZygpe31lbmRQcm9maWxpbmcoKXt0dCh0aGlzLnNlc3Npb25JZCl9fX0pO3ZhciBhdD17fTtidChhdCx7T25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQ6KCk9PnNlLGluaXRpYWxpemVGbGFnczooKT0+aXQsd2FzbUJhY2tlbmQ6KCk9PlV0fSk7aW1wb3J0e2VudiBhcyBffWZyb21cIm9ubnhydW50aW1lLWNvbW1vblwiO3ZhciBpdCxzZSxVdCx1dD1BKCgpPT57XCJ1c2Ugc3RyaWN0XCI7d2UoKTtzdCgpO2l0PSgpPT57aWYoKHR5cGVvZiBfLndhc20uaW5pdFRpbWVvdXQhPVwibnVtYmVyXCJ8fF8ud2FzbS5pbml0VGltZW91dDwwKSYmKF8ud2FzbS5pbml0VGltZW91dD0wKSxfLndhc20uc2ltZD09PSExJiZjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgcHJvcGVydHkgXCJlbnYud2FzbS5zaW1kXCIgaXMgc2V0IHRvIGZhbHNlLiBub24tU0lNRCBidWlsZCBpcyBubyBsb25nZXIgcHJvdmlkZWQsIGFuZCB0aGlzIHNldHRpbmcgd2lsbCBiZSBpZ25vcmVkLicpLHR5cGVvZiBfLndhc20ucHJveHkhPVwiYm9vbGVhblwiJiYoXy53YXNtLnByb3h5PSExKSx0eXBlb2YgXy53YXNtLnRyYWNlIT1cImJvb2xlYW5cIiYmKF8ud2FzbS50cmFjZT0hMSksdHlwZW9mIF8ud2FzbS5udW1UaHJlYWRzIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihfLndhc20ubnVtVGhyZWFkcyl8fF8ud2FzbS5udW1UaHJlYWRzPD0wKWlmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKV8ud2FzbS5udW1UaHJlYWRzPTE7ZWxzZXtsZXQgZT10eXBlb2YgbmF2aWdhdG9yPlwidVwiP2NlKFwibm9kZTpvc1wiKS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O18ud2FzbS5udW1UaHJlYWRzPU1hdGgubWluKDQsTWF0aC5jZWlsKChlfHwxKS8yKSl9fSxzZT1jbGFzc3thc3luYyBpbml0KHQpe2l0KCksYXdhaXQgWWUoKSxhd2FpdCBYZSh0KX1hc3luYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcih0LG4pe2xldCBzPW5ldyBvZTtyZXR1cm4gYXdhaXQgcy5sb2FkTW9kZWwodCxuKSxQcm9taXNlLnJlc29sdmUocyl9fSxVdD1uZXcgc2V9KTtleHBvcnQqZnJvbVwib25ueHJ1bnRpbWUtY29tbW9uXCI7aW1wb3J0KmFzIGt0IGZyb21cIm9ubnhydW50aW1lLWNvbW1vblwiO2ltcG9ydHtyZWdpc3RlckJhY2tlbmQgYXMgY3QsZW52IGFzIER0fWZyb21cIm9ubnhydW50aW1lLWNvbW1vblwiO3ZhciB2ZT1cIjEuMjEuMC1kZXYuMjAyNTAyMDYtZDk4MWIxNTNkM1wiO3ZhciBDcj1rdDt7bGV0IGU9KHV0KCksd3QoYXQpKS53YXNtQmFja2VuZDtjdChcImNwdVwiLGUsMTApLGN0KFwid2FzbVwiLGUsMTApfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdC52ZXJzaW9ucyxcIndlYlwiLHt2YWx1ZTp2ZSxlbnVtZXJhYmxlOiEwfSk7ZXhwb3J0e0NyIGFzIGRlZmF1bHR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3J0Lm5vZGUubWluLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.node.min.mjs?866d\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?2904":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \***************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort.webgpu.bundle.min.e2f00bf6.mjs";

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?eb77":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* binding */ Fp),\n/* harmony export */   TRACE: () => (/* binding */ _r),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* binding */ Ne),\n/* harmony export */   TRACE_FUNC_END: () => (/* binding */ Be),\n/* harmony export */   Tensor: () => (/* binding */ Fe),\n/* harmony export */   \"default\": () => (/* binding */ $1),\n/* harmony export */   env: () => (/* binding */ _e),\n/* harmony export */   registerBackend: () => (/* binding */ Tt)\n/* harmony export */ });\n/*!\n * ONNX Runtime Web v1.21.0-dev.20250206-d981b153d3\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar Rn=Object.defineProperty;var Vp=Object.getOwnPropertyDescriptor;var Wp=Object.getOwnPropertyNames;var Lp=Object.prototype.hasOwnProperty;var Un=(e=>typeof require<\"u\"?require:typeof Proxy<\"u\"?new Proxy(e,{get:(t,r)=>(typeof require<\"u\"?require:t)[r]}):e)(function(e){if(typeof require<\"u\")return require.apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var U=(e,t)=>()=>(e&&(t=e(e=0)),t);var Ht=(e,t)=>{for(var r in t)Rn(e,r,{get:t[r],enumerable:!0})},Gp=(e,t,r,n)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let o of Wp(t))!Lp.call(e,o)&&o!==r&&Rn(e,o,{get:()=>t[o],enumerable:!(n=Vp(t,o))||n.enumerable});return e};var gr=e=>Gp(Rn({},\"__esModule\",{value:!0}),e);var br,St,Tt,Hp,Xi,Nn=U(()=>{\"use strict\";br=new Map,St=[],Tt=(e,t,r)=>{if(t&&typeof t.init==\"function\"&&typeof t.createInferenceSessionHandler==\"function\"){let n=br.get(e);if(n===void 0)br.set(e,{backend:t,priority:r});else{if(n.priority>r)return;if(n.priority===r&&n.backend!==t)throw new Error(`cannot register backend \"${e}\" using priority ${r}`)}if(r>=0){let o=St.indexOf(e);o!==-1&&St.splice(o,1);for(let i=0;i<St.length;i++)if(br.get(St[i]).priority<=r){St.splice(i,0,e);return}St.push(e)}return}throw new TypeError(\"not a valid backend\")},Hp=async e=>{let t=br.get(e);if(!t)return\"backend not found.\";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(n){return r||(t.error=`${n}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Xi=async e=>{let t=e.executionProviders||[],r=t.map(l=>typeof l==\"string\"?l:l.name),n=r.length===0?St:r,o,i=[],a=new Set;for(let l of n){let p=await Hp(l);typeof p==\"string\"?i.push({name:l,err:p}):(o||(o=p),o===p&&a.add(l))}if(!o)throw new Error(`no available backend found. ERR: ${i.map(l=>`[${l.name}] ${l.err}`).join(\", \")}`);for(let{name:l,err:p}of i)r.includes(l)&&console.warn(`removing requested execution provider \"${l}\" from session options because it is not available: ${p}`);let d=t.filter(l=>a.has(typeof l==\"string\"?l:l.name));return[o,new Proxy(e,{get:(l,p)=>p===\"executionProviders\"?d:Reflect.get(l,p)})]}});var Ji=U(()=>{\"use strict\";Nn()});var ea,ta=U(()=>{\"use strict\";ea=\"1.21.0-dev.20250206-d981b153d3\"});var ra,Ue,Vn=U(()=>{\"use strict\";ta();ra=\"warning\",Ue={wasm:{},webgl:{},webgpu:{},versions:{common:ea},set logLevel(e){if(e!==void 0){if(typeof e!=\"string\"||[\"verbose\",\"info\",\"warning\",\"error\",\"fatal\"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);ra=e}},get logLevel(){return ra}};Object.defineProperty(Ue,\"logLevel\",{enumerable:!0})});var _e,na=U(()=>{\"use strict\";Vn();_e=Ue});var oa,ia,aa=U(()=>{\"use strict\";oa=(e,t)=>{let r=typeof document<\"u\"?document.createElement(\"canvas\"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let n=r.getContext(\"2d\");if(n!=null){let o,i;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],i=e.dims[3]):(o=e.dims[3],i=e.dims[2]);let a=t?.format!==void 0?t.format:\"RGB\",d=t?.norm,l,p;d===void 0||d.mean===void 0?l=[255,255,255,255]:typeof d.mean==\"number\"?l=[d.mean,d.mean,d.mean,d.mean]:(l=[d.mean[0],d.mean[1],d.mean[2],0],d.mean[3]!==void 0&&(l[3]=d.mean[3])),d===void 0||d.bias===void 0?p=[0,0,0,0]:typeof d.bias==\"number\"?p=[d.bias,d.bias,d.bias,d.bias]:(p=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(p[3]=d.bias[3]));let m=i*o,u=0,h=m,_=m*2,y=-1;a===\"RGBA\"?(u=0,h=m,_=m*2,y=m*3):a===\"RGB\"?(u=0,h=m,_=m*2):a===\"RBG\"&&(u=0,_=m,h=m*2);for(let g=0;g<i;g++)for(let x=0;x<o;x++){let $=(e.data[u++]-p[0])*l[0],v=(e.data[h++]-p[1])*l[1],S=(e.data[_++]-p[2])*l[2],T=y===-1?255:(e.data[y++]-p[3])*l[3];n.fillStyle=\"rgba(\"+$+\",\"+v+\",\"+S+\",\"+T+\")\",n.fillRect(x,g,1,1)}if(\"toDataURL\"in r)return r.toDataURL();throw new Error(\"toDataURL is not supported\")}else throw new Error(\"Can not access image data\")},ia=(e,t)=>{let r=typeof document<\"u\"?document.createElement(\"canvas\").getContext(\"2d\"):new OffscreenCanvas(1,1).getContext(\"2d\"),n;if(r!=null){let o,i,a;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],i=e.dims[1],a=e.dims[3]):(o=e.dims[3],i=e.dims[2],a=e.dims[1]);let d=t!==void 0&&t.format!==void 0?t.format:\"RGB\",l=t?.norm,p,m;l===void 0||l.mean===void 0?p=[255,255,255,255]:typeof l.mean==\"number\"?p=[l.mean,l.mean,l.mean,l.mean]:(p=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(p[3]=l.mean[3])),l===void 0||l.bias===void 0?m=[0,0,0,0]:typeof l.bias==\"number\"?m=[l.bias,l.bias,l.bias,l.bias]:(m=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(m[3]=l.bias[3]));let u=i*o;if(t!==void 0&&(t.format!==void 0&&a===4&&t.format!==\"RGBA\"||a===3&&t.format!==\"RGB\"&&t.format!==\"BGR\"))throw new Error(\"Tensor format doesn't match input tensor dims\");let h=4,_=0,y=1,g=2,x=3,$=0,v=u,S=u*2,T=-1;d===\"RGBA\"?($=0,v=u,S=u*2,T=u*3):d===\"RGB\"?($=0,v=u,S=u*2):d===\"RBG\"&&($=0,S=u,v=u*2),n=r.createImageData(o,i);for(let A=0;A<i*o;_+=h,y+=h,g+=h,x+=h,A++)n.data[_]=(e.data[$++]-m[0])*p[0],n.data[y]=(e.data[v++]-m[1])*p[1],n.data[g]=(e.data[S++]-m[2])*p[2],n.data[x]=T===-1?255:(e.data[T++]-m[3])*p[3]}else throw new Error(\"Can not access image data\");return n}});var Wn,sa,ua,da,la,ca,pa=U(()=>{\"use strict\";yr();Wn=(e,t)=>{if(e===void 0)throw new Error(\"Image buffer must be defined\");if(t.height===void 0||t.width===void 0)throw new Error(\"Image height and width must be defined\");if(t.tensorLayout===\"NHWC\")throw new Error(\"NHWC Tensor layout is not supported yet\");let{height:r,width:n}=t,o=t.norm??{mean:255,bias:0},i,a;typeof o.mean==\"number\"?i=[o.mean,o.mean,o.mean,o.mean]:i=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias==\"number\"?a=[o.bias,o.bias,o.bias,o.bias]:a=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let d=t.format!==void 0?t.format:\"RGBA\",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:\"RGB\",p=r*n,m=l===\"RGBA\"?new Float32Array(p*4):new Float32Array(p*3),u=4,h=0,_=1,y=2,g=3,x=0,$=p,v=p*2,S=-1;d===\"RGB\"&&(u=3,h=0,_=1,y=2,g=-1),l===\"RGBA\"?S=p*3:l===\"RBG\"?(x=0,v=p,$=p*2):l===\"BGR\"&&(v=0,$=p,x=p*2);for(let A=0;A<p;A++,h+=u,y+=u,_+=u,g+=u)m[x++]=(e[h]+a[0])/i[0],m[$++]=(e[_]+a[1])/i[1],m[v++]=(e[y]+a[2])/i[2],S!==-1&&g!==-1&&(m[S++]=(e[g]+a[3])/i[3]);return l===\"RGBA\"?new ze(\"float32\",m,[1,4,r,n]):new ze(\"float32\",m,[1,3,r,n])},sa=async(e,t)=>{let r=typeof HTMLImageElement<\"u\"&&e instanceof HTMLImageElement,n=typeof ImageData<\"u\"&&e instanceof ImageData,o=typeof ImageBitmap<\"u\"&&e instanceof ImageBitmap,i=typeof e==\"string\",a,d=t??{},l=()=>{if(typeof document<\"u\")return document.createElement(\"canvas\");if(typeof OffscreenCanvas<\"u\")return new OffscreenCanvas(1,1);throw new Error(\"Canvas is not supported\")},p=m=>typeof HTMLCanvasElement<\"u\"&&m instanceof HTMLCanvasElement||m instanceof OffscreenCanvas?m.getContext(\"2d\"):null;if(r){let m=l();m.width=e.width,m.height=e.height;let u=p(m);if(u!=null){let h=e.height,_=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(h=t.resizedHeight,_=t.resizedWidth),t!==void 0){if(d=t,t.tensorFormat!==void 0)throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");d.tensorFormat=\"RGBA\",d.height=h,d.width=_}else d.tensorFormat=\"RGBA\",d.height=h,d.width=_;u.drawImage(e,0,0),a=u.getImageData(0,0,_,h).data}else throw new Error(\"Can not access image data\")}else if(n){let m,u;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(m=t.resizedHeight,u=t.resizedWidth):(m=e.height,u=e.width),t!==void 0&&(d=t),d.format=\"RGBA\",d.height=m,d.width=u,t!==void 0){let h=l();h.width=u,h.height=m;let _=p(h);if(_!=null)_.putImageData(e,0,0),a=_.getImageData(0,0,u,m).data;else throw new Error(\"Can not access image data\")}else a=e.data}else if(o){if(t===void 0)throw new Error(\"Please provide image config with format for Imagebitmap\");let m=l();m.width=e.width,m.height=e.height;let u=p(m);if(u!=null){let h=e.height,_=e.width;return u.drawImage(e,0,0,_,h),a=u.getImageData(0,0,_,h).data,d.height=h,d.width=_,Wn(a,d)}else throw new Error(\"Can not access image data\")}else{if(i)return new Promise((m,u)=>{let h=l(),_=p(h);if(!e||!_)return u();let y=new Image;y.crossOrigin=\"Anonymous\",y.src=e,y.onload=()=>{h.width=y.width,h.height=y.height,_.drawImage(y,0,0,h.width,h.height);let g=_.getImageData(0,0,h.width,h.height);d.height=h.height,d.width=h.width,m(Wn(g.data,d))}});throw new Error(\"Input data provided is not supported - aborted tensor creation\")}if(a!==void 0)return Wn(a,d);throw new Error(\"Input data provided is not supported - aborted tensor creation\")},ua=(e,t)=>{let{width:r,height:n,download:o,dispose:i}=t,a=[1,n,r,4];return new ze({location:\"texture\",type:\"float32\",texture:e,dims:a,download:o,dispose:i})},da=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:i}=t;return new ze({location:\"gpu-buffer\",type:r??\"float32\",gpuBuffer:e,dims:n,download:o,dispose:i})},la=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:i}=t;return new ze({location:\"ml-tensor\",type:r??\"float32\",mlTensor:e,dims:n,download:o,dispose:i})},ca=(e,t,r)=>new ze({location:\"cpu-pinned\",type:e,data:t,dims:r??[t.length]})});var It,Ft,ma,fa,ha=U(()=>{\"use strict\";It=new Map([[\"float32\",Float32Array],[\"uint8\",Uint8Array],[\"int8\",Int8Array],[\"uint16\",Uint16Array],[\"int16\",Int16Array],[\"int32\",Int32Array],[\"bool\",Uint8Array],[\"float64\",Float64Array],[\"uint32\",Uint32Array],[\"int4\",Uint8Array],[\"uint4\",Uint8Array]]),Ft=new Map([[Float32Array,\"float32\"],[Uint8Array,\"uint8\"],[Int8Array,\"int8\"],[Uint16Array,\"uint16\"],[Int16Array,\"int16\"],[Int32Array,\"int32\"],[Float64Array,\"float64\"],[Uint32Array,\"uint32\"]]),ma=!1,fa=()=>{if(!ma){ma=!0;let e=typeof BigInt64Array<\"u\"&&BigInt64Array.from,t=typeof BigUint64Array<\"u\"&&BigUint64Array.from,r=typeof Float16Array<\"u\"&&Float16Array.from;e&&(It.set(\"int64\",BigInt64Array),Ft.set(BigInt64Array,\"int64\")),t&&(It.set(\"uint64\",BigUint64Array),Ft.set(BigUint64Array,\"uint64\")),r?(It.set(\"float16\",Float16Array),Ft.set(Float16Array,\"float16\")):It.set(\"float16\",Uint16Array)}}});var ga,ba,ya=U(()=>{\"use strict\";yr();ga=e=>{let t=1;for(let r=0;r<e.length;r++){let n=e[r];if(typeof n!=\"number\"||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},ba=(e,t)=>{switch(e.location){case\"cpu\":return new ze(e.type,e.data,t);case\"cpu-pinned\":return new ze({location:\"cpu-pinned\",data:e.data,type:e.type,dims:t});case\"texture\":return new ze({location:\"texture\",texture:e.texture,type:e.type,dims:t});case\"gpu-buffer\":return new ze({location:\"gpu-buffer\",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case\"ml-tensor\":return new ze({location:\"ml-tensor\",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var ze,yr=U(()=>{\"use strict\";aa();pa();ha();ya();ze=class{constructor(t,r,n){fa();let o,i;if(typeof t==\"object\"&&\"location\"in t)switch(this.dataLocation=t.location,o=t.type,i=t.dims,t.location){case\"cpu-pinned\":{let d=It.get(o);if(!d)throw new TypeError(`unsupported type \"${o}\" to create tensor from pinned buffer`);if(!(t.data instanceof d))throw new TypeError(`buffer should be of type ${d.name}`);this.cpuData=t.data;break}case\"texture\":{if(o!==\"float32\")throw new TypeError(`unsupported type \"${o}\" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case\"gpu-buffer\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case\"ml-tensor\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint64\"&&o!==\"int8\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let d,l;if(typeof t==\"string\")if(o=t,l=n,t===\"string\"){if(!Array.isArray(r))throw new TypeError(\"A string tensor's data must be a string array.\");d=r}else{let p=It.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t===\"float16\"&&p===Uint16Array||t===\"uint4\"||t===\"int4\")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${p.name} as data.`);t===\"uint64\"||t===\"int64\"?d=p.from(r,BigInt):d=p.from(r)}else if(r instanceof p)d=r;else if(r instanceof Uint8ClampedArray)if(t===\"uint8\")d=Uint8Array.from(r);else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");else throw new TypeError(`A ${o} tensor's data must be type of ${p}`)}else if(l=r,Array.isArray(t)){if(t.length===0)throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");let p=typeof t[0];if(p===\"string\")o=\"string\",d=t;else if(p===\"boolean\")o=\"bool\",d=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else if(t instanceof Uint8ClampedArray)o=\"uint8\",d=Uint8Array.from(t);else{let p=Ft.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=p,d=t}if(l===void 0)l=[d.length];else if(!Array.isArray(l))throw new TypeError(\"A tensor's dims must be a number array\");i=l,this.cpuData=d,this.dataLocation=\"cpu\"}let a=ga(i);if(this.cpuData&&a!==this.cpuData.length&&!((o===\"uint4\"||o===\"int4\")&&Math.ceil(a/2)===this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=i,this.size=a}static async fromImage(t,r){return sa(t,r)}static fromTexture(t,r){return ua(t,r)}static fromGpuBuffer(t,r){return da(t,r)}static fromMLTensor(t,r){return la(t,r)}static fromPinnedBuffer(t,r,n){return ca(t,r,n)}toDataURL(t){return oa(this,t)}toImageData(t){return ia(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error(\"The data is not stored as a WebGL texture.\");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error(\"The data is not stored as a WebGPU buffer.\");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error(\"The data is not stored as a WebNN MLTensor.\");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case\"cpu\":case\"cpu-pinned\":return this.data;case\"texture\":case\"gpu-buffer\":case\"ml-tensor\":{if(!this.downloader)throw new Error(\"The current tensor is not created with a specified data downloader.\");if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation=\"cpu\",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation=\"none\"}ensureValid(){if(this.dataLocation===\"none\")throw new Error(\"The tensor is disposed.\")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");return ba(this,t)}}});var Fe,Ln=U(()=>{\"use strict\";yr();Fe=ze});var _r,_a,Ne,Be,Gn=U(()=>{\"use strict\";Vn();_r=(e,t)=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||console.timeStamp(`${e}::ORT::${t}`)},_a=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],n=!1;for(let o=0;o<r.length;o++){if(n&&!r[o].includes(\"TRACE_FUNC\")){let i=`FUNC_${e}::${r[o].trim().split(\" \")[1]}`;t&&(i+=`::${t}`),_r(\"CPU\",i);return}r[o].includes(\"TRACE_FUNC\")&&(n=!0)}},Ne=e=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||_a(\"BEGIN\",e)},Be=e=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||_a(\"END\",e)}});var wr,wa=U(()=>{\"use strict\";Nn();Ln();Gn();wr=class e{constructor(t){this.handler=t}async run(t,r,n){Ne();let o={},i={};if(typeof t!=\"object\"||t===null||t instanceof Fe||Array.isArray(t))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let a=!0;if(typeof r==\"object\"){if(r===null)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(r instanceof Fe)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(r)){if(r.length===0)throw new TypeError(\"'fetches' cannot be an empty array.\");a=!1;for(let p of r){if(typeof p!=\"string\")throw new TypeError(\"'fetches' must be a string array or an object.\");if(this.outputNames.indexOf(p)===-1)throw new RangeError(`'fetches' contains invalid output name: ${p}.`);o[p]=null}if(typeof n==\"object\"&&n!==null)i=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else{let p=!1,m=Object.getOwnPropertyNames(r);for(let u of this.outputNames)if(m.indexOf(u)!==-1){let h=r[u];(h===null||h instanceof Fe)&&(p=!0,a=!1,o[u]=h)}if(p){if(typeof n==\"object\"&&n!==null)i=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else i=r}}else if(typeof r<\"u\")throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(let p of this.inputNames)if(typeof t[p]>\"u\")throw new Error(`input '${p}' is missing in 'feeds'.`);if(a)for(let p of this.outputNames)o[p]=null;let d=await this.handler.run(t,o,i),l={};for(let p in d)if(Object.hasOwnProperty.call(d,p)){let m=d[p];m instanceof Fe?l[p]=m:l[p]=new Fe(m.type,m.data,m.dims)}return Be(),l}async release(){return this.handler.dispose()}static async create(t,r,n,o){Ne();let i,a={};if(typeof t==\"string\"){if(i=t,typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof Uint8Array){if(i=t,typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<\"u\"&&t instanceof SharedArrayBuffer){let m=t,u=0,h=t.byteLength;if(typeof r==\"object\"&&r!==null)a=r;else if(typeof r==\"number\"){if(u=r,!Number.isSafeInteger(u))throw new RangeError(\"'byteOffset' must be an integer.\");if(u<0||u>=m.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${m.byteLength}).`);if(h=t.byteLength-u,typeof n==\"number\"){if(h=n,!Number.isSafeInteger(h))throw new RangeError(\"'byteLength' must be an integer.\");if(h<=0||u+h>m.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${m.byteLength-u}].`);if(typeof o==\"object\"&&o!==null)a=o;else if(typeof o<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(typeof n<\"u\")throw new TypeError(\"'byteLength' must be a number.\")}else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\");i=new Uint8Array(m,u,h)}else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");let[d,l]=await Xi(a),p=await d.createInferenceSessionHandler(i,l);return Be(),new e(p)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Fp,va=U(()=>{\"use strict\";wa();Fp=wr});var $a=U(()=>{\"use strict\"});var xa=U(()=>{\"use strict\"});var Sa=U(()=>{\"use strict\"});var Ta=U(()=>{\"use strict\"});var Hn={};Ht(Hn,{InferenceSession:()=>Fp,TRACE:()=>_r,TRACE_FUNC_BEGIN:()=>Ne,TRACE_FUNC_END:()=>Be,Tensor:()=>Fe,env:()=>_e,registerBackend:()=>Tt});var Le=U(()=>{\"use strict\";Ji();na();va();Ln();$a();xa();Gn();Sa();Ta()});var vr=U(()=>{\"use strict\"});var ka={};Ht(ka,{default:()=>qp});var Ca,Aa,qp,Ea=U(()=>{\"use strict\";Fn();gt();$r();Ca=\"ort-wasm-proxy-worker\",Aa=globalThis.self?.name===Ca;Aa&&(self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case\"init-wasm\":xr(r.wasm).then(()=>{Sr(r).then(()=>{postMessage({type:t})},n=>{postMessage({type:t,err:n})})},n=>{postMessage({type:t,err:n})});break;case\"init-ep\":{let{epName:n,env:o}=r;Tr(o,n).then(()=>{postMessage({type:t})},i=>{postMessage({type:t,err:i})});break}case\"copy-from\":{let{buffer:n}=r,o=qt(n);postMessage({type:t,out:o});break}case\"create\":{let{model:n,options:o}=r;Ir(n,o).then(i=>{postMessage({type:t,out:i})},i=>{postMessage({type:t,err:i})});break}case\"release\":Cr(r),postMessage({type:t});break;case\"run\":{let{sessionId:n,inputIndices:o,inputs:i,outputIndices:a,options:d}=r;Ar(n,o,i,a,new Array(a.length).fill(null),d).then(l=>{l.some(p=>p[3]!==\"cpu\")?postMessage({type:t,err:\"Proxy does not support non-cpu tensor location.\"}):postMessage({type:t,out:l},Er([...i,...l]))},l=>{postMessage({type:t,err:l})});break}case\"end-profiling\":kr(r),postMessage({type:t});break;default:}}catch(n){postMessage({type:t,err:n})}});qp=Aa?null:e=>new Worker(e??Ve,{type:\"module\",name:Ca})});var za={};Ht(za,{default:()=>Kp});var qn,Pa,Kp,Oa=U(()=>{\"use strict\";Pa=(qn=\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\",async function(e={}){function t(){return K.buffer!=Q.buffer&&pe(),Q}function r(){return K.buffer!=Q.buffer&&pe(),ie}function n(){return K.buffer!=Q.buffer&&pe(),te}function o(){return K.buffer!=Q.buffer&&pe(),be}function i(){return K.buffer!=Q.buffer&&pe(),Oe}function a(){return K.buffer!=Q.buffer&&pe(),ve}function d(){return K.buffer!=Q.buffer&&pe(),de}function l(){return K.buffer!=Q.buffer&&pe(),he}var p,m,u=Object.assign({},e),h=new Promise((s,c)=>{p=s,m=c}),_=typeof window==\"object\",y=typeof importScripts==\"function\",g=y&&self.name==\"em-pthread\";u.mountExternalData=(s,c)=>{s.startsWith(\"./\")&&(s=s.substring(2)),(u.Fb||(u.Fb=new Map)).set(s,c)},u.unmountExternalData=()=>{delete u.Fb};var x=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let $=()=>{let s=(f,b,w)=>(...I)=>{let O=Xe,B=b?.();I=f(...I);let G=b?.();return B!==G&&(f=G,w(B),b=w=null),Xe!=O?new Promise((F,X)=>{kn={resolve:F,reject:X}}):I},c=f=>async(...b)=>{try{if(u.Gb)throw Error(\"Session already started\");let w=u.Gb={hc:b[0],errors:[]},I=await f(...b);if(u.Gb!==w)throw Error(\"Session mismatch\");u.Hb?.flush();let O=w.errors;if(0<O.length){let B=await Promise.all(O);if(B=B.filter(G=>G),0<B.length)throw Error(B.join(`\n`))}return I}finally{u.Gb=null}};u._OrtCreateSession=s(u._OrtCreateSession,()=>u._OrtCreateSession,f=>u._OrtCreateSession=f),u._OrtRun=c(s(u._OrtRun,()=>u._OrtRun,f=>u._OrtRun=f)),u._OrtRunWithBinding=c(s(u._OrtRunWithBinding,()=>u._OrtRunWithBinding,f=>u._OrtRunWithBinding=f)),u._OrtBindInput=s(u._OrtBindInput,()=>u._OrtBindInput,f=>u._OrtBindInput=f),$=void 0};u.jsepInit=(s,c)=>{if($?.(),s===\"webgpu\"){[u.Hb,u.Vb,u.Zb,u.Ob,u.Yb,u.kb,u.$b,u.cc,u.Wb,u.Xb,u.ac]=c;let f=u.Hb;u.jsepRegisterBuffer=(b,w,I,O)=>f.registerBuffer(b,w,I,O),u.jsepGetBuffer=b=>f.getBuffer(b),u.jsepCreateDownloader=(b,w,I)=>f.createDownloader(b,w,I),u.jsepOnCreateSession=b=>{f.onCreateSession(b)},u.jsepOnReleaseSession=b=>{f.onReleaseSession(b)},u.jsepOnRunStart=b=>f.onRunStart(b),u.dc=(b,w)=>{f.upload(b,w)}}else if(s===\"webnn\"){[u.Hb,u.bc,u.Pb,u.jsepEnsureTensor,u.ec,u.jsepDownloadTensor]=c,u.jsepReleaseTensorId=u.Pb;let f=u.Hb;u.jsepOnRunStart=b=>f.onRunStart(b),u.jsepRegisterMLContext=(b,w)=>{f.registerMLContext(b,w)},u.jsepOnReleaseSession=b=>{f.onReleaseSession(b)},u.jsepCreateMLTensorDownloader=(b,w)=>f.createMLTensorDownloader(b,w),u.jsepRegisterMLTensor=(b,w,I)=>f.registerMLTensor(b,w,I),u.jsepCreateMLContext=b=>f.createMLContext(b),u.jsepRegisterMLConstant=(b,w,I,O,B)=>f.registerMLConstant(b,w,I,O,B,u.Fb)}};var v,S,T=Object.assign({},u),A=(s,c)=>{throw c},C=\"\";(_||y)&&(y?C=self.location.href:typeof document<\"u\"&&document.currentScript&&(C=document.currentScript.src),qn&&(C=qn),C=C.startsWith(\"blob:\")?\"\":C.substr(0,C.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1),y&&(S=s=>{var c=new XMLHttpRequest;return c.open(\"GET\",s,!1),c.responseType=\"arraybuffer\",c.send(null),new Uint8Array(c.response)}),v=(s,c,f)=>{var b=new XMLHttpRequest;b.open(\"GET\",s,!0),b.responseType=\"arraybuffer\",b.onload=()=>{b.status==200||b.status==0&&b.response?c(b.response):f()},b.onerror=f,b.send(null)});var P,D=console.log.bind(console),R=console.error.bind(console),H=D,L=R;if(Object.assign(u,T),T=null,g){let s=function(c){try{var f=c.data,b=f.cmd;if(b===\"load\"){let w=[];self.onmessage=I=>w.push(I),self.startWorker=()=>{postMessage({cmd:\"loaded\"});for(let I of w)s(I);self.onmessage=s};for(let I of f.handlers)u[I]&&!u[I].proxy||(u[I]=(...O)=>{postMessage({Nb:\"callHandler\",pc:I,args:O})},I==\"print\"&&(H=u[I]),I==\"printErr\"&&(L=u[I]));K=f.wasmMemory,pe(),re(f.wasmModule)}else if(b===\"run\"){On(f.pthread_ptr,0,0,1,0,0),Cn(f.pthread_ptr),xc(),Go(),V||(Vi(),V=!0);try{Sc(f.start_routine,f.arg)}catch(w){if(w!=\"unwind\")throw w}}else b===\"cancel\"?Rt()&&fr(-1):f.target!==\"setimmediate\"&&(b===\"checkMailbox\"?V&&or():b&&(L(`worker: received unknown command ${b}`),L(f)))}catch(w){throw Wi(),w}};var wg=s,re,V=!1;L=function(...c){c=c.join(\" \"),console.error(c)},self.alert=function(...c){postMessage({Nb:\"alert\",text:c.join(\" \"),rc:Rt()})},u.instantiateWasm=(c,f)=>new Promise(b=>{re=w=>{w=new WebAssembly.Instance(w,Uo()),f(w),b()}}),self.onunhandledrejection=c=>{throw c.reason||c},self.onmessage=s}u.wasmBinary&&(P=u.wasmBinary);var K,we,j,Q,ie,te,be,Oe,ve,de,W,Y,he,De=!1;function pe(){var s=K.buffer;u.HEAP8=Q=new Int8Array(s),u.HEAP16=te=new Int16Array(s),u.HEAPU8=ie=new Uint8Array(s),u.HEAPU16=be=new Uint16Array(s),u.HEAP32=Oe=new Int32Array(s),u.HEAPU32=ve=new Uint32Array(s),u.HEAPF32=de=new Float32Array(s),u.HEAPF64=he=new Float64Array(s),u.HEAP64=W=new BigInt64Array(s),u.HEAPU64=Y=new BigUint64Array(s)}if(!g){if(!((K=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof x))throw L(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),Error(\"bad memory\");pe()}var Ie=[],He=[],mn=[],wt=0,fn=null,Gt=null;function Oo(){if(--wt==0&&(fn!==null&&(clearInterval(fn),fn=null),Gt)){var s=Gt;Gt=null,s()}}function ct(s){throw L(s=\"Aborted(\"+s+\")\"),De=!0,j=1,s=new WebAssembly.RuntimeError(s+\". Build with -sASSERTIONS for more info.\"),m(s),s}var hn,Do=s=>s.startsWith(\"data:application/octet-stream;base64,\"),Bo=s=>s.startsWith(\"file://\");function Mo(s){if(s==hn&&P)return new Uint8Array(P);if(S)return S(s);throw\"both async and sync fetching of the wasm failed\"}function Ro(s,c,f){return function(b){if(!P&&(_||y)){if(typeof fetch==\"function\"&&!Bo(b))return fetch(b,{credentials:\"same-origin\"}).then(w=>{if(!w.ok)throw`failed to load wasm binary file at '${b}'`;return w.arrayBuffer()}).catch(()=>Mo(b));if(v)return new Promise((w,I)=>{v(b,O=>w(new Uint8Array(O)),I)})}return Promise.resolve().then(()=>Mo(b))}(s).then(b=>WebAssembly.instantiate(b,c)).then(f,b=>{L(`failed to asynchronously prepare wasm: ${b}`),ct(b)})}function Uo(){return{a:{O:$c,Aa:vc,b:Ic,aa:Ko,B:Zo,qa:Qo,Y:Jo,_:ei,ra:ti,oa:ri,ha:ni,na:oi,L:ii,Z:ai,W:si,pa:ui,X:di,va:Cc,F:kc,Q:Ec,P:zc,E:Dc,u:Bc,q:Mc,G:Rc,A:Hc,R:Fc,ua:qc,ka:Kc,U:jc,ba:Yc,H:Zc,ja:Cn,ta:Qc,t:Xc,Ba:Jc,x:rp,o:np,m:ip,c:Tn,n:ap,k:dp,w:lp,p:cp,f:pp,s:mp,l:fp,e:hp,j:gp,i:bp,g:yp,d:_p,ea:wp,fa:vp,ga:$p,ca:xi,da:Si,T:xp,h:Sp,D:Tp,I:Ip,M:Cp,y:Ap,sa:kp,V:Ep,v:Ii,z:Pp,N:zp,S:Op,za:Dp,ya:Bp,la:ki,ma:Ei,$:wn,C:Pi,K:zi,ia:Oi,J:Di,a:K,xa:_n,wa:Ri,r:Up}}}var gn={916868:(s,c,f,b,w)=>{if(u===void 0||!u.Fb)return 1;if((s=Ce(Number(s>>>0))).startsWith(\"./\")&&(s=s.substring(2)),!(s=u.Fb.get(s)))return 2;if(c=Number(c>>>0),f=Number(f>>>0),b=Number(b>>>0),c+f>s.byteLength)return 3;try{let I=s.subarray(c,c+f);switch(w){case 0:r().set(I,b>>>0);break;case 1:u.dc(b,I);break;default:return 4}return 0}catch{return 4}},917583:(s,c,f)=>{u.ec(s,r().subarray(c>>>0,c+f>>>0))},917646:()=>u.bc(),917687:s=>{u.Pb(s)},917723:()=>{u.Wb()},917754:()=>{u.Xb()},917783:()=>{u.ac()},917808:s=>u.Vb(s),917841:s=>u.Zb(s),917873:(s,c,f)=>{u.Ob(Number(s),Number(c),Number(f),!0)},917936:(s,c,f)=>{u.Ob(Number(s),Number(c),Number(f))},917993:()=>typeof wasmOffsetConverter<\"u\",918050:s=>{u.kb(\"Abs\",s,void 0)},918101:s=>{u.kb(\"Neg\",s,void 0)},918152:s=>{u.kb(\"Floor\",s,void 0)},918205:s=>{u.kb(\"Ceil\",s,void 0)},918257:s=>{u.kb(\"Reciprocal\",s,void 0)},918315:s=>{u.kb(\"Sqrt\",s,void 0)},918367:s=>{u.kb(\"Exp\",s,void 0)},918418:s=>{u.kb(\"Erf\",s,void 0)},918469:s=>{u.kb(\"Sigmoid\",s,void 0)},918524:(s,c,f)=>{u.kb(\"HardSigmoid\",s,{alpha:c,beta:f})},918603:s=>{u.kb(\"Log\",s,void 0)},918654:s=>{u.kb(\"Sin\",s,void 0)},918705:s=>{u.kb(\"Cos\",s,void 0)},918756:s=>{u.kb(\"Tan\",s,void 0)},918807:s=>{u.kb(\"Asin\",s,void 0)},918859:s=>{u.kb(\"Acos\",s,void 0)},918911:s=>{u.kb(\"Atan\",s,void 0)},918963:s=>{u.kb(\"Sinh\",s,void 0)},919015:s=>{u.kb(\"Cosh\",s,void 0)},919067:s=>{u.kb(\"Asinh\",s,void 0)},919120:s=>{u.kb(\"Acosh\",s,void 0)},919173:s=>{u.kb(\"Atanh\",s,void 0)},919226:s=>{u.kb(\"Tanh\",s,void 0)},919278:s=>{u.kb(\"Not\",s,void 0)},919329:(s,c,f)=>{u.kb(\"Clip\",s,{min:c,max:f})},919398:s=>{u.kb(\"Clip\",s,void 0)},919450:(s,c)=>{u.kb(\"Elu\",s,{alpha:c})},919508:s=>{u.kb(\"Gelu\",s,void 0)},919560:s=>{u.kb(\"Relu\",s,void 0)},919612:(s,c)=>{u.kb(\"LeakyRelu\",s,{alpha:c})},919676:(s,c)=>{u.kb(\"ThresholdedRelu\",s,{alpha:c})},919746:(s,c)=>{u.kb(\"Cast\",s,{to:c})},919804:s=>{u.kb(\"Add\",s,void 0)},919855:s=>{u.kb(\"Sub\",s,void 0)},919906:s=>{u.kb(\"Mul\",s,void 0)},919957:s=>{u.kb(\"Div\",s,void 0)},920008:s=>{u.kb(\"Pow\",s,void 0)},920059:s=>{u.kb(\"Equal\",s,void 0)},920112:s=>{u.kb(\"Greater\",s,void 0)},920167:s=>{u.kb(\"GreaterOrEqual\",s,void 0)},920229:s=>{u.kb(\"Less\",s,void 0)},920281:s=>{u.kb(\"LessOrEqual\",s,void 0)},920340:(s,c,f,b,w)=>{u.kb(\"ReduceMean\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},920515:(s,c,f,b,w)=>{u.kb(\"ReduceMax\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},920689:(s,c,f,b,w)=>{u.kb(\"ReduceMin\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},920863:(s,c,f,b,w)=>{u.kb(\"ReduceProd\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921038:(s,c,f,b,w)=>{u.kb(\"ReduceSum\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921212:(s,c,f,b,w)=>{u.kb(\"ReduceL1\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921385:(s,c,f,b,w)=>{u.kb(\"ReduceL2\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921558:(s,c,f,b,w)=>{u.kb(\"ReduceLogSum\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921735:(s,c,f,b,w)=>{u.kb(\"ReduceSumSquare\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},921915:(s,c,f,b,w)=>{u.kb(\"ReduceLogSumExp\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},922095:s=>{u.kb(\"Where\",s,void 0)},922148:(s,c,f)=>{u.kb(\"Transpose\",s,{perm:c?Array.from(i().subarray(Number(c)>>>0,Number(f)>>>0)):[]})},922272:(s,c,f,b)=>{u.kb(\"DepthToSpace\",s,{blocksize:c,mode:Ce(f),format:b?\"NHWC\":\"NCHW\"})},922405:(s,c,f,b)=>{u.kb(\"DepthToSpace\",s,{blocksize:c,mode:Ce(f),format:b?\"NHWC\":\"NCHW\"})},922538:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z,ue)=>{u.kb(\"ConvTranspose\",s,{format:G?\"NHWC\":\"NCHW\",autoPad:c,dilations:[f],group:b,kernelShape:[w],pads:[I,O],strides:[B],wIsConst:()=>!!t()[F>>>0],outputPadding:X?Array.from(i().subarray(Number(X)>>>0,Number(le)>>>0)):[],outputShape:ge?Array.from(i().subarray(Number(ge)>>>0,Number(z)>>>0)):[],activation:Ce(ue)})},922971:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"ConvTranspose\",s,{format:B?\"NHWC\":\"NCHW\",autoPad:c,dilations:Array.from(i().subarray(Number(f)>>>0,2+(Number(f)>>>0)>>>0)),group:b,kernelShape:Array.from(i().subarray(Number(w)>>>0,2+(Number(w)>>>0)>>>0)),pads:Array.from(i().subarray(Number(I)>>>0,4+(Number(I)>>>0)>>>0)),strides:Array.from(i().subarray(Number(O)>>>0,2+(Number(O)>>>0)>>>0)),wIsConst:()=>!!t()[G>>>0],outputPadding:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],outputShape:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[],activation:Ce(z)})},923632:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z,ue)=>{u.kb(\"ConvTranspose\",s,{format:G?\"NHWC\":\"NCHW\",autoPad:c,dilations:[f],group:b,kernelShape:[w],pads:[I,O],strides:[B],wIsConst:()=>!!t()[F>>>0],outputPadding:X?Array.from(i().subarray(Number(X)>>>0,Number(le)>>>0)):[],outputShape:ge?Array.from(i().subarray(Number(ge)>>>0,Number(z)>>>0)):[],activation:Ce(ue)})},924065:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"ConvTranspose\",s,{format:B?\"NHWC\":\"NCHW\",autoPad:c,dilations:Array.from(i().subarray(Number(f)>>>0,2+(Number(f)>>>0)>>>0)),group:b,kernelShape:Array.from(i().subarray(Number(w)>>>0,2+(Number(w)>>>0)>>>0)),pads:Array.from(i().subarray(Number(I)>>>0,4+(Number(I)>>>0)>>>0)),strides:Array.from(i().subarray(Number(O)>>>0,2+(Number(O)>>>0)>>>0)),wIsConst:()=>!!t()[G>>>0],outputPadding:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],outputShape:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[],activation:Ce(z)})},924726:(s,c)=>{u.kb(\"GlobalAveragePool\",s,{format:c?\"NHWC\":\"NCHW\"})},924817:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"AveragePool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(G)>>>0)):[],pads:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],strides:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[]})},925296:(s,c)=>{u.kb(\"GlobalAveragePool\",s,{format:c?\"NHWC\":\"NCHW\"})},925387:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"AveragePool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(G)>>>0)):[],pads:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],strides:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[]})},925866:(s,c)=>{u.kb(\"GlobalMaxPool\",s,{format:c?\"NHWC\":\"NCHW\"})},925953:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"MaxPool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(G)>>>0)):[],pads:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],strides:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[]})},926428:(s,c)=>{u.kb(\"GlobalMaxPool\",s,{format:c?\"NHWC\":\"NCHW\"})},926515:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z)=>{u.kb(\"MaxPool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(G)>>>0)):[],pads:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],strides:le?Array.from(i().subarray(Number(le)>>>0,Number(ge)>>>0)):[]})},926990:(s,c,f,b,w)=>{u.kb(\"Gemm\",s,{alpha:c,beta:f,transA:b,transB:w})},927094:s=>{u.kb(\"MatMul\",s,void 0)},927148:(s,c,f,b)=>{u.kb(\"ArgMax\",s,{keepDims:!!c,selectLastIndex:!!f,axis:b})},927256:(s,c,f,b)=>{u.kb(\"ArgMin\",s,{keepDims:!!c,selectLastIndex:!!f,axis:b})},927364:(s,c)=>{u.kb(\"Softmax\",s,{axis:c})},927427:(s,c)=>{u.kb(\"Concat\",s,{axis:c})},927487:(s,c,f,b,w)=>{u.kb(\"Split\",s,{axis:c,numOutputs:f,splitSizes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},927643:s=>{u.kb(\"Expand\",s,void 0)},927697:(s,c)=>{u.kb(\"Gather\",s,{axis:Number(c)})},927768:(s,c)=>{u.kb(\"GatherElements\",s,{axis:Number(c)})},927847:(s,c)=>{u.kb(\"GatherND\",s,{batch_dims:Number(c)})},927926:(s,c,f,b,w,I,O,B,G,F,X)=>{u.kb(\"Resize\",s,{antialias:c,axes:f?Array.from(i().subarray(Number(f)>>>0,Number(b)>>>0)):[],coordinateTransformMode:Ce(w),cubicCoeffA:I,excludeOutside:O,extrapolationValue:B,keepAspectRatioPolicy:Ce(G),mode:Ce(F),nearestMode:Ce(X)})},928288:(s,c,f,b,w,I,O)=>{u.kb(\"Slice\",s,{starts:c?Array.from(i().subarray(Number(c)>>>0,Number(f)>>>0)):[],ends:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[],axes:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[]})},928552:s=>{u.kb(\"Tile\",s,void 0)},928604:(s,c,f)=>{u.kb(\"InstanceNormalization\",s,{epsilon:c,format:f?\"NHWC\":\"NCHW\"})},928718:(s,c,f)=>{u.kb(\"InstanceNormalization\",s,{epsilon:c,format:f?\"NHWC\":\"NCHW\"})},928832:s=>{u.kb(\"Range\",s,void 0)},928885:(s,c)=>{u.kb(\"Einsum\",s,{equation:Ce(c)})},928966:(s,c,f,b,w)=>{u.kb(\"Pad\",s,{mode:c,value:f,pads:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},929109:(s,c,f,b,w,I)=>{u.kb(\"BatchNormalization\",s,{epsilon:c,momentum:f,spatial:!!w,trainingMode:!!b,format:I?\"NHWC\":\"NCHW\"})},929278:(s,c,f,b,w,I)=>{u.kb(\"BatchNormalization\",s,{epsilon:c,momentum:f,spatial:!!w,trainingMode:!!b,format:I?\"NHWC\":\"NCHW\"})},929447:(s,c,f)=>{u.kb(\"CumSum\",s,{exclusive:Number(c),reverse:Number(f)})},929544:(s,c,f)=>{u.kb(\"DequantizeLinear\",s,{axis:c,blockSize:f})},929634:(s,c,f,b,w)=>{u.kb(\"GridSample\",s,{align_corners:c,mode:Ce(f),padding_mode:Ce(b),format:w?\"NHWC\":\"NCHW\"})},929804:(s,c,f,b,w)=>{u.kb(\"GridSample\",s,{align_corners:c,mode:Ce(f),padding_mode:Ce(b),format:w?\"NHWC\":\"NCHW\"})},929974:(s,c,f,b,w,I,O,B,G)=>{u.kb(\"Attention\",s,{numHeads:c,isUnidirectional:f,maskFilterValue:b,scale:w,doRotary:I,qkvHiddenSizes:O?Array.from(i().subarray(Number(B)>>>0,Number(B)+O>>>0)):[],pastPresentShareBuffer:!!G})},930246:s=>{u.kb(\"BiasAdd\",s,void 0)},930301:s=>{u.kb(\"BiasSplitGelu\",s,void 0)},930362:s=>{u.kb(\"FastGelu\",s,void 0)},930418:(s,c,f,b,w,I,O,B,G,F,X,le,ge,z,ue,Se)=>{u.kb(\"Conv\",s,{format:le?\"NHWC\":\"NCHW\",auto_pad:c,dilations:f?Array.from(i().subarray(Number(f)>>>0,Number(b)>>>0)):[],group:w,kernel_shape:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],pads:B?Array.from(i().subarray(Number(B)>>>0,Number(G)>>>0)):[],strides:F?Array.from(i().subarray(Number(F)>>>0,Number(X)>>>0)):[],w_is_const:()=>!!t()[Number(ge)>>>0],activation:Ce(z),activation_params:ue?Array.from(d().subarray(Number(ue)>>>0,Number(Se)>>>0)):[]})},931002:s=>{u.kb(\"Gelu\",s,void 0)},931054:(s,c,f,b,w,I,O,B,G)=>{u.kb(\"GroupQueryAttention\",s,{numHeads:c,kvNumHeads:f,scale:b,softcap:w,doRotary:I,rotaryInterleaved:O,smoothSoftmax:B,localWindowSize:G})},931271:(s,c,f,b)=>{u.kb(\"LayerNormalization\",s,{axis:c,epsilon:f,simplified:!!b})},931382:(s,c,f,b)=>{u.kb(\"LayerNormalization\",s,{axis:c,epsilon:f,simplified:!!b})},931493:(s,c,f,b,w,I)=>{u.kb(\"MatMulNBits\",s,{k:c,n:f,accuracyLevel:b,bits:w,blockSize:I})},931620:(s,c,f,b,w,I)=>{u.kb(\"MultiHeadAttention\",s,{numHeads:c,isUnidirectional:f,maskFilterValue:b,scale:w,doRotary:I})},931779:(s,c)=>{u.kb(\"QuickGelu\",s,{alpha:c})},931843:(s,c,f,b,w)=>{u.kb(\"RotaryEmbedding\",s,{interleaved:!!c,numHeads:f,rotaryEmbeddingDim:b,scale:w})},931982:(s,c,f)=>{u.kb(\"SkipLayerNormalization\",s,{epsilon:c,simplified:!!f})},932084:(s,c,f)=>{u.kb(\"SkipLayerNormalization\",s,{epsilon:c,simplified:!!f})},932186:(s,c,f,b)=>{u.kb(\"GatherBlockQuantized\",s,{gatherAxis:c,quantizeAxis:f,blockSize:b})},932307:s=>{u.$b(s)},932341:(s,c)=>u.cc(Number(s),Number(c),u.Gb.hc,u.Gb.errors)};function vc(s,c,f){return yi(async()=>{await u.Yb(Number(s),Number(c),Number(f))})}function $c(){return typeof wasmOffsetConverter<\"u\"}function bn(s){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${s})`,this.status=s}var yn=s=>{s.terminate(),s.onmessage=()=>{}},No=s=>{pt.length==0&&(Fo(),Ho(pt[0]));var c=pt.pop();if(!c)return 6;$t.push(c),Ze[s.Bb]=c,c.Bb=s.Bb;var f={cmd:\"run\",start_routine:s.ic,arg:s.Rb,pthread_ptr:s.Bb};return c.postMessage(f,s.nc),0},vt=0,$e=(s,c,...f)=>{for(var b=2*f.length,w=Mn(),I=Bn(8*b),O=I>>>3,B=0;B<f.length;B++){var G=f[B];typeof G==\"bigint\"?(W[O+2*B]=1n,W[O+2*B+1]=G):(W[O+2*B]=0n,l()[O+2*B+1>>>0]=G)}return s=Li(s,0,b,I,c),hr(w),s};function _n(s){if(g)return $e(0,1,s);if(j=s,!(0<vt)){for(var c of $t)yn(c);for(c of pt)yn(c);pt=[],$t=[],Ze=[],De=!0}A(0,new bn(s))}function Vo(s){if(g)return $e(1,0,s);wn(s)}var wn=s=>{if(j=s,g)throw Vo(s),\"unwind\";_n(s)},pt=[],$t=[],Wo=[],Ze={},Lo=s=>{var c=s.Bb;delete Ze[c],pt.push(s),$t.splice($t.indexOf(s),1),s.Bb=0,Dn(c)};function Go(){Wo.forEach(s=>s())}var Ho=s=>new Promise(c=>{s.onmessage=w=>{var I=(w=w.data).cmd;if(w.targetThread&&w.targetThread!=Rt()){var O=Ze[w.targetThread];O?O.postMessage(w,w.transferList):L(`Internal error! Worker sent a message \"${I}\" to target pthread ${w.targetThread}, but that thread no longer exists!`)}else I===\"checkMailbox\"?or():I===\"spawnThread\"?No(w):I===\"cleanupThread\"?Lo(Ze[w.thread]):I===\"killThread\"?(w=w.thread,I=Ze[w],delete Ze[w],yn(I),Dn(w),$t.splice($t.indexOf(I),1),I.Bb=0):I===\"cancelThread\"?Ze[w.thread].postMessage({cmd:\"cancel\"}):I===\"loaded\"?(s.loaded=!0,c(s)):I===\"alert\"?alert(`Thread ${w.threadId}: ${w.text}`):w.target===\"setimmediate\"?s.postMessage(w):I===\"callHandler\"?u[w.handler](...w.args):I&&L(`worker sent an unknown command ${I}`)},s.onerror=w=>{throw L(`worker sent an error! ${w.filename}:${w.lineno}: ${w.message}`),w};var f,b=[];for(f of[])u.hasOwnProperty(f)&&b.push(f);s.postMessage({cmd:\"load\",handlers:b,wasmMemory:K,wasmModule:we})});function Fo(){var s=new Worker(\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\".startsWith(\"file:\")?/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?2904\")):new URL(\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"),{type:\"module\",workerData:\"em-pthread\",name:\"em-pthread\"});pt.push(s)}var nr=s=>{for(;0<s.length;)s.shift()(u)},xc=()=>{var s=Rt(),c=a()[s+52>>>2>>>0];s=a()[s+56>>>2>>>0],Hi(c,c-s),hr(c)},Sc=(s,c)=>{vt=0,s=Fi(s,c),0<vt?j=s:fr(s)};class Tc{constructor(c){this.Kb=c-24}}function Ic(s,c,f){var b=new Tc(s>>>=0);throw c>>>=0,f>>>=0,a()[b.Kb+16>>>2>>>0]=0,a()[b.Kb+4>>>2>>>0]=c,a()[b.Kb+8>>>2>>>0]=f,s}function qo(s,c,f,b){return g?$e(2,1,s,c,f,b):Ko(s,c,f,b)}function Ko(s,c,f,b){if(s>>>=0,c>>>=0,f>>>=0,b>>>=0,x===void 0)return L(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var w=[];return g&&w.length===0?qo(s,c,f,b):(s={ic:f,Bb:s,Rb:b,nc:w},g?(s.Nb=\"spawnThread\",postMessage(s,w),0):No(s))}var jo=typeof TextDecoder<\"u\"?new TextDecoder(\"utf8\"):void 0,Yo=(s,c,f)=>{var b=(c>>>=0)+f;for(f=c;s[f]&&!(f>=b);)++f;if(16<f-c&&s.buffer&&jo)return jo.decode(s.buffer instanceof x?s.slice(c,f):s.subarray(c,f));for(b=\"\";c<f;){var w=s[c++];if(128&w){var I=63&s[c++];if((224&w)==192)b+=String.fromCharCode((31&w)<<6|I);else{var O=63&s[c++];65536>(w=(240&w)==224?(15&w)<<12|I<<6|O:(7&w)<<18|I<<12|O<<6|63&s[c++])?b+=String.fromCharCode(w):(w-=65536,b+=String.fromCharCode(55296|w>>10,56320|1023&w))}}else b+=String.fromCharCode(w)}return b},Ce=(s,c)=>(s>>>=0)?Yo(r(),s,c):\"\";function Zo(s,c,f){return g?$e(3,1,s,c,f):0}function Qo(s,c){if(g)return $e(4,1,s,c)}var vn=s=>{for(var c=0,f=0;f<s.length;++f){var b=s.charCodeAt(f);127>=b?c++:2047>=b?c+=2:55296<=b&&57343>=b?(c+=4,++f):c+=3}return c},Xo=(s,c,f,b)=>{if(!(0<b))return 0;var w=f>>>=0;b=f+b-1;for(var I=0;I<s.length;++I){var O=s.charCodeAt(I);if(55296<=O&&57343>=O&&(O=65536+((1023&O)<<10)|1023&s.charCodeAt(++I)),127>=O){if(f>=b)break;c[f++>>>0]=O}else{if(2047>=O){if(f+1>=b)break;c[f++>>>0]=192|O>>6}else{if(65535>=O){if(f+2>=b)break;c[f++>>>0]=224|O>>12}else{if(f+3>=b)break;c[f++>>>0]=240|O>>18,c[f++>>>0]=128|O>>12&63}c[f++>>>0]=128|O>>6&63}c[f++>>>0]=128|63&O}}return c[f>>>0]=0,f-w},Dt=(s,c,f)=>Xo(s,r(),c,f);function Jo(s,c){if(g)return $e(5,1,s,c)}function ei(s,c,f){if(g)return $e(6,1,s,c,f)}function ti(s,c,f){return g?$e(7,1,s,c,f):0}function ri(s,c){if(g)return $e(8,1,s,c)}function ni(s,c,f){if(g)return $e(9,1,s,c,f)}function oi(s,c,f,b){if(g)return $e(10,1,s,c,f,b)}function ii(s,c,f,b){if(g)return $e(11,1,s,c,f,b)}function ai(s,c,f,b){if(g)return $e(12,1,s,c,f,b)}function si(s){if(g)return $e(13,1,s)}function ui(s,c){if(g)return $e(14,1,s,c)}function di(s,c,f){if(g)return $e(15,1,s,c,f)}var li,mt,Cc=()=>{ct(\"\")},Qe=s=>{for(var c=\"\";r()[s>>>0];)c+=li[r()[s++>>>0]];return c},$n={},xn={},Ac={};function st(s,c,f={}){if(!(\"argPackAdvance\"in c))throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");return function(b,w,I={}){var O=w.name;if(!b)throw new mt(`type \"${O}\" must have a positive integer typeid pointer`);if(xn.hasOwnProperty(b)){if(I.Tb)return;throw new mt(`Cannot register type '${O}' twice`)}xn[b]=w,delete Ac[b],$n.hasOwnProperty(b)&&(w=$n[b],delete $n[b],w.forEach(B=>B()))}(s,c,f)}var ci=(s,c,f)=>{switch(c){case 1:return f?b=>t()[b>>>0]:b=>r()[b>>>0];case 2:return f?b=>n()[b>>>1>>>0]:b=>o()[b>>>1>>>0];case 4:return f?b=>i()[b>>>2>>>0]:b=>a()[b>>>2>>>0];case 8:return f?b=>W[b>>>3]:b=>Y[b>>>3];default:throw new TypeError(`invalid integer width (${c}): ${s}`)}};function kc(s,c,f){f>>>=0,st(s>>>=0,{name:c=Qe(c>>>0),fromWireType:b=>b,toWireType:function(b,w){if(typeof w!=\"bigint\"&&typeof w!=\"number\")throw w=w===null?\"null\":(b=typeof w)==\"object\"||b===\"array\"||b===\"function\"?w.toString():\"\"+w,new TypeError(`Cannot convert \"${w}\" to ${this.name}`);return typeof w==\"number\"&&(w=BigInt(w)),w},argPackAdvance:ft,readValueFromPointer:ci(c,f,c.indexOf(\"u\")==-1),Eb:null})}var ft=8;function Ec(s,c,f,b){st(s>>>=0,{name:c=Qe(c>>>0),fromWireType:function(w){return!!w},toWireType:function(w,I){return I?f:b},argPackAdvance:ft,readValueFromPointer:function(w){return this.fromWireType(r()[w>>>0])},Eb:null})}var Sn=[],ut=[];function Tn(s){9<(s>>>=0)&&--ut[s+1]==0&&(ut[s]=void 0,Sn.push(s))}var Re=s=>{if(!s)throw new mt(\"Cannot use deleted val. handle = \"+s);return ut[s]},We=s=>{switch(s){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let c=Sn.pop()||ut.length;return ut[c]=s,ut[c+1]=1,c}};function In(s){return this.fromWireType(a()[s>>>2>>>0])}var Pc={name:\"emscripten::val\",fromWireType:s=>{var c=Re(s);return Tn(s),c},toWireType:(s,c)=>We(c),argPackAdvance:ft,readValueFromPointer:In,Eb:null};function zc(s){return st(s>>>0,Pc)}var Oc=(s,c)=>{switch(c){case 4:return function(f){return this.fromWireType(d()[f>>>2>>>0])};case 8:return function(f){return this.fromWireType(l()[f>>>3>>>0])};default:throw new TypeError(`invalid float width (${c}): ${s}`)}};function Dc(s,c,f){f>>>=0,st(s>>>=0,{name:c=Qe(c>>>0),fromWireType:b=>b,toWireType:(b,w)=>w,argPackAdvance:ft,readValueFromPointer:Oc(c,f),Eb:null})}function Bc(s,c,f,b,w){if(s>>>=0,f>>>=0,c=Qe(c>>>0),w===-1&&(w=4294967295),w=B=>B,b===0){var I=32-8*f;w=B=>B<<I>>>I}var O=c.includes(\"unsigned\")?function(B,G){return G>>>0}:function(B,G){return G};st(s,{name:c,fromWireType:w,toWireType:O,argPackAdvance:ft,readValueFromPointer:ci(c,f,b!==0),Eb:null})}function Mc(s,c,f){function b(I){var O=a()[I>>>2>>>0];return I=a()[I+4>>>2>>>0],new w(t().buffer,I,O)}var w=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][c];st(s>>>=0,{name:f=Qe(f>>>0),fromWireType:b,argPackAdvance:ft,readValueFromPointer:b},{Tb:!0})}function Rc(s,c){s>>>=0;var f=(c=Qe(c>>>0))===\"std::string\";st(s,{name:c,fromWireType:function(b){var w=a()[b>>>2>>>0],I=b+4;if(f)for(var O=I,B=0;B<=w;++B){var G=I+B;if(B==w||r()[G>>>0]==0){if(O=Ce(O,G-O),F===void 0)var F=O;else F+=String.fromCharCode(0),F+=O;O=G+1}}else{for(F=Array(w),B=0;B<w;++B)F[B]=String.fromCharCode(r()[I+B>>>0]);F=F.join(\"\")}return Je(b),F},toWireType:function(b,w){w instanceof ArrayBuffer&&(w=new Uint8Array(w));var I=typeof w==\"string\";if(!(I||w instanceof Uint8Array||w instanceof Uint8ClampedArray||w instanceof Int8Array))throw new mt(\"Cannot pass non-string to std::string\");var O=f&&I?vn(w):w.length,B=mr(4+O+1),G=B+4;if(a()[B>>>2>>>0]=O,f&&I)Dt(w,G,O+1);else if(I)for(I=0;I<O;++I){var F=w.charCodeAt(I);if(255<F)throw Je(G),new mt(\"String has UTF-16 code units that do not fit in 8 bits\");r()[G+I>>>0]=F}else for(I=0;I<O;++I)r()[G+I>>>0]=w[I];return b!==null&&b.push(Je,B),B},argPackAdvance:ft,readValueFromPointer:In,Eb(b){Je(b)}})}var pi=typeof TextDecoder<\"u\"?new TextDecoder(\"utf-16le\"):void 0,Uc=(s,c)=>{for(var f=s>>1,b=f+c/2;!(f>=b)&&o()[f>>>0];)++f;if(32<(f<<=1)-s&&pi)return pi.decode(r().slice(s,f));for(f=\"\",b=0;!(b>=c/2);++b){var w=n()[s+2*b>>>1>>>0];if(w==0)break;f+=String.fromCharCode(w)}return f},Nc=(s,c,f)=>{if(f??=2147483647,2>f)return 0;var b=c;f=(f-=2)<2*s.length?f/2:s.length;for(var w=0;w<f;++w){var I=s.charCodeAt(w);n()[c>>>1>>>0]=I,c+=2}return n()[c>>>1>>>0]=0,c-b},Vc=s=>2*s.length,Wc=(s,c)=>{for(var f=0,b=\"\";!(f>=c/4);){var w=i()[s+4*f>>>2>>>0];if(w==0)break;++f,65536<=w?(w-=65536,b+=String.fromCharCode(55296|w>>10,56320|1023&w)):b+=String.fromCharCode(w)}return b},Lc=(s,c,f)=>{if(c>>>=0,f??=2147483647,4>f)return 0;var b=c;f=b+f-4;for(var w=0;w<s.length;++w){var I=s.charCodeAt(w);if(55296<=I&&57343>=I&&(I=65536+((1023&I)<<10)|1023&s.charCodeAt(++w)),i()[c>>>2>>>0]=I,(c+=4)+4>f)break}return i()[c>>>2>>>0]=0,c-b},Gc=s=>{for(var c=0,f=0;f<s.length;++f){var b=s.charCodeAt(f);55296<=b&&57343>=b&&++f,c+=4}return c};function Hc(s,c,f){if(s>>>=0,c>>>=0,f=Qe(f>>>=0),c===2)var b=Uc,w=Nc,I=Vc,O=B=>o()[B>>>1>>>0];else c===4&&(b=Wc,w=Lc,I=Gc,O=B=>a()[B>>>2>>>0]);st(s,{name:f,fromWireType:B=>{for(var G,F=a()[B>>>2>>>0],X=B+4,le=0;le<=F;++le){var ge=B+4+le*c;le!=F&&O(ge)!=0||(X=b(X,ge-X),G===void 0?G=X:(G+=String.fromCharCode(0),G+=X),X=ge+c)}return Je(B),G},toWireType:(B,G)=>{if(typeof G!=\"string\")throw new mt(`Cannot pass non-string to C++ string type ${f}`);var F=I(G),X=mr(4+F+c);return a()[X>>>2>>>0]=F/c,w(G,X+4,F+c),B!==null&&B.push(Je,X),X},argPackAdvance:ft,readValueFromPointer:In,Eb(B){Je(B)}})}function Fc(s,c){st(s>>>=0,{Ub:!0,name:c=Qe(c>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var qc=()=>1;function Kc(s){On(s>>>0,!y,1,!_,131072,!1),Go()}var mi=s=>{if(!De)try{if(s(),!(0<vt))try{g?fr(j):wn(j)}catch(c){c instanceof bn||c==\"unwind\"||A(0,c)}}catch(c){c instanceof bn||c==\"unwind\"||A(0,c)}};function Cn(s){s>>>=0,typeof Atomics.oc==\"function\"&&(Atomics.oc(i(),s>>>2,s).value.then(or),s+=128,Atomics.store(i(),s>>>2,1))}var or=()=>{var s=Rt();s&&(Cn(s),mi(Gi))};function jc(s,c){(s>>>=0)==c>>>0?setTimeout(or):g?postMessage({targetThread:s,cmd:\"checkMailbox\"}):(s=Ze[s])&&s.postMessage({cmd:\"checkMailbox\"})}var An=[];function Yc(s,c,f,b,w){for(c>>>=0,b/=2,An.length=b,f=w>>>0>>>3,w=0;w<b;w++)An[w]=W[f+2*w]?W[f+2*w+1]:l()[f+2*w+1>>>0];return(c?gn[c]:Np[s])(...An)}function Zc(s){s>>>=0,g?postMessage({cmd:\"cleanupThread\",thread:s}):Lo(Ze[s])}function Qc(s){}var ir=(s,c)=>{var f=xn[s];if(f===void 0)throw s=Ni(s),f=Qe(s),Je(s),new mt(`${c} has unknown type ${f}`);return f},fi=(s,c,f)=>{var b=[];return s=s.toWireType(b,f),b.length&&(a()[c>>>2>>>0]=We(b)),s};function Xc(s,c,f){return c>>>=0,f>>>=0,s=Re(s>>>0),c=ir(c,\"emval::as\"),fi(c,f,s)}function Jc(s,c){return c>>>=0,s=Re(s>>>0),(c=ir(c,\"emval::as\")).toWireType(null,s)}var ar=s=>{try{s()}catch(c){ct(c)}},ht=0,Xe=null,hi=0,sr=[],gi={},bi={},ep=0,kn=null,tp=[];function yi(s){return function(c){if(!De){if(ht===0){var f=!1,b=!1;c((w=0)=>{if(!De&&(hi=w,f=!0,b)){ht=2,ar(()=>ji(Xe)),typeof Browser<\"u\"&&Browser.Lb.Sb&&Browser.Lb.resume(),w=!1;try{var I=function(){var G=i()[Xe+8>>>2>>>0];return G=Z[bi[G]],--vt,G()}()}catch(G){I=G,w=!0}var O=!1;if(!Xe){var B=kn;B&&(kn=null,(w?B.reject:B.resolve)(I),O=!0)}if(w&&!O)throw I}}),b=!0,f||(ht=1,Xe=function(){var w=mr(65548),I=w+12;a()[w>>>2>>>0]=I,a()[w+4>>>2>>>0]=I+65536,I=sr[0];var O=gi[I];return O===void 0&&(O=ep++,gi[I]=O,bi[O]=I),I=O,i()[w+8>>>2>>>0]=I,w}(),typeof Browser<\"u\"&&Browser.Lb.Sb&&Browser.Lb.pause(),ar(()=>qi(Xe)))}else ht===2?(ht=0,ar(Yi),Je(Xe),Xe=null,tp.forEach(mi)):ct(`invalid state: ${ht}`);return hi}}(c=>{s().then(c)})}function rp(s){return s>>>=0,yi(()=>(s=Re(s)).then(We))}var ur=[];function np(s,c,f,b){return f>>>=0,b>>>=0,(s=ur[s>>>0])(null,c=Re(c>>>0),f,b)}var op={},dr=s=>{var c=op[s];return c===void 0?Qe(s):c};function ip(s,c,f,b,w){return f>>>=0,b>>>=0,w>>>=0,(s=ur[s>>>0])(c=Re(c>>>0),c[f=dr(f)],b,w)}var _i=()=>typeof globalThis==\"object\"?globalThis:Function(\"return this\")();function ap(s){return(s>>>=0)==0?We(_i()):(s=dr(s),We(_i()[s]))}var sp=s=>{var c=ur.length;return ur.push(s),c},up=(s,c)=>{for(var f=Array(s),b=0;b<s;++b)f[b]=ir(a()[c+4*b>>>2>>>0],\"parameter \"+b);return f},wi=(s,c)=>Object.defineProperty(c,\"name\",{value:s});function dp(s,c,f){var b=(c=up(s,c>>>0)).shift();s--;var w=`return function (obj, func, destructorsRef, args) {\n`,I=0,O=[];f===0&&O.push(\"obj\");for(var B=[\"retType\"],G=[b],F=0;F<s;++F)O.push(\"arg\"+F),B.push(\"argType\"+F),G.push(c[F]),w+=`  var arg${F} = argType${F}.readValueFromPointer(args${I?\"+\"+I:\"\"});\n`,I+=c[F].argPackAdvance;return w+=`  var rv = ${f===1?\"new func\":\"func.call\"}(${O.join(\", \")});\n`,b.Ub||(B.push(\"emval_returnValue\"),G.push(fi),w+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),B.push(w+`};\n`),s=function(X){var le=Function;if(!(le instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof le} which is not a function`);var ge=wi(le.name||\"unknownFunctionName\",function(){});return ge.prototype=le.prototype,ge=new ge,(X=le.apply(ge,X))instanceof Object?X:ge}(B)(...G),f=`methodCaller<(${c.map(X=>X.name).join(\", \")}) => ${b.name}>`,sp(wi(f,s))}function lp(s){return s=dr(s>>>0),We(u[s])}function cp(s,c){return c>>>=0,s=Re(s>>>0),c=Re(c),We(s[c])}function pp(s){9<(s>>>=0)&&(ut[s+1]+=1)}function mp(){return We([])}function fp(s){s=Re(s>>>0);for(var c=Array(s.length),f=0;f<s.length;f++)c[f]=s[f];return We(c)}function hp(s){return We(dr(s>>>0))}function gp(){return We({})}function bp(s){for(var c=Re(s>>>=0);c.length;){var f=c.pop();c.pop()(f)}Tn(s)}function yp(s,c,f){c>>>=0,f>>>=0,s=Re(s>>>0),c=Re(c),f=Re(f),s[c]=f}function _p(s,c){return c>>>=0,s=(s=ir(s>>>0,\"_emval_take_value\")).readValueFromPointer(c),We(s)}function wp(s,c){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),c>>>=0,s=new Date(1e3*s),i()[c>>>2>>>0]=s.getUTCSeconds(),i()[c+4>>>2>>>0]=s.getUTCMinutes(),i()[c+8>>>2>>>0]=s.getUTCHours(),i()[c+12>>>2>>>0]=s.getUTCDate(),i()[c+16>>>2>>>0]=s.getUTCMonth(),i()[c+20>>>2>>>0]=s.getUTCFullYear()-1900,i()[c+24>>>2>>>0]=s.getUTCDay(),s=(s.getTime()-Date.UTC(s.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[c+28>>>2>>>0]=s}var Bt=s=>s%4==0&&(s%100!=0||s%400==0),vi=[0,31,60,91,121,152,182,213,244,274,305,335],$i=[0,31,59,90,120,151,181,212,243,273,304,334];function vp(s,c){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),c>>>=0,s=new Date(1e3*s),i()[c>>>2>>>0]=s.getSeconds(),i()[c+4>>>2>>>0]=s.getMinutes(),i()[c+8>>>2>>>0]=s.getHours(),i()[c+12>>>2>>>0]=s.getDate(),i()[c+16>>>2>>>0]=s.getMonth(),i()[c+20>>>2>>>0]=s.getFullYear()-1900,i()[c+24>>>2>>>0]=s.getDay();var f=(Bt(s.getFullYear())?vi:$i)[s.getMonth()]+s.getDate()-1|0;i()[c+28>>>2>>>0]=f,i()[c+36>>>2>>>0]=-60*s.getTimezoneOffset(),f=new Date(s.getFullYear(),6,1).getTimezoneOffset();var b=new Date(s.getFullYear(),0,1).getTimezoneOffset();s=0|(f!=b&&s.getTimezoneOffset()==Math.min(b,f)),i()[c+32>>>2>>>0]=s}function $p(s){s>>>=0;var c=new Date(i()[s+20>>>2>>>0]+1900,i()[s+16>>>2>>>0],i()[s+12>>>2>>>0],i()[s+8>>>2>>>0],i()[s+4>>>2>>>0],i()[s>>>2>>>0],0),f=i()[s+32>>>2>>>0],b=c.getTimezoneOffset(),w=new Date(c.getFullYear(),6,1).getTimezoneOffset(),I=new Date(c.getFullYear(),0,1).getTimezoneOffset(),O=Math.min(I,w);return 0>f?i()[s+32>>>2>>>0]=+(w!=I&&O==b):0<f!=(O==b)&&(w=Math.max(I,w),c.setTime(c.getTime()+6e4*((0<f?O:w)-b))),i()[s+24>>>2>>>0]=c.getDay(),f=(Bt(c.getFullYear())?vi:$i)[c.getMonth()]+c.getDate()-1|0,i()[s+28>>>2>>>0]=f,i()[s>>>2>>>0]=c.getSeconds(),i()[s+4>>>2>>>0]=c.getMinutes(),i()[s+8>>>2>>>0]=c.getHours(),i()[s+12>>>2>>>0]=c.getDate(),i()[s+16>>>2>>>0]=c.getMonth(),i()[s+20>>>2>>>0]=c.getYear(),s=c.getTime(),BigInt(isNaN(s)?-1:s/1e3)}function xi(s,c,f,b,w,I,O){return g?$e(16,1,s,c,f,b,w,I,O):-52}function Si(s,c,f,b,w,I){if(g)return $e(17,1,s,c,f,b,w,I)}function xp(s,c,f,b){s>>>=0,c>>>=0,f>>>=0,b>>>=0;var w=new Date().getFullYear(),I=new Date(w,0,1),O=new Date(w,6,1);w=I.getTimezoneOffset();var B=O.getTimezoneOffset(),G=Math.max(w,B);a()[s>>>2>>>0]=60*G,i()[c>>>2>>>0]=+(w!=B),I=(s=F=>F.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:\"short\"}).split(\" \")[1])(I),O=s(O),B<w?(Dt(I,f,17),Dt(O,b,17)):(Dt(I,b,17),Dt(O,f,17))}var En=[],Ti=(s,c)=>{En.length=0;for(var f;f=r()[s++>>>0];){var b=f!=105;c+=(b&=f!=112)&&c%8?4:0,En.push(f==112?a()[c>>>2>>>0]:f==106?W[c>>>3]:f==105?i()[c>>>2>>>0]:l()[c>>>3>>>0]),c+=b?8:4}return En};function Sp(s,c,f){return s>>>=0,c=Ti(c>>>0,f>>>0),gn[s](...c)}function Tp(s,c,f){return s>>>=0,c=Ti(c>>>0,f>>>0),gn[s](...c)}var Ip=()=>{},Cp=()=>Date.now();function Ap(s,c){return L(Ce(s>>>0,c>>>0))}var Ii,kp=()=>{throw vt+=1,\"unwind\"};function Ep(){return 4294901760}Ii=()=>performance.timeOrigin+performance.now();var Pp=()=>navigator.hardwareConcurrency;function zp(){return ct(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"),0}function Op(s){s>>>=0;var c=r().length;if(s<=c||4294901760<s)return!1;for(var f=1;4>=f;f*=2){var b=c*(1+.2/f);b=Math.min(b,s+100663296);var w=Math;b=Math.max(s,b);e:{w=(w.min.call(w,4294901760,b+(65536-b%65536)%65536)-K.buffer.byteLength+65535)/65536;try{K.grow(w),pe();var I=1;break e}catch{}I=void 0}if(I)return!0}return!1}var lr=()=>(ct(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"),0),Mt={},Ci=s=>{s.forEach(c=>{var f=lr();f&&(Mt[f]=c)})};function Dp(){var s=Error().stack.toString().split(`\n`);return s[0]==\"Error\"&&s.shift(),Ci(s),Mt.Qb=lr(),Mt.fc=s,Mt.Qb}function Bp(s,c,f){if(s>>>=0,c>>>=0,Mt.Qb==s)var b=Mt.fc;else(b=Error().stack.toString().split(`\n`))[0]==\"Error\"&&b.shift(),Ci(b);for(var w=3;b[w]&&lr()!=s;)++w;for(s=0;s<f&&b[s+w];++s)i()[c+4*s>>>2>>>0]=lr();return s}var Pn,zn={},Ai=()=>{if(!Pn){var s,c={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:\"./this.program\"};for(s in zn)zn[s]===void 0?delete c[s]:c[s]=zn[s];var f=[];for(s in c)f.push(`${s}=${c[s]}`);Pn=f}return Pn};function ki(s,c){if(g)return $e(18,1,s,c);s>>>=0,c>>>=0;var f=0;return Ai().forEach((b,w)=>{var I=c+f;for(w=a()[s+4*w>>>2>>>0]=I,I=0;I<b.length;++I)t()[w++>>>0]=b.charCodeAt(I);t()[w>>>0]=0,f+=b.length+1}),0}function Ei(s,c){if(g)return $e(19,1,s,c);s>>>=0,c>>>=0;var f=Ai();a()[s>>>2>>>0]=f.length;var b=0;return f.forEach(w=>b+=w.length+1),a()[c>>>2>>>0]=b,0}function Pi(s){return g?$e(20,1,s):52}function zi(s,c,f,b){return g?$e(21,1,s,c,f,b):52}function Oi(s,c,f,b){return g?$e(22,1,s,c,f,b):70}var Mp=[null,[],[]];function Di(s,c,f,b){if(g)return $e(23,1,s,c,f,b);c>>>=0,f>>>=0,b>>>=0;for(var w=0,I=0;I<f;I++){var O=a()[c>>>2>>>0],B=a()[c+4>>>2>>>0];c+=8;for(var G=0;G<B;G++){var F=r()[O+G>>>0],X=Mp[s];F===0||F===10?((s===1?H:L)(Yo(X,0)),X.length=0):X.push(F)}w+=B}return a()[b>>>2>>>0]=w,0}var Bi=[31,29,31,30,31,30,31,31,30,31,30,31],Mi=[31,28,31,30,31,30,31,31,30,31,30,31],Rp=(s,c)=>{t().set(s,c>>>0)};function Ri(s,c,f,b){function w(z,ue,Se){for(z=typeof z==\"number\"?z.toString():z||\"\";z.length<ue;)z=Se[0]+z;return z}function I(z,ue){return w(z,ue,\"0\")}function O(z,ue){function Se(Qi){return 0>Qi?-1:0<Qi?1:0}var xt;return(xt=Se(z.getFullYear()-ue.getFullYear()))===0&&(xt=Se(z.getMonth()-ue.getMonth()))===0&&(xt=Se(z.getDate()-ue.getDate())),xt}function B(z){switch(z.getDay()){case 0:return new Date(z.getFullYear()-1,11,29);case 1:return z;case 2:return new Date(z.getFullYear(),0,3);case 3:return new Date(z.getFullYear(),0,2);case 4:return new Date(z.getFullYear(),0,1);case 5:return new Date(z.getFullYear()-1,11,31);case 6:return new Date(z.getFullYear()-1,11,30)}}function G(z){var ue=z.Cb;for(z=new Date(new Date(z.Db+1900,0,1).getTime());0<ue;){var Se=z.getMonth(),xt=(Bt(z.getFullYear())?Bi:Mi)[Se];if(!(ue>xt-z.getDate())){z.setDate(z.getDate()+ue);break}ue-=xt-z.getDate()+1,z.setDate(1),11>Se?z.setMonth(Se+1):(z.setMonth(0),z.setFullYear(z.getFullYear()+1))}return Se=new Date(z.getFullYear()+1,0,4),ue=B(new Date(z.getFullYear(),0,4)),Se=B(Se),0>=O(ue,z)?0>=O(Se,z)?z.getFullYear()+1:z.getFullYear():z.getFullYear()-1}s>>>=0,c>>>=0,f>>>=0,b>>>=0;var F=a()[b+40>>>2>>>0];for(var X in b={lc:i()[b>>>2>>>0],kc:i()[b+4>>>2>>>0],Ib:i()[b+8>>>2>>>0],Mb:i()[b+12>>>2>>>0],Jb:i()[b+16>>>2>>>0],Db:i()[b+20>>>2>>>0],vb:i()[b+24>>>2>>>0],Cb:i()[b+28>>>2>>>0],sc:i()[b+32>>>2>>>0],jc:i()[b+36>>>2>>>0],mc:F?Ce(F):\"\"},f=Ce(f),F={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})f=f.replace(new RegExp(X,\"g\"),F[X]);var le=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),ge=\"January February March April May June July August September October November December\".split(\" \");for(X in F={\"%a\":z=>le[z.vb].substring(0,3),\"%A\":z=>le[z.vb],\"%b\":z=>ge[z.Jb].substring(0,3),\"%B\":z=>ge[z.Jb],\"%C\":z=>I((z.Db+1900)/100|0,2),\"%d\":z=>I(z.Mb,2),\"%e\":z=>w(z.Mb,2,\" \"),\"%g\":z=>G(z).toString().substring(2),\"%G\":G,\"%H\":z=>I(z.Ib,2),\"%I\":z=>((z=z.Ib)==0?z=12:12<z&&(z-=12),I(z,2)),\"%j\":z=>{for(var ue=0,Se=0;Se<=z.Jb-1;ue+=(Bt(z.Db+1900)?Bi:Mi)[Se++]);return I(z.Mb+ue,3)},\"%m\":z=>I(z.Jb+1,2),\"%M\":z=>I(z.kc,2),\"%n\":()=>`\n`,\"%p\":z=>0<=z.Ib&&12>z.Ib?\"AM\":\"PM\",\"%S\":z=>I(z.lc,2),\"%t\":()=>\"\t\",\"%u\":z=>z.vb||7,\"%U\":z=>I(Math.floor((z.Cb+7-z.vb)/7),2),\"%V\":z=>{var ue=Math.floor((z.Cb+7-(z.vb+6)%7)/7);if(2>=(z.vb+371-z.Cb-2)%7&&ue++,ue)ue==53&&((Se=(z.vb+371-z.Cb)%7)==4||Se==3&&Bt(z.Db)||(ue=1));else{ue=52;var Se=(z.vb+7-z.Cb-1)%7;(Se==4||Se==5&&Bt(z.Db%400-1))&&ue++}return I(ue,2)},\"%w\":z=>z.vb,\"%W\":z=>I(Math.floor((z.Cb+7-(z.vb+6)%7)/7),2),\"%y\":z=>(z.Db+1900).toString().substring(2),\"%Y\":z=>z.Db+1900,\"%z\":z=>{var ue=0<=(z=z.jc);return z=Math.abs(z)/60,(ue?\"+\":\"-\")+(\"0000\"+(z/60*100+z%60)).slice(-4)},\"%Z\":z=>z.mc,\"%%\":()=>\"%\"},f=f.replace(/%%/g,\"\\0\\0\"),F)f.includes(X)&&(f=f.replace(new RegExp(X,\"g\"),F[X](b)));return X=function(z){var ue=Array(vn(z)+1);return Xo(z,ue,0,ue.length),ue}(f=f.replace(/\\0\\0/g,\"%\")),X.length>c?0:(Rp(X,s),X.length-1)}function Up(s,c,f,b){return Ri(s>>>0,c>>>0,f>>>0,b>>>0)}g||function(){for(var s=u.numThreads-1;s--;)Fo();Ie.unshift(()=>{wt++,function(c){g?c():Promise.all(pt.map(Ho)).then(c)}(()=>Oo())})}();for(var Ui=Array(256),cr=0;256>cr;++cr)Ui[cr]=String.fromCharCode(cr);li=Ui,mt=u.BindingError=class extends Error{constructor(s){super(s),this.name=\"BindingError\"}},u.InternalError=class extends Error{constructor(s){super(s),this.name=\"InternalError\"}},ut.push(0,1,void 0,1,null,1,!0,1,!1,1),u.count_emval_handles=()=>ut.length/2-5-Sn.length;var Np=[_n,Vo,qo,Zo,Qo,Jo,ei,ti,ri,ni,oi,ii,ai,si,ui,di,xi,Si,ki,Ei,Pi,zi,Oi,Di],Z=function(){function s(f,b){return Z=f.exports,Z=function(){var w=Z,I={};for(let[O,B]of Object.entries(w))I[O]=typeof B==\"function\"?(...G)=>{sr.push(O);try{return B(...G)}finally{De||(sr.pop(),Xe&&ht===1&&sr.length===0&&(ht=0,vt+=1,ar(Ki),typeof Fibers<\"u\"&&Fibers.tc()))}}:B;return I}(),Z=function(){var w=Z,I=B=>G=>B(G)>>>0,O=B=>()=>B()>>>0;return(w=Object.assign({},w)).Da=I(w.Da),w.gb=O(w.gb),w.ib=I(w.ib),w.emscripten_main_runtime_thread_id=O(w.emscripten_main_runtime_thread_id),w.tb=I(w.tb),w.ub=O(w.ub),w}(),Wo.push(Z.jb),He.unshift(Z.Ca),we=b,Oo(),Z}var c=Uo();if(wt++,u.instantiateWasm)try{return u.instantiateWasm(c,s)}catch(f){L(`Module.instantiateWasm callback failed with error: ${f}`),m(f)}return hn||=u.locateFile?Do(\"ort-wasm-simd-threaded.jsep.wasm\")?\"ort-wasm-simd-threaded.jsep.wasm\":u.locateFile?u.locateFile(\"ort-wasm-simd-threaded.jsep.wasm\",C):C+\"ort-wasm-simd-threaded.jsep.wasm\":/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href,function(f,b){var w=hn;return P||typeof WebAssembly.instantiateStreaming!=\"function\"||Do(w)||Bo(w)||typeof fetch!=\"function\"?Ro(w,f,b):fetch(w,{credentials:\"same-origin\"}).then(I=>WebAssembly.instantiateStreaming(I,f).then(b,function(O){return L(`wasm streaming compile failed: ${O}`),L(\"falling back to ArrayBuffer instantiation\"),Ro(w,f,b)}))}(c,function(f){s(f.instance,f.module)}).catch(m),{}}(),Ni=s=>(Ni=Z.Da)(s),Vi=()=>(Vi=Z.Ea)();u._OrtInit=(s,c)=>(u._OrtInit=Z.Fa)(s,c),u._OrtGetLastError=(s,c)=>(u._OrtGetLastError=Z.Ga)(s,c),u._OrtCreateSessionOptions=(s,c,f,b,w,I,O,B,G,F)=>(u._OrtCreateSessionOptions=Z.Ha)(s,c,f,b,w,I,O,B,G,F),u._OrtAppendExecutionProvider=(s,c)=>(u._OrtAppendExecutionProvider=Z.Ia)(s,c),u._OrtAddFreeDimensionOverride=(s,c,f)=>(u._OrtAddFreeDimensionOverride=Z.Ja)(s,c,f),u._OrtAddSessionConfigEntry=(s,c,f)=>(u._OrtAddSessionConfigEntry=Z.Ka)(s,c,f),u._OrtReleaseSessionOptions=s=>(u._OrtReleaseSessionOptions=Z.La)(s),u._OrtCreateSession=(s,c,f)=>(u._OrtCreateSession=Z.Ma)(s,c,f),u._OrtReleaseSession=s=>(u._OrtReleaseSession=Z.Na)(s),u._OrtGetInputOutputCount=(s,c,f)=>(u._OrtGetInputOutputCount=Z.Oa)(s,c,f),u._OrtGetInputName=(s,c)=>(u._OrtGetInputName=Z.Pa)(s,c),u._OrtGetOutputName=(s,c)=>(u._OrtGetOutputName=Z.Qa)(s,c),u._OrtFree=s=>(u._OrtFree=Z.Ra)(s),u._OrtCreateTensor=(s,c,f,b,w,I)=>(u._OrtCreateTensor=Z.Sa)(s,c,f,b,w,I),u._OrtGetTensorData=(s,c,f,b,w)=>(u._OrtGetTensorData=Z.Ta)(s,c,f,b,w),u._OrtReleaseTensor=s=>(u._OrtReleaseTensor=Z.Ua)(s),u._OrtCreateRunOptions=(s,c,f,b)=>(u._OrtCreateRunOptions=Z.Va)(s,c,f,b),u._OrtAddRunConfigEntry=(s,c,f)=>(u._OrtAddRunConfigEntry=Z.Wa)(s,c,f),u._OrtReleaseRunOptions=s=>(u._OrtReleaseRunOptions=Z.Xa)(s),u._OrtCreateBinding=s=>(u._OrtCreateBinding=Z.Ya)(s),u._OrtBindInput=(s,c,f)=>(u._OrtBindInput=Z.Za)(s,c,f),u._OrtBindOutput=(s,c,f,b)=>(u._OrtBindOutput=Z._a)(s,c,f,b),u._OrtClearBoundOutputs=s=>(u._OrtClearBoundOutputs=Z.$a)(s),u._OrtReleaseBinding=s=>(u._OrtReleaseBinding=Z.ab)(s),u._OrtRunWithBinding=(s,c,f,b,w)=>(u._OrtRunWithBinding=Z.bb)(s,c,f,b,w),u._OrtRun=(s,c,f,b,w,I,O,B)=>(u._OrtRun=Z.cb)(s,c,f,b,w,I,O,B),u._OrtEndProfiling=s=>(u._OrtEndProfiling=Z.db)(s),u._JsepOutput=(s,c,f)=>(u._JsepOutput=Z.eb)(s,c,f),u._JsepGetNodeName=s=>(u._JsepGetNodeName=Z.fb)(s);var pr,Rt=()=>(Rt=Z.gb)(),Je=u._free=s=>(Je=u._free=Z.hb)(s),mr=u._malloc=s=>(mr=u._malloc=Z.ib)(s),On=(s,c,f,b,w,I)=>(On=Z.lb)(s,c,f,b,w,I),Wi=()=>(Wi=Z.mb)(),Li=(s,c,f,b,w)=>(Li=Z.nb)(s,c,f,b,w),Dn=s=>(Dn=Z.ob)(s),fr=s=>(fr=Z.pb)(s),Gi=()=>(Gi=Z.qb)(),Hi=(s,c)=>(Hi=Z.rb)(s,c),hr=s=>(hr=Z.sb)(s),Bn=s=>(Bn=Z.tb)(s),Mn=()=>(Mn=Z.ub)(),Fi=u.dynCall_ii=(s,c)=>(Fi=u.dynCall_ii=Z.wb)(s,c),qi=s=>(qi=Z.xb)(s),Ki=()=>(Ki=Z.yb)(),ji=s=>(ji=Z.zb)(s),Yi=()=>(Yi=Z.Ab)();function Zi(){0<wt||(g?(p(u),g||nr(He),startWorker(u)):(nr(Ie),0<wt||pr||(pr=!0,u.calledRun=!0,De||(g||nr(He),p(u),g||nr(mn)))))}return u.___start_em_js=932469,u.___stop_em_js=932715,u.stackSave=()=>Mn(),u.stackRestore=s=>hr(s),u.stackAlloc=s=>Bn(s),u.setValue=function(s,c,f=\"i8\"){switch(f.endsWith(\"*\")&&(f=\"*\"),f){case\"i1\":case\"i8\":t()[s>>>0]=c;break;case\"i16\":n()[s>>>1>>>0]=c;break;case\"i32\":i()[s>>>2>>>0]=c;break;case\"i64\":W[s>>>3]=BigInt(c);break;case\"float\":d()[s>>>2>>>0]=c;break;case\"double\":l()[s>>>3>>>0]=c;break;case\"*\":a()[s>>>2>>>0]=c;break;default:ct(`invalid type for setValue: ${f}`)}},u.getValue=function(s,c=\"i8\"){switch(c.endsWith(\"*\")&&(c=\"*\"),c){case\"i1\":case\"i8\":return t()[s>>>0];case\"i16\":return n()[s>>>1>>>0];case\"i32\":return i()[s>>>2>>>0];case\"i64\":return W[s>>>3];case\"float\":return d()[s>>>2>>>0];case\"double\":return l()[s>>>3>>>0];case\"*\":return a()[s>>>2>>>0];default:ct(`invalid type for getValue: ${c}`)}},u.UTF8ToString=Ce,u.stringToUTF8=Dt,u.lengthBytesUTF8=vn,Gt=function s(){pr||Zi(),pr||(Gt=s)},Zi(),u.PTR_SIZE=4,h}),Kp=Pa;globalThis.self?.name===\"em-pthread\"&&Pa()});var Ma,jp,Ve,Ra,Kn,Yp,Zp,Ua,Qp,Da,Na,Ba,Va,$r=U(()=>{\"use strict\";vr();Ma= false||typeof location>\"u\"?void 0:location.origin,jp=()=>{if(true)return \"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\")?new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?2904\")).href,Ma).href:\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"},Ve=jp(),Ra=()=>{if(Ve&&!Ve.startsWith(\"blob:\"))return Ve.substring(0,Ve.lastIndexOf(\"/\")+1)},Kn=(e,t)=>{try{let r=t??Ve;return(r?new URL(e,r):new URL(e)).origin===Ma}catch{return!1}},Yp=(e,t)=>{let r=t??Ve;try{return(r?new URL(e,r):new URL(e)).href}catch{return}},Zp=(e,t)=>`${t??\"./\"}${e}`,Ua=async e=>{let r=await(await fetch(e,{credentials:\"same-origin\"})).blob();return URL.createObjectURL(r)},Qp=async e=>(await import(/*webpackIgnore:true*/e)).default,Da=(Ea(),gr(ka)).default,Na=async()=>{if(!Ve)throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");if(Kn(Ve))return[void 0,Da()];let e=await Ua(Ve);return[e,Da(e)]},Ba=(Oa(),gr(za)).default,Va=async(e,t,r)=>{if(!e&&!t&&Ba&&Ve&&Kn(Ve))return[void 0,Ba];{let n=\"ort-wasm-simd-threaded.jsep.mjs\",o=e??Yp(n,t),i= true&&r&&o&&!Kn(o,t),a=i?await Ua(o):o??Zp(n,t);return[i?a:void 0,await Qp(a)]}}});var jn,Yn,Pr,Wa,Xp,Jp,xr,Te,gt=U(()=>{\"use strict\";$r();Yn=!1,Pr=!1,Wa=!1,Xp=()=>{if(typeof SharedArrayBuffer>\"u\")return!1;try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Jp=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},xr=async e=>{if(Yn)return Promise.resolve();if(Pr)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(Wa)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");Pr=!0;let t=e.initTimeout,r=e.numThreads;if(!Jp())throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");let n=Xp();r>1&&!n&&(typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+r+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"),e.numThreads=r=1);let o=e.wasmPaths,i=typeof o==\"string\"?o:void 0,a=o?.mjs,d=a?.href??a,l=o?.wasm,p=l?.href??l,m=e.wasmBinary,[u,h]=await Va(d,i,r>1),_=!1,y=[];if(t>0&&y.push(new Promise(g=>{setTimeout(()=>{_=!0,g()},t)})),y.push(new Promise((g,x)=>{let $={numThreads:r};if(m)$.wasmBinary=m;else if(p||i)$.locateFile=v=>p??i+v;else if(d&&d.indexOf(\"blob:\")!==0)$.locateFile=v=>new URL(v,d).href;else if(u){let v=Ra();v&&($.locateFile=S=>v+S)}h($).then(v=>{Pr=!1,Yn=!0,jn=v,g(),u&&URL.revokeObjectURL(u)},v=>{Pr=!1,Wa=!0,x(v)})})),await Promise.race(y),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Te=()=>{if(Yn&&jn)return jn;throw new Error(\"WebAssembly is not initialized yet.\")}});var ke,Kt,ce,zr=U(()=>{\"use strict\";gt();ke=(e,t)=>{let r=Te(),n=r.lengthBytesUTF8(e)+1,o=r._malloc(n);return r.stringToUTF8(e,o,n),t.push(o),o},Kt=(e,t,r,n)=>{if(typeof e==\"object\"&&e!==null){if(r.has(e))throw new Error(\"Circular reference in options\");r.add(e)}Object.entries(e).forEach(([o,i])=>{let a=t?t+o:o;if(typeof i==\"object\")Kt(i,a+\".\",r,n);else if(typeof i==\"string\"||typeof i==\"number\")n(a,i.toString());else if(typeof i==\"boolean\")n(a,i?\"1\":\"0\");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},ce=e=>{let t=Te(),r=t.stackSave();try{let n=t.PTR_SIZE,o=t.stackAlloc(2*n);t._OrtGetLastError(o,o+n);let i=Number(t.getValue(o,n===4?\"i32\":\"i64\")),a=t.getValue(o+n,\"*\"),d=a?t.UTF8ToString(a):\"\";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${d}`)}finally{t.stackRestore(r)}}});var La,Ga=U(()=>{\"use strict\";gt();zr();La=e=>{let t=Te(),r=0,n=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof e.logSeverityLevel!=\"number\"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!=\"number\"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let i=0;return e?.tag!==void 0&&(i=ke(e.tag,n)),r=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,i),r===0&&ce(\"Can't create run options.\"),e?.extra!==void 0&&Kt(e.extra,\"\",new WeakSet,(a,d)=>{let l=ke(a,n),p=ke(d,n);t._OrtAddRunConfigEntry(r,l,p)!==0&&ce(`Can't set a run config entry: ${a} - ${d}.`)}),[r,n]}catch(i){throw r!==0&&t._OrtReleaseRunOptions(r),n.forEach(a=>t._free(a)),i}}});var em,tm,rm,nm,Ha,Fa=U(()=>{\"use strict\";gt();zr();em=e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},tm=e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},rm=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some(r=>(typeof r==\"string\"?r:r.name)===\"webgpu\")&&(e.enableMemPattern=!1)},nm=(e,t,r)=>{for(let n of t){let o=typeof n==\"string\"?n:n.name;switch(o){case\"webnn\":if(o=\"WEBNN\",typeof n!=\"string\"){let d=n?.deviceType;if(d){let l=ke(\"deviceType\",r),p=ke(d,r);Te()._OrtAddSessionConfigEntry(e,l,p)!==0&&ce(`Can't set a session config entry: 'deviceType' - ${d}.`)}}break;case\"webgpu\":if(o=\"JS\",typeof n!=\"string\"){let a=n;if(a?.preferredLayout){if(a.preferredLayout!==\"NCHW\"&&a.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${a.preferredLayout}`);let d=ke(\"preferredLayout\",r),l=ke(a.preferredLayout,r);Te()._OrtAddSessionConfigEntry(e,d,l)!==0&&ce(`Can't set a session config entry: 'preferredLayout' - ${a.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${o}`)}let i=ke(o,r);Te()._OrtAppendExecutionProvider(e,i)!==0&&ce(`Can't append execution provider: ${o}.`)}},Ha=e=>{let t=Te(),r=0,n=[],o=e||{};rm(o);try{let i=em(o.graphOptimizationLevel??\"all\"),a=tm(o.executionMode??\"sequential\"),d=typeof o.logId==\"string\"?ke(o.logId,n):0,l=o.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let p=o.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let m=typeof o.optimizedModelFilePath==\"string\"?ke(o.optimizedModelFilePath,n):0;if(r=t._OrtCreateSessionOptions(i,!!o.enableCpuMemArena,!!o.enableMemPattern,a,!!o.enableProfiling,0,d,l,p,m),r===0&&ce(\"Can't create session options.\"),o.executionProviders&&nm(r,o.executionProviders,n),o.enableGraphCapture!==void 0){if(typeof o.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);let u=ke(\"enableGraphCapture\",n),h=ke(o.enableGraphCapture.toString(),n);t._OrtAddSessionConfigEntry(r,u,h)!==0&&ce(`Can't set a session config entry: 'enableGraphCapture' - ${o.enableGraphCapture}.`)}if(o.freeDimensionOverrides)for(let[u,h]of Object.entries(o.freeDimensionOverrides)){if(typeof u!=\"string\")throw new Error(`free dimension override name must be a string: ${u}`);if(typeof h!=\"number\"||!Number.isInteger(h)||h<0)throw new Error(`free dimension override value must be a non-negative integer: ${h}`);let _=ke(u,n);t._OrtAddFreeDimensionOverride(r,_,h)!==0&&ce(`Can't set a free dimension override: ${u} - ${h}.`)}return o.extra!==void 0&&Kt(o.extra,\"\",new WeakSet,(u,h)=>{let _=ke(u,n),y=ke(h,n);t._OrtAddSessionConfigEntry(r,_,y)!==0&&ce(`Can't set a session config entry: ${u} - ${h}.`)}),[r,n]}catch(i){throw r!==0&&t._OrtReleaseSessionOptions(r)!==0&&ce(\"Can't release session options.\"),n.forEach(a=>t._free(a)),i}}});var jt,bt,At,Or,Yt,Dr,Br,Zn,J=U(()=>{\"use strict\";jt=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;case\"int4\":return 22;case\"uint4\":return 21;default:throw new Error(`unsupported data type: ${e}`)}},bt=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";case 22:return\"int4\";case 21:return\"uint4\";default:throw new Error(`unsupported data type: ${e}`)}},At=(e,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],n=typeof t==\"number\"?t:t.reduce((o,i)=>o*i,1);return r>0?Math.ceil(n*r):void 0},Or=e=>{switch(e){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Yt=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Dr=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Br=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint64\"||e===\"int8\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Zn=e=>{switch(e){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;case\"ml-tensor\":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var Zt,Qn=U(()=>{\"use strict\";vr();Zt=async e=>{if(typeof e==\"string\")if(false){}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get(\"Content-Length\"),n=r?parseInt(r,10):0;if(n<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let o=t.body.getReader(),i;try{i=new ArrayBuffer(n)}catch(d){if(d instanceof RangeError){let l=Math.ceil(n/65536);i=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw d}let a=0;for(;;){let{done:d,value:l}=await o.read();if(d)break;let p=l.byteLength;new Uint8Array(i,a,p).set(l),a+=p}return new Uint8Array(i,0,n)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var om,im,qa,Ka,Mr,am,se,et=U(()=>{\"use strict\";J();om=[\"V\",\"I\",\"W\",\"E\",\"F\"],im=(e,t)=>{console.log(`[${om[e]},${new Date().toISOString()}]${t}`)},Mr=(e,t)=>{qa=e,Ka=t},am=(e,t)=>{let r=Yt(e),n=Yt(qa);r>=n&&im(r,typeof t==\"function\"?t():t)},se=(...e)=>{Ka&&am(...e)}});var Rr,Xn=U(()=>{\"use strict\";J();Rr=(e,t)=>new(Or(t))(e)});var Ur=U(()=>{\"use strict\"});var ja,Jn,eo,sm,um,Ya,ro,to,Qa,Xa=U(()=>{\"use strict\";et();Ur();ja=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Jn=[],eo=e=>Math.ceil(Number(e)/16)*16,sm=e=>{for(let t=0;t<Jn.length;t++){let r=Jn[t];if(e<=r)return r}return Math.ceil(e/16)*16},um=1,Ya=()=>um++,ro=async(e,t,r,n)=>{let o=eo(r),i=e.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,i,0,o),e.flush(),await i.mapAsync(GPUMapMode.READ);let d=i.getMappedRange();if(n){let l=n();return l.set(new Uint8Array(d,0,r)),l}else return new Uint8Array(d.slice(0,r))}finally{i.destroy()}},to=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[r]of ja)Jn.push(r),this.freeBuffers.set(r,[]),this.freeUniformBuffers.set(r,[]);this.sessionCount=0}upload(t,r){let n=r.buffer,o=r.byteOffset,i=r.byteLength,a=eo(i),d=this.storageCache.get(t);if(!d)throw new Error(\"gpu data for uploading does not exist\");if(Number(d.originalSize)!==i)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${i}`);let l=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=l.getMappedRange();new Uint8Array(p).set(new Uint8Array(n,o,i)),l.unmap();let m=this.backend.device.createCommandEncoder();m.copyBufferToBuffer(l,0,d.gpuData.buffer,0,a),this.backend.device.queue.submit([m.finish()]),l.destroy(),se(\"verbose\",()=>`[WebGPU] GpuDataManager.upload(id=${t})`)}memcpy(t,r){let n=this.storageCache.get(t);if(!n)throw new Error(\"source gpu data for memcpy does not exist\");let o=this.storageCache.get(r);if(!o)throw new Error(\"destination gpu data for memcpy does not exist\");if(n.originalSize!==o.originalSize)throw new Error(\"inconsistent source and destination gpu data size\");let i=eo(n.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(n.gpuData.buffer,0,o.gpuData.buffer,0,i)}registerExternalBuffer(t,r,n){let o;if(n){if(o=n[0],t===n[1])return se(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, buffer is the same, skip.`),o;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`)}else o=Ya();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:t},originalSize:r}),se(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, registered.`),o}unregisterExternalBuffer(t){t!==void 0&&(this.storageCache.delete(t),se(\"verbose\",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=sm(t),o,i=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||a){let p=(i?this.freeBuffers:this.freeUniformBuffers).get(n);p?p.length>0?o=p.pop():o=this.backend.device.createBuffer({size:n,usage:r}):o=this.backend.device.createBuffer({size:n,usage:r})}else o=this.backend.device.createBuffer({size:n,usage:r});let d={id:Ya(),type:0,buffer:o};return this.storageCache.set(d.id,{gpuData:d,originalSize:Number(t)}),se(\"verbose\",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=typeof t==\"bigint\"?Number(t):t,n=this.storageCache.get(r);if(!n){if(this.storageCache.size===0)return 0;throw new Error(\"releasing data does not exist\")}return se(\"verbose\",()=>`[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(r),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(t,r){let n=this.storageCache.get(Number(t));if(!n)throw new Error(\"data does not exist\");await ro(this.backend,n.gpuData.buffer,n.originalSize,r)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus===\"default\"){for(let t of this.buffersPending){let r=ja.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(t.size)||[];r===void 0||n.length>=r?t.destroy():n.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(t.size)||[];r===void 0||n.length>=r?t.destroy():n.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let r of this.buffersPending)t.push(r);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(t){let r=this.capturedPendingBuffers.get(t);r&&(r.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(t)),this.sessionCount-=1,this.sessionCount===0&&(se(\"warning\",()=>\"[WebGPU] Clearing webgpu buffer cache\"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Qa=(...e)=>new to(...e)});var no,ee,xe=U(()=>{\"use strict\";no=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(\";\")),this.key}},ee=e=>new no(e)});var oo,tt,k,kt,Nr,Ja,es,ne=U(()=>{\"use strict\";oo=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},tt=class{static calcShape(t,r,n=!1){let o=t.length,i=r.length;if(o===0)return r;if(i===0)return t;let a=Math.max(t.length,r.length),d=new Array(a);if(n){if(o<2||i<2)return;let l=oo.calcMatMulShape([t[o-2],t[o-1]],[r[i-2],r[i-1]]);if(l===void 0)return;[d[a-2],d[a-1]]=l}for(let l=n?3:1;l<=a;l++){let p=o-l<0?1:t[o-l],m=i-l<0?1:r[i-l];if(p!==m&&p>1&&m>1)return;let u=Math.max(p,m);if(p&&m)d[a-l]=Math.max(p,m);else{if(u>1)return;d[a-l]=0}}return d}static isValidBroadcast(t,r){let n=t.length,o=r.length;if(n>o)return!1;for(let i=1;i<=n;i++)if(t[n-i]!==1&&t[n-i]!==r[o-i])return!1;return!0}},k=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,r=4){let n=t.length;if(n===0)return[];let o=new Array(n),i=n-1;for(;i>=0;){if(t[i]%r===0){o[i]=t[i]/r;break}if(r%t[i]!==0)throw new Error(\"cannot convert shape\");o[i]=1,r/=t[i],i--}for(i--;i>=0;i--)o[i]=t[i];return o}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,n){let o=1;for(let i=r;i<n;i++){if(t[i]<0)throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains negative values in them.\");o*=Number(t[i])}return o}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let n=new Array(r);n[r-1]=1,n[r-2]=t[r-1];for(let o=r-3;o>=0;--o)n[o]=n[o+1]*t[o+1];return n}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error(\"unsupported axis for this operation.\");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(n=>this.normalizeAxis(n,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(n=>t[n]):t.slice().reverse()}static padShape(t,r){let n=t.length;return t.map((o,i)=>o+r[i]+r[i+n])}static areEqual(t,r){return t.length!==r.length?!1:t.every((n,o)=>n===r[o])}},kt=class e{static adjustPoolAttributes(t,r,n,o,i,a){if(!t&&n.length!==r.length-2)throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");if(t)for(let d=0;d<r.length-2;d++)d>=n.length?n.push(r[d+2]):n[d]=r[d+2];for(let d=0;d<n.length;d++)if(d<o.length){if(o[d]<0)throw new Error(\"strides should be greater than or equal to 1\")}else o.push(1);for(let d=0;d<n.length;d++)if(d<i.length){if(i[d]<0)throw new Error(\"dilations should be greater than or equal to 1\")}else i.push(1);for(let d=0;d<n.length*2;d++)if(d<a.length){if(a[d]<0)throw new Error(\"pad should be greater than or equal to 1\")}else a.push(0);for(let d=0;d<n.length;d++){if(n[d]<=0)throw new Error(\"kernel shapes need to be greater than 0\");if(a[d]>=n[d]||a[d+n.length]>=n[d])throw new Error(\"pads should be smaller than kernel\")}}static adjustPadsBasedOnAutoPad(t,r,n,o,i,a,d){if(d){if(i.length!==2*(t.length-2))throw new Error(\"length of pads should be twice the length of data dimensions\");if(r.length!==t.length-2)throw new Error(\"length of strides should be the length of data dimensions\");if(o.length!==t.length-2)throw new Error(\"length of kernel shapes should be the length of data dimensions\");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(a?1:2)],r[l],n[l],o[l],i,l,l+t.length-2,d)}}static computePoolOutputShape(t,r,n,o,i,a,d){if(r.length<=0)throw new Error(\"input shape must be of size greater than 0\");let l=[r[0],r[1]];return e.computeShapeHelper(t,r,l,n,o,i,a,d),l}static computeConvOutputShape(t,r,n,o,i,a,d){if(t.length<=0||r.length<=0)throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");let l=[t[0],r[0]];return e.computeShapeHelper(!1,t,l,n,o,i,a,d),l}static computeShapeHelper(t,r,n,o,i,a,d,l){if(t)for(let p=0;p<r.length-2;p++)n.push(1);else for(let p=0;p<r.length-2;p++)n.push(e.adjustPadAndReturnShape(r[p+2],o[p],i[p],a[p],d,p,p+r.length-2,l))}static adjustPadAndReturnShape(t,r,n,o,i,a,d,l){let p=n*(o-1)+1;if(l&&l!==\"NOTSET\")switch(l){case\"VALID\":return i[a]=0,i[d]=0,Math.floor((t-p)/r+1);case\"SAME_LOWER\":case\"SAME_UPPER\":if(n!==1)throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");{let u=((t+r-1)/r-1)*r+o-t;return i[a]=Math.floor(l===\"SAME_LOWER\"?(u+1)/2:u/2),i[d]=u-i[a],Math.floor((t+u-o)/r+1)}default:throw new Error(\"Unsupported AutoPad type\")}else return Math.floor((t+i[a]+i[d]-p)/r+1)}},Nr=class{static getShapeOfGemmResult(t,r,n,o,i){if(t.length!==2||n.length!==2)throw new Error(\"shape need to be of size 2\");let a,d,l;r?(a=t[1],d=t[0]):(a=t[0],d=t[1]);let p=-1;if(o?(l=n[0],p=1):(l=n[1],p=0),n[p]!==d)throw new Error(\"dimension mismatch\");if(a<=0||l<=0||d<=0)throw new Error(\"invalid shape specified\");if(i&&!tt.isValidBroadcast(i,[a,l]))throw new Error(\"gemm: invalid bias shape for broadcast\");return[a,l,d]}},Ja=-34028234663852886e22,es=34028234663852886e22});var Et,ao,ye,Ee,N,me,so,Pt,qe,q,Vr,E,M,ts,Wr,io,rs,ae=U(()=>{\"use strict\";J();ne();Et=64,ao=(e,t)=>{if(t===3)throw new Error(\"vec3 has same alignment as vec4, use vec4 instead\");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:\"f16\";case 1:return t>1?`vec${t}<f32>`:\"f32\";case 6:return t>1?`vec${t}<i32>`:\"i32\";case 12:return t>1?`vec${t}<u32>`:\"u32\";case 7:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"i32\"];case 13:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"u32\"];case 9:if(t!==4)throw new Error(\"bool must be vec4\");return[\"u32\",\"vec4<bool>\"];case 22:return\"i32\";case 21:return\"u32\";default:throw new Error(`Unknown data type: ${e}`)}},ye=(e,t=1)=>{let r=ao(e,t);return typeof r==\"string\"?r:r[0]},Ee=(e,t=1)=>{let r=ao(e,t);return typeof r==\"string\"?r:r[1]},N=(...e)=>{let t=[];return e.forEach(r=>{r.length!==0&&t.push({type:12,data:r},{type:12,data:k.computeStrides(r)})}),t},me=e=>e%4===0?4:e%2===0?2:1,so=(e=\"f32\",t,r=\"0\")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,Pt=(e,t,r)=>e===\"f32\"?r:t===1?`f32(${r})`:`vec${t}<f32>(${r})`,qe=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,q=(e,t,r,n)=>e.startsWith(\"uniforms.\")&&r>4?typeof t==\"string\"?n===\"f16\"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:n===\"f16\"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,Vr=(e,t,r,n,o)=>{let i=typeof r==\"number\",a=i?r:r.length,d=[...new Array(a).keys()],l=a<2?\"u32\":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,p=ao(t,o),m=typeof p==\"string\"?p:p[1],u=typeof p==\"string\"?p:p[0],h={indices:l,value:m,storage:u,tensor:t},_=W=>typeof W==\"string\"?W:`${W}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},g=i?\"uniforms.\":\"\",x=`${g}${e}_shape`,$=`${g}${e}_strides`,v=\"\";for(let W=0;W<a-1;W++)v+=`\n    let dim${W} = current / ${q($,W,a)};\n    let rest${W} = current % ${q($,W,a)};\n    indices[${W}] = dim${W};\n    current = rest${W};\n    `;v+=`indices[${a-1}] = current;`;let S=a<2?\"\":`\n  fn o2i_${e}(offset: u32) -> ${h.indices} {\n    var indices: ${h.indices};\n    var current = offset;\n    ${v}\n    return indices;\n  }`,T=W=>(y.offsetToIndices=!0,a<2?W:`o2i_${e}(${W})`),A=[];if(a>=2)for(let W=a-1;W>=0;W--)A.push(`${q($,W,a)} * (indices[${W}])`);let C=a<2?\"\":`\n  fn i2o_${e}(indices: ${h.indices}) -> u32 {\n    return ${A.join(\"+\")};\n  }`,P=W=>(y.indicesToOffset=!0,a<2?W:`i2o_${e}(${W})`),D=(...W)=>a===0?\"0u\":`${h.indices}(${W.map(_).join(\",\")})`,R=(W,Y)=>a<2?`${W}`:`${q(W,Y,a)}`,H=(W,Y,he)=>a<2?`${W}=${he};`:`${q(W,Y,a)}=${he};`,L={},re=(W,Y)=>{y.broadcastedIndicesToOffset=!0;let he=`${Y.name}broadcastedIndicesTo${e}Offset`;if(he in L)return`${he}(${W})`;let De=[];for(let pe=a-1;pe>=0;pe--){let Ie=Y.indicesGet(\"outputIndices\",pe+Y.rank-a);De.push(`${R($,pe)} * (${Ie} % ${R(x,pe)})`)}return L[he]=`fn ${he}(outputIndices: ${Y.type.indices}) -> u32 {\n             return ${De.length>0?De.join(\"+\"):\"0u\"};\n           }`,`${he}(${W})`},V=(W,Y)=>(()=>{if(h.storage===h.value)return`${e}[${W}]=${Y};`;if(h.storage===\"vec2<u32>\"&&h.value===\"i32\")return`${e}[${W}]=vec2<u32>(u32(${Y}), select(0u, 0xFFFFFFFFu, ${Y} < 0));`;if(h.storage===\"vec2<u32>\"&&h.value===\"u32\")return`${e}[${W}]=vec2<u32>(u32(${Y}), 0u);`;if(h.storage===\"u32\"&&h.value===\"vec4<bool>\")return`${e}[${W}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Y}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),K=W=>(()=>{if(h.storage===h.value)return`${e}[${W}]`;if(h.storage===\"vec2<u32>\"&&h.value===\"i32\")return`i32(${e}[${W}].x)`;if(h.storage===\"vec2<u32>\"&&h.value===\"u32\")return`u32(${e}[${W}].x)`;if(h.storage===\"u32\"&&h.value===\"vec4<bool>\")return`vec4<bool>(bool(${e}[${W}] & 0xFFu), bool(${e}[${W}] & 0xFF00u), bool(${e}[${W}] & 0xFF0000u), bool(${e}[${W}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),we=a<2?\"\":`\n  fn get_${e}ByIndices(indices: ${h.indices}) -> ${m} {\n    return ${K(`i2o_${e}(indices)`)};\n  }`,j=a<2?\"\":(()=>{let W=d.map(he=>`d${he}: u32`).join(\", \"),Y=d.map(he=>`d${he}`).join(\", \");return`\n  fn get_${e}(${W}) -> ${m} {\n    return get_${e}ByIndices(${D(Y)});\n  }`})(),Q=(...W)=>{if(W.length!==a)throw new Error(`indices length must be ${a}`);let Y=W.map(_).join(\",\");return a===0?K(\"0u\"):a===1?K(Y[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}(${Y})`)},ie=W=>a<2?K(W):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}ByIndices(${W})`),te=a<2?\"\":`\n  fn set_${e}ByIndices(indices: ${h.indices}, value: ${m}) {\n    ${V(`i2o_${e}(indices)`,\"value\")}\n  }`,be=a<2?\"\":(()=>{let W=d.map(he=>`d${he}: u32`).join(\", \"),Y=d.map(he=>`d${he}`).join(\", \");return`\n  fn set_${e}(${W}, value: ${m}) {\n    set_${e}ByIndices(${D(Y)}, value);\n  }`})();return{impl:()=>{let W=[],Y=!1;return y.offsetToIndices&&(W.push(S),Y=!0),y.indicesToOffset&&(W.push(C),Y=!0),y.broadcastedIndicesToOffset&&(Object.values(L).forEach(he=>W.push(he)),Y=!0),y.set&&(W.push(be),Y=!0),y.setByIndices&&(W.push(te),Y=!0),y.get&&(W.push(j),Y=!0),y.getByIndices&&(W.push(we),Y=!0),!i&&Y&&W.unshift(`const ${x} = ${h.indices}(${r.join(\",\")});`,`const ${$} = ${h.indices}(${k.computeStrides(r).join(\",\")});`),W.join(`\n`)},type:h,offsetToIndices:T,indicesToOffset:P,broadcastedIndicesToOffset:re,indices:D,indicesGet:R,indicesSet:H,set:(...W)=>{if(W.length!==a+1)throw new Error(`indices length must be ${a}`);let Y=W[a];if(typeof Y!=\"string\")throw new Error(\"value must be string\");let he=W.slice(0,a).map(_).join(\",\");return a===0?V(\"0u\",Y):a===1?V(he[0],Y):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}(${he}, ${Y})`)},setByOffset:V,setByIndices:(W,Y)=>a<2?V(W,Y):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}ByIndices(${W}, ${Y});`),get:Q,getByOffset:K,getByIndices:ie,usage:n,name:e,strides:$,shape:x,rank:a}},E=(e,t,r,n=1)=>Vr(e,t,r,\"input\",n),M=(e,t,r,n=1)=>Vr(e,t,r,\"output\",n),ts=(e,t,r)=>Vr(e,t,r,\"atomicOutput\",1),Wr=(e,t,r,n=1)=>Vr(e,t,r,\"internal\",n),io=class{constructor(t,r){this.normalizedDispatchGroup=t;this.limits=r;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t==\"number\"?`${t}u`:t}) { return; }`}mainStart(t=Et){let r=typeof t==\"number\"?t:t[0],n=typeof t==\"number\"?1:t[1],o=typeof t==\"number\"?1:t[2];if(r>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||o>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(r*n*o>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,a=i?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=i?`let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${r*n*o}u + local_idx;`;return`@compute @workgroup_size(${r}, ${n}, ${o})\n  fn main(${a}) {\n    ${d}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.shape.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}),t.strides.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.strides.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}))}declareVariable(t,r){if(t.usage===\"internal\")throw new Error(\"cannot use internal variable with declareVariable(). use registerInternalVariables() instead.\");this.variables.push(t),this.appendVariableUniforms(t);let n=t.usage===\"input\"?\"read\":\"read_write\",o=t.usage===\"atomicOutput\"?\"atomic<i32>\":t.type.storage;return`@group(0) @binding(${r}) var<storage, ${n}> ${t.name}: array<${o}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!==\"internal\")throw new Error(\"cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.\");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,n=1){return this.uniforms.push({name:t,type:r,length:n}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return\"\";let t=[];for(let{name:r,type:n,length:o}of this.uniforms)if(o&&o>4)n===\"f16\"?t.push(`@align(16) ${r}:array<mat2x4<${n}>, ${Math.ceil(o/8)}>`):t.push(`${r}:array<vec4<${n}>, ${Math.ceil(o/4)}>`);else{let i=o==null||o===1?n:`vec${o}<${n}>`;t.push(`${r}:${i}`)}return`\n      struct Uniforms { ${t.join(\", \")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=r=>[12,10,1,6][[\"u32\",\"f16\",\"f32\",\"i32\"].indexOf(r)];return this.uniforms.map(r=>[t(r.type),r.length??1])}},rs=(e,t)=>new io(e,t)});var dm,ns,lm,cm,pm,mm,Pe,os,is,dt=U(()=>{\"use strict\";J();ne();xe();ae();dm=(e,t)=>{if(!e||e.length!==1)throw new Error(\"Transpose requires 1 input.\");if(t.length!==0&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},ns=(e,t)=>t.length!==0?t:[...new Array(e).keys()].reverse(),lm=(e,t)=>k.sortBasedOnPerm(e,ns(e.length,t)),cm=(e,t,r,n)=>{let o=`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`;for(let i=0;i<t;++i)o+=`a[${e[i]}]=i[${i}];`;return o+=\"return a;}\"},pm=(e,t)=>{let r=[],n=[];for(let o=0;o<e.length;++o)e[o]!==1&&r.push(e[o]),e[t[o]]!==1&&n.push(t[o]);return{newShape:r,newPerm:n}},mm=(e,t)=>{let r=0;for(let n=0;n<e.length;++n)if(t[e[n]]!==1){if(e[n]<r)return!1;r=e[n]}return!0},Pe=(e,t)=>{let r=e.dataType,n=e.dims.length,o=ns(n,t),i=lm(e.dims,o),a=e.dims,d=i,l=n<2||mm(o,e.dims),p;if(l)return p=g=>{let x=E(\"input\",r,a,4),$=M(\"output\",r,d,4);return`\n  ${g.registerUniform(\"output_size\",\"u32\").declareVariables(x,$)}\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    output[global_idx] = input[global_idx];\n  }`},{name:\"TransposeCopy\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let g=k.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64/4)},programUniforms:[{type:12,data:Math.ceil(g/4)}]}},getShaderSource:p};let{newShape:m,newPerm:u}=pm(e.dims,o),h=k.areEqual(u,[2,3,1]),_=k.areEqual(u,[3,1,2]);if(m.length===2||h||_){a=h?[m[0],m[1]*m[2]]:_?[m[0]*m[1],m[2]]:m,d=[a[1],a[0]];let g=16;return p=x=>{let $=E(\"a\",r,a.length),v=M(\"output\",r,d.length);return`\n  ${x.registerUniform(\"output_size\",\"u32\").declareVariables($,v)}\n  var<workgroup> tile : array<array<${v.type.value}, ${g+1}>, ${g}>;\n  ${x.mainStart([g,g,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${g} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${g}u + local_id.x;\n    let input_row = workgroup_id_x * ${g}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${$.getByIndices(`${$.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${g}u + local_id.x;\n    let output_row = workgroup_id_y * ${g}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${v.setByIndices(`${v.type.indices}(output_row, output_col)`,\"tile[local_id.x][local_id.y]\")}\n    }\n  }`},{name:\"TransposeShared\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let x=k.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d[1]/g),y:Math.ceil(d[0]/g)},programUniforms:[{type:12,data:x},...N(a,d)]}},getShaderSource:p}}return p=g=>{let x=E(\"a\",r,a.length),$=M(\"output\",r,d.length);return`\n  ${g.registerUniform(\"output_size\",\"u32\").declareVariables(x,$)}\n\n  ${cm(o,n,x,$)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${$.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${$.setByOffset(\"global_idx\",x.getByIndices(\"aIndices\"))}\n  }`},{name:\"Transpose\",shaderCache:{hint:`${t}`,inputDependencies:[\"rank\"]},getRunData:()=>{let g=k.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:12,data:g},...N(a,d)]}},getShaderSource:p}},os=(e,t)=>{dm(e.inputs,t.perm),e.compute(Pe(e.inputs[0],t.perm))},is=e=>ee({perm:e.perm})});var fm,hm,gm,bm,ym,_m,wm,vm,$m,xm,rt,as,ss,us,ds,ls,cs,ps,ms,fs,hs,gs=U(()=>{\"use strict\";J();ne();ae();Lr();dt();fm={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate * candidate\",logSumExp:\"bestValue + exp(candidate)\",l1:\"bestValue + abs(candidate)\",l2:\"bestValue + candidate * candidate\",logSum:\"bestValue + candidate\"},hm={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate\",logSumExp:\"bestValue + candidate\",l1:\"bestValue + candidate\",l2:\"bestValue + candidate\",logSum:\"bestValue + candidate\"},gm={max:\"_A[offset]\",min:\"_A[offset]\",mean:\"0\",sum:\"0\",prod:\"1\",sumSquare:\"0\",logSumExp:\"0\",l1:\"0\",l2:\"0\",logSum:\"0\"},bm={max:\"bestValue\",min:\"bestValue\",sum:\"bestValue\",prod:\"bestValue\",sumSquare:\"bestValue\",logSumExp:\"log(bestValue)\",l1:\"bestValue\",l2:\"sqrt(bestValue)\",logSum:\"log(bestValue)\"},ym=(e,t)=>{let r=[];for(let n=t-e;n<t;++n)r.push(n);return r},_m=(e,t)=>{let r=[],n=e.length;for(let i=0;i<n;i++)t.indexOf(i)===-1&&r.push(e[i]);let o=t.map(i=>e[i]);return[r,o]},wm=(e,t)=>{let r=e.length+t.length,n=[],o=0;for(let i=0;i<r;i++)t.indexOf(i)===-1?n.push(e[o++]):n.push(1);return n},vm=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},$m=(e,t)=>{let r=[];if(!vm(e,t)){for(let n=0;n<t;++n)e.indexOf(n)===-1&&r.push(n);e.forEach(n=>r.push(n))}return r},xm=(e,t,r,n,o,i,a)=>{let d=r[0].dims,l=k.size(i),p=k.size(a),m=E(\"_A\",r[0].dataType,d),u=M(\"output\",o,i),h=64;l===1&&(h=256);let _=`\n          var<workgroup> aBestValues : array<f32, ${h}>;\n       `,y=g=>`\n        ${g.registerUniform(\"reduceSize\",\"u32\").declareVariables(m,u)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${g.mainStart(h)}\n\n          let outputIndex = global_idx / ${h};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${gm[n]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${h}) {\n           let candidate = f32(${m.getByOffset(\"offset + k\")});\n           bestValue = ${fm[n]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${h}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${hm[n]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${u.setByOffset(\"outputIndex\",`${n===\"mean\"?`${u.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${u.type.storage}(${bm[n]})`}`)};\n         }\n        }`;return{name:e,shaderCache:{hint:`${t};${h}`,inputDependencies:[\"type\"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:i,dataType:o}],dispatchGroup:{x:l},programUniforms:[{type:12,data:p}]})}},rt=(e,t,r,n)=>{let o=e.inputs.length===1?r:uo(e.inputs,r),i=o.axes;i.length===0&&!o.noopWithEmptyAxes&&(i=e.inputs[0].dims.map((_,y)=>y));let a=k.normalizeAxes(i,e.inputs[0].dims.length),d=a,l=e.inputs[0],p=$m(d,e.inputs[0].dims.length);p.length>0&&(l=e.compute(Pe(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],d=ym(d.length,l.dims.length));let[m,u]=_m(l.dims,d),h=m;o.keepDims&&(h=wm(m,a)),e.compute(xm(t,o.cacheKey,[l],n,e.inputs[0].dataType,h,u),{inputs:[l]})},as=(e,t)=>{rt(e,\"ReduceMeanShared\",t,\"mean\")},ss=(e,t)=>{rt(e,\"ReduceL1Shared\",t,\"l1\")},us=(e,t)=>{rt(e,\"ReduceL2Shared\",t,\"l2\")},ds=(e,t)=>{rt(e,\"ReduceLogSumExpShared\",t,\"logSumExp\")},ls=(e,t)=>{rt(e,\"ReduceMaxShared\",t,\"max\")},cs=(e,t)=>{rt(e,\"ReduceMinShared\",t,\"min\")},ps=(e,t)=>{rt(e,\"ReduceProdShared\",t,\"prod\")},ms=(e,t)=>{rt(e,\"ReduceSumShared\",t,\"sum\")},fs=(e,t)=>{rt(e,\"ReduceSumSquareShared\",t,\"sumSquare\")},hs=(e,t)=>{rt(e,\"ReduceLogSumShared\",t,\"logSum\")}});var nt,Sm,Gr,uo,ot,Tm,Im,Cm,Am,km,Em,Pm,zm,Om,Dm,it,bs,ys,_s,ws,vs,$s,xs,Ss,Ts,Is,Lr=U(()=>{\"use strict\";J();ne();xe();ae();gs();nt=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"Reduce op requires 1 or 2 inputs.\");if(e.length===2&&e[1].dims.length!==1)throw new Error(\"Invalid axes input dims.\")},Sm=e=>[\"\",\"\",`var value = ${e.getByIndices(\"input_indices\")};`,\"\"],Gr=(e,t,r,n,o,i,a=!1,d=!1)=>{let l=[],p=r[0].dims,m=p.length,u=k.normalizeAxes(o,m),h=!d&&u.length===0;p.forEach((x,$)=>{h||u.indexOf($)>=0?a&&l.push(1):l.push(x)});let _=l.length,y=k.size(l);return{name:e,shaderCache:t,getShaderSource:x=>{let $=[],v=E(\"_A\",r[0].dataType,m),S=M(\"output\",i,_),T=n(v,S,u),A=T[2];for(let C=0,P=0;C<m;C++)h||u.indexOf(C)>=0?(a&&P++,A=`for(var j${C}: u32 = 0; j${C} < ${p[C]}; j${C}++) {\n                  ${T[2].includes(\"last_index\")?`let last_index = j${C};`:\"\"}\n                  ${v.indicesSet(\"input_indices\",C,`j${C}`)}\n                  ${A}\n                }`):($.push(`${v.indicesSet(\"input_indices\",C,S.indicesGet(\"output_indices\",P))};`),P++);return`\n\n        ${x.registerUniform(\"output_size\",\"u32\").declareVariables(v,S)}\n\n        ${x.mainStart()}\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          var input_indices: ${v.type.indices};\n          let output_indices = ${S.offsetToIndices(\"global_idx\")};\n\n          ${$.join(`\n`)}\n          ${T[0]}       // init ops for reduce max/min\n          ${T[1]}\n          ${A}\n          ${T[3]}\n          ${T.length===4?S.setByOffset(\"global_idx\",\"value\"):T.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:i}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...N(p,l)]})}},uo=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),ee({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},ot=(e,t,r,n)=>{let o=e.inputs,i=o.length===1?r:uo(o,r);e.compute(Gr(t,{hint:i.cacheKey,inputDependencies:[\"rank\"]},[o[0]],i.noopWithEmptyAxes&&i.axes.length===0?Sm:n,i.axes,o[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},Tm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceLogSum\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${n.getByIndices(\"input_indices\")};`,\"value = log(value);\"])},Im=(e,t)=>{nt(e.inputs),ot(e,\"ReduceL1\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += abs(${n.getByIndices(\"input_indices\")});`,\"\"])},Cm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceL2\",t,(n,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${n.getByIndices(\"input_indices\")}; value += (t * t);`,\"value = sqrt(value);\"])},Am=(e,t)=>{nt(e.inputs),ot(e,\"ReduceLogSumExp\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += exp(${n.getByIndices(\"input_indices\")});`,\"value = log(value);\"])},km=(e,t)=>{nt(e.inputs),ot(e,\"ReduceMax\",t,(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(n.indicesSet(\"input_indices\",d,0));return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};`,`value = max(value, ${n.getByIndices(\"input_indices\")});`,\"\"]})},Em=(e,t)=>{nt(e.inputs),ot(e,\"ReduceMean\",t,(n,o,i)=>{let a=1;for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&(a*=e.inputs[0].dims[d]);return[\"var sum = f32(0);\",\"\",`sum += f32(${n.getByIndices(\"input_indices\")});`,`let value = ${o.type.value}(sum / ${a});`]})},Pm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceMin\",t,(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(`input_indices[${d}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};`,`value = min(value, ${n.getByIndices(\"input_indices\")});`,\"\"]})},zm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceProd\",t,(n,o)=>[`var value = ${o.type.storage}(1);`,\"\",`value *= ${n.getByIndices(\"input_indices\")};`,\"\"])},Om=(e,t)=>{nt(e.inputs),ot(e,\"ReduceSum\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${n.getByIndices(\"input_indices\")};`,\"\"])},Dm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceSumSquare\",t,(n,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${n.getByIndices(\"input_indices\")}; value += t * t;`,\"\"])},it=(e,t,r)=>{if(t.length===0)return r;let n=1,o=1;for(let i=0;i<t.length;i++)t.indexOf(i)===-1?n*=e[i]:o*=e[i];return o<32&&n>1024},bs=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Em(e,t):as(e,t)},ys=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Im(e,t):ss(e,t)},_s=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Cm(e,t):us(e,t)},ws=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Am(e,t):ds(e,t)},vs=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?km(e,t):ls(e,t)},$s=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Pm(e,t):cs(e,t)},xs=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?zm(e,t):ps(e,t)},Ss=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Om(e,t):ms(e,t)},Ts=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Dm(e,t):fs(e,t)},Is=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Tm(e,t):hs(e,t)}});var Cs,As,ks,lo,Es=U(()=>{\"use strict\";J();xe();Lr();Cs=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"ArgMinMaxOp op requires 1 or 2 inputs.\");if(e[0].dataType!==1)throw new Error(\"Invalid input type.\")},As=(e,t)=>{Cs(e.inputs);let r=(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(`input_indices[${d}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${n.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\"<=\":\"<\"} value) {\n         value = ${n.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Gr(\"ArgMin\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ks=(e,t)=>{Cs(e.inputs);let r=(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(`input_indices[${d}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${n.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\">=\":\">\"} value) {\n         value = ${n.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Gr(\"argMax\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},lo=e=>ee(e)});var Bm,co,Mm,Rm,Um,Ut,Nm,Ps,Hr=U(()=>{\"use strict\";J();ne();Ur();ae();Bm=(e,t)=>{let r=e[0],n=e[1],o=e[2],i=e[3],a=e[4],d=e[5];if(a&&d)throw new Error(\"Attention cannot have both past and attention_bias\");if(r.dims.length!==3)throw new Error('Input \"input\" must have 3 dimensions');let l=r.dims[0],p=r.dims[1],m=r.dims[2];if(o.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimensions');if(n.dims.length!==2)throw new Error('Input \"weights\" is expected to have 2 dimensions');if(n.dims[0]!==m)throw new Error(\"Input 1 dimension 0 should have same length as dimension 2 of input 0\");if(o.dims[0]!==n.dims[1])throw new Error('Input \"bias\" dimension 0 should have same length as dimension 1 of input \"weights\"');let u=o.dims[0]/3,h=u,_=h;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error(\"qkv_hidden_sizes attribute should have 3 elements\");for(let S of t.qkvHiddenSizes)if(S%t.numHeads!==0)throw new Error(\"qkv_hidden_sizes should be divisible by num_heads\");u=t.qkvHiddenSizes[0],h=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let y=p;if(u!==h)throw new Error(\"qkv_hidden_sizes first element should be same as the second\");if(o.dims[0]!==u+h+_)throw new Error('Input \"bias\" dimension 0 should have same length as sum of Q/K/V hidden sizes');let g=0;if(a){if(h!==_)throw new Error('Input \"past\" expect k_hidden_size == v_hidden_size');if(a.dims.length!==5)throw new Error('Input \"past\" must have 5 dimensions');if(a.dims[0]!==2)throw new Error('Input \"past\" first dimension must be 2');if(a.dims[1]!==l)throw new Error('Input \"past\" second dimension must be batch_size');if(a.dims[2]!==t.numHeads)throw new Error('Input \"past\" third dimension must be num_heads');if(a.dims[4]!==h/t.numHeads)throw new Error('Input \"past\" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(g=a.dims[3])}let x=y+g,$=-1,v=0;if(i)throw new Error(\"Mask not supported\");if(a)throw new Error(\"past is not supported\");if(d){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" must have 4 dimensions');if(d.dims[0]!==l||d.dims[1]!==t.numHeads||d.dims[2]!==p||d.dims[3]!==x)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:p,pastSequenceLength:g,kvSequenceLength:y,totalSequenceLength:x,maxSequenceLength:$,inputHiddenSize:m,hiddenSize:u,vHiddenSize:_,headSize:Math.floor(u/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:v,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},co=(e,t,r)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset(\"0\")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset(\"batchIdx\")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${r?\"let past_sequence_length = uniforms.past_sequence_length\":\"\"};\n    let present_sequence_length = total_sequence_length;\n    `,Mm=(e,t,r,n,o,i,a,d)=>{let l=me(a?1:i),p=64,m=i/l;m<p&&(p=32);let u=Math.ceil(i/l/p),h=[{type:12,data:t},{type:12,data:r},{type:12,data:n},{type:12,data:o},{type:12,data:m},{type:12,data:u}],_=ye(e.dataType,l),y=Ee(1,l),g=[\"type\"];a&&g.push(\"type\"),d&&g.push(\"type\");let x=$=>{let v=M(\"x\",e.dataType,e.dims,l),S=[v],T=a?E(\"seq_lens\",a.dataType,a.dims):void 0;T&&S.push(T);let A=d?E(\"total_sequence_length_input\",d.dataType,d.dims):void 0;A&&S.push(A);let C=Ee(e.dataType),P=[{name:\"batch_size\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"sequence_length\",type:\"u32\"},{name:\"total_sequence_length\",type:\"u32\"},{name:\"elements_per_thread\",type:\"u32\"}];return`\n  var<workgroup> thread_max: array<f32, ${p}>;\n  var<workgroup> thread_sum: array<f32, ${p}>;\n  ${$.registerUniforms(P).declareVariables(...S)}\n  ${$.mainStart([p,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${co(T,A,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${p}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${a?\"u32(past_sequence_length + workgroup_id.y + 1)\":\"total_sequence_length\"};\n    var thread_max_vector = ${y}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${y}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return\"thread_max_vector\";case 2:return\"max(thread_max_vector.x, thread_max_vector.y)\";case 4:return\"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${p}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${y}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${y}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return\"sum_vector\";case 2:return\"sum_vector.x + sum_vector.y\";case 4:return\"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${p}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${v.type.value}(${C}(1.0) / ${C}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${y}(x[offset + i]);\n        x[offset + i] = ${v.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${a?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${v.type.value}(${C}(0));\n        }`:\"\"};\n  }`};return{name:\"AttentionProbsSoftmax\",shaderCache:{hint:`${p};${_};${l}`,inputDependencies:g},getShaderSource:x,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(i/p),y:o,z:t*r},programUniforms:h})}},Rm=(e,t,r,n,o,i,a,d,l)=>{let p=a+i.kvSequenceLength,m=[i.batchSize,i.numHeads,i.sequenceLength,p],u=e>1&&n,h=i.kvNumHeads?i.kvNumHeads:i.numHeads,_=u?[i.batchSize,h,p,i.headSize]:void 0,y=i.nReps?i.nReps:1,g=i.scale===0?1/Math.sqrt(i.headSize):i.scale,x=me(i.headSize),$=i.headSize/x,v=12,S={x:Math.ceil(p/v),y:Math.ceil(i.sequenceLength/v),z:i.batchSize*i.numHeads},T=[{type:12,data:i.sequenceLength},{type:12,data:$},{type:12,data:p},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:1,data:g},{type:12,data:a},{type:12,data:i.kvSequenceLength},{type:12,data:y}],A=u&&n&&k.size(n.dims)>0,C=[\"type\",\"type\"];A&&C.push(\"type\"),o&&C.push(\"type\"),d&&C.push(\"type\"),l&&C.push(\"type\");let P=[{dims:m,dataType:t.dataType,gpuDataType:0}];u&&P.push({dims:_,dataType:t.dataType,gpuDataType:0});let D=R=>{let H=E(\"q\",t.dataType,t.dims,x),L=E(\"key\",r.dataType,r.dims,x),re=[H,L];if(A){let te=E(\"past_key\",n.dataType,n.dims,x);re.push(te)}o&&re.push(E(\"attention_bias\",o.dataType,o.dims));let V=d?E(\"seq_lens\",d.dataType,d.dims):void 0;V&&re.push(V);let K=l?E(\"total_sequence_length_input\",l.dataType,l.dims):void 0;K&&re.push(K);let we=M(\"output\",t.dataType,m),j=[we];u&&j.push(M(\"present_key\",t.dataType,_,x));let Q=Ee(1,x),ie=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${v}u;\n\n  var<workgroup> tileQ: array<${H.type.storage}, ${v*v}>;\n  var<workgroup> tileK: array<${H.type.storage}, ${v*v}>;\n  ${R.registerUniforms(ie).declareVariables(...re,...j)}\n  ${R.mainStart([v,v,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${y===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n    let kv_num_heads = ${y===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${co(V,K,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${A&&u?\"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;\":\"\"};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${u?\"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;\":\"\"}\n    var value = ${Q}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${(()=>A&&u?`\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }`:`\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }`)()}\n      ${u?`if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }`:\"\"}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${Q}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(x){case 1:return\"value\";case 2:return\"value.x + value.y\";case 4:return\"value.x + value.y + value.z + value.w\";default:throw new Error(`Unsupported components: ${x}`)}})()};\n        output[outputIdx] = ${we.type.value} (sum * uniforms.alpha) + ${o?\"attention_bias[outputIdx]\":\"0.0\"};\n    }\n  }`};return{name:\"AttentionProbs\",shaderCache:{hint:`${x};${o!==void 0};${n!==void 0};${e}`,inputDependencies:C},getRunData:()=>({outputs:P,dispatchGroup:S,programUniforms:T}),getShaderSource:D}},Um=(e,t,r,n,o,i,a=void 0,d=void 0)=>{let l=i+o.kvSequenceLength,p=o.nReps?o.nReps:1,m=o.vHiddenSize*p,u=e>1&&n,h=o.kvNumHeads?o.kvNumHeads:o.numHeads,_=u?[o.batchSize,h,l,o.headSize]:void 0,y=[o.batchSize,o.sequenceLength,m],g=12,x={x:Math.ceil(o.vHeadSize/g),y:Math.ceil(o.sequenceLength/g),z:o.batchSize*o.numHeads},$=[{type:12,data:o.sequenceLength},{type:12,data:l},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:o.headSize},{type:12,data:m},{type:12,data:i},{type:12,data:o.kvSequenceLength},{type:12,data:p}],v=u&&n&&k.size(n.dims)>0,S=[\"type\",\"type\"];v&&S.push(\"type\"),a&&S.push(\"type\"),d&&S.push(\"type\");let T=[{dims:y,dataType:t.dataType,gpuDataType:0}];u&&T.push({dims:_,dataType:t.dataType,gpuDataType:0});let A=C=>{let P=E(\"probs\",t.dataType,t.dims),D=E(\"v\",r.dataType,r.dims),R=[P,D];v&&R.push(E(\"past_value\",n.dataType,n.dims));let H=a?E(\"seq_lens\",a.dataType,a.dims):void 0;a&&R.push(H);let L=d?E(\"total_sequence_length_input\",d.dataType,d.dims):void 0;d&&R.push(L);let V=[M(\"output\",t.dataType,y)];u&&V.push(M(\"present_value\",t.dataType,_));let K=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"v_hidden_size\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${g}u;\n  var<workgroup> tileQ: array<${P.type.value}, ${g*g}>;\n  var<workgroup> tileV: array<${P.type.value}, ${g*g}>;\n  ${C.registerUniforms(K).declareVariables(...R,...V)}\n  ${C.mainStart([g,g,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${p===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n   let kv_num_heads = ${p===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${co(H,L,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${v&&u?\"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;\":\"\"};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${u?\"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;\":\"\"}\n   var value = ${P.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${(()=>v&&u?`\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      `:`\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }`)()}\n        ${u?`\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }`:\"\"}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`};return{name:\"AttentionScore\",shaderCache:{hint:`${n!==void 0};${e}`,inputDependencies:S},getRunData:()=>({outputs:T,dispatchGroup:x,programUniforms:$}),getShaderSource:A}},Ut=(e,t,r,n,o,i,a,d,l,p,m=void 0,u=void 0)=>{let h=Math.min(e.outputCount,1+(a?1:0)+(d?1:0)),_=h>1?p.pastSequenceLength:0,y=_+p.kvSequenceLength,g=l&&k.size(l.dims)>0?l:void 0,x=[t,r];h>1&&a&&k.size(a.dims)>0&&x.push(a),g&&x.push(g),m&&x.push(m),u&&x.push(u);let $=e.compute(Rm(h,t,r,a,g,p,_,m,u),{inputs:x,outputs:h>1?[-1,1]:[-1]})[0];e.compute(Mm($,p.batchSize,p.numHeads,_,p.sequenceLength,y,m,u),{inputs:m&&u?[$,m,u]:[$],outputs:[]});let v=[$,n];h>1&&d&&k.size(d.dims)>0&&v.push(d),m&&v.push(m),u&&v.push(u),e.compute(Um(h,$,n,d,p,_,m,u),{inputs:v,outputs:h>1?[0,2]:[0]})},Nm=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],n=t.sequenceLength,o=t.inputHiddenSize,i=t.headSize,a=12,d={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],p=[{type:12,data:n},{type:12,data:o},{type:12,data:i},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],m=u=>{let h=M(\"output_q\",l[0].dataType,r),_=M(\"output_k\",l[0].dataType,r),y=M(\"output_v\",l[0].dataType,r),g=E(\"input\",l[0].dataType,l[0].dims),x=E(\"weight\",l[1].dataType,l[1].dims),$=E(\"bias\",l[2].dataType,l[2].dims),v=g.type.storage,S=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"ldb\",type:\"u32\"}];return`\n  const TILE_SIZE = ${a}u;\n  var<workgroup> tileInput: array<${v}, ${a*a}>;\n  var<workgroup> tileWeightQ: array<${v}, ${a*a}>;\n  var<workgroup> tileWeightK: array<${v}, ${a*a}>;\n  var<workgroup> tileWeightV: array<${v}, ${a*a}>;\n  ${u.registerUniforms(S).declareVariables(g,x,$,h,_,y)}\n  ${u.mainStart([a,a,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${v}(0);\n    var valueK = ${v}(0);\n    var valueV = ${v}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:\"AttentionPrepare\",shaderCache:{inputDependencies:[\"type\",\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:d,programUniforms:p}),getShaderSource:m},{inputs:l,outputs:[-1,-1,-1]})},Ps=(e,t)=>{let r=Bm(e.inputs,t),[n,o,i]=Nm(e,r);return Ut(e,n,o,i,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r)}});var Vm,Wm,Lm,zs,Os=U(()=>{\"use strict\";Le();J();ne();xe();ae();Vm=(e,t)=>{if(!e||e.length!==5)throw new Error(\"BatchNormalization requires 5 inputs\");let r=(n,o,i)=>{let a=o.length;if(a!==n.length)throw new Error(`${i}: num dimensions != ${a}`);o.forEach((d,l)=>{if(d!==n[l])throw new Error(`${i}: dim[${l}] do not match`)})};if(e[0].dims.length>1){let n=t.format===\"NHWC\"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,n,\"Invalid input scale\"),r(e[2].dims,n,\"Invalid input B\"),r(e[3].dims,n,\"Invalid input mean\"),r(e[4].dims,n,\"Invalid input var\")}else r(e[1].dims,[1],\"Invalid input scale\"),r(e[2].dims,[1],\"Invalid input B\"),r(e[3].dims,[1],\"Invalid input mean\"),r(e[4].dims,[1],\"Invalid input var\")},Wm=(e,t)=>{let{epsilon:r,spatial:n,format:o}=t,i=e[0].dims,a=n?me(i[i.length-1]):1,d=o===\"NHWC\"&&i.length>1?a:1,l=k.size(i)/a,p=n,m=p?i.length:i,u=E(\"x\",e[0].dataType,e[0].dims,a),h=E(\"scale\",e[1].dataType,e[1].dims,d),_=E(\"bias\",e[2].dataType,e[2].dims,d),y=E(\"inputMean\",e[3].dataType,e[3].dims,d),g=E(\"inputVar\",e[4].dataType,e[4].dims,d),x=M(\"y\",e[0].dataType,m,a),$=()=>{let S=\"\";if(n)S=`let cOffset = ${i.length===1?\"0u\":o===\"NHWC\"?`outputIndices[${i.length-1}] / ${a}`:\"outputIndices[1]\"};`;else if(o===\"NCHW\")S=`\n            ${x.indicesSet(\"outputIndices\",\"0\",\"0\")}\n            let cOffset = ${x.indicesToOffset(\"outputIndices\")};`;else{S=`var cIndices = ${h.type.indices}(0);\n                       cIndices[0] = outputIndices[${i.length-1}];`;for(let T=1;T<h.rank;T++)S+=`cIndices[${T}] = outputIndices[${T}];`;S+=`let cOffset = ${h.indicesToOffset(\"cIndices\")};`}return S},v=S=>`\n  const epsilon = ${r};\n  ${S.registerUniform(\"outputSize\",\"u32\").declareVariables(u,h,_,y,g,x)}\n  ${S.mainStart()}\n  ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n    var outputIndices = ${x.offsetToIndices(`global_idx * ${a}`)};\n    ${$()}\n    let scale = ${h.getByOffset(\"cOffset\")};\n    let bias = ${_.getByOffset(\"cOffset\")};\n    let inputMean = ${y.getByOffset(\"cOffset\")};\n    let inputVar = ${g.getByOffset(\"cOffset\")};\n    let x = ${u.getByOffset(\"global_idx\")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${x.setByOffset(\"global_idx\",\"value\")}\n  }`;return{name:\"BatchNormalization\",shaderCache:{hint:`${t.epsilon}_${t.format}_${n}_${a}`,inputDependencies:p?[\"rank\",\"type\",\"type\",\"type\",\"type\"]:void 0},getShaderSource:v,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p?[{type:12,data:l},...N(i)]:[{type:12,data:l}]})}},Lm=e=>ee(e),zs=(e,t)=>{let{inputs:r,outputCount:n}=e,o=Lm({...t,outputCount:n});if(_e.webgpu.validateInputContent&&Vm(r,o),t.trainingMode)throw new Error(\"BatchNormalization trainingMode is not supported yet.\");e.compute(Wm(r,o))}});var Gm,Hm,Ds,Bs=U(()=>{\"use strict\";ne();ae();Gm=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![320,640,1280].includes(e[0].dims[2]))throw new Error(\"number of channels should be 320, 640 or 1280\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Hm=e=>{let t=e[0].dims,r=e[0].dims[2],n=k.size(t)/4,o=e[0].dataType,i=E(\"input\",o,t,4),a=E(\"bias\",o,[r],4),d=E(\"residual\",o,t,4),l=M(\"output\",o,t,4);return{name:\"BiasAdd\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:m=>`\n  const channels = ${r}u / 4;\n  ${m.declareVariables(i,a,d,l)}\n\n  ${m.mainStart()}\n    ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let value = ${i.getByOffset(\"global_idx\")}\n      + ${a.getByOffset(\"global_idx % channels\")} + ${d.getByOffset(\"global_idx\")};\n    ${l.setByOffset(\"global_idx\",\"value\")}\n  }`}},Ds=e=>{Gm(e.inputs),e.compute(Hm(e.inputs))}});var Fm,fe,Ms,Rs,Us,Ns,Vs,Ws,Ls,Gs,Hs,qm,Fs,qs,Ks,js,Qt,Ys,Fr,Zs,Qs,Xs,Js,eu,tu,ru,nu,ou,iu,au,su,uu,du,lu,cu,pu,mu,po,mo,fu,hu,gu,Km,jm,bu,qr=U(()=>{\"use strict\";J();ne();xe();ae();Fm=(e,t,r,n,o,i,a)=>{let d=Math.ceil(t/4),l=\"\";typeof o==\"string\"?l=`${o}(a)`:l=o(\"a\");let p=E(\"inputData\",r,[d],4),m=M(\"outputData\",n,[d],4),u=[{name:\"vec_size\",type:\"u32\"}];return a&&u.push(...a),`\n      ${e.registerUniforms(u).declareVariables(p,m)}\n\n  ${i??\"\"}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n\n    let a = ${p.getByOffset(\"global_idx\")};\n    ${m.setByOffset(\"global_idx\",l)}\n  }`},fe=(e,t,r,n,o,i=e.dataType,a,d)=>{let l=[{type:12,data:Math.ceil(k.size(e.dims)/4)}];return a&&l.push(...a),{name:t,shaderCache:{hint:o,inputDependencies:[\"type\"]},getShaderSource:p=>Fm(p,k.size(e.dims),e.dataType,i,r,n,d),getRunData:p=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(k.size(p[0].dims)/64/4)},programUniforms:l})}},Ms=e=>{e.compute(fe(e.inputs[0],\"Abs\",\"abs\"))},Rs=e=>{e.compute(fe(e.inputs[0],\"Acos\",\"acos\"))},Us=e=>{e.compute(fe(e.inputs[0],\"Acosh\",\"acosh\"))},Ns=e=>{e.compute(fe(e.inputs[0],\"Asin\",\"asin\"))},Vs=e=>{e.compute(fe(e.inputs[0],\"Asinh\",\"asinh\"))},Ws=e=>{e.compute(fe(e.inputs[0],\"Atan\",\"atan\"))},Ls=e=>{e.compute(fe(e.inputs[0],\"Atanh\",\"atanh\"))},Gs=e=>ee(e),Hs=(e,t)=>{let r;switch(t.to){case 10:r=\"vec4<f16>\";break;case 1:r=\"vec4<f32>\";break;case 12:r=\"vec4<u32>\";break;case 6:r=\"vec4<i32>\";break;case 9:r=\"vec4<bool>\";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(fe(e.inputs[0],\"Cast\",r,void 0,t.cacheKey,t.to))},qm=e=>{let t,r,n=e.length>=2&&e[1].data!==0,o=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=n?e[1].getFloat32Array()[0]:-34028234663852886e22,r=o?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=n?e[1].getUint16Array()[0]:64511,r=o?e[2].getUint16Array()[0]:31743;break;default:throw new Error(\"Unsupport data type\")}return ee({min:t,max:r})},Fs=(e,t)=>{let r=t||qm(e.inputs),n=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Clip\",o=>`clamp(${o}, vec4<${n}>(uniforms.min), vec4<${n}>(uniforms.max))`,void 0,r.cacheKey,void 0,[{type:e.inputs[0].dataType,data:r.min},{type:e.inputs[0].dataType,data:r.max}],[{name:\"min\",type:n},{name:\"max\",type:n}]),{inputs:[0]})},qs=e=>{e.compute(fe(e.inputs[0],\"Ceil\",\"ceil\"))},Ks=e=>{e.compute(fe(e.inputs[0],\"Cos\",\"cos\"))},js=e=>{e.compute(fe(e.inputs[0],\"Cosh\",\"cosh\"))},Qt=e=>ee(e),Ys=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Elu\",n=>`elu_vf32(${n})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Fr=(e=\"f32\")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Zs=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Erf\",r=>`erf_vf32(${r})`,Fr(t)))},Qs=e=>{e.compute(fe(e.inputs[0],\"Exp\",\"exp\"))},Xs=e=>{e.compute(fe(e.inputs[0],\"Floor\",\"floor\"))},Js=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Gelu\",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Fr(t)))},eu=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"LeakyRelu\",n=>`select(leaky_relu_alpha_ * ${n}, ${n}, ${n} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},tu=e=>{e.compute(fe(e.inputs[0],\"Not\",t=>`!${t}`))},ru=e=>{e.compute(fe(e.inputs[0],\"Neg\",t=>`-${t}`))},nu=e=>{e.compute(fe(e.inputs[0],\"Reciprocal\",t=>`1.0/${t}`))},ou=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Relu\",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},iu=e=>{e.compute(fe(e.inputs[0],\"Sigmoid\",t=>`(1.0 / (1.0 + exp(-${t})))`))},au=e=>ee(e),su=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"HardSigmoid\",n=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${n} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},uu=e=>{e.compute(fe(e.inputs[0],\"Sin\",\"sin\"))},du=e=>{e.compute(fe(e.inputs[0],\"Sinh\",\"sinh\"))},lu=e=>{e.compute(fe(e.inputs[0],\"Sqrt\",\"sqrt\"))},cu=e=>{e.compute(fe(e.inputs[0],\"Tan\",\"tan\"))},pu=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,mu=e=>{e.compute(fe(e.inputs[0],\"Tanh\",pu))},po=(e=\"f32\")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${pu(\"v\")};\n}\n`,mo=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,fu=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"FastGelu\",mo,po(t),void 0,e.inputs[0].dataType))},hu=(e,t)=>{let r=Ee(e.inputs[0].dataType);return e.compute(fe(e.inputs[0],\"ThresholdedRelu\",n=>`select(vec4<${r}>(0.0), ${n}, ${n} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},gu=e=>{e.compute(fe(e.inputs[0],\"Log\",\"log\"))},Km=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,jm=e=>`quick_gelu_impl(${e})`,bu=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"QuickGelu\",jm,Km(r,t.alpha),t.cacheKey,e.inputs[0].dataType))}});var Ym,Zm,_u,wu=U(()=>{\"use strict\";ne();ae();qr();Ym=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error(\"hidden state should be 2560, 5120 or 10240\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Zm=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=E(\"input\",e[0].dataType,e[0].dims,4),n=E(\"bias\",e[0].dataType,[e[0].dims[2]],4),o=M(\"output\",e[0].dataType,t,4),i=k.size(t)/4,a=ye(e[0].dataType);return{name:\"BiasSplitGelu\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:l=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${l.declareVariables(r,n,o)}\n\n  ${Fr(a)}\n\n  ${l.mainStart()}\n    ${l.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${o.setByOffset(\"global_idx\",\"valueLeft * geluRight\")}\n  }`}},_u=e=>{Ym(e.inputs),e.compute(Zm(e.inputs))}});var Qm,Xm,at,vu,$u,xu,Su,Tu,Iu,Cu,Au,ku,Eu,Pu=U(()=>{\"use strict\";J();ne();ae();Qm=(e,t,r,n,o,i,a,d,l,p,m,u)=>{let h,_;typeof d==\"string\"?h=_=(v,S)=>`${d}((${v}),(${S}))`:typeof d==\"function\"?h=_=d:(h=d.scalar,_=d.vector);let y=M(\"outputData\",m,n.length,4),g=E(\"aData\",l,t.length,4),x=E(\"bData\",p,r.length,4),$;if(o)if(i){let v=k.size(t)===1,S=k.size(r)===1,T=t.length>0&&t[t.length-1]%4===0,A=r.length>0&&r[r.length-1]%4===0;v||S?$=y.setByOffset(\"global_idx\",_(v?`${g.type.value}(${g.getByOffset(\"0\")}.x)`:g.getByOffset(\"global_idx\"),S?`${x.type.value}(${x.getByOffset(\"0\")}.x)`:x.getByOffset(\"global_idx\"))):$=`\n            let outputIndices = ${y.offsetToIndices(\"global_idx * 4u\")};\n            let offsetA = ${g.broadcastedIndicesToOffset(\"outputIndices\",y)};\n            let offsetB = ${x.broadcastedIndicesToOffset(\"outputIndices\",y)};\n            ${y.setByOffset(\"global_idx\",_(a||T?g.getByOffset(\"offsetA / 4u\"):`${g.type.value}(${g.getByOffset(\"offsetA / 4u\")}[offsetA % 4u])`,a||A?x.getByOffset(\"offsetB / 4u\"):`${x.type.value}(${x.getByOffset(\"offsetB / 4u\")}[offsetB % 4u])`))}\n          `}else $=y.setByOffset(\"global_idx\",_(g.getByOffset(\"global_idx\"),x.getByOffset(\"global_idx\")));else{if(!i)throw new Error(\"no necessary to use scalar implementation for element-wise binary op implementation.\");let v=(S,T,A=\"\")=>{let C=`aData[indexA${T}][componentA${T}]`,P=`bData[indexB${T}][componentB${T}]`;return`\n            let outputIndices${T} = ${y.offsetToIndices(`global_idx * 4u + ${T}u`)};\n            let offsetA${T} = ${g.broadcastedIndicesToOffset(`outputIndices${T}`,y)};\n            let offsetB${T} = ${x.broadcastedIndicesToOffset(`outputIndices${T}`,y)};\n            let indexA${T} = offsetA${T} / 4u;\n            let indexB${T} = offsetB${T} / 4u;\n            let componentA${T} = offsetA${T} % 4u;\n            let componentB${T} = offsetB${T} % 4u;\n            ${S}[${T}] = ${A}(${h(C,P)});\n          `};m===9?$=`\n            var data = vec4<u32>(0);\n            ${v(\"data\",0,\"u32\")}\n            ${v(\"data\",1,\"u32\")}\n            ${v(\"data\",2,\"u32\")}\n            ${v(\"data\",3,\"u32\")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:$=`\n            ${v(\"outputData[global_idx]\",0)}\n            ${v(\"outputData[global_idx]\",1)}\n            ${v(\"outputData[global_idx]\",2)}\n            ${v(\"outputData[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(g,x,y)}\n\n        ${u??\"\"}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${$}\n      }`},Xm=(e,t,r,n,o,i,a=r.dataType)=>{let d=r.dims.map(g=>Number(g)??1),l=n.dims.map(g=>Number(g)??1),p=!k.areEqual(d,l),m=d,u=k.size(d),h=!1,_=!1,y=[p];if(p){let g=tt.calcShape(d,l,!1);if(!g)throw new Error(\"Can't perform binary op on the given tensors\");m=g.slice(),u=k.size(m);let x=k.size(d)===1,$=k.size(l)===1,v=d.length>0&&d[d.length-1]%4===0,S=l.length>0&&l[l.length-1]%4===0;y.push(x),y.push($),y.push(v),y.push(S);let T=1;for(let A=1;A<m.length;A++){let C=d[d.length-A],P=l[l.length-A];if(C===P)T*=C;else break}T%4===0?(_=!0,h=!0):(x||$||v||S)&&(h=!0)}else h=!0;return y.push(h),{name:e,shaderCache:{hint:t+y.map(g=>g.toString()).join(\"_\"),inputDependencies:[\"rank\",\"rank\"]},getShaderSource:g=>Qm(g,d,l,m,h,p,_,o,r.dataType,n.dataType,a,i),getRunData:()=>({outputs:[{dims:m,dataType:a}],dispatchGroup:{x:Math.ceil(u/64/4)},programUniforms:[{type:12,data:Math.ceil(k.size(m)/4)},...N(d,l,m)]})}},at=(e,t,r,n,o,i)=>{e.compute(Xm(t,o??\"\",e.inputs[0],e.inputs[1],r,n,i))},vu=e=>{at(e,\"Add\",(t,r)=>`${t}+${r}`)},$u=e=>{at(e,\"Div\",(t,r)=>`${t}/${r}`)},xu=e=>{at(e,\"Equal\",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Su=e=>{at(e,\"Mul\",(t,r)=>`${t}*${r}`)},Tu=e=>{let t=E(\"input\",e.inputs[0].dataType,e.inputs[0].dims).type.value;at(e,\"Pow\",{scalar:(n,o)=>`pow_custom(${n},${o})`,vector:(n,o)=>`pow_vector_custom(${n},${o})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t===\"i32\"?\"round\":\"\"}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Iu=e=>{at(e,\"Sub\",(t,r)=>`${t}-${r}`)},Cu=e=>{at(e,\"Greater\",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Au=e=>{at(e,\"Less\",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},ku=e=>{at(e,\"GreaterOrEqual\",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Eu=e=>{at(e,\"LessOrEqual\",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var ef,tf,rf,nf,zu,Ou,Du=U(()=>{\"use strict\";J();ne();xe();ae();ef=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");let r=0,n=e[r],o=n.dataType,i=n.dims.length;e.forEach((a,d)=>{if(d!==r){if(a.dataType!==o)throw new Error(\"input tensors should be one type\");if(a.dims.length!==i)throw new Error(\"input tensors should have the same shape\");a.dims.forEach((l,p)=>{if(p!==t&&l!==n.dims[p])throw new Error(\"non concat dimensions must match\")})}})},tf=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,rf=(e,t)=>{let r=e.length,n=[];for(let o=0;o<r;++o){let i=t.setByOffset(\"global_idx\",e[o].getByIndices(\"indices\"));r===1?n.push(i):o===0?n.push(`if (inputIndex == ${o}u) { ${i} }`):o===r-1?n.push(`else { ${i} }`):n.push(`else if (inputIndex == ${o}) { ${i} }`)}return n.join(`\n`)},nf=(e,t,r,n)=>{let o=k.size(r),i=new Array(e.length),a=new Array(e.length),d=0,l=[],p=[],m=[{type:12,data:o}];for(let g=0;g<e.length;++g)d+=e[g].dims[t],i[g]=d,p.push(e[g].dims.length),a[g]=E(`input${g}`,n,p[g]),l.push(\"rank\"),m.push({type:12,data:i[g]});for(let g=0;g<e.length;++g)m.push(...N(e[g].dims));m.push(...N(r));let u=M(\"output\",n,r.length),h=u.indicesGet(\"indices\",t),_=Array.from(Array(i.length).keys()).map(g=>`uniforms.sizeInConcatAxis${g}`).join(\",\"),y=g=>`\n\n  ${(()=>{g.registerUniform(\"outputSize\",\"u32\");for(let x=0;x<e.length;x++)g.registerUniform(`sizeInConcatAxis${x}`,\"u32\");return g.declareVariables(...a,u)})()}\n\n  ${tf(i.length,_)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n    var indices = ${u.offsetToIndices(\"global_idx\")};\n\n    let inputIndex = calculateInputIndex(${h});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${i.length}u>(${_});\n      ${h} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${rf(a,u)}\n  }`;return{name:\"Concat\",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:r,dataType:n}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:m}),getShaderSource:y}},zu=(e,t)=>{let r=e.inputs,n=r[0].dims,o=k.normalizeAxis(t.axis,n.length);ef(r,o);let i=n.slice();i[o]=r.reduce((d,l)=>d+(l.dims.length>o?l.dims[o]:0),0);let a=r.filter(d=>k.size(d.dims)>0);e.compute(nf(a,o,i,r[0].dataType),{inputs:a})},Ou=e=>ee({axis:e.axis})});var Ke,je,Ye,Kr,yt=U(()=>{\"use strict\";J();ne();Ke=(e,t,r=\"f32\")=>{switch(e.activation){case\"Relu\":return`value = max(value, ${t}(0.0));`;case\"Sigmoid\":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case\"Clip\":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case\"HardSigmoid\":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case\"LeakyRelu\":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case\"Tanh\":return`let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        `;case\"\":return\"\";default:throw new Error(`Unsupported activation ${e.activation}`)}},je=(e,t)=>{e.activation===\"Clip\"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation===\"HardSigmoid\"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation===\"LeakyRelu\"&&t.push({type:1,data:e.alpha})},Ye=(e,t)=>{e.activation===\"Clip\"?t.push({name:\"clip_max\",type:\"f32\"},{name:\"clip_min\",type:\"f32\"}):e.activation===\"HardSigmoid\"?t.push({name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}):e.activation===\"LeakyRelu\"&&t.push({name:\"alpha\",type:\"f32\"})},Kr=e=>{let t=e?.activation||\"\";if(t===\"HardSigmoid\"){let[r,n]=e?.activation_params||[.2,.5];return{activation:t,alpha:r,beta:n}}else if(t===\"Clip\"){let[r,n]=e?.activation_params||[Ja,es];return{activation:t,clipMax:n,clipMin:r}}else if(t===\"LeakyRelu\"){let[r]=e?.activation_params||[.01];return{activation:t,alpha:r}}return{activation:t}}});var Ae,Bu,jr=U(()=>{\"use strict\";Ae=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Bu=e=>`\n      ${e?\"value = value + getBiasByOutputCoords(coords);\":\"\"}\n      `});var Mu,Ru=U(()=>{\"use strict\";Mu=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var Xt,Yr,Zr=U(()=>{\"use strict\";J();ne();ae();yt();Xt=(e,t,r,n,o)=>{let i=n-r;return`\n      ${Array.from({length:r}).map((a,d)=>`\n      if (${q(t.shape,d,t.rank)} != 1) {\n        ${t.indicesSet(e,d,q(o,d+i,n))}\n      } else {\n        ${t.indicesSet(e,d,0)}\n      }`).join(\"\")}\n`},Yr=(e,t,r,n,o=!1,i)=>{let a=e[0].dims,d=e[1].dims,l=a[a.length-2],p=d[d.length-1],m=a[a.length-1],u=me(p),h=me(m),_=me(l),y=k.size(r)/u/_,g=e.length>2,x=n?n.slice(0,-2):r.slice(0,-2),v=[k.size(x),l,p],S=[{type:12,data:y},{type:12,data:l},{type:12,data:p},{type:12,data:m}];je(t,S),S.push(...N(x,a,d)),g&&S.push(...N(e[2].dims)),S.push(...N(v));let T=A=>{let C=Wr(\"batch_dims\",e[0].dataType,x.length),P=E(\"a\",e[0].dataType,a.length,h),D=E(\"b\",e[1].dataType,d.length,u),R=M(\"output\",e[0].dataType,v.length,u),H=ye(R.type.tensor),L=Ke(t,R.type.value,H),re=[P,D],V=\"\";if(g){let j=o?u:1;re.push(E(\"bias\",e[2].dataType,e[2].dims.length,j)),V=`${o?`value += bias[col / ${j}];`:`value += ${R.type.value}(bias[row + i]);`}`}let K=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"}];Ye(t,K);let we=()=>{let j=`var a_data: ${P.type.value};`;for(let Q=0;Q<h;Q++)j+=`\n              let b_data${Q} = b[(b_offset + (k + ${Q}) * uniforms.N + col) / ${u}];`;for(let Q=0;Q<_;Q++){j+=`a_data = a[(a_offset + (row + ${Q}) * uniforms.K + k) / ${h}];`;for(let ie=0;ie<h;ie++)j+=`\n            values[${Q}] = fma(${D.type.value}(a_data${h===1?\"\":`[${ie}]`}), b_data${ie}, values[${Q}]);\n`}return j};return`\n  ${A.registerUniforms(K).registerInternalVariables(C).declareVariables(...re,R)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let col = (global_idx % (uniforms.N / ${u})) * ${u};\n    var index1 = global_idx / (uniforms.N / ${u});\n    let stride1 = uniforms.M / ${_};\n    let row = (index1 % stride1) * ${_};\n    let batch = index1 / stride1;\n\n    ${r.length===2?\"\":`let batch_indices = ${C.offsetToIndices(\"batch\")};`}\n\n    var a_indices: ${P.type.indices};\n    ${Xt(\"a_indices\",P,P.rank-2,C.rank,\"batch_indices\")}\n    ${P.indicesSet(\"a_indices\",P.rank-2,0)}\n    ${P.indicesSet(\"a_indices\",P.rank-1,0)}\n    let a_offset = ${P.indicesToOffset(\"a_indices\")};\n\n    var b_indices: ${D.type.indices};\n    ${Xt(\"b_indices\",D,D.rank-2,C.rank,\"batch_indices\")}\n    ${D.indicesSet(\"b_indices\",D.rank-2,0)}\n    ${D.indicesSet(\"b_indices\",D.rank-1,0)}\n    let b_offset = ${D.indicesToOffset(\"b_indices\")};\n    var values: array<${R.type.value}, ${_}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {\n      ${we()}\n    }\n    for (var i = 0u; i < ${_}u; i++) {\n      var value = values[i];\n      ${V}\n      ${L}\n      let cur_indices = ${R.type.indices}(batch, row + i, col);\n      let offset = ${R.indicesToOffset(\"cur_indices\")};\n      ${R.setByOffset(`offset / ${u}`,\"value\")};\n    }\n  }\n  `};return{name:\"MatMulNaive\",shaderCache:{hint:`${t.activation};${u};${h};${_};${o}`,inputDependencies:g?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:i?i(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:S}),getShaderSource:T}}});var of,af,fo,Uu,sf,ho,uf,Jt,Qr=U(()=>{\"use strict\";J();ne();ae();yt();Zr();jr();of=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `,af=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?\"\":\"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];\"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached3[i] + acc[i];\"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached.w + acc[i];\"}\n        }`,fo=(e,t,r=\"f32\",n,o=!1,i=32,a=!1,d=32)=>{let l=t[1]*e[1],p=t[0]*e[0],m=o?l:i,u=o?i:l,h=m/t[0],_=i/t[1];if(!((o&&h===4&&e[1]===4||!o&&(h===3||h===4))&&m%t[0]===0&&i%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${h} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${h} must be 3 or 4.\n  tileAWidth ${m} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${h}<${r}>, ${m/h}>, ${u}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${i}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${h};\nconst tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${a?\"0\":\"i32(globalId.z)\"};\n  ${n?`let batchIndices = ${n.offsetToIndices(\"u32(batch)\")};`:\"\"}\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let num_tiles = ${a?`${Math.ceil(d/i)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n  var kStart = ${a?`i32(globalId.z) * ${d}`:\"0\"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${of(o,n)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${n?\", batchIndices\":\"\"});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${h===3?\"\":\"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];\"}\n\n          ${af(o,h)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Uu=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?\", batchIndices\":\"\"});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?\", batchIndices\":\"\"});\n            `,sf=e=>e?\"let ACached = mm_Asub[k][tileRow + innerRow];\":\"let ACached = mm_Asub[tileRow + innerRow][k];\",ho=(e,t,r=\"f32\",n,o=!1,i=32,a=!1,d=32,l=!1)=>{let p=e[1]*t[1],m=e[0]*t[0],u=o?p:i,h=o?i:p;if(!(h%t[1]===0&&u%t[0]===0&&i%t[1]===0))throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let _=h/t[1],y=u/t[0],g=i/t[1],x=l?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${m};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${t[0]}) {\n          ${Uu(o,n)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${m}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${n?\", batchIndices\":\"\"});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${y};\nlet tileRowB = i32(localId.y) * ${g};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Uu(o,n)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${n?\", batchIndices\":\"\"});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${sf(o)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${u}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${m}>, ${i}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${a?\"0\":\"i32(globalId.z)\"};\n    ${n?`let batchIndices = ${n.offsetToIndices(\"u32(batch)\")};`:\"\"}\n    let num_tiles = ${a?`${Math.ceil(d/i)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n    var kStart = ${a?`i32(globalId.z) * ${d}`:\"0\"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n    ${x}\n  }\n`},uf=(e,t,r,n,o=!1)=>{let[i,a,d,l]=n,p=ye(n[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ae(e,p)} {\n      var value = ${Ae(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${a.type.indices};\n        ${Xt(\"aIndices\",a,a.rank-2,i.rank,\"batchIndices\")}\n        ${a.indicesSet(\"aIndices\",a.rank-2,\"u32(row)\")}\n        ${a.indicesSet(\"aIndices\",a.rank-1,\"u32(colIn)\")}\n        value = ${a.getByIndices(\"aIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ae(e,p)} {\n      var value = ${Ae(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${d.type.indices};\n        ${Xt(\"bIndices\",d,d.rank-2,i.rank,\"batchIndices\")}\n        ${d.indicesSet(\"bIndices\",d.rank-2,\"u32(row)\")}\n        ${d.indicesSet(\"bIndices\",d.rank-1,\"u32(colIn)\")}\n        value = ${d.getByIndices(\"bIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ae(e,p)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${o?\"bias[colIn]\":`${Ae(e,p)}(bias[row])`};`:\"\"}\n        ${r}\n        ${l.setByIndices(\"vec3<u32>(coords)\",\"value\")}\n      }\n    }\n    `},Jt=(e,t,r,n,o=!1,i)=>{let a=e[0].dims,d=e[1].dims,l=a.slice(0,-2),p=d.slice(0,-2),m=n?n.slice(0,-2):r.slice(0,-2),u=k.size(m),h=a[a.length-2],_=a[a.length-1],y=d[d.length-1],g=_%4===0&&y%4===0,x=h<=8?[4,1,1]:[4,4,1],$=[8,8,1],v=[Math.ceil(y/$[0]/x[0]),Math.ceil(h/$[1]/x[1]),Math.ceil(u/$[2]/x[2])],S=g?4:1,T=[...l,h,_/S],A=T.length,C=[...p,_,y/S],P=C.length,D=[u,h,y/S],R=[{type:6,data:h},{type:6,data:y},{type:6,data:_}];je(t,R),R.push(...N(m,T,C));let H=[\"rank\",\"rank\"],L=e.length>2;L&&(R.push(...N(e[2].dims)),H.push(\"rank\")),R.push(...N(D));let re=V=>{let K=m.length,we=Wr(\"batchDims\",e[0].dataType,K,1),j=ye(e[0].dataType),Q=E(\"a\",e[0].dataType,A,S),ie=E(\"b\",e[1].dataType,P,S),te=M(\"result\",e[0].dataType,D.length,S),be=[Q,ie];if(L){let Y=o?S:1;be.push(E(\"bias\",e[2].dataType,e[2].dims.length,Y))}let Oe=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"}];Ye(t,Oe);let ve=ye(te.type.tensor),de=Ke(t,te.type.value,ve),W=uf(S,L,de,[we,Q,ie,te],o);return`\n  ${V.registerUniforms(Oe).registerInternalVariables(we).declareVariables(...be,te)}\n  ${W}\n  ${g?fo(x,$,j,we):ho(x,$,j,we)}\n                   `};return{name:\"MatMul\",shaderCache:{hint:`${x};${t.activation};${g};${o}`,inputDependencies:H},getRunData:()=>({outputs:[{dims:i?i(r):r,dataType:e[0].dataType}],dispatchGroup:{x:v[0],y:v[1],z:v[2]},programUniforms:R}),getShaderSource:re}}});var df,Nu,Vu=U(()=>{\"use strict\";J();et();ae();yt();jr();Ru();Qr();df=(e,t,r,n,o=!1,i,a=4,d=4,l=4,p=\"f32\")=>{let m=H=>{switch(H){case 1:return\"resData = x[xIndex];\";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return\"resData = x[xIndex / 4];\";default:throw new Error(`innerElementSize ${H} is not supported.`)}},u=H=>{switch(H){case 1:return\"return w[row * i32(uniforms.w_shape[3]) + colIn];\";case 4:return\"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];\";default:throw new Error(`innerElementSize ${H} is not supported.`)}},h=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?\"i32(uniforms.x_shape[1])\":\"i32(uniforms.x_shape[2])\",g=e?\"i32(uniforms.x_shape[2])\":\"i32(uniforms.x_shape[3])\",x=e?\"row\":\"col\",$=e?\"col\":\"row\",v=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n    let outRow = ${x} / outWidth;\n    let outCol = ${x} % outWidth;\n\n    let WRow = ${$} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${$} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${$} % inChannels;\n    var resData = ${Ae(a,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${g}) {\n      ${h}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${m(a)}\n    }\n    return resData;`,S=e?t&&n?`\n    let col = colIn * ${a};\n    ${v}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${v}\n    }\n    return ${Ae(a,p)}(0.0);`:n&&r?`\n    let col = colIn * ${a};\n    ${v}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${v}\n    }\n    return ${Ae(a,p)}(0.0);`,T=e?n&&r?u(d):`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${u(d)}\n    }\n    return ${Ae(d,p)}(0.0);`:`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${u(d)}\n    }\n    return ${Ae(d,p)}(0.0);`,A=Ae(l,p),C=e?Ae(a,p):Ae(d,p),P=e?Ae(d,p):Ae(a,p),D=Ke(i,A,p);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${C} {\n      ${e?S:T}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${P} {\n      ${e?T:S}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${A}) {\n      let col = colIn * ${l};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n      ${_}\n      ${Bu(o)}\n      ${D}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Nu=(e,t,r,n,o,i,a,d,l)=>{let p=t.format===\"NHWC\",m=p?e[0].dims[3]:e[0].dims[1],u=r[0],h=p?r[2]:r[3],_=p?r[1]:r[2],y=p?r[3]:r[1],g=p&&(m%4===0||m%3===0)&&y%4===0,x=p?y:h*_,$=p?h*_:y,v=[8,8,1],S=n<=8?[4,1,1]:[4,4,1],T=[Math.ceil(x/v[0]/S[0]),Math.ceil($/v[1]/S[1]),Math.ceil(u/v[2]/S[2])];se(\"verbose\",()=>`[conv2d_mm_webgpu] dispatch = ${T}`);let A=g?p&&m%4!==0?3:4:1,C=v[1]*S[1],P=v[0]*S[0],D=Math.max(v[0]*A,v[1]),R=n%C===0,H=o%P===0,L=i%D===0,re=g?[A,4,4]:[1,1,1],V=[{type:6,data:n},{type:6,data:o},{type:6,data:i},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];je(t,V),V.push(...N(e[0].dims,e[1].dims));let K=[\"rank\",\"rank\"];a&&(V.push(...N(e[2].dims)),K.push(\"rank\")),V.push(...N(r));let we=j=>{let Q=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"},{name:\"pad\",type:\"i32\",length:2},{name:\"stride\",type:\"i32\",length:2},{name:\"dilation\",type:\"i32\",length:2}];Ye(t,Q);let ie=g?4:1,te=ye(e[0].dataType),be=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${g?`vec4<${te}>`:te}) {\n        result[flatIndex] = ${g?`vec4<${te}>`:te}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${g?`vec4<${te}>`:te}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${g?\"/ 4\":\"\"}, value);\n      }`,Oe=E(\"x\",e[0].dataType,e[0].dims.length,A===3?1:A),ve=E(\"w\",e[1].dataType,e[1].dims.length,ie),de=[Oe,ve],W=M(\"result\",e[0].dataType,r.length,ie);if(a){let Y=E(\"bias\",e[2].dataType,e[2].dims.length,ie);de.push(Y),be+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${g?`vec4<${te}>`:te} {\n          return bias[coords.${p?\"w\":\"y\"}${g?\"/ 4\":\"\"}];\n        }`}return`\n        ${Mu(\"uniforms.result_strides\")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${j.registerUniforms(Q).declareVariables(...de,W)}\n        ${be}\n        ${df(p,R,H,L,a,t,re[0],re[1],re[2],te)}\n        ${g?fo(S,v,te,void 0,!p,D):ho(S,v,te,void 0,!p,D,!1,void 0,d)}`};return{name:\"Conv2DMatMul\",shaderCache:{hint:`${t.cacheKey};${A};${g};${R};${H};${L};${C};${P};${D}`,inputDependencies:K},getRunData:()=>({outputs:[{dims:l?l(r):r,dataType:e[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]},programUniforms:V}),getShaderSource:we}}});var lf,Wu,Xr,cf,Lu,pf,Gu,Hu,Fu=U(()=>{\"use strict\";J();et();ne();ae();yt();jr();lf=e=>{let t=1;for(let r=0;r<e.length;r++)t*=e[r];return t},Wu=e=>typeof e==\"number\"?[e,e,e]:e,Xr=(e,t)=>t<=1?e:e+(e-1)*(t-1),cf=(e,t,r,n=1)=>{let o=Xr(t,n);return Math.floor((e[0]*(r-1)-r+o)/2)},Lu=(e,t,r,n,o)=>{o==null&&(o=cf(e,t[0],n[0]));let i=[0,0,0,r];for(let a=0;a<3;a++)e[a]+2*o>=t[a]&&(i[a]=Math.trunc((e[a]-t[a]+2*o)/n[a]+1));return i},pf=(e,t,r,n,o,i,a,d,l,p)=>{let m,u,h,_;if(e===\"VALID\"&&(e=0),typeof e==\"number\"){m={top:e,bottom:e,left:e,right:e,front:e,back:e};let y=Lu([t,r,n,1],[d,l,p],1,[o,i,a],e);u=y[0],h=y[1],_=y[2]}else if(Array.isArray(e)){if(!e.every((g,x,$)=>g===$[0]))throw Error(`Unsupported padding parameter: ${e}`);m={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let y=Lu([t,r,n,1],[d,l,p],1,[o,i,a],e[0]);u=y[0],h=y[1],_=y[2]}else if(e===\"SAME_UPPER\"){u=Math.ceil(t/o),h=Math.ceil(r/i),_=Math.ceil(n/a);let y=(u-1)*o+d-t,g=(h-1)*i+l-r,x=(_-1)*a+p-n,$=Math.floor(y/2),v=y-$,S=Math.floor(g/2),T=g-S,A=Math.floor(x/2),C=x-A;m={top:S,bottom:T,left:A,right:C,front:$,back:v}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:m,outDepth:u,outHeight:h,outWidth:_}},Gu=(e,t,r,n,o,i=!1,a=\"channelsLast\")=>{let d,l,p,m,u;if(a===\"channelsLast\")[d,l,p,m,u]=e;else if(a===\"channelsFirst\")[d,u,l,p,m]=e;else throw new Error(`Unknown dataFormat ${a}`);let[h,,_,y,g]=t,[x,$,v]=Wu(r),[S,T,A]=Wu(n),C=Xr(_,S),P=Xr(y,T),D=Xr(g,A),{padInfo:R,outDepth:H,outHeight:L,outWidth:re}=pf(o,l,p,m,x,$,v,C,P,D),V=i?h*u:h,K=[0,0,0,0,0];return a===\"channelsFirst\"?K=[d,V,H,L,re]:a===\"channelsLast\"&&(K=[d,H,L,re,V]),{batchSize:d,dataFormat:a,inDepth:l,inHeight:p,inWidth:m,inChannels:u,outDepth:H,outHeight:L,outWidth:re,outChannels:V,padInfo:R,strideDepth:x,strideHeight:$,strideWidth:v,filterDepth:_,filterHeight:y,filterWidth:g,effectiveFilterDepth:C,effectiveFilterHeight:P,effectiveFilterWidth:D,dilationDepth:S,dilationHeight:T,dilationWidth:A,inShape:e,outShape:K,filterShape:t}},Hu=(e,t,r,n,o,i)=>{let a=i===\"channelsLast\",d=a?e[0].dims[3]:e[0].dims[1],l=!1,p=[64,1,1],m={x:r.map((v,S)=>S)},u=[Math.ceil(lf(m.x.map(v=>r[v]))/p[0]),1,1];se(\"verbose\",()=>`[conv3d_naive_webgpu] dispatch = ${u}`);let h=l?a&&d%4!==0?3:4:1,_=k.size(r),y=[{type:12,data:_},{type:12,data:n},{type:12,data:o},{type:12,data:t.strides},{type:12,data:t.dilations}];je(t,y),y.push(...N(e[0].dims,e[1].dims));let g=[\"rank\",\"rank\"],x=e.length===3;x&&(y.push(...N(e[2].dims)),g.push(\"rank\")),y.push(...N(r));let $=v=>{let S=[{name:\"output_size\",type:\"u32\"},{name:\"filter_dims\",type:\"u32\",length:n.length},{name:\"pads\",type:\"u32\",length:o.length},{name:\"strides\",type:\"u32\",length:t.strides.length},{name:\"dilations\",type:\"u32\",length:t.dilations.length}];Ye(t,S);let T=l?4:1,A=ye(e[0].dataType),C=E(\"x\",e[0].dataType,e[0].dims.length,h===3?1:h),P=E(\"W\",e[1].dataType,e[1].dims.length,T),D=[C,P],R=M(\"result\",e[0].dataType,r.length,T),H=\"\";if(x){let V=E(\"bias\",e[2].dataType,e[2].dims.length,T);D.push(V),H+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l?`vec4<${A}>`:A} {\n          return bias[${a?q(\"coords\",4,5):q(\"coords\",1,5)}${l?\"/ 4\":\"\"}];\n        }`}let L=Ae(h,A),re=Ke(t,L,A);return`\n            ${H}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${C.getByIndices(\"aIndices\")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${P.getByIndices(\"aIndices\")};\n            }\n          ${v.registerUniforms(S).declareVariables(...D,R)}\n          ${v.mainStart()}\n          ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n              let coords = ${R.offsetToIndices(\"global_idx\")};\n              let batch = ${q(\"coords\",0,C.rank)};\n              let d2 = ${a?q(\"coords\",C.rank-1,C.rank):q(\"coords\",1,C.rank)};\n              let xFRCCorner = vec3<u32>(${a?q(\"coords\",1,C.rank):q(\"coords\",2,C.rank)},\n              ${a?q(\"coords\",2,C.rank):q(\"coords\",3,C.rank)},\n              ${a?q(\"coords\",3,C.rank):q(\"coords\",4,C.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${a?q(\"uniforms.x_shape\",1,C.rank):q(\"uniforms.x_shape\",2,C.rank)};\n              let xShapeZ = ${a?q(\"uniforms.x_shape\",2,C.rank):q(\"uniforms.x_shape\",3,C.rank)};\n              let xShapeW = ${a?q(\"uniforms.x_shape\",3,C.rank):q(\"uniforms.x_shape\",4,C.rank)};\n              let xShapeU = ${a?q(\"uniforms.x_shape\",4,C.rank):q(\"uniforms.x_shape\",1,C.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${a?`let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            `:`let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            `}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${a?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${a?`let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      `:`let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    `}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${a?`let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      `:`let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    `}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${x?\"value = value + getBiasByOutputCoords(coords)\":\"\"};\n              ${re}\n              result[global_idx] = f32(value);\n          }`};return{name:\"Conv3DNaive\",shaderCache:{hint:`${t.cacheKey};${a};${h};${x}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:u[0],y:u[1],z:u[2]},programUniforms:y}),getShaderSource:$}}});var qu,Ku,ju=U(()=>{\"use strict\";J();ne();ae();yt();qu=(e,t,r,n)=>{let o=e.length>2,i=o?\"value += b[output_channel];\":\"\",a=e[0].dims,d=e[1].dims,l=t.format===\"NHWC\",p=l?r[3]:r[1],m=p/t.group,u=l&&m>=4?me(p):1,h=k.size(r)/u,_=[{type:12,data:h},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:m}];je(t,_),_.push(...N(a,[d[0],d[1],d[2],d[3]/u]));let y=o?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"];_.push(...N([r[0],r[1],r[2],r[3]/u]));let g=x=>{let $=M(\"output\",e[0].dataType,r.length,u),v=ye($.type.tensor),S=Ke(t,$.type.value,v),T=E(\"x\",e[0].dataType,a.length),A=E(\"w\",e[1].dataType,d.length,u),C=[T,A];o&&C.push(E(\"b\",e[2].dataType,e[2].dims,u));let P=[{name:\"output_size\",type:\"u32\"},{name:\"dilations\",type:\"u32\",length:t.dilations.length},{name:\"strides\",type:\"u32\",length:2},{name:\"pads\",type:\"u32\",length:2},{name:\"output_channels_per_group\",type:\"u32\"}];Ye(t,P);let D=l?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${T.get(\"batch\",\"xHeight\",\"xWidth\",\"input_channel\")};\n            let wVal = ${A.get(\"wHeight\",\"wWidth\",\"wInChannel\",\"output_channel\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${T.get(\"batch\",\"input_channel\",\"xHeight\",\"xWidth\")};\n            let wVal = ${A.get(\"output_channel\",\"wInChannel\",\"wHeight\",\"wWidth\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${x.registerUniforms(P).declareVariables(...C,$)}\n\n  ${x.mainStart()}\n    ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let outputIndices = ${$.offsetToIndices(\"global_idx\")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${l?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${u} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\n\n    var value: ${$.type.value} = ${$.type.value}(0);\n    ${D}\n    ${i}\n    ${S}\n    ${$.setByOffset(\"global_idx\",\"value\")}\n  }`};return{name:\"GroupedConv\",shaderCache:{hint:`${t.cacheKey}_${u}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:_}),getShaderSource:g}},Ku=(e,t,r,n)=>{let o=e.length>2,i=me(r[3]),a=me(r[2]),d=k.size(r)/i/a,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/i],p=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/i],m=[r[0],r[1],r[2],r[3]/i],u=[{type:12,data:d},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];je(t,u),u.push(...N(l,p,m));let h=(a-1)*t.strides[1]+p[1],_=y=>{let g=M(\"output\",e[0].dataType,m.length,i),x=ye(g.type.tensor),$=Ke(t,g.type.value,x),v=E(\"x\",e[0].dataType,l.length,i),S=E(\"w\",e[1].dataType,p.length,i),T=[v,S];o&&T.push(E(\"b\",e[2].dataType,e[2].dims,i));let A=o?\"value += b[output_channel];\":\"\",C=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"i32\",length:2},{name:\"pads\",type:\"i32\",length:2}];return Ye(t,C),`\n  ${y.registerUniforms(C).declareVariables(...T,g)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${a}u;\n    let col = (index1 % width1) * ${a}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${v.type.value}, ${h}>;\n    var values: array<${g.type.value}, ${a}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${p[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${h}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${v.get(\"batch\",\"u32(x_height)\",\"u32(x_width)\",\"input_channel\")};\n          } else {\n            x_vals[i] = ${v.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${p[1]}; w_width++) {\n          let w_val = ${S.get(\"w_height\",\"w_width\",\"0\",\"output_channel\")};\n          for (var i = 0u; i < ${a}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${a}u; i++) {\n      var value = values[i];\n      ${A}\n      ${$}\n      ${g.set(\"batch\",\"row\",\"col + i\",\"output_channel\",\"value\")};\n    }\n  }`};return{name:\"GroupedConv-Vectorize\",shaderCache:{hint:`${t.cacheKey};${i};${a};${h};${p[0]};${p[1]}`,inputDependencies:o?[\"rank\",\"rank\",\"type\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}),getShaderSource:_}}});var mf,go,ff,bo,yo,Yu,hf,gf,_o,Zu=U(()=>{\"use strict\";ne();Vu();Fu();Qr();ju();yt();Zr();dt();mf=(e,t,r,n,o,i)=>{let a=e[0],d=e.slice(i?1:2,i?3:4),l=d.length,p=t[0],u=t.slice(2).map((y,g)=>y+(y-1)*(r[g]-1)),_=d.map((y,g)=>y+n[g]+n[g+l]).map((y,g)=>Math.floor((y-u[g]+o[g])/o[g]));return _.splice(0,0,a),_.splice(i?3:1,0,p),_},go=[2,3,1,0],ff=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length>5)throw new Error(\"greater than 5D is not supported\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let r=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],n=e[1].dims[1]*t.group;if(r!==n)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error(\"invalid bias\");let o=e[0].dims.length-2;if(t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\")},bo=(e,t)=>{let r=e.kernelShape.slice();r.length<t[1].dims.length-2&&r.push(...Array(t[1].dims.length-2-r.length).fill(0));for(let i=2;i<t[1].dims.length;++i)r[i-2]===0&&(r[i-2]=t[1].dims[i]);let n=e.pads.slice();kt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,n,e.format===\"NHWC\",e.autoPad);let o=Object.assign({},e);return Object.assign(o,{kernelShape:r,pads:n}),o},yo=e=>{let t=Kr(e),r=e.format,n=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],o=e.dilations,i=e.group,a=e.kernel_shape,d=e.pads,l=e.strides,p=e.w_is_const();return{autoPad:n,format:r,dilations:o,group:i,kernelShape:a,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},Yu=(e,t,r,n)=>{let o=r.format===\"NHWC\",i=mf(t[0].dims,t[1].dims,r.dilations,r.pads,r.strides,o);if(r.group!==1){let C=[t[0]];if(o){let D=e.kernelCustomData.wT??e.compute(Pe(t[1],go),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=D),C.push(D)}else C.push(t[1]);t.length===3&&C.push(t[2]),!e.adapterInfo.isArchitecture(\"ampere\")&&o&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1?e.compute(Ku(C,r,i,n),{inputs:C}):e.compute(qu(C,r,i,n),{inputs:C});return}let a=t.length===3,d=t[0].dims[o?1:2],l=t[0].dims[o?2:3],p=t[0].dims[o?3:1],m=t[1].dims[2],u=t[1].dims[3],h=i[o?1:2],_=i[o?2:3],y=i[o?3:1],g=o&&m===d&&u===l&&r.pads[0]===0&&r.pads[1]===0;if(g||m===1&&u===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let C=i[0],P,D,R,H=[];if(o){let V=e.kernelCustomData.wT??e.compute(Pe(t[1],go),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=V),g){let K=d*l*p;P=t[0].reshape([1,C,K]),D=V.reshape([1,K,y]),R=[1,C,y]}else P=t[0].reshape([C,d*l,p]),D=V.reshape([1,p,y]),R=[C,h*_,y];H.push(P),H.push(D)}else P=t[0].reshape([C,p,d*l]),D=t[1].reshape([1,y,p]),R=[C,y,h*_],H.push(D),H.push(P);a&&H.push(t[2]);let L=R[2],re=H[0].dims[H[0].dims.length-1];L<8&&re<8?e.compute(Yr(H,r,i,R,o,n),{inputs:H}):e.compute(Jt(H,r,i,R,o,n),{inputs:H});return}let x=!0,$=e.kernelCustomData.wT??e.compute(Pe(t[1],go),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=$);let v=[t[0],$];a&&v.push(t[2]);let S=o?h*_:y,T=o?y:h*_,A=m*u*p;e.compute(Nu(v,r,i,S,T,A,a,x,n),{inputs:v})},hf=(e,t)=>{let r=t.format===\"NHWC\",n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&n.push(e.inputs[2]);let o=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),a=[1].concat(t.dilations),d=[1].concat(t.kernelShape),l=bo({...t,pads:o,strides:i,dilations:a,kernelShape:d},n);Yu(e,n,l,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]])},gf=(e,t,r)=>{let n=r.format===\"NHWC\"?\"channelsLast\":\"channelsFirst\",o=bo(r,t),i=r.autoPad===\"NOTSET\"?r.pads:r.autoPad,a=Gu(t[0].dims,t[1].dims,r.strides,r.dilations,i,!1,n);e.compute(Hu(t,o,a.outShape,[a.filterDepth,a.filterHeight,a.filterWidth],[a.padInfo.front,a.padInfo.top,a.padInfo.left],n))},_o=(e,t)=>{if(ff(e.inputs,t),e.inputs[0].dims.length===3)hf(e,t);else if(e.inputs[0].dims.length===5)gf(e,e.inputs,t);else{let r=bo(t,e.inputs);Yu(e,e.inputs,r)}}});var Qu,Xu=U(()=>{\"use strict\";J();et();ne();ae();Qu=(e,t,r)=>{let n=e.length>2,o=t.outputShape,i=t.format===\"NHWC\",a=t.group,d=e[1].dims,l=d[2]/a,p=d[3],m=i?me(l):1,u=i?me(p):1,h=i?p===1?m:u:1,_=k.size(o)/u,y=[Math.ceil(_/64),1,1];se(\"verbose\",()=>`[conv2d_backprop_webgpu] dispatch = ${y}`);let g=[\"rank\",\"rank\"],x=[t.strides[0],t.strides[1]],$=[t.kernelShape[i?1:2],t.kernelShape[i?2:3]],v=[t.dilations[0],t.dilations[1]],S=[$[0]+(t.dilations[0]<=1?0:(t.kernelShape[i?1:2]-1)*(t.dilations[0]-1)),$[1]+(t.dilations[1]<=1?0:(t.kernelShape[i?2:3]-1)*(t.dilations[1]-1))],T=[S[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),S[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],A=[{type:12,data:_},{type:12,data:x},{type:12,data:$},{type:12,data:v},{type:12,data:S},{type:6,data:T},{type:12,data:l},{type:12,data:p},...N(e[0].dims,e[1].dims)];n&&(A.push(...N(e[2].dims)),g.push(\"rank\")),A.push(...N(o));let C=P=>{let D=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"u32\",length:x.length},{name:\"filter_dims\",type:\"u32\",length:$.length},{name:\"dilations\",type:\"u32\",length:$.length},{name:\"effective_filter_dims\",type:\"u32\",length:S.length},{name:\"pads\",type:\"i32\",length:T.length},{name:\"input_channels_per_group\",type:\"u32\"},{name:\"output_channels_per_group\",type:\"u32\"}],R=ye(e[0].dataType),H=i?1:2,L=i?2:3,re=i?3:1,V=E(\"W\",e[1].dataType,e[1].dims.length,h),K=E(\"Dy\",e[0].dataType,e[0].dims.length,m),we=[K,V];n&&we.push(E(\"bias\",e[2].dataType,[o[re]].length,u));let j=M(\"result\",e[0].dataType,o.length,u),Q=()=>{let te=\"\";if(m===1)te+=`\n        let w_offset = ${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n        let wValue = ${V.getByOffset(`w_offset / ${h}`)};\n        dotProd = dotProd + xValue * wValue;`;else if(p===1)te+=`\n          let wValue = ${V.getByOffset(`${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${h}`)};\n          dotProd = dotProd + dot(xValue, wValue);`;else for(let be=0;be<m;be++)te+=`\n            let wValue${be} = ${V.getByOffset(`${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${be}, wOutChannel)`)} / ${h}`)};\n            dotProd = dotProd + xValue[${be}] * wValue${be};`;return te},ie=`\n            let outputIndices = ${j.offsetToIndices(`global_idx * ${u}`)};\n            let batch = ${j.indicesGet(\"outputIndices\",0)};\n            let d1 = ${j.indicesGet(\"outputIndices\",re)};\n            let r = ${j.indicesGet(\"outputIndices\",H)};\n            let c = ${j.indicesGet(\"outputIndices\",L)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${j.type.value}(0.0);\n            var wR: u32 = 0;\n            if (uniforms.dilations.x == 1) {\n              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0\n              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);\n            }\n            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${R}(dyRCorner) + ${R}(wR)) / ${R}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${R}(uniforms.Dy_shape[${H}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              let idyR: u32 = u32(dyR);\n              var wC: u32 = 0;\n              if (uniforms.dilations.y == 1) {\n                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0\n                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);\n              }\n\n              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${R}(dyCCorner) + ${R}(wC)) / ${R}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${R}(uniforms.Dy_shape[${L}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${m}) {\n                  let xValue = ${i?K.getByOffset(`${K.indicesToOffset(`${K.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${m}`):K.get(\"batch\",\"inputChannel\",\"idyR\",\"idyC\")};\n                  ${Q()}\n                  inputChannel = inputChannel + ${m};\n                }\n                wC = wC + uniforms.strides.y - 1;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n            }\n            let value = dotProd${n?` + bias[d1 / ${u}]`:\"\"};\n            ${j.setByOffset(\"global_idx\",\"value\")};\n          `;return`\n    ${P.registerUniforms(D).declareVariables(...we,j)}\n      ${P.mainStart()}\n      ${P.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")};\n    ${ie}}`};return{name:\"ConvTranspose2D\",shaderCache:{hint:`${t.cacheKey};${m}${h}${u}${p===1}`,inputDependencies:g},getRunData:()=>({dispatchGroup:{x:y[0],y:y[1],z:y[2]},outputs:[{dims:r?r(o):o,dataType:e[0].dataType}],programUniforms:A}),getShaderSource:C}}});var bf,yf,_f,Ju,ed,wf,td,vf,rd,nd=U(()=>{\"use strict\";Xu();yt();dt();bf=(e,t,r,n,o,i)=>(e-1)*t+r+(n-1)*o+1-i,yf=(e,t,r,n,o)=>{let i=Math.floor(e/2);t===\"SAME_UPPER\"?(r[n]=i,r[o]=e-i):t===\"SAME_LOWER\"&&(r[n]=e-i,r[o]=i)},_f=(e,t,r,n,o,i,a,d,l,p)=>{let m=e.length-2,u=p.length===0;l.length<m&&l.push(...Array(m-l.length).fill(0));let h=e[0],_=t[d?3:1]*o;for(let y=0,g=e.length-m-(d?1:0);y<m;++y,++g){let x=e[g],$=u?x*a[y]:p[y],v=bf(x,a[y],i[y],t[g],r[y],$);yf(v,n,i,y,y+m),u&&p.push(a[y]*(x-1)+l[y]+(t[g]-1)*r[y]+1-i[y]-i[y+m])}p.splice(0,0,h),p.splice(d?3:1,0,_)},Ju=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((u,h)=>u*h,1)===0){r.length=0;for(let u=2;u<t[1].dims.length;++u)r.push(t[1].dims[u])}let n=e.format===\"NHWC\";r.splice(0,0,t[1].dims[0]),r.splice(n?3:1,0,t[1].dims[1]);let o=e.pads.slice(),i=e.outputShape.slice(),a=e.outputPadding.slice(),d=t[0].dims,l=e.dilations.slice();if(l.reduce((u,h)=>u+h,0)===0){let u=t[0].dims.length-2;l=new Array(u).fill(1)}let p=e.strides.slice();if(p.reduce((u,h)=>u+h,0)===0){let u=t[0].dims.length-2;p=new Array(u).fill(1)}_f(d,r,l,e.autoPad,e.group,o,p,n,a,i);let m=Object.assign({},e);return Object.assign(m,{kernelShape:r,pads:o,outputPadding:a,outputShape:i,dilations:l,strides:p}),m},ed=e=>{let t=Kr(e),r=e.format,n=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][typeof e.autoPad>\"u\"?0:e.autoPad],o=e.dilations,i=e.group,a=e.kernelShape,d=e.pads,l=e.strides,p=e.wIsConst(),m=e.outputPadding,u=e.outputShape;return{autoPad:n,format:r,dilations:o,group:i,kernelShape:a,outputPadding:m,outputShape:u,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},wf=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error(\"currently only support 2-dimensional conv\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let r=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],n=e[1].dims[0];if(r!==n)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");let o=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==o))throw new Error(\"invalid bias\");let i=e[0].dims.length-2;if(t.dilations.reduce((m,u)=>m+u,0)>0&&t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.reduce((m,u)=>m+u,0)>0&&t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.reduce((m,u)=>m+u,0)>0&&t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.outputPadding.length!==i&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${i}D`);if(t.kernelShape.reduce((m,u)=>m+u,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error(\"invalid output shape\")},td=(e,t,r,n)=>{let o=e.kernelCustomData.wT??e.compute(Pe(t[1],[2,3,0,1]),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=o);let i=[t[0],o];t.length===3&&i.push(t[2]),e.compute(Qu(i,r,n),{inputs:i})},vf=(e,t)=>{let r=t.format===\"NHWC\",n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&n.push(e.inputs[2]);let o=t.kernelShape;(o.length===0||o[0]===0)&&(o=[e.inputs[1].dims[2]]);let i=t.dilations;(i.length===0||i[0]===0)&&(i=[1]);let a=t.strides;(a.length===0||a[0]===0)&&(a=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],a=[1].concat(a),i=[1].concat(i),o=[1].concat(o);let l=t.outputPadding;l=[0].concat(l);let p=Ju({...t,pads:d,strides:a,dilations:i,kernelShape:o,outputPadding:l},n);td(e,n,p,m=>r?[m[0],m[2],m[3]]:[m[0],m[1],m[3]])},rd=(e,t)=>{if(wf(e.inputs,t),e.inputs[0].dims.length===3)vf(e,t);else{let r=Ju(t,e.inputs);td(e,e.inputs,r)}}});var $f,od,id,ad=U(()=>{\"use strict\";J();ne();xe();ae();$f=(e,t,r,n)=>{let o=k.size(t),i=t.length,a=E(\"input\",e,i),d=M(\"output\",e,i),l=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),p=k.normalizeAxis(l,i),m=u=>{let h=` i32(${a.indicesGet(\"inputIndices\",\"uniforms.axis\")}) `,_=q(\"uniforms.input_shape\",\"uniforms.axis\",i),y=n.reverse?h+(n.exclusive?\" + 1\":\"\"):\"0\",g=n.reverse?_:h+(n.exclusive?\"\":\" + 1\");return`\n                ${u.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axis\",\"u32\").declareVariables(a,d)}\n                ${u.mainStart()}\n                  ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n                  var inputIndices = ${d.offsetToIndices(\"global_idx\")};\n                  var sum = ${d.type.value}(0);\n                  let first : i32 = ${y};\n                  let last : i32 = ${g};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${a.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(i)\")};\n                    sum = sum + ${a.getByIndices(\"inputIndices\")};\n                  }\n                  ${d.setByOffset(\"global_idx\",\"sum\")};\n                }`};return{name:\"CumSum\",shaderCache:{hint:n.cacheKey,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:12,data:o},{type:12,data:p},...N(t,t)]}),getShaderSource:m}},od=(e,t)=>{let r=e.inputs[0].dims,n=e.inputs[0].dataType,o=e.inputs[1];e.compute($f(n,r,o,t),{inputs:[0]})},id=e=>{let t=e.exclusive===1,r=e.reverse===1;return ee({exclusive:t,reverse:r})}});var xf,Sf,Tf,sd,ud,dd=U(()=>{\"use strict\";J();ne();xe();ae();xf=e=>{if(!e||e.length!==1)throw new Error(\"DepthToSpace requires 1 input.\");if(e[0].dims.length!==4)throw new Error(\"DepthToSpace requires 4D input.\")},Sf=(e,t,r,n)=>{let o=[];o.push(`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let i=0;i<t;++i)o.push(r.indicesSet(\"a\",e[i],`i[${i}]`));return o.push(\"return a;}\"),o.join(`\n`)},Tf=(e,t)=>{let r,n,o,i,a,d,l=t.format===\"NHWC\",p=t.blocksize,m=t.mode===\"DCR\";l?([r,n,o,i]=e.dims,a=m?[r,n,o,p,p,i/p**2]:[r,n,o,i/p**2,p,p],d=m?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([r,n,o,i]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=m?[r,p,p,i/p**2,n,o]:[r,i/p**2,p,p,n,o],d=m?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let u=e.reshape(a),h=u.dims.length,_=e.dataType,y=E(\"a\",_,h),g=M(\"output\",_,h),x=$=>`\n  ${$.registerUniform(\"output_size\",\"u32\").declareVariables(y,g)}\n\n  ${Sf(d,h,y,g)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${g.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${g.setByOffset(\"global_idx\",y.getByIndices(\"aIndices\"))}\n  }`;return{name:\"DepthToSpace\",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:[\"rank\"]},getRunData:$=>{let v=l?[r,n*p,o*p,i/p**2]:[r,i/p**2,n*p,o*p],S=k.size(v),T=u.dims,A=k.sortBasedOnPerm(T,d);return{outputs:[{dims:v,dataType:$[0].dataType}],dispatchGroup:{x:Math.ceil(S/64)},programUniforms:[{type:12,data:S},...N(T,A)]}},getShaderSource:x}},sd=(e,t)=>{xf(e.inputs),e.compute(Tf(e.inputs[0],t))},ud=e=>ee({blocksize:e.blocksize,mode:e.mode,format:e.format})});var wo,Jr,ld,If,Cf,vo,$o,cd,Af,pd,md,fd=U(()=>{\"use strict\";J();ne();xe();ae();wo=\"[a-zA-Z]|\\\\.\\\\.\\\\.\",Jr=\"(\"+wo+\")+\",ld=\"^\"+Jr+\"$\",If=\"(\"+Jr+\",)*\"+Jr,Cf=\"^\"+If+\"$\",vo=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let n=this.symbolToIndices.get(t);n===void 0?n=[r]:n.push(r),this.symbolToIndices.set(t,n)}},$o=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,o]=r.includes(\"->\")?r.split(\"->\",2):[r,\"\"];if(!n.match(RegExp(Cf)))throw new Error(\"Invalid LHS term\");if(n.split(\",\").forEach((d,l)=>{let p=t[l].dims.slice();if(!d.match(RegExp(ld)))throw new Error(\"Invalid LHS term\");let m=this.processTerm(d,!0,p,l);this.lhs.push(m)}),o===\"\")o+=[...this.symbolToInfo.entries()].filter(([d,l])=>l.count===1||d===\"...\").map(([d])=>d).join(\"\");else if(!o.match(RegExp(Jr)))throw new Error(\"Invalid RHS\");o.match(RegExp(wo,\"g\"))?.forEach(d=>{if(d===\"...\")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let l=this.symbolToInfo.get(d);if(l===void 0)throw new Error(\"Invalid RHS symbol\");this.outputDims.push(l.dimValue)}}),this.rhs=this.processTerm(o,!1,this.outputDims)}addSymbol(t,r,n){let o=this.symbolToInfo.get(t);if(o!==void 0){if(o.dimValue!==r&&o.count!==1)throw new Error(\"Dimension mismatch\");o.count++,o.inputIndices.push(n)}else o={count:1,dimValue:r,inputIndices:[n]};this.symbolToInfo.set(t,o)}processTerm(t,r,n,o=-1){let i=n.length,a=!1,d=[],l=0;if(!t.match(RegExp(ld))&&!r&&t!==\"\")throw new Error(\"Invalid LHS term\");let p=t.match(RegExp(wo,\"g\")),m=new vo(o);return p?.forEach((u,h)=>{if(u===\"...\"){if(a)throw new Error(\"Only one ellipsis is allowed per input term\");a=!0;let _=i-p.length+1;if(_<0)throw new Error(\"Ellipsis out of bounds\");if(d=n.slice(l,l+_),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error(\"Ellipsis dimensions mismatch\")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error(\"Ellipsis must be specified in the LHS\");for(let y=0;y<d.length;y++){let g=String.fromCharCode(\"0\".charCodeAt(0)+y);m.addSymbol(g,h+y),this.addSymbol(g,n[l++],o)}}else m.addSymbol(u,h+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(u,n[l++],o)}),m}},cd=e=>e+\"_max\",Af=(e,t,r,n)=>{let i=e.map(m=>m.length).map((m,u)=>E(`input${u}`,t,m)),a=k.size(n),d=M(\"output\",t,n.length),l=[...r.symbolToInfo.keys()].filter(m=>!r.rhs.symbolToIndices.has(m)),p=m=>{let u=[],h=\"var prod = 1.0;\",_=\"var sum = 0.0;\",y=\"sum += prod;\",g=[],x=[],$=[],v=[],S=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((A,C)=>{if(r.rhs.symbolToIndices.has(C)){let P=r.rhs.symbolToIndices.get(C)?.[0];P!==void 0&&r.lhs.forEach((D,R)=>{if(A.inputIndices.includes(R)){let H=D.symbolToIndices.get(C);if(H===void 0)throw new Error(\"Invalid symbol error\");H.forEach(L=>{u.push(`${i[R].indicesSet(`input${R}Indices`,L,d.indicesGet(\"outputIndices\",P))}`)})}})}else r.lhs.forEach((P,D)=>{if(A.inputIndices.includes(D)){let R=P.symbolToIndices.get(C);if(R===void 0)throw new Error(\"Invalid symbol error\");R.forEach(H=>{g.push(`${i[D].indicesSet(`input${D}Indices`,H,`${C}`)}`)}),v.push(`prod *= ${i[D].getByIndices(`input${D}Indices`)};`)}}),x.push(`for(var ${C}: u32 = 0; ${C} < uniforms.${cd(C)}; ${C}++) {`),$.push(\"}\")});let T=S?[...u,`let sum = ${i.map((A,C)=>A.getByIndices(`input${C}Indices`)).join(\" * \")};`]:[...u,_,...x,...g,h,...v,y,...$];return`\n            ${m.registerUniforms(l.map(A=>({name:`${cd(A)}`,type:\"u32\"}))).registerUniform(\"outputSize\",\"u32\").declareVariables(...i,d)}\n\n            ${m.mainStart()}\n            ${m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n            var outputIndices = ${d.offsetToIndices(\"global_idx\")};\n            ${i.map((A,C)=>`var input${C}Indices: ${i[C].type.indices};`).join(`\n`)}\n            ${T.join(`\n`)};\n            ${d.setByOffset(\"global_idx\",\"sum\")};\n          }`};return{name:\"Einsum\",shaderCache:{hint:r.equation,inputDependencies:e.map(()=>\"rank\")},getRunData:()=>{let m=l.filter(h=>r.symbolToInfo.has(h)).map(h=>({type:12,data:r.symbolToInfo.get(h)?.dimValue||0}));m.push({type:12,data:a});let u=e.map((h,_)=>[...N(h)]).reduce((h,_)=>h.concat(_),m);return u.push(...N(n)),{outputs:[{dims:n,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:u}},getShaderSource:p}},pd=(e,t)=>{let r=new $o(e.inputs,t.equation),n=r.outputDims,o=e.inputs.map((i,a)=>i.dims);e.compute(Af(o,e.inputs[0].dataType,r,n))},md=e=>{let t=e.equation.replace(/\\s+/g,\"\");return ee({equation:t})}});var kf,hd,Ef,Pf,gd,bd=U(()=>{\"use strict\";J();ne();ae();kf=e=>{if(!e||e.length!==2)throw new Error(\"Expand requires 2 input.\");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=r.length<t.length?0:r.length-t.length,o=t.length<r.length?0:t.length-r.length;for(;n<r.length&&o<t.length;++n,++o)if(r[n]!==t[o]&&r[n]!==1&&t[o]!==1)throw new Error(\"Expand requires shape to be broadcastable to input\")},hd=(e,t)=>{let r=e.length-t.length,n=[];for(let o=0;o<r;++o)n.push(e[o]);for(let o=0;o<t.length;++o)n.push(t[o]===1?e[o+r]:t[o]);return n},Ef=(e,t)=>e.length>t.length?hd(e,t):hd(t,e),Pf=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=Ef(t,r),o=e[0].dataType,i=o===9||k.size(t)===1,a=o===9||t.length>0&&t[t.length-1]%4===0?4:1,d=i||n.length>0&&n[n.length-1]%4===0?4:1,l=Math.ceil(k.size(n)/d),p=u=>{let h=E(\"input\",o,t.length,a),_=M(\"output\",o,n.length,d),y;if(o===9){let g=(x,$,v=\"\")=>`\n          let outputIndices${$} = ${_.offsetToIndices(`outputOffset + ${$}u`)};\n          let offset${$} = ${h.broadcastedIndicesToOffset(`outputIndices${$}`,_)};\n          let index${$} = offset${$} / 4u;\n          let component${$} = offset${$} % 4u;\n          ${x}[${$}] = ${v}(${h.getByOffset(`index${$}`)}[component${$}]);\n        `;y=`\n        let outputOffset = global_idx * ${d};\n        var data = vec4<u32>(0);\n        ${g(\"data\",0,\"u32\")}\n        ${g(\"data\",1,\"u32\")}\n        ${g(\"data\",2,\"u32\")}\n        ${g(\"data\",3,\"u32\")}\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`}else y=`\n        let outputIndices = ${_.offsetToIndices(`global_idx * ${d}`)};\n        let inputOffset = ${h.broadcastedIndicesToOffset(\"outputIndices\",_)};\n        let data = ${_.type.value}(${h.getByOffset(`inputOffset / ${a}`)});\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`;return`\n    ${u.registerUniform(\"vec_size\",\"u32\").declareVariables(h,_)}\n    ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n    ${y}`},m=[{type:12,data:l},...N(t,n)];return{name:\"Expand\",shaderCache:{hint:`${n.length};${a}${d}`,inputDependencies:[\"rank\"]},getShaderSource:p,getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:m})}},gd=e=>{kf(e.inputs),e.compute(Pf(e.inputs),{inputs:[0]})}});var zf,yd,_d=U(()=>{\"use strict\";J();ne();ae();qr();zf=e=>{let t=e[0].dataType,r=k.size(e[0].dims),n=k.size(e[1].dims),o=n%4===0,i=a=>{let d=E(\"x\",t,[1],4),l=E(\"bias\",t,[1],4),p=M(\"y\",t,[1],4),m=[{name:\"output_vec_size\",type:\"u32\"},{name:\"bias_size\",type:\"u32\"}],u=_=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${l.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,h=o?`\n      let bias = ${l.getByOffset(\"global_idx % (uniforms.bias_size / 4)\")};`:`${u(0)}${u(1)}${u(2)}${u(3)}\n      let bias = ${d.type.value}(bias0, bias1, bias2, bias3);`;return`${a.registerUniforms(m).declareVariables(d,l,p)}\n\n    ${po(Ee(t))}\n\n    ${a.mainStart(Et)}\n      ${a.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_vec_size\")}\n\n      let x = ${d.getByOffset(\"global_idx\")};\n      ${h}\n      let x_in = x + bias;\n      ${p.setByOffset(\"global_idx\",mo(\"x_in\"))}\n    }`};return{name:\"FastGeluWithBias\",shaderCache:{hint:`${o}`,inputDependencies:[\"type\",\"type\"]},getShaderSource:i,getRunData:a=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:n}],dispatchGroup:{x:Math.ceil(r/Et/4)}})}},yd=e=>{e.inputs.length<2||k.size(e.inputs[1].dims)===0?fu(e):e.compute(zf(e.inputs))}});var Of,Df,wd,vd,$d=U(()=>{\"use strict\";J();ne();xe();ae();Of=e=>{if(!e||e.length!==2)throw new Error(\"Gather requires 2 inputs.\")},Df=(e,t)=>{let r=e[0].dims,n=e[1].dims,o=r.length,i=k.normalizeAxis(t.axis,o),a=r.slice(0);a.splice(i,1,...n);let d=r[i],l=e[0].dataType===9?4:1,p=Math.ceil(k.size(a)/l),m=[{type:12,data:p},{type:6,data:d},{type:12,data:i},...N(e[0].dims,e[1].dims,a)],u=h=>{let _=E(\"data\",e[0].dataType,e[0].dims.length,l),y=E(\"inputIndices\",e[1].dataType,e[1].dims.length),g=M(\"output\",e[0].dataType,a.length,l),x=v=>{let S=n.length,T=`var indicesIndices${v}  = ${y.type.indices}(0);`;for(let A=0;A<S;A++)T+=`${S>1?`indicesIndices${v}[${A}]`:`indicesIndices${v}`} = ${a.length>1?`outputIndices${v}[uniforms.axis + ${A}]`:`outputIndices${v}`};`;T+=`\n          var idx${v} = ${y.getByIndices(`indicesIndices${v}`)};\n          if (idx${v} < 0) {\n            idx${v} = idx${v} + uniforms.axisDimLimit;\n          }\n          var dataIndices${v} : ${_.type.indices};\n        `;for(let A=0,C=0;A<o;A++)A===i?(T+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = u32(idx${v});`,C+=S):(T+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = ${a.length>1?`outputIndices${v}[${C}]`:`outputIndices${v}`};`,C++);return T},$;if(e[0].dataType===9){let v=(S,T,A=\"\")=>`\n          let outputIndices${T} = ${g.offsetToIndices(`outputOffset + ${T}u`)};\n          ${x(T)};\n          let offset${T} = ${_.indicesToOffset(`dataIndices${T}`)};\n          let index${T} = offset${T} / 4u;\n          let component${T} = offset${T} % 4u;\n          ${S}[${T}] = ${A}(${_.getByOffset(`index${T}`)}[component${T}]);\n        `;$=`\n        let outputOffset = global_idx * ${l};\n        var value = vec4<u32>(0);\n        ${v(\"value\",0,\"u32\")}\n        ${v(\"value\",1,\"u32\")}\n        ${v(\"value\",2,\"u32\")}\n        ${v(\"value\",3,\"u32\")}\n        ${g.setByOffset(\"global_idx\",\"value\")}\n      `}else $=`\n      let outputIndices = ${g.offsetToIndices(\"global_idx\")};\n      ${x(\"\")};\n      let value = ${_.getByIndices(\"dataIndices\")};\n      ${g.setByOffset(\"global_idx\",\"value\")};\n      `;return`\n      ${h.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(_,y,g)}\n      ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        ${$}\n      }`};return{name:\"Gather\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:m}),getShaderSource:u}},wd=e=>ee({axis:e.axis}),vd=(e,t)=>{let r=e.inputs;Of(r),e.compute(Df(e.inputs,t))}});var Bf,xd,Sd,Td=U(()=>{\"use strict\";J();ne();ae();Bf=(e,t,r,n,o,i,a,d,l)=>{let p=[{type:12,data:i},{type:12,data:n},{type:12,data:o},{type:12,data:r},{type:12,data:a},{type:12,data:d},{type:12,data:l}],m=[i];p.push(...N(t.dims,m));let u=h=>{let _=E(\"indices_data\",t.dataType,t.dims.length),y=M(\"input_slice_offsets_data\",12,1,1),g=[_,y],x=[{name:\"output_size\",type:\"u32\"},{name:\"batch_dims\",type:\"u32\"},{name:\"input_dims\",type:\"u32\",length:o.length},{name:\"sizes_from_slice_dims_data\",type:\"u32\",length:r.length},{name:\"num_slices_per_batch\",type:\"u32\"},{name:\"input_batch_stride\",type:\"u32\"},{name:\"num_slice_dims\",type:\"u32\"}];return`\n  ${h.registerUniforms(x).declareVariables(...g)}\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${o.length===1?\"index += i32(uniforms.input_dims);\":\"index += i32(uniforms.input_dims[input_dim_idx]);\"}\n      }\n      ${r.length===1?\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);\":\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);\"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`};return e.compute({name:\"computeSliceOffsets\",shaderCache:{hint:`${o.length}_${r.length}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:m,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:p}),getShaderSource:u},{inputs:[t],outputs:[-1]})[0]},xd=(e,t)=>{let r=e.inputs,n=r[0].dims,o=r[0].dataType,i=r[1].dims,a=i[i.length-1],d=k.sizeToDimension(i,i.length-1),l=k.sizeFromDimension(n,t.batchDims+a),p=k.sizeToDimension(n,t.batchDims),m=k.sizeFromDimension(n,t.batchDims),u=d/p,h=new Array(a),_=l;for(let T=0;T<a;++T)h[a-1-T]=_,_*=n[t.batchDims+a-1-T];let y=Bf(e,r[1],h,t.batchDims,n,d,u,m,a),g=t.batchDims+a;if(g>n.length)throw new Error(\"last dimension of indices must not be larger than rank of input tensor\");let x=i.slice(0,-1).concat(n.slice(g)),$=k.size(x),v=[{type:12,data:$},{type:12,data:l},...N(r[0].dims,y.dims,x)],S=T=>{let A=E(\"data\",r[0].dataType,r[0].dims.length),C=E(\"slice_offsets\",12,y.dims.length),P=M(\"output\",r[0].dataType,x.length);return`\n          ${T.registerUniform(\"output_size\",\"u32\").registerUniform(\"slice_size\",\"u32\").declareVariables(A,C,P)}\n            ${T.mainStart()}\n            ${T.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`};e.compute({name:\"GatherND\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:x,dataType:o}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:v}),getShaderSource:S},{inputs:[r[0],y]})},Sd=e=>({batchDims:e.batch_dims,cacheKey:\"\"})});var Mf,Rf,Id,Cd,Ad=U(()=>{\"use strict\";J();ne();xe();ae();Mf=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"GatherBlockQuantized requires 3 or 4 inputs.\");let r=k.normalizeAxis(t.quantizeAxis,e[0].dims.length),n=t.blockSize,o=e[0],i=e[2],a=e.length===4?e[3]:void 0;if(i.dims.length!==o.dims.length||!o.dims.map((d,l)=>l===r?Math.ceil(d/n)===i.dims[l]:d===i.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.\");if(a){if(a.dataType!==o.dataType)throw new Error(\"Zero point must have the same data type as the input tensor.\");if(a.dims.length!==i.dims.length||!a.dims.map((d,l)=>d===i.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.\")}},Rf=(e,t)=>{let r=e[0].dims,n=e[1].dims,o=r.length,i=k.normalizeAxis(t.gatherAxis,o),a=k.normalizeAxis(t.quantizeAxis,o),d=r.slice(0);d.splice(i,1,...n);let l=k.size(d),p=e[2].dataType,u=e[0].dataType===22,h=[{type:12,data:l},{type:12,data:a},{type:12,data:i},{type:12,data:t.blockSize},...N(...e.map((y,g)=>y.dims),d)],_=y=>{let g=E(\"data\",e[0].dataType,e[0].dims.length),x=E(\"inputIndices\",e[1].dataType,e[1].dims.length),$=E(\"scales\",e[2].dataType,e[2].dims.length),v=e.length>3?E(\"zeroPoint\",e[3].dataType,e[3].dims.length):void 0,S=M(\"output\",p,d.length),T=[g,x,$];v&&T.push(v);let A=[{name:\"output_size\",type:\"u32\"},{name:\"quantize_axis\",type:\"u32\"},{name:\"gather_axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n        ${y.registerUniforms(A).declareVariables(...T,S)}\n        ${y.mainStart()}\n        let output_indices = ${S.offsetToIndices(\"global_idx\")};\n        var indices_indices = ${x.type.indices}(0);\n        ${(()=>n.length>1?`\n          for (var i: u32 = 0; i < ${n.length}; i++) {\n            let index = ${S.indicesGet(\"output_indices\",\"uniforms.gather_axis + i\")};\n            ${x.indicesSet(\"indices_indices\",\"i\",\"index\")};\n          }`:`indices_indices = ${S.indicesGet(\"output_indices\",\"uniforms.gather_axis\")};`)()};\n        var data_indices = ${g.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${S.indicesGet(\"output_indices\",\"i\")};\n          ${g.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        var index_from_indices = ${x.getByIndices(\"indices_indices\")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${r[i]};\n        }\n        ${g.indicesSet(\"data_indices\",\"uniforms.gather_axis\",\"u32(index_from_indices)\")};\n        for (var i = uniforms.gather_axis + 1; i < ${d.length}; i++) {\n          let index = ${S.indicesGet(\"output_indices\",`i + ${n.length} - 1`)};\n          ${g.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        let data_offset = ${g.indicesToOffset(\"data_indices\")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${g.getByOffset(\"data_offset / 8\")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${u?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${$.indicesGet(\"data_indices\",\"uniforms.quantize_axis\")} / uniforms.block_size;\n        ${$.indicesSet(\"scale_indices\",\"uniforms.quantize_axis\",\"quantize_axis_index\")};\n        var scale = ${$.getByIndices(\"scale_indices\")};\n        ${(()=>v?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${v.indicesToOffset(\"zero_point_indices\")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${v.getByOffset(\"zero_point_offset / 8\")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${u?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:\"var zero_point = 0\")()};\n        let dequantized_data = ${Ee(p)}(quantized_data - zero_point) * scale;\n        ${S.setByOffset(\"global_idx\",\"dequantized_data\")};\n    }`};return{name:\"GatherBlockQuantized\",shaderCache:{hint:`${t.cacheKey};${e.filter((y,g)=>g!==1).map(y=>y.dims.join(\"_\")).join(\";\")}`,inputDependencies:Array.from({length:e.length},(y,g)=>\"rank\")},getRunData:()=>({outputs:[{dims:d,dataType:p}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:h}),getShaderSource:_}},Id=(e,t)=>{let r=e.inputs;Mf(r,t),e.compute(Rf(e.inputs,t))},Cd=e=>ee({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})});var Uf,Nf,kd,Ed,Pd=U(()=>{\"use strict\";J();ne();xe();ae();Uf=e=>{if(!e||e.length!==2)throw new Error(\"GatherElements requires 2 inputs.\");if(e[0].dims.length<1)throw new Error(\"GatherElements requires that the data input be rank >= 1.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Nf=(e,t)=>{let r=e[0].dims,n=e[0].dataType,o=r.length,i=e[1].dims,a=e[1].dataType,d=k.normalizeAxis(t.axis,o),l=r[d],p=i.slice(0),m=k.size(p),u=E(\"input\",n,o),h=E(\"indicesInput\",a,i.length),_=M(\"output\",n,p.length),y=[{type:12,data:m},{type:6,data:l},{type:12,data:d}];return y.push(...N(r,i,p)),{name:\"GatherElements\",shaderCache:{inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:y}),getShaderSource:$=>`\n      ${$.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(u,h,_)}\n      ${$.mainStart()}\n      ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n      let outputIndices = ${_.offsetToIndices(\"global_idx\")};\n\n      var idx = ${h.getByOffset(\"global_idx\")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${u.type.indices}(outputIndices);\n      ${u.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(idx)\")};\n      let value = ${u.getByIndices(\"inputIndices\")};\n\n      ${_.setByOffset(\"global_idx\",\"value\")};\n  }`}},kd=e=>ee({axis:e.axis}),Ed=(e,t)=>{let r=e.inputs;Uf(r),e.compute(Nf(e.inputs,t))}});var Vf,Wf,zd,Od,Dd=U(()=>{\"use strict\";J();ne();ae();Vf=e=>{if(!e)throw new Error(\"Input is missing\");if(e.length<2||e.length>3)throw new Error(\"Invaid input number.\");if(e.length===3&&e[2].dims.length>2)throw new Error(\"Invalid input shape of C\");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"Input types are mismatched\")},Wf=(e,t)=>{let r=e[0].dims.slice(),n=e[1].dims.slice(),[o,i,a]=Nr.getShapeOfGemmResult(r,t.transA,n,t.transB,e.length===3?e[2].dims:void 0),d=[o,i];if(!d)throw new Error(\"Can't use gemm on the given tensors\");let l=16,p=Math.ceil(i/l),m=Math.ceil(o/l),u=!0,h=k.size(d),_=[{type:12,data:u?p:h},{type:12,data:o},{type:12,data:i},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}],y=[\"type\",\"type\"];e.length===3&&(_.push(...N(e[2].dims)),y.push(\"rank\")),_.push(...N(d));let g=$=>{let v=\"\";t.transA&&t.transB?v=\"value += a[k * uniforms.M + m] * b[n * uniforms.K + k];\":t.transA&&!t.transB?v=\"value += a[k * uniforms.M + m] * b[k * uniforms.N + n];\":!t.transA&&t.transB?v=\"value += a[m * uniforms.K + k] * b[n * uniforms.K + k];\":!t.transA&&!t.transB&&(v=\"value += a[m * uniforms.K + k] * b[k * uniforms.N + n];\");let S=t.alpha===1?\"\":\"value *= uniforms.alpha;\",T=E(\"a\",e[0].dataType,e[0].dims),A=E(\"b\",e[1].dataType,e[1].dims),C=T.type.value,P=null,D=[T,A];e.length===3&&(P=E(\"c\",e[2].dataType,e[2].dims.length),D.push(P));let R=M(\"output\",e[0].dataType,d.length);D.push(R);let H=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}];return`\n  ${$.registerUniforms(H).declareVariables(...D)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${C}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${v}\n    }\n\n    ${S}\n    ${(()=>P!=null?`let cOffset = ${P.broadcastedIndicesToOffset(\"vec2(m, n)\",R)}; value += ${C}(uniforms.beta) * ${P.getByOffset(\"cOffset\")};`:\"\")()}\n    output[global_idx] = value;\n  }`},x=$=>{let v=E(\"a\",e[0].dataType,e[0].dims),S=E(\"b\",e[1].dataType,e[1].dims),T=null,A=[v,S];e.length===3&&(T=E(\"c\",e[2].dataType,e[2].dims.length),A.push(T));let C=M(\"output\",e[0].dataType,d.length);A.push(C);let P=[{name:\"num_tile_n\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}],D=\"\",R=\"\";t.transA&&t.transB?(R=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[k][local_id.y] * tile_b[local_id.x][k];\"):t.transA&&!t.transB?(R=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[k][local_id.y] * tile_b[k][local_id.x];\"):!t.transA&&t.transB?(R=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[local_id.y][k] * tile_b[local_id.x][k];\"):!t.transA&&!t.transB&&(R=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[local_id.y][k] * tile_b[k][local_id.x];\");let H=t.alpha===1?\"\":\"value *= uniforms.alpha;\";return`\n  ${$.registerUniforms(P).declareVariables(...A)}\n  var<workgroup> tile_a: array<array<${v.type.storage}, ${l}>, ${l}>;\n  var<workgroup> tile_b: array<array<${S.type.storage}, ${l}>, ${l}>;\n  ${$.mainStart([l,l,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};\n    let num_tiles = (uniforms.K - 1) / ${l} + 1;\n    var k_start = 0u;\n    var value = ${C.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${R}\n      k_start = k_start + ${l};\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < ${l}; k++) {\n        ${D}\n      }\n      workgroupBarrier();\n    }\n\n    ${H}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${(()=>T!=null?`let cOffset = ${T.broadcastedIndicesToOffset(\"vec2(m, n)\",C)}; value += ${C.type.value}(uniforms.beta) * ${T.getByOffset(\"cOffset\")};`:\"\")()}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`};return u?{name:\"GemmShared\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:p*m},programUniforms:_}),getShaderSource:x}:{name:\"Gemm\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:_}),getShaderSource:g}},zd=e=>{let t=e.transA,r=e.transB,n=e.alpha,o=e.beta;return{transA:t,transB:r,alpha:n,beta:o,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},Od=(e,t)=>{Vf(e.inputs),e.compute(Wf(e.inputs,t))}});var lt,_t,Nt,Vt,Lf,Gf,Hf,Ff,qf,Kf,jf,Yf,Bd,Md,Rd=U(()=>{\"use strict\";J();ne();xe();ae();[lt,_t,Nt,Vt]=[0,1,2,3],Lf=e=>{if(e[0].dims.length!==4)throw new Error(\"only 4-D tensor is supported.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"input dimensions must be equal to grid dimensions\");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error(\"grid batch size must match input batch size\")},Gf=`\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n`,Hf=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,Ff=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${e.alignCorners===0?`\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    `:`\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    `}\n  }\n`,qf=e=>`\n  ${e.paddingMode===\"reflection\"?`\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }`:\"\"}\n`,Kf=(e,t,r)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${lt}] = batch;\n     indices[${_t}] = channel;`+(()=>{switch(r.paddingMode){case\"zeros\":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${Nt}] = u32(r);\n            indices[${Vt}] = u32(c);\n          }\n        `;case\"border\":return`\n          indices[${Nt}] = u32(clamp(r, 0, H - 1));\n          indices[${Vt}] = u32(clamp(c, 0, W - 1));\n        `;case\"reflection\":return`\n          indices[${Nt}] = gs_reflect(r, border[1], border[3]);\n          indices[${Vt}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${r.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices(\"indices\")};\n  }\n`,jf=(e,t,r)=>(()=>{switch(r.mode){case\"nearest\":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${lt}], indices[${_t}], border);\n        `;case\"bilinear\":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${lt}], indices[${_t}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case\"bicubic\":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${lt}], indices[${_t}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${r.mode} is not supported`)}})()+`${e.setByOffset(\"global_idx\",\"result\")}`,Yf=(e,t)=>{let r=E(\"x\",e[0].dataType,e[0].dims.length),n=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],o=E(\"grid\",e[1].dataType,n.length,2),i=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];t.format===\"NHWC\"&&(i=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[lt,_t,Nt,Vt]=[0,3,1,2]);let a=M(\"output\",e[0].dataType,i.length),d=r.type.value,l=k.size(i),p=[{type:12,data:l},...N(e[0].dims,n,i)],m=u=>`\n  ${u.registerUniform(\"output_size\",\"u32\").declareVariables(r,o,a)}\n  ${Gf}\n  ${Hf(d)}\n  ${Ff(t)}\n  ${qf(t)}\n  ${Kf(r,d,t)}\n\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let H_in = i32(uniforms.x_shape[${Nt}]);\n      let W_in = i32(uniforms.x_shape[${Vt}]);\n\n      ${t.alignCorners===0?`\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      `:`\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      `};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${a.offsetToIndices(\"global_idx\")};\n      var grid_indices = vec3<u32>(indices[${lt}], indices[${Nt}], indices[${Vt}]);\n      let nxy = ${o.getByIndices(\"grid_indices\")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${jf(a,d,t)}\n  }`;return{name:\"GridSample\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:[\"type\",\"type\"]},getRunData:u=>{let h=k.size(i);return{outputs:[{dims:i,dataType:u[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:p}},getShaderSource:m}},Bd=(e,t)=>{Lf(e.inputs),e.compute(Yf(e.inputs,t))},Md=e=>ee({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})});var Me,Xf,Nd,Ud,Jf,er,Vd,xo=U(()=>{\"use strict\";J();ne();xe();Ur();Hr();ae();dt();Me=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,Xf=(e,t)=>{let r=e[0],n=Me(e,1),o=Me(e,2),i=Me(e,3),a=Me(e,4),d=Me(e,5),l=Me(e,6),p=Me(e,7);if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let m=r.dims[0],u=r.dims[1],h=r.dims.length===3?r.dims[2]:t.numHeads*r.dims[4],_=u,y=0,g=0,x=Math.floor(h/t.numHeads);if(l&&p&&k.size(l.dims)&&k.size(p.dims)){if(l.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(l.dims[0]!==m||l.dims[1]!==t.numHeads||l.dims[3]!==x)throw new Error('Input \"past_key\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(p.dims[0]!==m||p.dims[1]!==t.numHeads||p.dims[3]!==x)throw new Error('Input \"past_value\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==p.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have same dim 2 (past_sequence_length)');if(p.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');y=l.dims[2],g=l.dims[2]}else if(l&&k.size(l.dims)||p&&k.size(p.dims))throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let $;if(n&&k.size(n.dims)>0){if(r.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(n.dims.length===3){if(n.dims[2]!==r.dims[2])throw new Error('Input \"query\" and \"key\" shall have same dim 2 (hidden_size)');$=2,_=n.dims[1]}else if(n.dims.length===5){if(n.dims[2]!==t.numHeads||n.dims[3]!==2||n.dims[4]!==x)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');$=5,_=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==x)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');$=0,_=n.dims[2]}}else{if(r.dims.length!==5)throw new Error('Input \"query\" is expected to have 5 dimensions when key is empty');if(r.dims[2]!==t.numHeads||r.dims[3]!==3)throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');$=3}if(i&&k.size(i.dims)>0){if(i.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimension');if(n&&n.dims.length===5&&n.dims[3]===2)throw new Error(\"bias is not allowed for packed kv.\")}let v=y+_,S=0;if(a&&k.size(a.dims)>0){S=8;let P=a.dims;throw P.length===1?P[0]===m?S=1:P[0]===3*m+2&&(S=3):P.length===2&&P[0]===m&&P[1]===v&&(S=5),S===8?new Error('Input \"key_padding_mask\" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error(\"Mask not supported\")}let T=!1,A=h;if(o&&k.size(o.dims)>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(r.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(_!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(_!==o.dims[2])throw new Error('Input \"key\" and \"value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],T=!0}}let C=!1;if(a&&k.size(a.dims)>0)throw new Error(\"Key padding mask is not supported\");if(d&&k.size(d.dims)>0){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" is expected to have 4 dimensions');if(d.dims[0]!==m||d.dims[1]!==t.numHeads||d.dims[2]!==u||d.dims[3]!==v)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:m,sequenceLength:u,pastSequenceLength:y,kvSequenceLength:_,totalSequenceLength:v,maxSequenceLength:g,inputHiddenSize:0,hiddenSize:h,vHiddenSize:A,headSize:x,vHeadSize:Math.floor(A/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:S,scale:t.scale,broadcastResPosBias:C,passPastInKv:T,qkvFormat:$}},Nd=e=>ee({...e}),Ud=ee({perm:[0,2,1,3]}),Jf=(e,t,r,n,o,i,a)=>{let d=[n,o,i],l=k.size(d),p=[{type:12,data:l},{type:12,data:a},{type:12,data:i}],m=u=>{let h=M(\"qkv_with_bias\",t.dataType,d),_=E(\"qkv\",t.dataType,d),y=E(\"bias\",r.dataType,d),g=[{name:\"output_size\",type:\"u32\"},{name:\"bias_offset\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"}];return`\n  ${u.registerUniforms(g).declareVariables(_,y,h)}\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:\"MultiHeadAttentionAddBias\",shaderCache:{inputDependencies:[\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:d,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p}),getShaderSource:m},{inputs:[t,r],outputs:[-1]})[0]},er=(e,t,r,n,o,i,a,d)=>{let l=i;if(a&&k.size(a.dims)>0){if(n===1)throw new Error(\"AddBiasReshape is not implemented. Please export your model with packed QKV or KV\");return l=Jf(e,i,a,t,n,r*o,d),l=l.reshape([t,n,r,o]),r===1||n===1?l:e.compute(Pe(l,Ud.perm),{inputs:[l],outputs:[-1]})[0]}else return i.dims.length===3&&(l=i.reshape([t,n,r,o])),r===1||n===1?l:e.compute(Pe(l,Ud.perm),{inputs:[l],outputs:[-1]})[0]},Vd=(e,t)=>{let r=Xf(e.inputs,t),n=e.inputs[0],o=Me(e.inputs,1),i=Me(e.inputs,2),a=Me(e.inputs,3),d=Me(e.inputs,4),l=Me(e.inputs,5),p=Me(e.inputs,6),m=Me(e.inputs,7);if(n.dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(o?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let u=o&&i&&o.dims.length===4&&i.dims.length===4,h=er(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,n,a,0);if(u)return Ut(e,h,o,i,d,void 0,p,m,l,r);if(!o||!i)throw new Error(\"key and value must be provided\");let _=er(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,o,a,r.hiddenSize),y=er(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,i,a,2*r.hiddenSize);Ut(e,h,_,y,d,void 0,p,m,l,r)}});var eh,th,rh,nh,So,Wd,Ld,To=U(()=>{\"use strict\";J();ne();xe();ae();eh=e=>{if(!e||e.length<1)throw new Error(\"too few inputs\")},th=(e,t)=>{let r=[],n=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),n=r.length),ee({numOutputs:n,axis:t.axis,splitSizes:r})},rh=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${q(\"uniforms.size_in_split_axis\",\"i\",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,nh=e=>{let t=e.length,r=[];for(let n=0;n<t;++n){let o=e[n].setByIndices(\"indices\",\"input[global_idx]\");t===1?r.push(o):n===0?r.push(`if (output_number == ${n}u) { ${o} }`):n===t-1?r.push(`else { ${o} }`):r.push(`else if (output_number == ${n}) { ${o} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},So=(e,t)=>{let r=e[0].dims,n=k.size(r),o=e[0].dataType,i=k.normalizeAxis(t.axis,r.length),a=new Array(t.numOutputs),d=E(\"input\",o,r.length),l=new Array(t.numOutputs),p=[],m=[],u=0,h=[{type:12,data:n}];for(let y=0;y<t.numOutputs;y++){u+=t.splitSizes[y],l[y]=u;let g=r.slice();g[i]=t.splitSizes[y],m.push(g),a[y]=M(`output${y}`,o,g.length),p.push({dims:m[y],dataType:e[0].dataType})}h.push({type:12,data:l},...N(r,...m));let _=y=>`\n  ${y.registerUniform(\"input_size\",\"u32\").registerUniform(\"size_in_split_axis\",\"u32\",l.length).declareVariables(d,...a)}\n  ${rh(l.length)}\n  ${nh(a)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.input_size\")}\n\n    var indices = ${d.offsetToIndices(\"global_idx\")};\n    var index = ${d.indicesGet(\"indices\",i)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${q(\"uniforms.size_in_split_axis\",\"output_number - 1u\",l.length)};\n      ${d.indicesSet(\"indices\",i,\"index\")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:\"Split\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\"]},getShaderSource:_,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(n/64)},programUniforms:h})}},Wd=(e,t)=>{eh(e.inputs);let r=e.inputs.length===1?t:th(e.inputs,t);e.compute(So(e.inputs,r),{inputs:[0]})},Ld=e=>{let t=e.axis,r=e.splitSizes,n=e.numOutputs<0?r.length:e.numOutputs;if(n!==r.length)throw new Error(\"numOutputs and splitSizes lengh must be equal\");return ee({axis:t,numOutputs:n,splitSizes:r})}});var oh,ih,Gd,Hd,Fd=U(()=>{\"use strict\";xe();Hr();xo();To();dt();oh=(e,t)=>{if(t.doRotary)throw new Error(\"GroupQuerryAttention do_rotary attribute is not supported\");if(t.doRotary&&e.length<=7)throw new Error(\"cos_cache and sin_cache inputs are required if do_rotary is specified\");let r=e[0],n=e[1],o=e[2],i=e[3],a=e[4];if(t.localWindowSize!==-1)throw new Error(\"Local attention is not supported\");if(t.softcap!==0)throw new Error(\"Softcap is not supported\");if(t.rotaryInterleaved!==0)throw new Error(\"Rotary interleaved is not supported\");if(t.smoothSoftmax)throw new Error(\"Smooth softmax is not supported\");if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let d=!1,l=r.dims[0],p=r.dims[1],m=r.dims.length===3?d?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],u=p,h=0,_=!n||n.dims.length===0,y=Math.floor(_?m/(t.numHeads+2*t.kvNumHeads):m/t.numHeads);_&&(m=y*t.numHeads);let g=i&&i.dims.length!==0,x=a&&a.dims.length!==0;if(g&&i.dims.length===4&&i.dims[0]===l&&i.dims[1]!==t.kvNumHeads&&i.dims[2]===t.kvNumHeads&&i.dims[3]===y)throw new Error(\"BSNH pastKey/pastValue is not supported\");if(g&&x){if(i.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(a.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');h=i.dims[2]}else if(g||x)throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let v=1;if(n&&n.dims.length>0){if(r.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(n.dims.length===3){if(r.dims[2]%n.dims[2]!==0)throw new Error('Dimension 2 of \"query\" should be a multiple of \"key\"');u=n.dims[1]}else if(n.dims.length===5){if(n.dims[2]!==t.numHeads||n.dims[3]!==2||n.dims[4]!==y)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');u=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==y)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');u=n.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');v=3}let S=0,T=!1,A=t.kvNumHeads?y*t.kvNumHeads:m;if(o&&o.dims.length>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(r.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(u!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(u!==o.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],T=!0}}let C=e.length>4?e[5]:void 0;if(C&&C.dims.length!==1&&C.dims[0]!==l)throw new Error('Input \"seqlens\" is expected to have 1 dimension and the same dim 0 as batch_size');let P=-1,D=-1,R=!1;return{batchSize:l,sequenceLength:p,pastSequenceLength:h,kvSequenceLength:u,totalSequenceLength:P,maxSequenceLength:D,inputHiddenSize:0,hiddenSize:m,vHiddenSize:A,headSize:y,vHeadSize:Math.floor(A/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:S,scale:t.scale,broadcastResPosBias:R,passPastInKv:T,qkvFormat:v}},ih=ee({perm:[0,2,1,3]}),Gd=(e,t,r)=>{let n=t,o=r.kvNumHeads;return t.dims.length===3&&r.kvSequenceLength!==0&&(n=t.reshape([r.batchSize,r.kvSequenceLength,o,r.headSize]),n=e.compute(Pe(n,ih.perm),{inputs:[n],outputs:[-1]})[0]),n},Hd=(e,t)=>{let r=oh(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(e.inputs[1]?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let n=e.inputs[0],o=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,i=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,a=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,d=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,p=e.inputs.length>5?e.inputs[6]:void 0,m=r.kvNumHeads?r.kvNumHeads:r.numHeads,u=ee({axis:2,numOutputs:3,splitSizes:[r.numHeads*r.headSize,m*r.headSize,m*r.headSize]}),[h,_,y]=!o&&!i?e.compute(So([n],u),{inputs:[n],outputs:[-1,-1,-1]}):[n,o,i],g=er(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,h,void 0,0);Ut(e,g,Gd(e,_,r),Gd(e,y,r),void 0,void 0,a,d,void 0,r,l,p)}});var qd,ah,sh,Kd,jd=U(()=>{\"use strict\";J();ne();dt();ae();qd=(e,t,r,n,o,i,a,d)=>{let l=me(i),p=l===1?\"f32\":`vec${l}f`,m=l===1?\"vec2f\":`mat2x${l}f`,u=o*a,h=64;u===1&&(h=256);let _=[o,a,i/l],y=[o,a,2],g=[\"rank\",\"type\",\"type\"],x=[];x.push(...N(_,y));let $=v=>{let S=E(\"x\",t.dataType,3,l),T=E(\"scale\",r.dataType,r.dims),A=E(\"bias\",n.dataType,n.dims),C=M(\"output\",1,3,2),P=[S,T,A,C];return`\n  var<workgroup> workgroup_shared : array<${m}, ${h}>;\n  const workgroup_size = ${h}u;\n  ${v.declareVariables(...P)}\n  ${v.mainStart(h)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${p}(0);\n    var squared_sum = ${p}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${p}(${S.get(\"batch\",\"channel\",\"h\")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${m}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${qe(\"workgroup_shared[0][0]\",l)} / f32(hight * ${l});\n      let squared_sum_final = ${qe(\"workgroup_shared[0][1]\",l)} / f32(hight * ${l});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${d}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`};return e.compute({name:\"InstanceNormComputeChannelScaleShift\",shaderCache:{hint:`${l};${d};${h}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:y,dataType:1}],dispatchGroup:{x:u},programUniforms:x}),getShaderSource:$},{inputs:[t,r,n],outputs:[-1]})[0]},ah=(e,t,r)=>{let n=t[0].dims,o=n,i=2,a=n[0],d=n[1],l=k.sizeFromDimension(n,i),p=me(l),m=k.size(o)/p,u=qd(e,t[0],t[1],t[2],a,l,d,r.epsilon),h=[a,d,l/p],_=[a,d],y=[\"type\",\"none\"],g=x=>{let $=E(\"x\",t[0].dataType,h.length,p),v=E(\"scale_shift\",1,_.length,2),S=M(\"output\",t[0].dataType,h.length,p),T=[$,v,S];return`\n  ${x.registerUniform(\"output_size\",\"u32\").declareVariables(...T)}\n  ${x.mainStart()}\n  ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let outputIndices = ${S.offsetToIndices(\"global_idx\")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${v.getByIndices(\"vec2<u32>(batch, channel)\")};\n      let value = ${$.getByOffset(\"global_idx\")} * ${S.type.value}(scale_shift.x) + ${S.type.value}(scale_shift.y);\n      ${S.setByOffset(\"global_idx\",\"value\")};\n  }`};e.compute({name:\"InstanceNormalization\",shaderCache:{hint:`${p}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...N(h,_,h)]}),getShaderSource:g},{inputs:[t[0],u]})},sh=(e,t,r)=>{let n=t[0].dims,o=n,i=n[0],a=n[n.length-1],d=k.sizeFromDimension(n,1)/a,l=me(a),p=k.size(o)/l,m=[{type:12,data:d},{type:12,data:Math.floor(a/l)}],u=[\"type\",\"type\"],h=!1,_=[0,n.length-1];for(let $=0;$<n.length-2;$++)h=h||n[$+1]!==1,_.push($+1);h=h&&n[n.length-1]!==1;let y=h?e.compute(Pe(e.inputs[0],_),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:n.length},($,v)=>n[_[v]])),g=qd(e,y,t[1],t[2],i,d,a,r.epsilon),x=$=>{let v=ye(t[0].dataType),S=l===1?\"vec2f\":`mat${l}x2f`,T=P=>{let D=P===0?\"x\":\"y\",R=l===1?\"f32\":`vec${l}f`;switch(l){case 1:return`${v}(${R}(scale.${D}))`;case 2:return`vec2<${v}>(${R}(scale[0].${D}, scale[1].${D}))`;case 4:return`vec4<${v}>(${R}(scale[0].${D}, scale[1].${D}, scale[2].${D}, scale[3].${D}))`;default:throw new Error(`Not supported compoents ${l}`)}},A=E(\"input\",t[0].dataType,t[0].dims,l),C=M(\"output\",t[0].dataType,o,l);return`\n  @group(0) @binding(0) var<storage, read> input : array<${A.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${S}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${C.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${$.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${T(0)}, ${T(1)});\n  }`};e.compute({name:\"InstanceNormalizationNHWC\",shaderCache:{hint:`${l}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:m}),getShaderSource:x},{inputs:[t[0],g]})},Kd=(e,t)=>{t.format===\"NHWC\"?sh(e,e.inputs,t):ah(e,e.inputs,t)}});var uh,dh,Yd,Zd=U(()=>{\"use strict\";J();ne();ae();uh=e=>{if(!e||e.length<2)throw new Error(\"layerNorm requires at least 2 inputs.\")},dh=(e,t,r)=>{let n=t.simplified,o=e[0].dims,i=e[1],a=!n&&e[2],d=o,l=k.normalizeAxis(t.axis,o.length),p=k.sizeToDimension(o,l),m=k.sizeFromDimension(o,l),u=k.size(i.dims),h=a?k.size(a.dims):0;if(u!==m||a&&h!==m)throw new Error(`Size of X.shape()[axis:] == ${m}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${u} and bias size of ${h}`);let _=[];for(let A=0;A<o.length;++A)A<l?_.push(o[A]):_.push(1);let y=me(m),g=[\"type\",\"type\"],x=[{type:12,data:p},{type:1,data:m},{type:12,data:Math.floor(m/y)},{type:1,data:t.epsilon}];a&&g.push(\"type\");let $=r>1,v=r>2,S=A=>{let C=ye(e[0].dataType),P=[E(\"x\",e[0].dataType,e[0].dims,y),E(\"scale\",i.dataType,i.dims,y)];a&&P.push(E(\"bias\",a.dataType,a.dims,y)),P.push(M(\"output\",e[0].dataType,d,y)),$&&P.push(M(\"mean_data_output\",1,_)),v&&P.push(M(\"inv_std_output\",1,_));let D=[{name:\"norm_count\",type:\"u32\"},{name:\"norm_size\",type:\"f32\"},{name:\"norm_size_vectorized\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}];return`\n  ${A.registerUniforms(D).declareVariables(...P)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.norm_count\")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${so(\"f32\",y)};\n    var mean_square_vector = ${so(\"f32\",y)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Pt(C,y,\"x[h + offset]\")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${qe(\"mean_vector\",y)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${qe(\"mean_square_vector\",y)} / uniforms.norm_size ${n?\"\":\"- mean * mean\"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Pt(C,y,\"x[j + offset]\")};\n      let f32scale = ${Pt(C,y,\"scale[j]\")};\n      output[j + offset] = ${P[0].type.value}((f32input ${n?\"\":\"- mean\"}) * inv_std_dev * f32scale\n        ${a?`+ ${Pt(C,y,\"bias[j]\")}`:\"\"}\n      );\n    }\n\n    ${$?\"mean_data_output[global_idx] = mean\":\"\"};\n    ${v?\"inv_std_output[global_idx] = inv_std_dev\":\"\"};\n  }`},T=[{dims:d,dataType:e[0].dataType}];return $&&T.push({dims:_,dataType:1}),v&&T.push({dims:_,dataType:1}),{name:\"LayerNormalization\",shaderCache:{hint:`${y};${r};${n}`,inputDependencies:g},getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(p/64)},programUniforms:x}),getShaderSource:S}},Yd=(e,t)=>{uh(e.inputs),e.compute(dh(e.inputs,t,e.outputCount))}});var lh,Qd,Xd=U(()=>{\"use strict\";ne();Zr();Qr();lh=e=>{if(!e||e.length!==2)throw new Error(\"MatMul requires 2 inputs.\");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error(\"shared dimension does not match.\")},Qd=e=>{lh(e.inputs);let t=tt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error(\"Can't use matmul on the given tensors\");let r=t[t.length-1],n=e.inputs[0].dims[e.inputs[0].dims.length-1];if(r<8&&n<8)e.compute(Yr(e.inputs,{activation:\"\"},t));else{let o=t[t.length-2],i=k.size(e.inputs[0].dims.slice(0,-2)),a=k.size(e.inputs[1].dims.slice(0,-2));if(i!==1&&o===1&&a===1){let d=e.inputs[0].reshape([1,i,n]),l=e.inputs[1].reshape([1,n,r]),p=[1,i,r],m=[d,l];e.compute(Jt(m,{activation:\"\"},t,p),{inputs:m})}else e.compute(Jt(e.inputs,{activation:\"\"},t))}}});var ch,ph,mh,Jd,el,tl=U(()=>{\"use strict\";J();ne();xe();ae();ch=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"MatMulNBits requires 3 or 4 inputs\");let r=e[0],n=r.dims.length;if(r.dims[n-1]!==t.k)throw new Error(\"The last dim of input shape does not match the k value\");let o=Math.floor((t.k+t.blockSize-1)/t.blockSize),i=t.blockSize/8*t.bits,a=e[1];if(!k.areEqual(a.dims,[t.n,o,i]))throw new Error(\"The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize\");let l=e[2].dims;if(k.size(l)!==t.n*o)throw new Error(\"scales input size error.\");if(e.length===4){let m=e[3].dims,u=t.bits>4?t.n*o:t.n*Math.floor((o+1)/2);if(k.size(m)!==u)throw new Error(\"zeroPoints input size error.\")}},ph=(e,t)=>{let r=e[0].dims,n=r.length,o=r[n-2],i=t.k,a=t.n,d=r.slice(0,n-2),l=k.size(d),m=e[1].dims[2]/4,u=e[0].dataType,h=me(t.k),_=me(m),y=me(a),g=d.concat([o,a]),x=o>1&&a/y%2===0?2:1,$=k.size(g)/y/x,v=64,S=[],T=[l,o,i/h],A=k.convertShape(e[1].dims).slice();A.splice(-1,1,m/_),S.push(...N(T)),S.push(...N(A)),S.push(...N(e[2].dims)),e.length===4&&S.push(...N(k.convertShape(e[3].dims)));let C=[l,o,a/y];S.push(...N(C));let P=D=>{let R=T.length,H=E(\"a\",e[0].dataType,R,h),L=E(\"b\",12,A.length,_),re=E(\"scales\",e[2].dataType,e[2].dims.length),V=[H,L,re],K=e.length===4?E(\"zero_points\",12,e[3].dims.length):void 0;K&&V.push(K);let we=C.length,j=M(\"output\",e[0].dataType,we,y),Q=ye(e[0].dataType),ie=(()=>{switch(h){case 1:return`array<${Q}, 8>`;case 2:return`mat4x2<${Q}>`;case 4:return`mat2x4<${Q}>`;default:throw new Error(`${h}-component is not supported.`)}})(),te=()=>{let ve=`\n          // reuse a data\n            var input_offset = ${H.indicesToOffset(`${H.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${ie};\n            for (var j: u32 = 0; j < ${8/h}; j++) {\n              a_data[j] = ${H.getByOffset(\"input_offset\")};\n              input_offset++;\n            }\n          `;for(let de=0;de<y*x;de++)ve+=`\n            b_value = ${_===1?`b${de}_data`:`b${de}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${ie}(${Array.from({length:4},(W,Y)=>`${Q}(b_value_lower[${Y}]), ${Q}(b_value_upper[${Y}])`).join(\", \")});\n            b_dequantized_values = ${(()=>h===1?`${ie}(${Array.from({length:8},(W,Y)=>`(b_quantized_values[${Y}] - ${K?`zero_point${de}`:\"zero_point\"}) * scale${de}`).join(\", \")});`:`(b_quantized_values - ${ie}(${Array(8).fill(`${K?`zero_point${de}`:\"zero_point\"}`).join(\",\")})) * scale${de};`)()};\n            workgroup_shared[local_id.x * ${x} + ${Math.floor(de/y)}]${y>1?`[${de%y}]`:\"\"} += ${Array.from({length:8/h},(W,Y)=>`${h===1?`a_data[${Y}] * b_dequantized_values[${Y}]`:`dot(a_data[${Y}], b_dequantized_values[${Y}])`}`).join(\" + \")};\n          `;return ve},be=()=>{let ve=`\n            var col_index = col * ${y};\n            ${K?`\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${Q}(8);`}\n            `;for(let de=0;de<y*x;de++)ve+=`\n            let scale${de} = ${re.getByOffset(\"col_index * nBlocksPerCol + block\")};\n            ${K?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${K.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point${de} = ${Q}((zero_point_word) & 0xFu);`:\"\"}\n            col_index += 1;`;return ve},Oe=()=>{let ve=`col_index = col * ${y};`;for(let de=0;de<y*x;de++)ve+=`\n            let b${de}_data = ${L.getByIndices(`${L.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return ve+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${ie};\n            var b_dequantized_values: ${ie};`,ve};return`\n        var<workgroup> workgroup_shared: array<${j.type.value}, ${x*v}>;\n        ${D.declareVariables(...V,j)}\n        ${D.mainStart([v,1,1])}\n          let output_indices = ${j.offsetToIndices(`(global_idx / ${v}) * ${x}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += ${v}) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/h};\n            ${be()}\n            for (var word: u32 = 0; word < ${m}; word += ${_}) {\n              ${Oe()}\n              for (var i: u32 = 0; i < ${_}; i++) {\n                ${te()}\n                word_offset += ${8/h};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${x}) {\n            var output_value: ${j.type.value} = ${j.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < ${v}u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${x};\n            }\n            ${j.setByIndices(`${j.type.indices}(batch, row, col + local_id.x)`,\"output_value\")};\n          }\n        }`};return{name:\"MatMulNBits\",shaderCache:{hint:`${t.blockSize};${t.bits};${h};${_};${y};${x};${v}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:g,dataType:u}],dispatchGroup:{x:$},programUniforms:S}),getShaderSource:P}},mh=(e,t)=>{let r=e[0].dims,n=r.length,o=r[n-2],i=t.k,a=t.n,d=r.slice(0,n-2),l=k.size(d),m=e[1].dims[2]/4,u=e[0].dataType,h=me(t.k),_=me(m),y=d.concat([o,a]),g=128,x=a%8===0?8:a%4===0?4:1,$=g/x,v=$*_*8,S=v/h,T=v/t.blockSize,A=k.size(y)/x,C=[],P=[l,o,i/h],D=k.convertShape(e[1].dims).slice();D.splice(-1,1,m/_),C.push(...N(P)),C.push(...N(D)),C.push(...N(e[2].dims)),e.length===4&&C.push(...N(k.convertShape(e[3].dims)));let R=[l,o,a];C.push(...N(R));let H=L=>{let re=P.length,V=E(\"a\",e[0].dataType,re,h),K=E(\"b\",12,D.length,_),we=E(\"scales\",e[2].dataType,e[2].dims.length),j=[V,K,we],Q=e.length===4?E(\"zero_points\",12,e[3].dims.length):void 0;Q&&j.push(Q);let ie=R.length,te=M(\"output\",e[0].dataType,ie),be=ye(e[0].dataType),Oe=()=>{switch(h){case 1:return`\n          let a_data0 = vec4<${be}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${be}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${be}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${be}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${h}-component is not supported.`)}};return`\n        var<workgroup> sub_a: array<${V.type.value}, ${S}>;\n        var<workgroup> inter_results: array<array<${te.type.value}, ${$}>, ${x}>;\n        ${L.declareVariables(...j,te)}\n        ${L.mainStart([$,x,1])}\n          let output_indices = ${te.offsetToIndices(`workgroup_index * ${x}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${T} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${S};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${S}; a_offset += ${g})\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${V.getByIndices(`${V.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${V.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${T} + local_id.x;\n            ${Q?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${Q.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point = ${be}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${be}(8);`}\n            let scale = ${we.getByOffset(\"b_row * n_blocks_per_col + block\")};\n            let b_data = ${K.getByIndices(`${K.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/h};\n            for (var i: u32 = 0; i < ${_}; i++) {\n              ${Oe()}\n              let b_value = ${_===1?\"b_data\":\"b_data[i]\"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${be}>(${Array.from({length:4},(ve,de)=>`${be}(b_value_lower[${de}]), ${be}(b_value_upper[${de}])`).join(\", \")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${be}>(${Array(8).fill(\"zero_point\").join(\",\")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(ve,de)=>`${`dot(a_data${de}, b_dequantized_values[${de}])`}`).join(\" + \")};\n              word_offset += ${8/h};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${x}) {\n            var output_value: ${te.type.value} = ${te.type.value}(0);\n            for (var b = 0u; b < ${$}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${te.setByIndices(`${te.type.indices}(batch, row, col + local_idx)`,\"output_value\")}\n            }\n          }\n        }`};return{name:\"BlockwiseMatMulNBits32\",shaderCache:{hint:`${t.blockSize};${h};${_};${$};${x}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:y,dataType:u}],dispatchGroup:{x:A},programUniforms:C}),getShaderSource:H}},Jd=(e,t)=>{ch(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor(\"intel\")&&e.adapterInfo.isArchitecture(\"gen-12lp\")?e.compute(mh(e.inputs,t)):e.compute(ph(e.inputs,t))},el=e=>ee(e)});var fh,hh,gh,bh,yh,_h,wh,vh,rl,nl=U(()=>{\"use strict\";J();ne();ae();fh=e=>{if(!e||e.length<1)throw new Error(\"Too few inputs\");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error(\"Input type must be float or float16.\");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error(\"The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].\")}},hh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n            k = i32(${e.indicesGet(\"indices\",o)}) - ${q(\"uniforms.pads\",o,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${q(\"uniforms.x_shape\",o,t)})) {\n              break;\n            }\n            offset += k * i32(${q(\"uniforms.x_strides\",o,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${n}\n            value = x[offset];\n          }\n      `},gh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${q(\"uniforms.pads\",o,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${q(\"uniforms.x_shape\",o,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${q(\"uniforms.x_shape\",o,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${q(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},bh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${q(\"uniforms.pads\",o,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${q(\"uniforms.x_shape\",o,t)})) {\n                  k = i32(${q(\"uniforms.x_shape\",o,t)}) - 1;\n                }\n                offset += k * i32(${q(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},yh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${q(\"uniforms.pads\",o,r)};\n                if (k < 0)  {\n                  k += i32(${q(\"uniforms.x_shape\",o,t)}]);\n                }\n                if (k >= i32(${q(\"uniforms.x_shape\",o,t)})) {\n                  k -= i32(${q(\"uniforms.x_shape\",o,t)});\n                }\n                offset += k * i32(${q(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},_h=(e,t,r)=>{switch(r.mode){case 0:return hh(e,t,r.pads.length);case 1:return gh(e,t,r.pads.length);case 2:return bh(e,t,r.pads.length);case 3:return yh(e,t,r.pads.length);default:throw new Error(\"Invalid mode\")}},wh=(e,t)=>{let r=k.padShape(e[0].dims.slice(),t.pads),n=e[0].dims,o=k.size(r),i=[{type:12,data:o},{type:6,data:t.pads}],a=e.length>=3&&e[2].data;t.mode===0&&i.push({type:a?e[2].dataType:1,data:t.value}),i.push(...N(e[0].dims,r));let d=[\"rank\"],l=p=>{let m=M(\"output\",e[0].dataType,r.length),u=E(\"x\",e[0].dataType,n.length),h=u.type.value,_=_h(m,n.length,t),y=[{name:\"output_size\",type:\"u32\"},{name:\"pads\",type:\"i32\",length:t.pads.length}];return t.mode===0&&y.push({name:\"constant_value\",type:a?h:\"f32\"}),`\n            ${p.registerUniforms(y).declareVariables(u,m)}\n            ${p.mainStart()}\n            ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n            let indices = ${m.offsetToIndices(\"global_idx\")};\n\n            var value = ${h}(0);\n            ${_}\n            output[global_idx] = value;\n        }`};return{name:\"Pad\",shaderCache:{hint:`${t.mode}${a}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(r)/64)},programUniforms:i}),getShaderSource:l}},vh=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),n=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,o=e[0].dims.length,i=new Int32Array(2*o).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let l=0;l<d.length;l++)i[Number(d[l])]=Number(r[l]),i[Number(d[l])+o]=Number(r[l+d.length])}else r.forEach((d,l)=>i[Number(l)]=Number(d));let a=[];return i.forEach(d=>a.push(d)),{mode:t.mode,value:n,pads:a}}else return t},rl=(e,t)=>{fh(e.inputs);let r=vh(e.inputs,t);e.compute(wh(e.inputs,r),{inputs:[0]})}});var en,ol,il,al,sl,$h,xh,ul,dl,ll,cl,pl,ml,fl,hl,gl,bl,yl,_l,wl=U(()=>{\"use strict\";Le();J();ne();ae();en=e=>{if(_e.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error(\"Pool ops requires 1 input.\")},ol=(e,t,r)=>{let n=t.format===\"NHWC\",o=e.dims.slice();n&&o.splice(1,0,o.pop());let i=Object.hasOwnProperty.call(t,\"dilations\"),a=t.kernelShape.slice(),d=t.strides.slice(),l=i?t.dilations.slice():[],p=t.pads.slice();kt.adjustPoolAttributes(r,o,a,d,l,p);let m=kt.computePoolOutputShape(r,o,d,l,a,p,t.autoPad),u=Object.assign({},t);i?Object.assign(u,{kernelShape:a,strides:d,pads:p,dilations:l,cacheKey:t.cacheKey}):Object.assign(u,{kernelShape:a,strides:d,pads:p,cacheKey:t.cacheKey});let h=m.slice();return h.push(h.splice(1,1)[0]),[u,n?h:m]},il=(e,t)=>{let r=t.format===\"NHWC\",n=k.size(e),o=k.size(t.kernelShape),i=[{type:12,data:n},{type:12,data:o}],a=[{name:\"outputSize\",type:\"u32\"},{name:\"kernelSize\",type:\"u32\"}];if(t.kernelShape.length<=2){let d=t.kernelShape[t.kernelShape.length-1],l=t.strides[t.strides.length-1],p=t.pads[t.pads.length/2-1],m=t.pads[t.pads.length-1],u=!!(p+m);i.push({type:12,data:d},{type:12,data:l},{type:12,data:p},{type:12,data:m}),a.push({name:\"kw\",type:\"u32\"},{name:\"sw\",type:\"u32\"},{name:\"pwStart\",type:\"u32\"},{name:\"pwEnd\",type:\"u32\"});let h=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],y=t.strides[t.strides.length-2],g=t.pads[t.pads.length/2-2],x=t.pads[t.pads.length-2];h=!!(g+x),i.push({type:12,data:_},{type:12,data:y},{type:12,data:g},{type:12,data:x}),a.push({name:\"kh\",type:\"u32\"},{name:\"sh\",type:\"u32\"},{name:\"phStart\",type:\"u32\"},{name:\"phEnd\",type:\"u32\"})}return[i,a,!0,u,h]}else{if(r)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let d=k.computeStrides(t.kernelShape);i.push({type:12,data:d},{type:12,data:t.pads},{type:12,data:t.strides}),a.push({name:\"kernelStrides\",type:\"u32\",length:d.length},{name:\"pads\",type:\"u32\",length:t.pads.length},{name:\"strides\",type:\"u32\",length:t.strides.length});let l=t.pads.reduce((p,m)=>p+m);return[i,a,!!l,!1,!1]}},al=(e,t,r,n,o,i,a,d,l,p,m,u)=>{let h=o.format===\"NHWC\",_=t.type.value,y=M(\"output\",t.type.tensor,n);if(o.kernelShape.length<=2){let g=\"\",x=\"\",$=\"\",v=r-(h?2:1);if(m?g=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${v}] < 0 || xIndices[${v}]\n                      >= uniforms.x_shape[${v}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${i}\n                }`:g=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${i}\n                }`,o.kernelShape.length===2){let T=r-(h?3:2);u?x=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${T}] < 0 || xIndices[${T}] >= uniforms.x_shape[${T}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:x=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;\n                `,$=`\n              }\n            `}return`\n            ${e.registerUniforms(l).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n              let indices = ${y.offsetToIndices(\"global_idx\")};\n              var xIndices = ${y.offsetToIndices(\"global_idx\")};\n\n              var value = ${_}(${d});\n              var pad = 0;\n              ${x}\n              ${g}\n              ${$}\n              ${a}\n\n              output[global_idx] = value;\n            }`}else{if(h)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let g=o.kernelShape.length,x=o.pads.length,$=\"\";return p?$=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                ${i}\n              }`:$=`\n              }\n              let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n              ${i}\n            `,`\n            ${e.registerUniforms(l).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n              let indices = ${y.offsetToIndices(\"global_idx\")};\n              var xIndices = ${y.offsetToIndices(\"global_idx\")};\n\n              var offsets: array<u32, ${g}>;\n\n              var value = ${_}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${g-1}u; j++) {\n                  offsets[j] = offset / ${q(\"uniforms.kernelStrides\",\"j\",g)};\n                  offset -= offsets[j] * ${q(\"uniforms.kernelStrides\",\"j\",g)};\n                }\n                offsets[${g-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-g}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${q(\"uniforms.strides\",`j - ${r-g}u`,g)}\n                    + offsets[j - ${r-g}u] - ${q(\"uniforms.pads\",\"j - 2u\",x)};\n                  ${$}\n              }\n              ${a}\n\n              output[global_idx] = value;\n            }`}},sl=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,$h=e=>`${sl(e)};${e.countIncludePad}`,xh=e=>`${sl(e)};${e.storageOrder};${e.dilations}`,ul=e=>({format:e.format,autoPad:[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),dl=(e,t,r,n)=>{let[o,i]=ol(t,n,r),a=E(\"x\",t.dataType,t.dims.length),d=a.type.value,l=\"value += x_val;\",p=\"\";o.countIncludePad?p+=`value /= ${d}(uniforms.kernelSize);`:p+=`value /= ${d}(i32(uniforms.kernelSize) - pad);`;let[m,u,h,_,y]=il(i,o);m.push(...N(t.dims,i));let g=[\"rank\"];return{name:e,shaderCache:{hint:`${n.cacheKey};${h};${_};${y}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(i)/64)},programUniforms:m}),getShaderSource:x=>al(x,a,t.dims.length,i.length,o,l,p,0,u,h,_,y)}},ll=e=>{let t=e.count_include_pad!==0,r=ul(e);if(r.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");let n={countIncludePad:t,...r,cacheKey:\"\"};return{...n,cacheKey:$h(n)}},cl=(e,t)=>{en(e.inputs),e.compute(dl(\"AveragePool\",e.inputs[0],!1,t))},pl={autoPad:\"\",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},ml=e=>{let t=e.format;return{format:t,...pl,cacheKey:t}},fl=(e,t)=>{en(e.inputs),e.compute(dl(\"GlobalAveragePool\",e.inputs[0],!0,t))},hl=(e,t,r,n)=>{let[o,i]=ol(t,n,r),a=`\n      value = max(x_val, value);\n    `,d=\"\",l=E(\"x\",t.dataType,t.dims.length),p=[\"rank\"],[m,u,h,_,y]=il(i,o);return m.push(...N(t.dims,i)),{name:e,shaderCache:{hint:`${n.cacheKey};${h};${_};${y}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(i)/64)},programUniforms:m}),getShaderSource:g=>al(g,l,t.dims.length,i.length,o,a,d,t.dataType===10?-65504:-1e5,u,h,_,y)}},gl=(e,t)=>{en(e.inputs),e.compute(hl(\"MaxPool\",e.inputs[0],!1,t))},bl=e=>{let t=e.storage_order,r=e.dilations,n=ul(e);if(t!==0)throw new Error(\"column major storage order is not yet supported for MaxPool\");if(n.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");let o={storageOrder:t,dilations:r,...n,cacheKey:\"\"};return{...o,cacheKey:xh(o)}},yl=e=>{let t=e.format;return{format:t,...pl,cacheKey:t}},_l=(e,t)=>{en(e.inputs),e.compute(hl(\"GlobalMaxPool\",e.inputs[0],!0,t))}});var Th,Ih,vl,$l,xl=U(()=>{\"use strict\";J();ne();xe();ae();Th=(e,t)=>{if(e.length<2||e.length>3)throw new Error(\"DequantizeLinear requires 2 or 3 inputs.\");if(e.length===3&&e[1].dims===e[2].dims)throw new Error(\"x-scale and x-zero-point must have the same shape.\");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[0].dataType===6&&e.length>2)throw new Error(\"In the case of dequantizing int32 there is no zero point.\");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error(\"scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.\");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[1].dims.length!==e[2].dims.length)throw new Error(\"scale and zero-point inputs must have the same rank.\");if(!e[1].dims.map((r,n)=>r===e[2].dims[n]).reduce((r,n)=>r&&n,!0))throw new Error(\"scale and zero-point inputs must have the same shape.\")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error(\"blockSize must be set only for block quantization.\");if(!e[1].dims.map((o,i)=>i===t.axis||o===e[0].dims[i]).reduce((o,i)=>o&&i,!0))throw new Error(\"For block qunatization, scale input shape to match the input shape except for the axis\");if(e[1].dims.length!==e[0].dims.length)throw new Error(\"For block qunatization the scale input rank must be the same as the x rank.\");let r=e[0].dims[t.axis],n=e[1].dims[t.axis];if(t.blockSize<Math.ceil(r/n)||t.blockSize>Math.ceil(r/(n-1)-1))throw new Error(\"blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].\")}},Ih=(e,t)=>{let r=k.normalizeAxis(t.axis,e[0].dims.length),n=e[0].dataType,o=n===3,i=e[0].dims,a=e[1].dataType,d=k.size(i),l=n===3||n===2,p=l?[Math.ceil(k.size(e[0].dims)/4)]:e[0].dims,m=e[1].dims,u=e.length>2?e[2]:void 0,h=u?l?[Math.ceil(k.size(u.dims)/4)]:u.dims:void 0,_=m.length===0||m.length===1&&m[0]===1,y=_===!1&&m.length===1,g=me(d),x=_&&(!l||g===4),$=x?g:1,v=x&&!l?g:1,S=E(\"input\",l?12:n,p.length,v),T=E(\"scale\",a,m.length),A=u?E(\"zero_point\",l?12:n,h.length):void 0,C=M(\"output\",a,i.length,$),P=[S,T];A&&P.push(A);let D=[p,m];u&&D.push(h);let R=[{type:12,data:d/$},{type:12,data:r},{type:12,data:t.blockSize},...N(...D,i)],H=L=>{let re=[{name:\"output_size\",type:\"u32\"},{name:\"axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n      ${L.registerUniforms(re).declareVariables(...P,C)}\n      ${L.mainStart()}\n          ${L.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let output_indices = ${C.offsetToIndices(\"global_idx\")};\n\n          // Set input x\n          ${(()=>l?`\n            let input = ${S.getByOffset(\"global_idx / 4\")};\n            let x_vec = ${o?\"unpack4xI8(input)\":\"unpack4xU8(input)\"};\n            let x_value = ${$===1?\"x_vec[global_idx % 4]\":\"x_vec\"};`:`let x_value = ${S.getByOffset(\"global_idx\")};`)()};\n\n          // Set scale input\n          ${(()=>_?`let scale_value= ${T.getByOffset(\"0\")}`:y?`\n            let scale_index = ${C.indicesGet(\"output_indices\",\"uniforms.axis\")};\n            let scale_value= ${T.getByOffset(\"scale_index\")};`:`\n            var scale_indices: ${T.type.indices} = output_indices;\n            let index = ${T.indicesGet(\"scale_indices\",\"uniforms.axis\")} / uniforms.block_size;\n            ${T.indicesSet(\"scale_indices\",\"uniforms.axis\",\"index\")};\n            let scale_value= ${T.getByIndices(\"scale_indices\")};`)()};\n\n          // Set zero-point input\n          ${(()=>A?_?l?`\n                let zero_point_input = ${A.getByOffset(\"0\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${A.getByOffset(\"0\")}`:y?l?`\n                let zero_point_index = ${C.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_index / 4\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${C.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_value = ${A.getByOffset(\"zero_point_index\")};`:l?`\n                let zero_point_offset = ${T.indicesToOffset(\"scale_indices\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_offset / 4\")};\n                let zero_point_vec = ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${A.getByIndices(\"scale_indices\")};`:`let zero_point_value = ${l?o?\"i32\":\"u32\":S.type.value}(0);`)()};\n      // Compute and write output\n      ${C.setByOffset(\"global_idx\",`${C.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`};return{name:\"DequantizeLinear\",shaderCache:{hint:t.cacheKey,inputDependencies:A?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getShaderSource:H,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:Math.ceil(d/$/64),y:1,z:1},programUniforms:R})}},vl=(e,t)=>{Th(e.inputs,t),e.compute(Ih(e.inputs,t))},$l=e=>ee({axis:e.axis,blockSize:e.blockSize})});var Ch,Ah,Sl,Tl=U(()=>{\"use strict\";Le();J();ae();Ch=(e,t,r)=>{let n=e===t,o=e<t&&r<0,i=e>t&&r>0;if(n||o||i)throw new Error(\"Range these inputs' contents are invalid.\")},Ah=(e,t,r,n)=>{let o=Math.abs(Math.ceil((t-e)/r)),i=[o],a=o,d=[{type:12,data:a},{type:n,data:e},{type:n,data:r},...N(i)],l=p=>{let m=M(\"output\",n,i.length),u=m.type.value,h=[{name:\"outputSize\",type:\"u32\"},{name:\"start\",type:u},{name:\"delta\",type:u}];return`\n        ${p.registerUniforms(h).declareVariables(m)}\n        ${p.mainStart()}\n        ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        output[global_idx] = uniforms.start + ${u}(global_idx) * uniforms.delta;\n      }`};return{name:\"Range\",shaderCache:{hint:`${n}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:i,dataType:n}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:d})}},Sl=e=>{let t=0,r=0,n=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],n=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],n=e.inputs[2].getFloat32Array()[0]),_e.webgpu.validateInputContent&&Ch(t,r,n),e.compute(Ah(t,r,n,e.inputs[0].dataType),{inputs:[]})}});var kh,Eh,Il,Cl,Al=U(()=>{\"use strict\";J();ne();xe();ae();kh=(e,t,r,n)=>{if(e!==\"none\"&&n!==\"i32\"&&n!==\"u32\"&&n!==\"f32\")throw new Error(`Input ${n} is not supported with reduction ${e}.`);let o=`{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =`,i=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case\"none\":return`${t}=${r};`;case\"add\":return n===\"i32\"||n===\"u32\"?`atomicAdd(&${t}, bitcast<${n}>(${r}));`:`\n              ${o}bitcast<${n}>(oldValue) + (${r})${i}`;case\"max\":return n===\"i32\"||n===\"u32\"?`atomicMax(&${t}, bitcast<${n}>(${r}));`:`\n                ${o}max(bitcast<f32>(oldValue), (${r}))${i}`;case\"min\":return n===\"i32\"||n===\"u32\"?`atomicMin(&${t}, bitcast<${n}>(${r}));`:`${o}min(bitcast<${n}>(oldValue), (${r}))${i}`;case\"mul\":return`${o}(bitcast<${n}>(oldValue) * (${r}))${i}`;default:throw new Error(`Reduction ${e} is not supported.`)}},Eh=(e,t)=>{let r=e[0].dims,n=e[1].dims,o=r,i=1,a=Math.ceil(k.size(n)/i),d=n[n.length-1],l=k.sizeFromDimension(r,d),p=[{type:12,data:a},{type:12,data:d},{type:12,data:l},...N(e[1].dims,e[2].dims,o)],m=u=>{let h=E(\"indices\",e[1].dataType,e[1].dims.length),_=E(\"updates\",e[2].dataType,e[2].dims.length,i),y=t.reduction!==\"none\"&&t.reduction!==\"\"?ts(\"output\",e[0].dataType,o.length):M(\"output\",e[0].dataType,o.length,i);return`\n      ${u.registerUniform(\"output_size\",\"u32\").registerUniform(\"last_index_dimension\",\"u32\").registerUniform(\"num_updates_elements\",\"u32\").declareVariables(h,_,y)}\n      ${u.mainStart()}\n        ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n  var data_offset = 0u;\n  let indices_start = uniforms.last_index_dimension * global_idx;\n  let indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${e[0].dims.length===1?`\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;`:`\n    let element_count_dim = uniforms.output_strides[i - indices_start];\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}\n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));\n  }\n\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\n    ${kh(t.reduction,\"output[data_offset + i]\",\"value\",y.type.value)}\n  }\n\n      }`};return{name:\"ScatterND\",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:m}},Il=e=>ee({reduction:e.reduction}),Cl=(e,t)=>{e.compute(Eh(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}});var Ph,zh,Oh,kl,Dh,Bh,Mh,Rh,Uh,Nh,Vh,Wh,El,Lh,Gh,Hh,Fh,qh,Pl,zl,Ol=U(()=>{\"use strict\";J();ne();xe();ae();Ph=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error(\"Resize requires scales input values to be positive\")})),e.length>0){if(t.mode===\"linear\"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode===\"cubic\"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error(\"Resize requires scales input size to be 2 or 4 for cubic mode\")}},zh=(e,t,r)=>{t.every(o=>o>=0&&o<r||(()=>{throw new Error(\"Resize requires axes input values to be positive and less than rank\")}));let n=new Array(r).fill(1);return t.forEach((o,i)=>n[o]=e[i]),n},Oh=(e,t,r,n,o,i)=>{let[a,d,l]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach(m=>i.push(m));else if(t.coordinateTransformMode===\"tf_crop_and_resize\")throw new Error(\"Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize\");if(d>0&&e.length>d&&e[d].dims.length===1&&e[d].dims[0]>0){if(e[d].getFloat32Array().forEach(m=>n.push(m)),n.length!==0&&n.length!==p&&r>=18&&n.length!==t.axes.length)throw new Error(\"Resize requires scales input size to be same as input rank or axes size for opset 18 and up\");Ph(n,t),t.axes.length>0&&zh(n,t.axes,p).forEach((m,u)=>n[u]=m)}if(l>0&&e.length>l&&e[l].dims.length===1&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach(m=>o.push(Number(m))),o.length!==0&&o.length!==p&&r>=18&&o.length!==t.axes.length))throw new Error(\"Resize requires sizes input size to be same as input rank or axes size for opset 18 and up\");if(t.axes.length>0){if(n.length!==0&&n.length!==t.axes.length)throw new Error('Resize requires \"scales\" input size to be of axes rank when axes attributes is specified');if(o.length!==0&&o.length!==t.axes.length)throw new Error('Resize requires \"sizes\" input size to be of rank axes rank when axes attributes is specified')}if(typeof n<\"u\"&&typeof o<\"u\"&&n.length>0&&o.length>p)throw new Error(\"Resize requires only of scales or sizes to be specified\")},kl=(e,t,r,n)=>`\n  // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n  // offset-by-one error later in floor().\n  let big = (${e}) * (${t});\n  let whole = ${n}(big / (${r}));\n  let fract = ${n}(big % (${r})) / ${n}(${r});\n  return whole + fract;\n`,Dh=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case\"asymmetric\":return`\n          if (xScale < 1.0 || floor(xScale) != xScale) {\n            return ${t}(xResized) / ${t}(xScale);\n          } else {\n            ${kl(\"xResized\",\"lengthOriginal\",\"lengthResized\",t)}\n          }\n        `;case\"pytorch_half_pixel\":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case\"tf_half_pixel_for_nn\":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case\"align_corners\":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    ${kl(\"xResized\",\"lengthOriginal - 1\",\"lengthResized - 1\",t)}\n                  }`;case\"tf_crop_and_resize\":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case\"half_pixel_symmetric\":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case\"half_pixel\":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+\"}\",Bh=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case\"round_prefer_ceil\":return\"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }\";case\"floor\":return\"return floor(xOriginal);\";case\"ceil\":return\"return ceil(xOriginal);\";case\"round_prefer_floor\":return\"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }\";case\"simple\":default:if(t<11)return\"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }\";throw new Error(`Nearest mode ${e} is not supported`)}})()+\"}\",Mh=(e,t,r)=>{let n=new Array(r).fill(0).concat(new Array(r).fill(1)),o=e.length===0?n:e.slice();return t.length>0?(t.forEach((i,a)=>{n[i]=o[a],n[a+r]=o[t.length+a]}),n):o},Rh=(e,t,r,n)=>{let o=[];if(r.length>0)if(n.length>0){if(e.forEach(i=>o.push(i)),Math.max(...n)>e.length)throw new Error(\"axes is out of bound\");n.forEach((i,a)=>o[i]=r[a])}else r.forEach(i=>o.push(i));else{if(t.length===0)throw new Error(\"Resize requires either scales or sizes.\");o=e.map((i,a)=>Math.round(i*t[a]))}return o},Uh=(e,t,r)=>{let n=(()=>{switch(r.keepAspectRatioPolicy){case\"not_larger\":return r.axes.length>0?Math.min(...r.axes.map(i=>t[i]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case\"not_smaller\":return r.axes.length>0?Math.max(...r.axes.map(i=>t[i]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let o=e.slice();return r.axes.length>0?(r.axes.forEach(i=>t[i]=n),r.axes.forEach(i=>o[i]=Math.round(e[i]*t[i]))):(t.fill(n,0,t.length),o.forEach((i,a)=>o[a]=Math.round(i*t[a]))),o},Nh=(e,t,r,n,o)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet(\"output_indices\",\"i\")};\n        var scale = ${q(\"uniforms.scales\",\"i\",n)};\n        var roi_low = ${q(\"uniforms.roi\",\"i\",o)};\n        var roi_hi = ${q(\"uniforms.roi\",`i + ${t.length}`,o)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${q(\"uniforms.input_shape\",\"i\",t.length)};\n          var output_shape_i = ${q(\"uniforms.output_shape\",\"i\",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Vh=(e,t,r,n,o,i,a)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n        var input_index: u32;\n        var scale = ${q(\"uniforms.scales\",\"i\",o)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${q(\"uniforms.roi\",\"i\",i)};\n          var roi_hi = ${q(\"uniforms.roi\",`i + ${r.length}`,i)};\n          var input_shape_i = ${q(\"uniforms.input_shape\",\"i\",r.length)};\n          var output_shape_i = ${q(\"uniforms.output_shape\",\"i\",n.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")}\n      }\n      return input_indices;\n    }`,Wh=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet(\"input_indices\",\"i\")};\n        if (input_index < 0 || input_index >= ${q(\"uniforms.input_shape\",\"i\",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,El=(e,t,r,n)=>e.rank>n?`\n    ${e.indicesSet(\"input_indices\",t,\"channel\")};\n    ${e.indicesSet(\"input_indices\",r,\"batch\")};\n`:\"\",Lh=(e,t,r,n,o)=>{let[a,d,l,p]=r.length===2?[-1,0,1,-1]:[0,2,3,1],m=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${m} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(row, ${r[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(col, ${r[l]} - 1))`)};\n      ${El(e,p,a,2)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${m} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${m} = originalIndices[${d}];\n      var col:${m} = originalIndices[${l}];\n      ${n?`if (row < 0 || row > (${r[d]} - 1) || col < 0 || col > (${r[l]} - 1)) {\n        return ${o};\n      }`:\"\"};\n      row = max(0, min(row, ${r[d]} - 1));\n      col = max(0, min(col, ${r[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${p}])`:\"0\"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${a}])`:\"0\"};\n      var x11: ${m} = getInputValue(batch, channel, row1, col1);\n      var x12: ${m} = getInputValue(batch, channel, row1, col2);\n      var x21: ${m} = getInputValue(batch, channel, row2, col1);\n      var x22: ${m} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${m} = abs(row - ${m}(row1));\n      var dx2: ${m} = abs(${m}(row2) - row);\n      var dy1: ${m} = abs(col - ${m}(col1));\n      var dy2: ${m} = abs(${m}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Gh=(e,t,r,n,o,i,a,d,l,p)=>{let m=r.length===2,u=!0,[h,_]=m?[0,1]:u?[2,3]:[1,2],y=e.type.value,g=x=>{let $=x===h?\"row\":\"col\";return`\n      fn ${$}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${y} {\n        var output_index = ${t.indicesGet(\"output_indices\",x)};\n        var originalIdx: ${y} = getOriginalCoordinateFromResizedCoordinate(output_index, ${o[x]},\n        ${n[x]}, ${r[x]}, ${i[x]}, ${i[x]} + ${r.length});\n        var fractOriginalIdx: ${y} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[x]} - 1))) {\n          return ${l};\n        }\n        var data: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${$}: ${y} = originalIdx + ${y}(i);\n          if (${$} < 0 || ${$} >= ${r[x]}) {\n            ${(()=>p?`coefs[i + 1] = 0.0;\n                        continue;`:d?`return ${l};`:`${$} = max(0, min(${$}, ${r[x]} - 1));`)()};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet(\"input_indices_copy\",x,`u32(${$})`)};\n          data[i + 1] = ${x===h?e.getByIndices(\"input_indices_copy\"):\"rowCubicInterpolation(input_indices_copy, output_indices)\"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${g(h)};\n    ${g(_)};\n  fn getCubicInterpolationCoefs(s: ${y}) -> array<${y}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${y} = 1.0 - absS;\n    var twoMinusAbsS: ${y} = 2.0 - absS;\n    var onePlusAbsS: ${y} = 1.0 + absS;\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${y}, 4>, coefs: array<${y}, 4>) -> ${y} {\n    var coefsSum: ${y} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${y} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},Hh=(e,t,r,n,o)=>{let[a,d,l,p,m]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],u=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${u} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(depth, ${r[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(height, ${r[l]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",p,`max(0, min(width, ${r[p]} - 1))`)};\n      ${El(e,m,a,3)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${u} = originalIndices[${d}];\n      var height:${u} = originalIndices[${l}];\n      var width:${u} = originalIndices[${p}];\n      ${n?`if (depth < 0 || depth > (${r[d]} - 1) || height < 0 || height > (${r[l]} - 1) || width < 0 || (width > ${r[p]} - 1)) {\n      return ${o};\n        }`:\"\"};\n\n    depth = max(0, min(depth, ${r[d]} - 1));\n      height = max(0, min(height, ${r[l]} - 1));\n      width = max(0, min(width, ${r[p]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${m}])`:\"0\"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${a}])`:\"0\"};\n\n      var x111: ${u} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${u} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${u} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${u} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${u} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${u} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${u} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${u} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${u} = abs(depth - ${u}(depth1));\n      var dx2: ${u} = abs(${u}(depth2) - depth);\n      var dy1: ${u} = abs(height - ${u}(height1));\n      var dy2: ${u} = abs(${u}(height2) - height);\n      var dz1: ${u} = abs(width - ${u}(width1));\n      var dz2: ${u} = abs(${u}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Fh=(e,t,r,n,o,i)=>{let a=e.dims,d=Mh(i,t.axes,a.length),l=Rh(a,n,o,t.axes),p=n.slice();n.length===0&&(p=a.map((v,S)=>v===0?1:l[S]/v),t.keepAspectRatioPolicy!==\"stretch\"&&(l=Uh(a,p,t)));let m=M(\"output\",e.dataType,l.length),u=E(\"input\",e.dataType,a.length),h=k.size(l),_=a.length===l.length&&a.every((v,S)=>v===l[S]),y=t.coordinateTransformMode===\"tf_crop_and_resize\",g=t.extrapolationValue,x=u.type.value,$=v=>`\n      ${_?\"\":`\n      ${Dh(t.coordinateTransformMode,x)};\n      ${(()=>{switch(t.mode){case\"nearest\":return`\n              ${Wh(u,a)};\n              ${Bh(t.nearestMode,r,x)};\n              ${Vh(u,m,a,l,p.length,d.length,y)};\n              `;case\"linear\":return`\n              ${Nh(m,a,l,p.length,d.length)};\n              ${(()=>{if(a.length===2||a.length===4)return`${Lh(u,m,a,y,g)}`;if(a.length===3||a.length===5)return`${Hh(u,m,a,y,g)}`;throw Error(\"Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.\")})()};\n            `;case\"cubic\":return`\n            ${(()=>{if(a.length===2||a.length===4)return`${Gh(u,m,a,l,p,d,t.cubicCoeffA,y,t.extrapolationValue,t.excludeOutside)}`;throw Error(\"Cubic mode only supports input dims 2 and 4 are supported in linear mode.\")})()};\n            `;default:throw Error(\"Invalid resize mode\")}})()};\n      `}\n      ${v.registerUniform(\"output_size\",\"u32\").registerUniform(\"scales\",\"f32\",p.length).registerUniform(\"roi\",\"f32\",d.length).declareVariables(u,m)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n        ${_?\"output[global_idx] = input[global_idx];\":`\n        let output_indices = ${m.offsetToIndices(\"global_idx\")};\n        var input_indices: ${u.type.indices};\n        ${(()=>{switch(t.mode){case\"nearest\":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${u.getByIndices(\"input_indices\")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case\"linear\":return`output[global_idx] = ${a.length===2||a.length===4?\"bilinearInterpolation\":\"trilinearInterpolation\"}(output_indices);`;case\"cubic\":return\"output[global_idx] = bicubicInterpolation(output_indices);\";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:\"Resize\",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?t.mode===\"cubic\"?p:p.length:\"\"}|${o.length>0?o:\"\"}|${d.length>0?d:\"\"}|${_}|${t.mode===\"nearest\"?a.length:a}`,inputDependencies:[\"rank\"]},getShaderSource:$,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},{type:1,data:p},{type:1,data:d},...N(a,l)]})}},qh=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Pl=(e,t)=>{let r=[],n=[],o=[],i=qh(e);if(t.antialias!==0)throw Error(\"Only default value (0) for Antialias attribute is supported\");Oh(e.inputs,t,i,r,n,o),e.compute(Fh(e.inputs[0],t,i,r,n,o),{inputs:[0]})},zl=e=>{let t=e.antialias,r=e.axes,n=e.coordinateTransformMode,o=e.cubicCoeffA,i=e.excludeOutside!==0,a=e.extrapolationValue,d=e.keepAspectRatioPolicy,l=e.mode,p=e.nearestMode===\"\"?\"simple\":e.nearestMode;return ee({antialias:t,axes:r,coordinateTransformMode:n,cubicCoeffA:o,excludeOutside:i,extrapolationValue:a,keepAspectRatioPolicy:d,mode:l,nearestMode:p})}});var Kh,jh,Dl,Bl=U(()=>{\"use strict\";J();ne();xe();ae();Kh=(e,t)=>{let[r,n,o,i]=e,{numHeads:a,rotaryEmbeddingDim:d}=t;if(r.dims.length!==3&&r.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);if(!k.areEqual(n.dims,[])&&!k.areEqual(n.dims,[1])&&n.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${n.dims.length}`);if(o.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${o.dims.length}`);if(i.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${i.dims.length}`);if(!k.areEqual(o.dims,i.dims))throw new Error(\"Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape\");if(d>0&&a===0)throw new Error(\"num_heads must be provided if rotary_embedding_dim is specified\");let l=r.dims[0],p=r.dims[r.dims.length-2],m=o.dims[0],u=k.sizeFromDimension(r.dims,1)/p,h=d===0?o.dims[1]*2:u/a;if(d>h)throw new Error(\"rotary_embedding_dim must be less than or equal to head_size\");if(n.dims.length===2){if(l!==n.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${n.dims[0]}`);if(p!==n.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${n.dims[1]}`)}if(h/2!==o.dims[1]&&d/2!==o.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${o.dims[1]}`);if(p>m)throw new Error(\"Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported\")},jh=(e,t)=>{let{interleaved:r,numHeads:n,rotaryEmbeddingDim:o,scale:i}=t,a=e[0].dims[0],d=k.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],p=d/l,m=e[2].dims[1],u=o===0?m*2:p/n,h=new Array(a,l,p/u,u-m),_=k.computeStrides(h),y=[{type:1,data:i},{type:12,data:h},{type:12,data:_},...e[0].dims.length===3?new Array({type:12,data:[d,p,u,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[d,u,l*u,1]}):[],...N(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],g=x=>{let $=E(\"input\",e[0].dataType,e[0].dims.length),v=E(\"position_ids\",e[1].dataType,e[1].dims.length),S=E(\"cos_cache\",e[2].dataType,e[2].dims.length),T=E(\"sin_cache\",e[3].dataType,e[3].dims.length),A=M(\"output\",e[0].dataType,e[0].dims.length);return x.registerUniforms([{name:\"scale\",type:\"f32\"},{name:\"global_shape\",type:\"u32\",length:h.length},{name:\"global_strides\",type:\"u32\",length:_.length},{name:\"input_output_strides\",type:\"u32\",length:_.length}]),`\n        ${x.declareVariables($,v,S,T,A)}\n\n        ${x.mainStart(Et)}\n          let half_rotary_emb_dim = uniforms.${S.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"size\")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${v.broadcastedIndicesToOffset(\"bsnh.xy\",M(\"\",v.type.tensor,2))};\n            let position_id =\n                u32(${v.getByOffset(\"position_ids_idx\")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});\n            let j = i + select(half_rotary_emb_dim, 1, ${r});\n            let re = ${$.getByOffset(\"i\")} * ${S.get(\"position_id\",\"bsnh[3]\")} -\n                ${$.getByOffset(\"j\")} * ${T.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"i\",\"re\")}\n            let im = ${$.getByOffset(\"i\")} * ${T.get(\"position_id\",\"bsnh[3]\")} +\n                ${$.getByOffset(\"j\")} * ${S.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"j\",\"im\")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${A.setByOffset(\"k\",$.getByOffset(\"k\"))}\n          }\n        }`};return{name:\"RotaryEmbedding\",shaderCache:{hint:ee({interleaved:r}).cacheKey,inputDependencies:[\"rank\",\"rank\",\"rank\",\"rank\"]},getShaderSource:g,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(h)/Et)},programUniforms:y})}},Dl=(e,t)=>{Kh(e.inputs,t),e.compute(jh(e.inputs,t))}});var Yh,Zh,Ml,Rl=U(()=>{\"use strict\";J();ne();ae();Yh=e=>{if(!e||e.length<3)throw new Error(\"layerNorm requires at least 3 inputs.\");let t=e[0],r=e[1],n=e[2];if(t.dataType!==r.dataType||t.dataType!==n.dataType)throw new Error(\"All inputs must have the same data type\");if(t.dims.length!==3&&t.dims.length!==2)throw new Error(\"Input must be 2D or 3D\");if(r.dims.length!==3&&r.dims.length!==2)throw new Error(\"Skip must be 2D or 3D\");let o=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==o)throw new Error(\"Skip must have the same hidden size as input\");if(r.dims[r.dims.length-2]!==i)throw new Error(\"Skip must have the same sequence length as input\");if(n.dims.length!==1)throw new Error(\"Gamma must be 1D\");if(n.dims[n.dims.length-1]!==o)throw new Error(\"Gamma must have the same hidden size as input\");if(e.length>3){let a=e[3];if(a.dims.length!==1)throw new Error(\"Beta must be 1D\");if(a.dims[a.dims.length-1]!==o)throw new Error(\"Beta must have the same hidden size as input\")}if(e.length>4){let a=e[4];if(a.dims.length!==1)throw new Error(\"Bias must be 1D\");if(a.dims[a.dims.length-1]!==o)throw new Error(\"Bias must have the same hidden size as input\")}},Zh=(e,t,r,n)=>{let o=t.simplified,i=e[0].dims,a=k.size(i),d=i,l=a,p=i.slice(-1)[0],m=n?i.slice(0,-1).concat(1):[],u=!o&&e.length>3,h=e.length>4,_=n&&r>1,y=n&&r>2,g=r>3,x=64,$=me(p),v=[{type:12,data:l},{type:12,data:$},{type:12,data:p},{type:1,data:t.epsilon}],S=A=>{let C=[{name:\"output_size\",type:\"u32\"},{name:\"components\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}],P=[E(\"x\",e[0].dataType,e[0].dims,$),E(\"skip\",e[1].dataType,e[1].dims,$),E(\"gamma\",e[2].dataType,e[2].dims,$)];u&&P.push(E(\"beta\",e[3].dataType,e[3].dims,$)),h&&P.push(E(\"bias\",e[4].dataType,e[4].dims,$)),P.push(M(\"output\",e[0].dataType,d,$)),_&&P.push(M(\"mean_output\",1,m)),y&&P.push(M(\"inv_std_output\",1,m)),g&&P.push(M(\"input_skip_bias_sum\",e[0].dataType,d,$));let D=ye(e[0].dataType),R=ye(1,$);return`\n\n      ${A.registerUniforms(C).declareVariables(...P)}\n      var<workgroup> sum_shared : array<${R}, ${x}>;\n      var<workgroup> sum_squared_shared : array<${R}, ${x}>;\n\n      ${A.mainStart([x,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / ${x};\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / ${x};\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == ${x-1}) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${h?\"bias[offset1d + i]\":D+\"(0.0)\"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${g?\"input_skip_bias_sum[offset + i] = value;\":\"\"}\n          output[offset + i] = value;\n          let f32_value = ${Pt(D,$,\"value\")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = ${x};\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${qe(\"sum\",$)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${qe(\"square_sum\",$)} / f32(uniforms.hidden_size) ${o?\"\":\"- mean * mean\"} + uniforms.epsilon);\n        ${_?\"mean_output[global_idx] = mean;\":\"\"}\n        ${y?\"inv_std_output[global_idx] = inv_std_dev;\":\"\"}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${o?\"\":`- ${D}(mean)`}) *\n            ${D}(inv_std_dev) * gamma[offset1d + i]\n            ${u?\"+ beta[offset1d + i]\":\"\"};\n        }\n      }`},T=[{dims:d,dataType:e[0].dataType}];return r>1&&T.push({dims:m,dataType:1}),r>2&&T.push({dims:m,dataType:1}),r>3&&T.push({dims:i,dataType:e[0].dataType}),{name:\"SkipLayerNormalization\",shaderCache:{hint:`${$};${_};${y};${g}`,inputDependencies:e.map((A,C)=>\"type\")},getShaderSource:S,getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(l/p)},programUniforms:v})}},Ml=(e,t)=>{Yh(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(Zh(e.inputs,t,e.outputCount,!1),{outputs:n})}});var Qh,tn,Xh,Ul,Jh,eg,Nl,Vl,Wl=U(()=>{\"use strict\";J();ne();xe();ae();Qh=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error(\"axes, starts and ends must have the same length\")}else if(t.starts.length!==t.ends.length)throw new Error(\"starts and ends must have the same length\");e.slice(1).forEach((r,n)=>{if(e[n+1].dataType!==6&&e[n+1].dataType!==7)throw new Error(`Input ${n} must be an array of int32 or int64`)})},tn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(n=>r.push(Number(n)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(n=>r.push(Number(n)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Xh=(e,t)=>{if(e.length>1){let r=tn(e,1),n=tn(e,2),o=tn(e,3);return o.length===0&&(o=[...Array(e[0].dims.length).keys()]),ee({starts:r,ends:n,axes:o})}else return t},Ul=(e,t,r,n,o)=>{let i=e;return e<0&&(i+=r[n[t]]),o[t]<0?Math.max(0,Math.min(i,r[n[t]]-1)):Math.max(0,Math.min(i,r[n[t]]))},Jh=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${q(\"uniforms.input_shape\",\"i\",r.length)};\n            let steps_i = ${q(\"uniforms.steps\",\"i\",r.length)};\n            let signs_i = ${q(\"uniforms.signs\",\"i\",r.length)};\n            let starts_i = ${q(\"uniforms.starts\",\"i\",r.length)};\n            var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")};\n          }\n          return input_indices;\n      }`,eg=(e,t)=>{let r=e[0].dims,n=k.size(r),o=t.axes.length>0?k.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],i=tn(e,4);i.forEach($=>$!==0||(()=>{throw new Error(\"step cannot be 0\")})),i.length===0&&(i=Array(o.length).fill(1));let a=t.starts.map(($,v)=>Ul($,v,r,o,i)),d=t.ends.map(($,v)=>Ul($,v,r,o,i));if(o.length!==a.length||o.length!==d.length)throw new Error(\"start, ends and axes should have the same number of elements\");if(o.length!==r.length)for(let $=0;$<r.length;++$)o.includes($)||(a.splice($,0,0),d.splice($,0,r[$]),i.splice($,0,1));let l=i.map($=>Math.sign($));i.forEach(($,v,S)=>{if($<0){let T=(d[v]-a[v])/$,A=a[v],C=A+T*i[v];a[v]=C,d[v]=A,S[v]=-$}});let p=r.slice(0);o.forEach(($,v)=>{p[$]=Math.ceil((d[$]-a[$])/i[$])});let m={dims:p,dataType:e[0].dataType},u=M(\"output\",e[0].dataType,p.length),h=E(\"input\",e[0].dataType,e[0].dims.length),_=k.size(p),y=[{name:\"outputSize\",type:\"u32\"},{name:\"starts\",type:\"u32\",length:a.length},{name:\"signs\",type:\"i32\",length:l.length},{name:\"steps\",type:\"u32\",length:i.length}],g=[{type:12,data:_},{type:12,data:a},{type:6,data:l},{type:12,data:i},...N(e[0].dims,p)],x=$=>`\n      ${$.registerUniforms(y).declareVariables(h,u)}\n        ${Jh(h,u,r)}\n        ${$.mainStart()}\n          ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n          let output_indices = ${u.offsetToIndices(\"global_idx\")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${u.setByOffset(\"global_idx\",h.getByIndices(\"input_indices\"))}\n      }`;return{name:\"Slice\",shaderCache:{hint:`${l.length}_${a.length}_${i.length}`,inputDependencies:[\"rank\"]},getShaderSource:x,getRunData:()=>({outputs:[m],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:g})}},Nl=(e,t)=>{Qh(e.inputs,t);let r=Xh(e.inputs,t);e.compute(eg(e.inputs,r),{inputs:[0]})},Vl=e=>{let t=e.starts,r=e.ends,n=e.axes;return ee({starts:t,ends:r,axes:n})}});var tg,rg,Ll,Gl,Hl=U(()=>{\"use strict\";J();ne();xe();dt();ae();tg=e=>{if(!e||e.length!==1)throw new Error(\"Softmax op requires 1 input.\")},rg=(e,t)=>{let r=e.inputs[0],n=r.dims,o=k.size(n),i=n.length,a=k.normalizeAxis(t.axis,i),d=a<n.length-1,l,p=[];d?(p=Array.from({length:i},(P,D)=>D),p[a]=i-1,p[i-1]=a,l=e.compute(Pe(r,p),{inputs:[r],outputs:[-1]})[0]):l=r;let m=l.dims,u=m[i-1],h=o/u,_=me(u),y=u/_,g=64;h===1&&(g=256);let x=(P,D)=>D===4?`max(max(${P}.x, ${P}.y), max(${P}.z, ${P}.w))`:D===2?`max(${P}.x, ${P}.y)`:D===3?`max(max(${P}.x, ${P}.y), ${P}.z)`:P,$=E(\"x\",l.dataType,l.dims,_),v=M(\"result\",l.dataType,l.dims,_),S=$.type.value,T=ye(l.dataType)===\"f32\"?`var threadMax = ${S}(-3.402823e+38f);`:`var threadMax = ${S}(-65504.0h);`,A=P=>`\n      var<workgroup> rowMaxShared : ${S};\n      var<workgroup> rowSumShared : ${S};\n      var<workgroup> threadShared : array<${S}, ${g}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${S} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${S}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${P.registerUniform(\"packedCols\",\"i32\").declareVariables($,v)}\n      ${P.mainStart(g)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${g};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${T}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${S}(${x(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${S}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${S}(${qe(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`,C=e.compute({name:\"Softmax\",shaderCache:{hint:`${_};${g}`,inputDependencies:[\"type\"]},getRunData:()=>({outputs:[{dims:m,dataType:l.dataType}],dispatchGroup:{x:h},programUniforms:[{type:6,data:y}]}),getShaderSource:A},{inputs:[l],outputs:[d?-1:0]})[0];d&&e.compute(Pe(C,p),{inputs:[C]})},Ll=(e,t)=>{tg(e.inputs),rg(e,t)},Gl=e=>ee({axis:e.axis})});var Fl,ng,og,ig,ql,Kl=U(()=>{\"use strict\";J();ne();ae();Fl=e=>Array.from(e.getBigInt64Array(),Number),ng=e=>{if(!e||e.length!==2)throw new Error(\"Tile requires 2 inputs.\");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error(\"Tile only support float, float16, int32, and uint32 data types\");if(e[1].dataType!==7)throw new Error(\"Tile `repeats` input should be of int64 data type\");if(e[1].dims.length!==1)throw new Error(\"Tile `repeats` input should be 1-D\");if(Fl(e[1]).length!==e[0].dims.length)throw new Error(\"Tile `repeats` input should have same number of elements as rank of input data tensor\")},og=(e,t)=>{let r=[];for(let n=0;n<e.length;++n)r.push(e[n]*t[n]);return r},ig=(e,t)=>{let r=e[0].dims,n=t??Fl(e[1]),o=og(r,n),i=k.size(o),a=e[0].dataType,d=E(\"input\",a,r.length),l=M(\"output\",a,o.length),p=m=>`\n      const inputShape = ${d.indices(...r)};\n      ${m.registerUniform(\"output_size\",\"u32\").declareVariables(d,l)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let output_indices = ${l.offsetToIndices(\"global_idx\")};\n      var input_indices: ${d.type.indices};\n      for (var i = 0; i < ${r.length}; i++) {\n        let input_dim_i = ${d.indicesGet(\"uniforms.input_shape\",\"i\")};\n        let input_dim_value = ${l.indicesGet(\"output_indices\",\"i\")}  % input_dim_i;\n\n        ${d.indicesSet(\"input_indices\",\"i\",\"input_dim_value\")}\n      }\n      ${l.setByOffset(\"global_idx\",d.getByIndices(\"input_indices\"))}\n    }`;return{name:\"Tile\",shaderCache:{hint:`${n}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...N(e[0].dims,o)]}),getShaderSource:p}},ql=e=>{ng(e.inputs),e.compute(ig(e.inputs),{inputs:[0]})}});var ag,sg,jl,Yl=U(()=>{\"use strict\";J();ne();ae();ag=(e,t,r,n,o)=>{let i=M(\"output_data\",o,r.length,4),a=E(\"a_data\",t[1].dataType,t[1].dims.length,4),d=E(\"b_data\",t[2].dataType,t[2].dims.length,4),l=E(\"c_data\",t[0].dataType,t[0].dims.length,4),p,m=(u,h,_)=>`select(${h}, ${u}, ${_})`;if(!n)p=i.setByOffset(\"global_idx\",m(a.getByOffset(\"global_idx\"),d.getByOffset(\"global_idx\"),l.getByOffset(\"global_idx\")));else{let u=(h,_,y=\"\")=>{let g=`a_data[index_a${_}][component_a${_}]`,x=`b_data[index_b${_}][component_b${_}]`,$=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`\n            let output_indices${_} = ${i.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${a.broadcastedIndicesToOffset(`output_indices${_}`,i)};\n            let offset_b${_} = ${d.broadcastedIndicesToOffset(`output_indices${_}`,i)};\n            let offset_c${_} = ${l.broadcastedIndicesToOffset(`output_indices${_}`,i)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${h}[${_}] = ${y}(${m(g,x,$)});\n          `};o===9?p=`\n            var data = vec4<u32>(0);\n            ${u(\"data\",0,\"u32\")}\n            ${u(\"data\",1,\"u32\")}\n            ${u(\"data\",2,\"u32\")}\n            ${u(\"data\",3,\"u32\")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`\n            ${u(\"output_data[global_idx]\",0)}\n            ${u(\"output_data[global_idx]\",1)}\n            ${u(\"output_data[global_idx]\",2)}\n            ${u(\"output_data[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(l,a,d,i)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${p}\n      }`},sg=e=>{let t=e[1].dims,r=e[2].dims,n=e[0].dims,o=e[1].dataType,i=!(k.areEqual(t,r)&&k.areEqual(r,n)),a=t,d=k.size(t);if(i){let p=tt.calcShape(tt.calcShape(t,r,!1),n,!1);if(!p)throw new Error(\"Can't perform where op on the given tensors\");a=p,d=k.size(a)}let l=Math.ceil(d/4);return{name:\"Where\",shaderCache:{inputDependencies:[\"rank\",\"rank\",\"rank\"]},getShaderSource:p=>ag(p,e,a,i,o),getRunData:()=>({outputs:[{dims:a,dataType:o}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:l},...N(n,t,r,a)]})}},jl=e=>{e.compute(sg(e.inputs))}});var Zl,Ql=U(()=>{\"use strict\";Es();Hr();Os();Bs();wu();Pu();Du();Zu();nd();ad();dd();fd();bd();_d();$d();Td();Ad();Pd();Dd();Rd();Fd();jd();Zd();Xd();tl();xo();nl();wl();xl();Tl();Al();Lr();Ol();Bl();Rl();Wl();Hl();To();Kl();dt();qr();Yl();Zl=new Map([[\"Abs\",[Ms]],[\"Acos\",[Rs]],[\"Acosh\",[Us]],[\"Add\",[vu]],[\"ArgMax\",[ks,lo]],[\"ArgMin\",[As,lo]],[\"Asin\",[Ns]],[\"Asinh\",[Vs]],[\"Atan\",[Ws]],[\"Atanh\",[Ls]],[\"Attention\",[Ps]],[\"AveragePool\",[cl,ll]],[\"BatchNormalization\",[zs]],[\"BiasAdd\",[Ds]],[\"BiasSplitGelu\",[_u]],[\"Cast\",[Hs,Gs]],[\"Ceil\",[qs]],[\"Clip\",[Fs]],[\"Concat\",[zu,Ou]],[\"Conv\",[_o,yo]],[\"ConvTranspose\",[rd,ed]],[\"Cos\",[Ks]],[\"Cosh\",[js]],[\"CumSum\",[od,id]],[\"DepthToSpace\",[sd,ud]],[\"DequantizeLinear\",[vl,$l]],[\"Div\",[$u]],[\"Einsum\",[pd,md]],[\"Elu\",[Ys,Qt]],[\"Equal\",[xu]],[\"Erf\",[Zs]],[\"Exp\",[Qs]],[\"Expand\",[gd]],[\"FastGelu\",[yd]],[\"Floor\",[Xs]],[\"FusedConv\",[_o,yo]],[\"Gather\",[vd,wd]],[\"GatherElements\",[Ed,kd]],[\"GatherBlockQuantized\",[Id,Cd]],[\"GatherND\",[xd,Sd]],[\"Gelu\",[Js]],[\"Gemm\",[Od,zd]],[\"GlobalAveragePool\",[fl,ml]],[\"GlobalMaxPool\",[_l,yl]],[\"Greater\",[Cu]],[\"GreaterOrEqual\",[ku]],[\"GridSample\",[Bd,Md]],[\"GroupQueryAttention\",[Hd]],[\"HardSigmoid\",[su,au]],[\"InstanceNormalization\",[Kd]],[\"LayerNormalization\",[Yd]],[\"LeakyRelu\",[eu,Qt]],[\"Less\",[Au]],[\"LessOrEqual\",[Eu]],[\"Log\",[gu]],[\"MatMul\",[Qd]],[\"MatMulNBits\",[Jd,el]],[\"MaxPool\",[gl,bl]],[\"Mul\",[Su]],[\"MultiHeadAttention\",[Vd,Nd]],[\"Neg\",[ru]],[\"Not\",[tu]],[\"Pad\",[rl]],[\"Pow\",[Tu]],[\"QuickGelu\",[bu,Qt]],[\"Range\",[Sl]],[\"Reciprocal\",[nu]],[\"ReduceMin\",[$s]],[\"ReduceMean\",[bs]],[\"ReduceMax\",[vs]],[\"ReduceSum\",[Ss]],[\"ReduceProd\",[xs]],[\"ReduceL1\",[ys]],[\"ReduceL2\",[_s]],[\"ReduceLogSum\",[Is]],[\"ReduceLogSumExp\",[ws]],[\"ReduceSumSquare\",[Ts]],[\"Relu\",[ou]],[\"Resize\",[Pl,zl]],[\"RotaryEmbedding\",[Dl]],[\"ScatterND\",[Cl,Il]],[\"Sigmoid\",[iu]],[\"Sin\",[uu]],[\"Sinh\",[du]],[\"Slice\",[Nl,Vl]],[\"SkipLayerNormalization\",[Ml]],[\"Split\",[Wd,Ld]],[\"Sqrt\",[lu]],[\"Softmax\",[Ll,Gl]],[\"Sub\",[Iu]],[\"Tan\",[cu]],[\"Tanh\",[mu]],[\"ThresholdedRelu\",[hu,Qt]],[\"Tile\",[ql]],[\"Transpose\",[os,is]],[\"Where\",[jl]]])});var rn,Xl=U(()=>{\"use strict\";Le();et();ae();rn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,n,o,i){Ne(t.programInfo.name);let a=this.backend.device,d=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let l=[];for(let m of r)l.push({binding:l.length,resource:{buffer:m.buffer}});for(let m of n)l.push({binding:l.length,resource:{buffer:m.buffer}});i&&l.push({binding:l.length,resource:i});let p=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:l,label:t.programInfo.name});if(this.backend.sessionStatus===\"capturing\"){let m={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:p,dispatchGroup:o};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(m)}d.setPipeline(t.computePipeline),d.setBindGroup(0,p),d.dispatchWorkgroups(...o),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType===\"at-passes\")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Be(t.programInfo.name)}dispose(){}build(t,r){Ne(t.name);let n=this.backend.device,o=[];[{feature:\"shader-f16\",extension:\"f16\"},{feature:\"subgroups\",extension:\"subgroups\"},{feature:\"subgroups-f16\",extension:\"subgroups_f16\"}].forEach(u=>{n.features.has(u.feature)&&o.push(`enable ${u.extension};`)});let a=rs(r,this.backend.device.limits),d=t.getShaderSource(a),l=`${o.join(`\n`)}\n${a.additionalImplementations}\n${d}`,p=n.createShaderModule({code:l,label:t.name});se(\"verbose\",()=>`[WebGPU] ${t.name} shader code: ${l}`);let m=n.createComputePipeline({compute:{module:p,entryPoint:\"main\"},layout:\"auto\",label:t.name});return Be(t.name),{programInfo:t,computePipeline:m,uniformVariablesInfo:a.variablesInfo}}normalizeDispatchGroupSize(t){let r=typeof t==\"number\"?t:t.x,n=typeof t==\"number\"?1:t.y||1,o=typeof t==\"number\"?1:t.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=i&&n<=i&&o<=i)return[r,n,o];let a=r*n*o,d=Math.ceil(Math.sqrt(a));if(d>i){if(d=Math.ceil(Math.cbrt(a)),d>i)throw new Error(\"Total dispatch size exceeds WebGPU maximum.\");return[d,d,d]}else return[d,d,1]}}});var ug,dg,Io,Co,nn,Jl=U(()=>{\"use strict\";Le();J();et();Xn();Xa();Ql();Xl();ug=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let n=0;n<e.length;++n){let o=e[n].dataType;switch(t[n]){case\"none\":{r.push(\"\");break}case\"type\":{r.push(`${o}`);break}case\"rank\":{let i=e[n].dims.length;r.push(`${o};${i}`);break}case\"dims\":{let i=e[n].dims.join(\",\");r.push(`${o};${i}`);break}default:throw new Error(`unsupported input dependency: ${t[n]}`)}}return r.join(\"|\")},dg=(e,t,r)=>{let n=e.name;return e.shaderCache?.hint&&(n+=\"[\"+e.shaderCache.hint+\"]\"),n+=\":\"+r+`:${ug(t,e.shaderCache?.inputDependencies??new Array(t.length).fill(\"dims\"))}`,n},Io=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},Co=class{constructor(t){this.subgroupsSupported=t.features.has(\"subgroups\"),this.subgroupsF16Supported=t.features.has(\"subgroups\");let r=t.limits;!this.subgroupsSupported||!r.minSubgroupSize||!r.maxSubgroupSize?this.subgroupSizeRange=void 0:this.subgroupSizeRange=[r.minSubgroupSize,r.maxSubgroupSize]}},nn=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus=\"default\";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error(\"currentKernelCustomData(): currentKernelId is null. (should not happen)\");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let n=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},i=a=>r.features.has(a)&&n.push(a)&&!0;i(\"chromium-experimental-timestamp-query-inside-passes\")||i(\"timestamp-query\"),i(\"shader-f16\"),i(\"subgroups\")&&i(\"subgroups-f16\"),this.device=await r.requestDevice(o),this.deviceInfo=new Co(this.device),this.adapterInfo=new Io(r.info||await r.requestAdapterInfo()),this.gpuDataManager=Qa(this),this.programManager=new rn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Mr(t.logLevel,!!t.debug),this.device.onuncapturederror=a=>{a.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${a.error.message}`)},Object.defineProperty(this.env.webgpu,\"device\",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,\"adapter\",{value:r,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<\"u\"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),r={};this.queryType===\"at-passes\"&&(r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Ne(),this.endComputePass();let t;this.queryType!==\"none\"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!==\"none\"&&t.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.getMappedRange()),n=this.pendingQueries.get(t);for(let o=0;o<r.length/2;o++){let i=n[o],a=i.kernelId,d=this.kernels.get(a),l=d.kernelType,p=d.kernelName,m=i.programName,u=i.inputTensorViews,h=i.outputTensorViews,_=r[o*2],y=r[o*2+1];typeof this.queryTimeBase>\"u\"&&(this.queryTimeBase=_);let g=Number(_-this.queryTimeBase),x=Number(y-this.queryTimeBase);if(!Number.isSafeInteger(g)||!Number.isSafeInteger(x))throw new RangeError(\"incorrect timestamp range\");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:u.map($=>({dims:$.dims,dataType:bt($.dataType)})),outputsMetadata:h.map($=>({dims:$.dims,dataType:bt($.dataType)})),kernelId:a,kernelType:l,kernelName:p,programName:m,startTime:g,endTime:x});else{let $=\"\";u.forEach((S,T)=>{$+=`input[${T}]: [${S.dims}] | ${bt(S.dataType)}, `});let v=\"\";h.forEach((S,T)=>{v+=`output[${T}]: [${S.dims}] | ${bt(S.dataType)}, `}),console.log(`[profiling] kernel \"${a}|${l}|${p}|${m}\" ${$}${v}execution time: ${x-g} ns`)}_r(\"GPU\",`${m}::${_}::${y}`)}t.unmap(),this.pendingQueries.delete(t)}),Be()}run(t,r,n,o,i,a){Ne(t.name);let d=[];for(let S=0;S<r.length;++S){let T=r[S].data;if(T===0)continue;let A=this.gpuDataManager.get(T);if(!A)throw new Error(`no GPU data for input: ${T}`);d.push(A)}let{outputs:l,dispatchGroup:p,programUniforms:m}=t.getRunData(r),u=n.length===0?l.map((S,T)=>T):n;if(u.length!==l.length)throw new Error(`Output size ${u.length} must be equal to ${l.length}.`);let h=[],_=[];for(let S=0;S<l.length;++S){if(!Number.isInteger(u[S])||u[S]<-3||u[S]>=a)throw new Error(`Invalid output index: ${u[S]}`);if(u[S]===-3)continue;let T=u[S]===-1,A=u[S]===-2,C=T||A?i(l[S].dataType,l[S].dims):o(u[S],l[S].dataType,l[S].dims);if(h.push(C),C.data===0)continue;let P=this.gpuDataManager.get(C.data);if(!P)throw new Error(`no GPU data for output: ${C.data}`);if(T&&this.temporaryData.push(P),A){let D=this.kernelPersistentData.get(this.currentKernelId);D||(D=[],this.kernelPersistentData.set(this.currentKernelId,D)),D.push(P)}_.push(P)}if(d.length!==r.length||_.length!==h.length){if(_.length===0)return Be(t.name),h;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let y;if(m){let S=0,T=[];m.forEach(D=>{let R=typeof D.data==\"number\"?[D.data]:D.data;if(R.length===0)return;let H=D.type===10?2:4,L,re;D.type===10?(re=R.length>4?16:R.length>2?8:R.length*H,L=R.length>4?16:H*R.length):(re=R.length<=2?R.length*H:16,L=16),S=Math.ceil(S/re)*re,T.push(S);let V=D.type===10?8:4;S+=R.length>4?Math.ceil(R.length/V)*L:R.length*H});let A=16;S=Math.ceil(S/A)*A;let C=new ArrayBuffer(S);m.forEach((D,R)=>{let H=T[R],L=typeof D.data==\"number\"?[D.data]:D.data;if(D.type===6)new Int32Array(C,H,L.length).set(L);else if(D.type===12)new Uint32Array(C,H,L.length).set(L);else if(D.type===10)new Uint16Array(C,H,L.length).set(L);else if(D.type===1)new Float32Array(C,H,L.length).set(L);else throw new Error(`Unsupported uniform type: ${bt(D.type)}`)});let P=this.gpuDataManager.create(S,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(P.buffer,0,C,0,S),this.gpuDataManager.release(P.id),y={offset:0,size:S,buffer:P.buffer}}let g=this.programManager.normalizeDispatchGroupSize(p),x=g[1]===1&&g[2]===1,$=dg(t,r,x),v=this.programManager.getArtifact($);if(v||(v=this.programManager.build(t,g),this.programManager.setArtifact($,v),se(\"info\",()=>`[artifact] key: ${$}, programName: ${t.name}`)),m&&v.uniformVariablesInfo){if(m.length!==v.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${v.uniformVariablesInfo.length}, got ${m.length} in program \"${v.programInfo.name}\".`);for(let S=0;S<m.length;S++){let T=m[S],A=T.type,C=typeof T.data==\"number\"?1:T.data.length,[P,D]=v.uniformVariablesInfo[S];if(A!==P||C!==D)throw new Error(`Uniform variable ${S} mismatch: expect type ${P} with size ${D}, got type ${A} with size ${C} in program \"${v.programInfo.name}\".`)}}if(se(\"info\",()=>`[ProgramManager] run \"${t.name}\" (key=${$}) with ${g[0]}x${g[1]}x${g[2]}`),this.queryType!==\"none\"||this.sessionStatus===\"capturing\"){let S={kernelId:this.currentKernelId,programName:v.programInfo.name,inputTensorViews:r,outputTensorViews:h};this.pendingKernels.push(S),this.sessionStatus===\"capturing\"&&this.capturedPendingKernels.get(this.currentSessionId).push(S)}return this.programManager.run(v,d,_,g,y),Be(t.name),h}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,n,o){let i=Zl.get(t);if(!i)throw new Error(`kernel not implemented: ${t}`);let a={kernelType:t,kernelName:o,kernelEntry:i[0],attributes:[i[1],n]};this.kernels.set(r,a)}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let n of r)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,n){let o=this.kernels.get(t);if(!o)throw new Error(`kernel not created: ${t}`);let i=o.kernelType,a=o.kernelName,d=o.kernelEntry,l=o.attributes;if(this.currentKernelId!==null)throw new Error(`kernel \"[${i}] ${a}\" is not allowed to be called recursively`);this.currentKernelId=t,l[0]&&(l[1]=l[0](l[1]),l[0]=void 0),se(\"info\",()=>`[WebGPU] Start to run kernel \"[${i}] ${a}\"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope(\"validation\"),d(r,l[1]),0}catch(m){return n.push(Promise.resolve(`[WebGPU] Kernel \"[${i}] ${a}\" failed. ${m}`)),1}finally{p&&n.push(this.device.popErrorScope().then(m=>m?`GPU validation error for kernel \"[${i}] ${a}\": ${m.message}`:null));for(let m of this.temporaryData)this.gpuDataManager.release(m.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,n,o){let i=this.sessionExternalDataMapping.get(t);i||(i=new Map,this.sessionExternalDataMapping.set(t,i));let a=i.get(r),d=this.gpuDataManager.registerExternalBuffer(n,o,a);return i.set(r,[d,n]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,n){return async()=>{let o=await ro(this,t,r);return Rr(o.buffer,n)}}writeTimestamp(t){this.queryType===\"inside-passes\"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType=\"none\",(this.env.webgpu.profiling?.mode===\"default\"||(typeof this.env.trace>\"u\"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has(\"chromium-experimental-timestamp-query-inside-passes\")?this.queryType=\"inside-passes\":this.device.features.has(\"timestamp-query\")&&(this.queryType=\"at-passes\"),this.queryType!==\"none\"&&typeof this.querySet>\"u\"&&(this.querySet=this.device.createQuerySet({type:\"timestamp\",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){se(\"info\",\"captureBegin\"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus=\"capturing\"}captureEnd(){se(\"info\",\"captureEnd\"),this.flush(),this.sessionStatus=\"default\"}replay(){se(\"info\",\"replay\"),this.sessionStatus=\"replaying\";let t=this.capturedCommandList.get(this.currentSessionId),r=this.capturedPendingKernels.get(this.currentSessionId),n=t.length;this.pendingKernels=[];for(let o=0;o<n;o++){let i=this.getComputePassEncoder(),a=t[o];this.writeTimestamp(this.pendingDispatchNumber*2),i.setPipeline(a.computePipeline),i.setBindGroup(0,a.bindGroup),i.dispatchWorkgroups(...a.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!==\"none\"&&this.pendingKernels.push(r[o]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType===\"at-passes\")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus=\"default\"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var lg,ec,cg,tc,on,an,Ao,rc,nc=U(()=>{\"use strict\";et();lg=1,ec=()=>lg++,cg=new Map([[\"float32\",32],[\"float16\",16],[\"int32\",32],[\"uint32\",32],[\"int64\",64],[\"uint64\",64],[\"int8\",8],[\"uint8\",8],[\"int4\",4],[\"uint4\",4]]),tc=(e,t)=>{let r=cg.get(e);if(!r)throw new Error(\"Unsupported data type.\");return t.length>0?Math.ceil(t.reduce((n,o)=>n*o)*r/8):0},on=class{constructor(t){this.sessionId=t.sessionId,this.mlContext=t.context,this.mlTensor=t.tensor,this.dataType=t.dataType,this.tensorShape=t.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return tc(this.dataType,this.tensorShape)}destroy(){se(\"verbose\",()=>\"[WebNN] TensorWrapper.destroy\"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,r,n){return this.mlContext===t&&this.dataType===r&&this.tensorShape.length===n.length&&this.tensorShape.every((o,i)=>o===n[i])}},an=class{constructor(t,r){this.tensorManager=t;this.wrapper=r}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,r,n,o){if(this.wrapper){if(this.wrapper.canReuseTensor(t,r,n))return this.wrapper.tensor;if(o){if(this.wrapper.byteLength!==tc(r,n))throw new Error(\"Unable to copy data to tensor with different size.\");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let i=typeof MLTensorUsage>\"u\"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(r,n,i,!0,!0),o&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){if(this.wrapper)if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else se(\"verbose\",()=>\"Data size does not match tensor size. Releasing tensor.\"),this.releaseTensor();this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(t){if(this.activeUpload)if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(this.activeUpload):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error(\"Tensor has not been created.\");return t?this.wrapper.read(t):this.wrapper.read()}},Ao=class{constructor(t){this.backend=t;this.tensorTrackersById=new Map;this.freeTensors=[];this.externalTensors=new Set}reserveTensorId(){let t=ec();return this.tensorTrackersById.set(t,new an(this)),t}releaseTensorId(t){let r=this.tensorTrackersById.get(t);r&&(this.tensorTrackersById.delete(t),r.tensorWrapper&&this.releaseTensor(r.tensorWrapper))}async ensureTensor(t,r,n,o){se(\"verbose\",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${r}, shape: ${n}, copyOld: ${o}}`);let i=this.tensorTrackersById.get(t);if(!i)throw new Error(\"Tensor not found.\");return i.ensureTensor(this.backend.currentContext,r,n,o)}upload(t,r){let n=this.tensorTrackersById.get(t);if(!n)throw new Error(\"Tensor not found.\");n.upload(r)}async download(t,r){se(\"verbose\",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${r?.byteLength}}`);let n=this.tensorTrackersById.get(t);if(!n)throw new Error(\"Tensor not found.\");return n.download(r)}releaseTensorsForSession(t){for(let r of this.freeTensors)r.sessionId===t&&r.destroy();this.freeTensors=this.freeTensors.filter(r=>r.sessionId!==t)}registerTensor(t,r,n,o){let i=ec(),a=new on({sessionId:this.backend.currentSessionId,context:t,tensor:r,dataType:n,shape:o});return this.tensorTrackersById.set(i,new an(this,a)),this.externalTensors.add(a),i}async getCachedTensor(t,r,n,o,i){let a=this.backend.currentSessionId,d=this.backend.currentContext;for(let[p,m]of this.freeTensors.entries())if(m.canReuseTensor(d,t,r)){se(\"verbose\",()=>`[WebNN] Reusing tensor {dataType: ${t}, shape: ${r}}`);let u=this.freeTensors.splice(p,1)[0];return u.sessionId=a,u}se(\"verbose\",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, shape: ${r}}`);let l=await d.createTensor({dataType:t,shape:r,dimensions:r,usage:n,writable:o,readable:i});return new on({sessionId:a,context:d,tensor:l,dataType:t,shape:r})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},rc=(...e)=>new Ao(...e)});var oc,pg,sn,ic=U(()=>{\"use strict\";J();gt();Xn();nc();et();oc=new Map([[1,\"float32\"],[10,\"float16\"],[6,\"int32\"],[12,\"uint32\"],[7,\"int64\"],[13,\"uint64\"],[22,\"int4\"],[21,\"uint4\"],[3,\"int8\"],[2,\"uint8\"],[9,\"uint8\"]]),pg=(e,t)=>{if(e===t)return!0;if(e===void 0||t===void 0)return!1;let r=Object.keys(e).sort(),n=Object.keys(t).sort();return r.length===n.length&&r.every((o,i)=>o===n[i]&&e[o]===t[o])},sn=class{constructor(t){this.tensorManager=rc(this);this.mlContextBySessionId=new Map;this.sessionIdsByMLContext=new Map;this.mlContextCache=[];Mr(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error(\"No active session\");return this.activeSessionId}onRunStart(t){this.activeSessionId=t}async createMLContext(t){if(t instanceof GPUDevice){let n=this.mlContextCache.findIndex(o=>o.gpuDevice===t);if(n!==-1)return this.mlContextCache[n].mlContext;{let o=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:o}),o}}else if(t===void 0){let n=this.mlContextCache.findIndex(o=>o.options===void 0&&o.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let o=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:o}),o}}let r=this.mlContextCache.findIndex(n=>pg(n.options,t));if(r!==-1)return this.mlContextCache[r].mlContext;{let n=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:n}),n}}get currentContext(){let t=this.getMLContext(this.currentSessionId);if(!t)throw new Error(`No MLContext found for session ${this.currentSessionId}`);return t}registerMLContext(t,r){this.mlContextBySessionId.set(t,r);let n=this.sessionIdsByMLContext.get(r);n||(n=new Set,this.sessionIdsByMLContext.set(r,n)),n.add(t)}onReleaseSession(t){let r=this.mlContextBySessionId.get(t);if(!r)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t);let n=this.sessionIdsByMLContext.get(r);if(n.delete(t),n.size===0){this.sessionIdsByMLContext.delete(r);let o=this.mlContextCache.findIndex(i=>i.mlContext===r);o!==-1&&this.mlContextCache.splice(o,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){se(\"verbose\",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,r,n,o){let i=oc.get(r);if(!i)throw new Error(`Unsupported ONNX data type: ${r}`);return this.tensorManager.ensureTensor(t,i,n,o)}uploadTensor(t,r){if(!Te().shouldTransferToMLTensor)throw new Error(\"Trying to upload to a MLTensor while shouldTransferToMLTensor is false\");se(\"verbose\",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${r.byteLength}}`),this.tensorManager.upload(t,r)}async downloadTensor(t,r){return this.tensorManager.download(t,r)}createMLTensorDownloader(t,r){return async()=>{let n=await this.tensorManager.download(t);return Rr(n,r)}}registerMLTensor(t,r,n){let o=oc.get(r);if(!o)throw new Error(`Unsupported ONNX data type: ${r}`);let i=this.tensorManager.registerTensor(this.currentContext,t,o,n);return se(\"verbose\",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${o}, dimensions: ${n}} -> {tensorId: ${i}}`),i}registerMLConstant(t,r,n,o,i,a){if(!a)throw new Error(\"External mounted files are not available.\");let d=t;t.startsWith(\"./\")&&(d=t.substring(2));let l=a.get(d);if(!l)throw new Error(`File with name ${d} not found in preloaded files.`);if(r+n>l.byteLength)throw new Error(\"Out of bounds: data offset and length exceed the external file data size.\");let p=l.slice(r,r+n).buffer,m;switch(i.dataType){case\"float32\":m=new Float32Array(p);break;case\"float16\":m=new Uint16Array(p);break;case\"int32\":m=new Int32Array(p);break;case\"uint32\":m=new Uint32Array(p);break;case\"int64\":m=new BigInt64Array(p);break;case\"uint64\":m=new BigUint64Array(p);break;case\"int8\":m=new Int8Array(p);break;case\"int4\":case\"uint4\":case\"uint8\":m=new Uint8Array(p);break;default:throw new Error(`Unsupported data type: ${i.dataType} in creating WebNN Constant from external data.`)}return se(\"verbose\",()=>`[WebNN] registerMLConstant {dataType: ${i.dataType}, shape: ${i.shape}}}`),o.constant(i,m)}flush(){}}});var ac={};Ht(ac,{init:()=>mg});var tr,ko,mg,sc=U(()=>{\"use strict\";J();Jl();et();ne();ic();tr=class e{constructor(t,r,n,o){this.module=t;this.dataType=r;this.data=n;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error(\"Invalid data type\");let t=k.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error(\"Invalid data type\");let t=k.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error(\"Invalid data type\");let t=k.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error(\"Invalid data type\");let t=k.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(k.size(t)!==k.size(this.dims))throw new Error(\"Invalid new shape\");return new e(this.module,this.dataType,this.data,t)}},ko=class{constructor(t,r,n){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=r.adapterInfo,this.deviceInfo=r.deviceInfo;let o=t.PTR_SIZE,i=n/t.PTR_SIZE,a=o===4?\"i32\":\"i64\";this.opKernelContext=Number(t.getValue(o*i++,a));let d=Number(t.getValue(o*i++,a));this.outputCount=Number(t.getValue(o*i++,a)),this.customDataOffset=Number(t.getValue(o*i++,\"*\")),this.customDataSize=Number(t.getValue(o*i++,a));let l=[];for(let p=0;p<d;p++){let m=Number(t.getValue(o*i++,a)),u=Number(t.getValue(o*i++,\"*\")),h=Number(t.getValue(o*i++,a)),_=[];for(let y=0;y<h;y++)_.push(Number(t.getValue(o*i++,a)));l.push(new tr(t,m,u,_))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let n=r?.inputs?.map(d=>typeof d==\"number\"?this.inputs[d]:d)??this.inputs,o=r?.outputs??[],i=(d,l,p)=>new tr(this.module,l,this.output(d,p),p),a=(d,l)=>{let p=At(d,l);if(!p)throw new Error(`Unsupported data type: ${d}`);let m=p>0?this.backend.gpuDataManager.create(p).id:0;return new tr(this.module,d,m,l)};return this.backend.run(t,n,o,i,a,this.outputCount)}output(t,r){let n=this.module.stackSave();try{let o=this.module.PTR_SIZE,i=o===4?\"i32\":\"i64\",a=this.module.stackAlloc((1+r.length)*o);this.module.setValue(a,r.length,i);for(let d=0;d<r.length;d++)this.module.setValue(a+o*(d+1),r[d],i);return this.module._JsepOutput(this.opKernelContext,t,a)}catch(o){throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(n)}}},mg=async(e,t,r,n)=>{let o=t.jsepInit;if(!o)throw new Error(\"Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.\");if(e===\"webgpu\"){let i=new nn;await i.initialize(r,n),o(\"webgpu\",[i,a=>i.alloc(Number(a)),a=>i.free(a),(a,d,l,p=!1)=>{if(p)se(\"verbose\",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(a)}, dst=${Number(d)}, size=${Number(l)}`),i.memcpy(Number(a),Number(d));else{se(\"verbose\",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(a)}, gpuDataId=${Number(d)}, size=${Number(l)}`);let m=t.HEAPU8.subarray(Number(a>>>0),Number(a>>>0)+Number(l));i.upload(Number(d),m)}},async(a,d,l)=>{se(\"verbose\",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${d}, size=${l}`),await i.download(Number(a),()=>t.HEAPU8.subarray(Number(d)>>>0,Number(d+l)>>>0))},(a,d,l)=>i.createKernel(a,Number(d),l,t.UTF8ToString(t._JsepGetNodeName(Number(d)))),a=>i.releaseKernel(a),(a,d,l,p)=>{se(\"verbose\",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${a}, contextDataOffset=${d}`);let m=new ko(t,i,Number(d));return i.computeKernel(Number(a),m,p)},()=>i.captureBegin(),()=>i.captureEnd(),()=>i.replay()])}else{let i=new sn(r);o(\"webnn\",[i,()=>i.reserveTensorId(),a=>i.releaseTensorId(a),async(a,d,l,p)=>i.ensureTensor(a,d,l,p),(a,d)=>{i.uploadTensor(a,d)},async(a,d)=>i.downloadTensor(a,d)])}}});var fg,Sr,Tr,zt,hg,qt,Ir,Cr,uc,Ar,kr,Er,Fn=U(()=>{\"use strict\";Ga();Fa();J();gt();zr();Qn();fg=(e,t)=>{Te()._OrtInit(e,t)!==0&&ce(\"Can't initialize onnxruntime.\")},Sr=async e=>{fg(e.wasm.numThreads,Yt(e.logLevel))},Tr=async(e,t)=>{{let r=(sc(),gr(ac)).init;if(t===\"webgpu\"){if(typeof navigator>\"u\"||!navigator.gpu)throw new Error(\"WebGPU is not supported in current environment\");let n=e.webgpu.adapter;if(n){if(typeof n.limits!=\"object\"||typeof n.features!=\"object\"||typeof n.requestDevice!=\"function\")throw new Error(\"Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.\")}else{let o=e.webgpu.powerPreference;if(o!==void 0&&o!==\"low-power\"&&o!==\"high-performance\")throw new Error(`Invalid powerPreference setting: \"${o}\"`);let i=e.webgpu.forceFallbackAdapter;if(i!==void 0&&typeof i!=\"boolean\")throw new Error(`Invalid forceFallbackAdapter setting: \"${i}\"`);if(n=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:i}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.')}await r(\"webgpu\",Te(),e,n)}if(t===\"webnn\"){if(typeof navigator>\"u\"||!navigator.ml)throw new Error(\"WebNN is not supported in current environment\");await r(\"webnn\",Te(),e)}}},zt=new Map,hg=e=>{let t=Te(),r=t.stackSave();try{let n=t.PTR_SIZE,o=t.stackAlloc(2*n);t._OrtGetInputOutputCount(e,o,o+n)!==0&&ce(\"Can't get session input/output count.\");let a=n===4?\"i32\":\"i64\";return[Number(t.getValue(o,a)),Number(t.getValue(o+n,a))]}finally{t.stackRestore(r)}},qt=e=>{let t=Te(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Ir=async(e,t)=>{let r,n,o=Te();Array.isArray(e)?[r,n]=e:e.buffer===o.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=qt(e);let i=0,a=0,d=0,l=[],p=[],m=[];try{if([a,l]=Ha(t),t?.externalData&&o.mountExternalData){let v=[];for(let S of t.externalData){let T=typeof S==\"string\"?S:S.path;v.push(Zt(typeof S==\"string\"?S:S.data).then(A=>{o.mountExternalData(T,A)}))}await Promise.all(v)}for(let v of t?.executionProviders??[])if((typeof v==\"string\"?v:v.name)===\"webnn\"){if(o.shouldTransferToMLTensor=!1,typeof v!=\"string\"){let T=v,A=T?.context,C=T?.gpuDevice,P=T?.deviceType,D=T?.powerPreference;A?o.currentContext=A:C?o.currentContext=await o.jsepCreateMLContext(C):o.currentContext=await o.jsepCreateMLContext({deviceType:P,powerPreference:D})}else o.currentContext=await o.jsepCreateMLContext();break}i=await o._OrtCreateSession(r,n,a),i===0&&ce(\"Can't create a session.\"),o.jsepOnCreateSession?.(),o.currentContext&&(o.jsepRegisterMLContext(i,o.currentContext),o.currentContext=void 0,o.shouldTransferToMLTensor=!0);let[u,h]=hg(i),_=!!t?.enableGraphCapture,y=[],g=[],x=[];for(let v=0;v<u;v++){let S=o._OrtGetInputName(i,v);S===0&&ce(\"Can't get an input name.\"),p.push(S),y.push(o.UTF8ToString(S))}for(let v=0;v<h;v++){let S=o._OrtGetOutputName(i,v);S===0&&ce(\"Can't get an output name.\"),m.push(S);let T=o.UTF8ToString(S);g.push(T);{if(_&&t?.preferredOutputLocation===void 0){x.push(\"gpu-buffer\");continue}let A=typeof t?.preferredOutputLocation==\"string\"?t.preferredOutputLocation:t?.preferredOutputLocation?.[T]??\"cpu\";if(A!==\"cpu\"&&A!==\"cpu-pinned\"&&A!==\"gpu-buffer\"&&A!==\"ml-tensor\")throw new Error(`Not supported preferred output location: ${A}.`);if(_&&A!==\"gpu-buffer\")throw new Error(`Not supported preferred output location: ${A}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);x.push(A)}}let $=null;return x.some(v=>v===\"gpu-buffer\"||v===\"ml-tensor\")&&(d=o._OrtCreateBinding(i),d===0&&ce(\"Can't create IO binding.\"),$={handle:d,outputPreferredLocations:x,outputPreferredLocationsEncoded:x.map(v=>Zn(v))}),zt.set(i,[i,p,m,$,_,!1]),[i,y,g]}catch(u){throw p.forEach(h=>o._OrtFree(h)),m.forEach(h=>o._OrtFree(h)),d!==0&&o._OrtReleaseBinding(d)!==0&&ce(\"Can't release IO binding.\"),i!==0&&o._OrtReleaseSession(i)!==0&&ce(\"Can't release session.\"),u}finally{o._free(r),a!==0&&o._OrtReleaseSessionOptions(a)!==0&&ce(\"Can't release session options.\"),l.forEach(u=>o._free(u)),o.unmountExternalData?.()}},Cr=e=>{let t=Te(),r=zt.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[n,o,i,a,d]=r;a&&(d&&t._OrtClearBoundOutputs(a.handle)!==0&&ce(\"Can't clear bound outputs.\"),t._OrtReleaseBinding(a.handle)!==0&&ce(\"Can't release IO binding.\")),t.jsepOnReleaseSession?.(e),o.forEach(l=>t._OrtFree(l)),i.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(n)!==0&&ce(\"Can't release session.\"),zt.delete(e)},uc=(e,t,r,n,o,i=!1)=>{if(!e){t.push(0);return}let a=Te(),d=a.PTR_SIZE,l=e[0],p=e[1],m=e[3],u,h;if(l===\"string\"&&(m===\"gpu-buffer\"||m===\"ml-tensor\"))throw new Error(\"String tensor is not supported on GPU.\");if(i&&m!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if(m===\"gpu-buffer\"){let g=e[2].gpuBuffer;h=At(jt(l),p);let x=a.jsepRegisterBuffer;if(!x)throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');u=x(n,o,g,h)}else if(m===\"ml-tensor\"){let g=e[2].mlTensor;h=At(jt(l),p);let x=a.jsepRegisterMLTensor;if(!x)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');u=x(g,jt(l),p)}else{let g=e[2];if(Array.isArray(g)){h=d*g.length,u=a._malloc(h),r.push(u);for(let x=0;x<g.length;x++){if(typeof g[x]!=\"string\")throw new TypeError(`tensor data at index ${x} is not a string`);a.setValue(u+x*d,ke(g[x],r),\"*\")}}else h=g.byteLength,u=a._malloc(h),r.push(u),a.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,h),u)}let _=a.stackSave(),y=a.stackAlloc(4*p.length);try{p.forEach((x,$)=>a.setValue(y+$*d,x,d===4?\"i32\":\"i64\"));let g=a._OrtCreateTensor(jt(l),u,h,y,p.length,Zn(m));g===0&&ce(`Can't create tensor for input/output. session=${n}, index=${o}.`),t.push(g)}finally{a.stackRestore(_)}},Ar=async(e,t,r,n,o,i)=>{let a=Te(),d=a.PTR_SIZE,l=zt.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let p=l[0],m=l[1],u=l[2],h=l[3],_=l[4],y=l[5],g=t.length,x=n.length,$=0,v=[],S=[],T=[],A=[],C=a.stackSave(),P=a.stackAlloc(g*d),D=a.stackAlloc(g*d),R=a.stackAlloc(x*d),H=a.stackAlloc(x*d);try{a.jsepOnRunStart?.(p),[$,v]=La(i);for(let V=0;V<g;V++)uc(r[V],S,A,e,t[V],_);for(let V=0;V<x;V++)uc(o[V],T,A,e,g+n[V],_);for(let V=0;V<g;V++)a.setValue(P+V*d,S[V],\"*\"),a.setValue(D+V*d,m[t[V]],\"*\");for(let V=0;V<x;V++)a.setValue(R+V*d,T[V],\"*\"),a.setValue(H+V*d,u[n[V]],\"*\");if(h&&!y){let{handle:V,outputPreferredLocations:K,outputPreferredLocationsEncoded:we}=h;if(m.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${m.length}).`);for(let j=0;j<g;j++){let Q=t[j];await a._OrtBindInput(V,m[Q],S[j])!==0&&ce(`Can't bind input[${j}] for session=${e}.`)}for(let j=0;j<x;j++){let Q=n[j];o[j]?.[3]?a._OrtBindOutput(V,u[Q],T[j],0)!==0&&ce(`Can't bind pre-allocated output[${j}] for session=${e}.`):a._OrtBindOutput(V,u[Q],0,we[Q])!==0&&ce(`Can't bind output[${j}] to ${K[j]} for session=${e}.`)}zt.set(e,[p,m,u,h,_,!0])}let L;h?L=await a._OrtRunWithBinding(p,h.handle,x,R,$):L=await a._OrtRun(p,D,P,g,H,x,R,$),L!==0&&ce(\"failed to call OrtRun().\");let re=[];for(let V=0;V<x;V++){let K=Number(a.getValue(R+V*d,\"*\"));if(K===T[V]){re.push(o[V]);continue}let we=a.stackSave(),j=a.stackAlloc(4*d),Q=!1,ie,te=0;try{a._OrtGetTensorData(K,j,j+d,j+2*d,j+3*d)!==0&&ce(`Can't access output tensor data on index ${V}.`);let Oe=d===4?\"i32\":\"i64\",ve=Number(a.getValue(j,Oe));te=a.getValue(j+d,\"*\");let de=a.getValue(j+d*2,\"*\"),W=Number(a.getValue(j+d*3,Oe)),Y=[];for(let pe=0;pe<W;pe++)Y.push(Number(a.getValue(de+pe*d,Oe)));a._OrtFree(de)!==0&&ce(\"Can't free memory for tensor dims.\");let he=Y.reduce((pe,Ie)=>pe*Ie,1);ie=bt(ve);let De=h?.outputPreferredLocations[n[V]];if(ie===\"string\"){if(De===\"gpu-buffer\"||De===\"ml-tensor\")throw new Error(\"String tensor is not supported on GPU.\");let pe=[];for(let Ie=0;Ie<he;Ie++){let He=a.getValue(te+Ie*d,\"*\"),mn=a.getValue(te+(Ie+1)*d,\"*\"),wt=Ie===he-1?void 0:mn-He;pe.push(a.UTF8ToString(He,wt))}re.push([ie,Y,pe,\"cpu\"])}else if(De===\"gpu-buffer\"&&he>0){let pe=a.jsepGetBuffer;if(!pe)throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');let Ie=pe(te),He=At(ve,he);if(He===void 0||!Dr(ie))throw new Error(`Unsupported data type: ${ie}`);Q=!0,re.push([ie,Y,{gpuBuffer:Ie,download:a.jsepCreateDownloader(Ie,He,ie),dispose:()=>{a._OrtReleaseTensor(K)!==0&&ce(\"Can't release tensor.\")}},\"gpu-buffer\"])}else if(De===\"ml-tensor\"&&he>0){let pe=a.jsepEnsureTensor;if(!pe)throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');if(At(ve,he)===void 0||!Br(ie))throw new Error(`Unsupported data type: ${ie}`);let He=await pe(te,ve,Y,!1);Q=!0,re.push([ie,Y,{mlTensor:He,download:a.jsepCreateMLTensorDownloader(te,ie),dispose:()=>{a.jsepReleaseTensorId(te),a._OrtReleaseTensor(K)}},\"ml-tensor\"])}else{let pe=Or(ie),Ie=new pe(he);new Uint8Array(Ie.buffer,Ie.byteOffset,Ie.byteLength).set(a.HEAPU8.subarray(te,te+Ie.byteLength)),re.push([ie,Y,Ie,\"cpu\"])}}finally{a.stackRestore(we),ie===\"string\"&&te&&a._free(te),Q||a._OrtReleaseTensor(K)}}return h&&!_&&(a._OrtClearBoundOutputs(h.handle)!==0&&ce(\"Can't clear bound outputs.\"),zt.set(e,[p,m,u,h,_,!1])),re}finally{a.stackRestore(C),S.forEach(L=>a._OrtReleaseTensor(L)),T.forEach(L=>a._OrtReleaseTensor(L)),A.forEach(L=>a._free(L)),$!==0&&a._OrtReleaseRunOptions($),v.forEach(L=>a._free(L))}},kr=e=>{let t=Te(),r=zt.get(e);if(!r)throw new Error(\"invalid session id\");let n=r[0],o=t._OrtEndProfiling(n);o===0&&ce(\"Can't get an profile file name.\"),t._OrtFree(o)},Er=e=>{let t=[];for(let r of e){let n=r[2];!Array.isArray(n)&&\"buffer\"in n&&t.push(n.buffer)}return t}});var Ot,Ge,rr,dn,ln,un,Eo,Po,Wt,Lt,bg,dc,lc,cc,pc,mc,fc,hc,zo=U(()=>{\"use strict\";Le();Fn();gt();$r();Ot=()=>!!_e.wasm.proxy&&typeof document<\"u\",rr=!1,dn=!1,ln=!1,Po=new Map,Wt=(e,t)=>{let r=Po.get(e);r?r.push(t):Po.set(e,[t])},Lt=()=>{if(rr||!dn||ln||!Ge)throw new Error(\"worker not ready\")},bg=e=>{switch(e.data.type){case\"init-wasm\":rr=!1,e.data.err?(ln=!0,Eo[1](e.data.err)):(dn=!0,Eo[0]()),un&&(URL.revokeObjectURL(un),un=void 0);break;case\"init-ep\":case\"copy-from\":case\"create\":case\"release\":case\"run\":case\"end-profiling\":{let t=Po.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}default:}},dc=async()=>{if(!dn){if(rr)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(ln)throw new Error(\"previous call to 'initWasm()' failed.\");if(rr=!0,Ot())return new Promise((e,t)=>{Ge?.terminate(),Na().then(([r,n])=>{try{Ge=n,Ge.onerror=i=>t(i),Ge.onmessage=bg,Eo=[e,t];let o={type:\"init-wasm\",in:_e};!o.in.wasm.wasmPaths&&(r||\"file:///Users/kluless/flowerpress/node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\"))&&(o.in.wasm.wasmPaths={wasm:/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href}),Ge.postMessage(o),un=r}catch(o){t(o)}},t)});try{await xr(_e.wasm),await Sr(_e),dn=!0}catch(e){throw ln=!0,e}finally{rr=!1}}},lc=async e=>{if(Ot())return Lt(),new Promise((t,r)=>{Wt(\"init-ep\",[t,r]);let n={type:\"init-ep\",in:{epName:e,env:_e}};Ge.postMessage(n)});await Tr(_e,e)},cc=async e=>Ot()?(Lt(),new Promise((t,r)=>{Wt(\"copy-from\",[t,r]);let n={type:\"copy-from\",in:{buffer:e}};Ge.postMessage(n,[e.buffer])})):qt(e),pc=async(e,t)=>{if(Ot()){if(t?.preferredOutputLocation)throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');return Lt(),new Promise((r,n)=>{Wt(\"create\",[r,n]);let o={type:\"create\",in:{model:e,options:{...t}}},i=[];e instanceof Uint8Array&&i.push(e.buffer),Ge.postMessage(o,i)})}else return Ir(e,t)},mc=async e=>{if(Ot())return Lt(),new Promise((t,r)=>{Wt(\"release\",[t,r]);let n={type:\"release\",in:e};Ge.postMessage(n)});Cr(e)},fc=async(e,t,r,n,o,i)=>{if(Ot()){if(r.some(a=>a[3]!==\"cpu\"))throw new Error(\"input tensor on GPU is not supported for proxy.\");if(o.some(a=>a))throw new Error(\"pre-allocated output tensor is not supported for proxy.\");return Lt(),new Promise((a,d)=>{Wt(\"run\",[a,d]);let l=r,p={type:\"run\",in:{sessionId:e,inputIndices:t,inputs:l,outputIndices:n,options:i}};Ge.postMessage(p,Er(l))})}else return Ar(e,t,r,n,o,i)},hc=async e=>{if(Ot())return Lt(),new Promise((t,r)=>{Wt(\"end-profiling\",[t,r]);let n={type:\"end-profiling\",in:e};Ge.postMessage(n)});kr(e)}});var gc,yg,cn,bc=U(()=>{\"use strict\";Le();zo();J();vr();Qn();gc=(e,t)=>{switch(e.location){case\"cpu\":return[e.type,e.dims,e.data,\"cpu\"];case\"gpu-buffer\":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},\"gpu-buffer\"];case\"ml-tensor\":return[e.type,e.dims,{mlTensor:e.mlTensor},\"ml-tensor\"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},yg=e=>{switch(e[3]){case\"cpu\":return new Fe(e[0],e[2],e[1]);case\"gpu-buffer\":{let t=e[0];if(!Dr(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:n,dispose:o}=e[2];return Fe.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:o})}case\"ml-tensor\":{let t=e[0];if(!Br(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:n,dispose:o}=e[2];return Fe.fromMLTensor(r,{dataType:t,dims:e[1],download:n,dispose:o})}default:throw new Error(`invalid data location: ${e[3]}`)}},cn=class{async fetchModelAndCopyToWasmMemory(t){return cc(await Zt(t))}async loadModel(t,r){Ne();let n;typeof t==\"string\"? false?0:n=await this.fetchModelAndCopyToWasmMemory(t):n=t,[this.sessionId,this.inputNames,this.outputNames]=await pc(n,r),Be()}async dispose(){return mc(this.sessionId)}async run(t,r,n){Ne();let o=[],i=[];Object.entries(t).forEach(h=>{let _=h[0],y=h[1],g=this.inputNames.indexOf(_);if(g===-1)throw new Error(`invalid input '${_}'`);o.push(y),i.push(g)});let a=[],d=[];Object.entries(r).forEach(h=>{let _=h[0],y=h[1],g=this.outputNames.indexOf(_);if(g===-1)throw new Error(`invalid output '${_}'`);a.push(y),d.push(g)});let l=o.map((h,_)=>gc(h,()=>`input \"${this.inputNames[i[_]]}\"`)),p=a.map((h,_)=>h?gc(h,()=>`output \"${this.outputNames[d[_]]}\"`):null),m=await fc(this.sessionId,i,l,d,p,n),u={};for(let h=0;h<m.length;h++)u[this.outputNames[d[h]]]=a[h]??yg(m[h]);return Be(),u}startProfiling(){}endProfiling(){hc(this.sessionId)}}});var _c={};Ht(_c,{OnnxruntimeWebAssemblyBackend:()=>pn,initializeFlags:()=>yc,wasmBackend:()=>_g});var yc,pn,_g,wc=U(()=>{\"use strict\";Le();zo();bc();yc=()=>{if((typeof _e.wasm.initTimeout!=\"number\"||_e.wasm.initTimeout<0)&&(_e.wasm.initTimeout=0),_e.wasm.simd===!1&&console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof _e.wasm.proxy!=\"boolean\"&&(_e.wasm.proxy=!1),typeof _e.wasm.trace!=\"boolean\"&&(_e.wasm.trace=!1),typeof _e.wasm.numThreads!=\"number\"||!Number.isInteger(_e.wasm.numThreads)||_e.wasm.numThreads<=0)if(typeof self<\"u\"&&!self.crossOriginIsolated)_e.wasm.numThreads=1;else{let e=typeof navigator>\"u\"?Un(\"node:os\").cpus().length:navigator.hardwareConcurrency;_e.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},pn=class{async init(t){yc(),await dc(),await lc(t)}async createInferenceSessionHandler(t,r){let n=new cn;return await n.loadModel(t,r),Promise.resolve(n)}},_g=new pn});Le();Le();Le();var Ia=\"1.21.0-dev.20250206-d981b153d3\";var $1=Hn;{let e=(wc(),gr(_c)).wasmBackend;Tt(\"webgpu\",e,5),Tt(\"webnn\",e,5),Tt(\"cpu\",e,10),Tt(\"wasm\",e,10)}Object.defineProperty(_e.versions,\"web\",{value:Ia,enumerable:!0});\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n//# sourceMappingURL=ort.webgpu.bundle.min.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vb25ueHJ1bnRpbWUtd2ViQDEuMjEuMC1kZXYuMjAyNTAyMDYtZDk4MWIxNTNkMy9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LndlYmdwdS5idW5kbGUubWluLm1qcz9lYjc3IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUMsa0NBQWtDLHVDQUF1QyxvRUFBb0UsNkNBQTZDLGlCQUFpQiwyREFBMkQsMkRBQTJELEVBQUUsbUNBQW1DLGVBQWUsdUJBQXVCLHVCQUF1QixFQUFFLGdCQUFnQixnR0FBZ0csbURBQW1ELEVBQUUsVUFBVSxrQkFBa0IsZUFBZSxTQUFTLEtBQUssNkJBQTZCLGFBQWEsOEJBQThCLHFGQUFxRixnQkFBZ0Isd0JBQXdCLHFCQUFxQixFQUFFLEtBQUssdUJBQXVCLDZFQUE2RSxFQUFFLG1CQUFtQixFQUFFLEdBQUcsU0FBUyxvQkFBb0IsdUJBQXVCLFlBQVksWUFBWSxrQ0FBa0MsaUJBQWlCLE9BQU8sV0FBVyxPQUFPLDJDQUEyQyxjQUFjLGdCQUFnQixpQ0FBaUMsa0NBQWtDLDZCQUE2QixzQkFBc0IsSUFBSSwyRkFBMkYsU0FBUyxzQkFBc0IsRUFBRSx3QkFBd0IsUUFBUSx1QkFBdUIsY0FBYyw0R0FBNEcsZ0JBQWdCLGtCQUFrQiwyQkFBMkIsYUFBYSw2QkFBNkIsMERBQTBELGFBQWEsT0FBTyxJQUFJLE1BQU0sY0FBYyxHQUFHLFFBQVEsYUFBYSwyRUFBMkUsRUFBRSxzREFBc0QsRUFBRSxHQUFHLHNEQUFzRCxzQkFBc0IsdURBQXVELElBQUksRUFBRSxjQUFjLGFBQWEsS0FBSyxFQUFFLGlCQUFpQixhQUFhLG9DQUFvQyxFQUFFLG9CQUFvQixhQUFhLEtBQUssaUJBQWlCLE9BQU8sU0FBUyxVQUFVLFdBQVcsVUFBVSxpQkFBaUIsZUFBZSxrSUFBa0ksRUFBRSxHQUFHLE1BQU0sZ0JBQWdCLFlB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SSxvQkFBb0IsRUFBRSxjQUFjLDhCQUE4QixnREFBZ0QsNkNBQTZDLEVBQUUsSUFBSSxvQkFBb0IsRUFBRSxzQ0FBc0Msc0JBQXNCLDBDQUEwQyx1QkFBdUIsb0RBQW9ELFlBQVksV0FBVyw2Q0FBNkMsY0FBYyxrQkFBa0IsZUFBZSxxQkFBcUIsRUFBRSxVQUFVLE9BQU8sK0VBQStFLEVBQUUsdUJBQXVCLGFBQWEsS0FBSyxLQUFLLEtBQUssUUFBUSx1Z0JBQXVnQixLQUFLLHFGQUFxRixvREFBb0QsVUFBVSxjQUFjLDRCQUE0Qix5Q0FBeUMsYUFBYSxrREFBa0QsV0FBVyxFQUFFLEtBQUssS0FBSyxLQUFLLHdDQUF3QyxXQUFXLGdDQUFnQyxnRUFBZ0UseUNBQXlDLHVCQUF1QixFQUFvSjtBQUNsaHpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMva2x1bGVzcy9mbG93ZXJwcmVzcy9ub2RlX21vZHVsZXMvLnBucG0vb25ueHJ1bnRpbWUtd2ViQDEuMjEuMC1kZXYuMjAyNTAyMDYtZDk4MWIxNTNkMy9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LndlYmdwdS5idW5kbGUubWluLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE9OTlggUnVudGltZSBXZWIgdjEuMjEuMC1kZXYuMjAyNTAyMDYtZDk4MWIxNTNkM1xuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbnZhciBSbj1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIFZwPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIFdwPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBMcD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBVbj0oZT0+dHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0eXBlb2YgUHJveHk8XCJ1XCI/bmV3IFByb3h5KGUse2dldDoodCxyKT0+KHR5cGVvZiByZXF1aXJlPFwidVwiP3JlcXVpcmU6dClbcl19KTplKShmdW5jdGlvbihlKXtpZih0eXBlb2YgcmVxdWlyZTxcInVcIilyZXR1cm4gcmVxdWlyZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhyb3cgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZSBvZiBcIicrZSsnXCIgaXMgbm90IHN1cHBvcnRlZCcpfSk7dmFyIFU9KGUsdCk9PigpPT4oZSYmKHQ9ZShlPTApKSx0KTt2YXIgSHQ9KGUsdCk9Pntmb3IodmFyIHIgaW4gdClSbihlLHIse2dldDp0W3JdLGVudW1lcmFibGU6ITB9KX0sR3A9KGUsdCxyLG4pPT57aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ8fHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpZm9yKGxldCBvIG9mIFdwKHQpKSFMcC5jYWxsKGUsbykmJm8hPT1yJiZSbihlLG8se2dldDooKT0+dFtvXSxlbnVtZXJhYmxlOiEobj1WcCh0LG8pKXx8bi5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9O3ZhciBncj1lPT5HcChSbih7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgYnIsU3QsVHQsSHAsWGksTm49VSgoKT0+e1widXNlIHN0cmljdFwiO2JyPW5ldyBNYXAsU3Q9W10sVHQ9KGUsdCxyKT0+e2lmKHQmJnR5cGVvZiB0LmluaXQ9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI9PVwiZnVuY3Rpb25cIil7bGV0IG49YnIuZ2V0KGUpO2lmKG49PT12b2lkIDApYnIuc2V0KGUse2JhY2tlbmQ6dCxwcmlvcml0eTpyfSk7ZWxzZXtpZihuLnByaW9yaXR5PnIpcmV0dXJuO2lmKG4ucHJpb3JpdHk9PT1yJiZuLmJhY2tlbmQhPT10KXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke2V9XCIgdXNpbmcgcHJpb3JpdHkgJHtyfWApfWlmKHI+PTApe2xldCBvPVN0LmluZGV4T2YoZSk7byE9PS0xJiZTdC5zcGxpY2UobywxKTtmb3IobGV0IGk9MDtpPFN0Lmxlbmd0aDtpKyspaWYoYnIuZ2V0KFN0W2ldKS5wcmlvcml0eTw9cil7U3Quc3BsaWNlKGksMCxlKTtyZXR1cm59U3QucHVzaChlKX1yZXR1cm59dGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIHZhbGlkIGJhY2tlbmRcIil9LEhwPWFzeW5jIGU9PntsZXQgdD1ici5nZXQoZSk7aWYoIXQpcmV0dXJuXCJiYWNrZW5kIG5vdCBmb3VuZC5cIjtpZih0LmluaXRpYWxpemVkKXJldHVybiB0LmJhY2tlbmQ7aWYodC5hYm9ydGVkKXJldHVybiB0LmVycm9yO3tsZXQgcj0hIXQuaW5pdFByb21pc2U7dHJ5e3JldHVybiByfHwodC5pbml0UHJvbWlzZT10LmJhY2tlbmQuaW5pdChlKSksYXdhaXQgdC5pbml0UHJvbWlzZSx0LmluaXRpYWxpemVkPSEwLHQuYmFja2VuZH1jYXRjaChuKXtyZXR1cm4gcnx8KHQuZXJyb3I9YCR7bn1gLHQuYWJvcnRlZD0hMCksdC5lcnJvcn1maW5hbGx5e2RlbGV0ZSB0LmluaXRQcm9taXNlfX19LFhpPWFzeW5jIGU9PntsZXQgdD1lLmV4ZWN1dGlvblByb3ZpZGVyc3x8W10scj10Lm1hcChsPT50eXBlb2YgbD09XCJzdHJpbmdcIj9sOmwubmFtZSksbj1yLmxlbmd0aD09PTA/U3Q6cixvLGk9W10sYT1uZXcgU2V0O2ZvcihsZXQgbCBvZiBuKXtsZXQgcD1hd2FpdCBIcChsKTt0eXBlb2YgcD09XCJzdHJpbmdcIj9pLnB1c2goe25hbWU6bCxlcnI6cH0pOihvfHwobz1wKSxvPT09cCYmYS5hZGQobCkpfWlmKCFvKXRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHtpLm1hcChsPT5gWyR7bC5uYW1lfV0gJHtsLmVycn1gKS5qb2luKFwiLCBcIil9YCk7Zm9yKGxldHtuYW1lOmwsZXJyOnB9b2YgaSlyLmluY2x1ZGVzKGwpJiZjb25zb2xlLndhcm4oYHJlbW92aW5nIHJlcXVlc3RlZCBleGVjdXRpb24gcHJvdmlkZXIgXCIke2x9XCIgZnJvbSBzZXNzaW9uIG9wdGlvbnMgYmVjYXVzZSBpdCBpcyBub3QgYXZhaWxhYmxlOiAke3B9YCk7bGV0IGQ9dC5maWx0ZXIobD0+YS5oYXModHlwZW9mIGw9PVwic3RyaW5nXCI/bDpsLm5hbWUpKTtyZXR1cm5bbyxuZXcgUHJveHkoZSx7Z2V0OihsLHApPT5wPT09XCJleGVjdXRpb25Qcm92aWRlcnNcIj9kOlJlZmxlY3QuZ2V0KGwscCl9KV19fSk7dmFyIEppPVUoKCk9PntcInVzZSBzdHJpY3RcIjtObigpfSk7dmFyIGVhLHRhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtlYT1cIjEuMjEuMC1kZXYuMjAyNTAyMDYtZDk4MWIxNTNkM1wifSk7dmFyIHJhLFVlLFZuPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0YSgpO3JhPVwid2FybmluZ1wiLFVlPXt3YXNtOnt9LHdlYmdsOnt9LHdlYmdwdTp7fSx2ZXJzaW9uczp7Y29tbW9uOmVhfSxzZXQgbG9nTGV2ZWwoZSl7aWYoZSE9PXZvaWQgMCl7aWYodHlwZW9mIGUhPVwic3RyaW5nXCJ8fFtcInZlcmJvc2VcIixcImluZm9cIixcIndhcm5pbmdcIixcImVycm9yXCIsXCJmYXRhbFwiXS5pbmRleE9mKGUpPT09LTEpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCk7cmE9ZX19LGdldCBsb2dMZXZlbCgpe3JldHVybiByYX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShVZSxcImxvZ0xldmVsXCIse2VudW1lcmFibGU6ITB9KX0pO3ZhciBfZSxuYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Vm4oKTtfZT1VZX0pO3ZhciBvYSxpYSxhYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7b2E9KGUsdCk9PntsZXQgcj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTpuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7ci53aWR0aD1lLmRpbXNbM10sci5oZWlnaHQ9ZS5kaW1zWzJdO2xldCBuPXIuZ2V0Q29udGV4dChcIjJkXCIpO2lmKG4hPW51bGwpe2xldCBvLGk7dD8udGVuc29yTGF5b3V0IT09dm9pZCAwJiZ0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiPyhvPWUuZGltc1syXSxpPWUuZGltc1szXSk6KG89ZS5kaW1zWzNdLGk9ZS5kaW1zWzJdKTtsZXQgYT10Py5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JcIixkPXQ/Lm5vcm0sbCxwO2Q9PT12b2lkIDB8fGQubWVhbj09PXZvaWQgMD9sPVsyNTUsMjU1LDI1NSwyNTVdOnR5cGVvZiBkLm1lYW49PVwibnVtYmVyXCI/bD1bZC5tZWFuLGQubWVhbixkLm1lYW4sZC5tZWFuXToobD1bZC5tZWFuWzBdLGQubWVhblsxXSxkLm1lYW5bMl0sMF0sZC5tZWFuWzNdIT09dm9pZCAwJiYobFszXT1kLm1lYW5bM10pKSxkPT09dm9pZCAwfHxkLmJpYXM9PT12b2lkIDA/cD1bMCwwLDAsMF06dHlwZW9mIGQuYmlhcz09XCJudW1iZXJcIj9wPVtkLmJpYXMsZC5iaWFzLGQuYmlhcyxkLmJpYXNdOihwPVtkLmJpYXNbMF0sZC5iaWFzWzFdLGQuYmlhc1syXSwwXSxkLmJpYXNbM10hPT12b2lkIDAmJihwWzNdPWQuYmlhc1szXSkpO2xldCBtPWkqbyx1PTAsaD1tLF89bSoyLHk9LTE7YT09PVwiUkdCQVwiPyh1PTAsaD1tLF89bSoyLHk9bSozKTphPT09XCJSR0JcIj8odT0wLGg9bSxfPW0qMik6YT09PVwiUkJHXCImJih1PTAsXz1tLGg9bSoyKTtmb3IobGV0IGc9MDtnPGk7ZysrKWZvcihsZXQgeD0wO3g8bzt4Kyspe2xldCAkPShlLmRhdGFbdSsrXS1wWzBdKSpsWzBdLHY9KGUuZGF0YVtoKytdLXBbMV0pKmxbMV0sUz0oZS5kYXRhW18rK10tcFsyXSkqbFsyXSxUPXk9PT0tMT8yNTU6KGUuZGF0YVt5KytdLXBbM10pKmxbM107bi5maWxsU3R5bGU9XCJyZ2JhKFwiKyQrXCIsXCIrditcIixcIitTK1wiLFwiK1QrXCIpXCIsbi5maWxsUmVjdCh4LGcsMSwxKX1pZihcInRvRGF0YVVSTFwiaW4gcilyZXR1cm4gci50b0RhdGFVUkwoKTt0aHJvdyBuZXcgRXJyb3IoXCJ0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9LGlhPShlLHQpPT57bGV0IHI9dHlwZW9mIGRvY3VtZW50PFwidVwiP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKS5nZXRDb250ZXh0KFwiMmRcIiksbjtpZihyIT1udWxsKXtsZXQgbyxpLGE7dD8udGVuc29yTGF5b3V0IT09dm9pZCAwJiZ0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiPyhvPWUuZGltc1syXSxpPWUuZGltc1sxXSxhPWUuZGltc1szXSk6KG89ZS5kaW1zWzNdLGk9ZS5kaW1zWzJdLGE9ZS5kaW1zWzFdKTtsZXQgZD10IT09dm9pZCAwJiZ0LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGw9dD8ubm9ybSxwLG07bD09PXZvaWQgMHx8bC5tZWFuPT09dm9pZCAwP3A9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGwubWVhbj09XCJudW1iZXJcIj9wPVtsLm1lYW4sbC5tZWFuLGwubWVhbixsLm1lYW5dOihwPVtsLm1lYW5bMF0sbC5tZWFuWzFdLGwubWVhblsyXSwyNTVdLGwubWVhblszXSE9PXZvaWQgMCYmKHBbM109bC5tZWFuWzNdKSksbD09PXZvaWQgMHx8bC5iaWFzPT09dm9pZCAwP209WzAsMCwwLDBdOnR5cGVvZiBsLmJpYXM9PVwibnVtYmVyXCI/bT1bbC5iaWFzLGwuYmlhcyxsLmJpYXMsbC5iaWFzXToobT1bbC5iaWFzWzBdLGwuYmlhc1sxXSxsLmJpYXNbMl0sMF0sbC5iaWFzWzNdIT09dm9pZCAwJiYobVszXT1sLmJpYXNbM10pKTtsZXQgdT1pKm87aWYodCE9PXZvaWQgMCYmKHQuZm9ybWF0IT09dm9pZCAwJiZhPT09NCYmdC5mb3JtYXQhPT1cIlJHQkFcInx8YT09PTMmJnQuZm9ybWF0IT09XCJSR0JcIiYmdC5mb3JtYXQhPT1cIkJHUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgZm9ybWF0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXNcIik7bGV0IGg9NCxfPTAseT0xLGc9Mix4PTMsJD0wLHY9dSxTPXUqMixUPS0xO2Q9PT1cIlJHQkFcIj8oJD0wLHY9dSxTPXUqMixUPXUqMyk6ZD09PVwiUkdCXCI/KCQ9MCx2PXUsUz11KjIpOmQ9PT1cIlJCR1wiJiYoJD0wLFM9dSx2PXUqMiksbj1yLmNyZWF0ZUltYWdlRGF0YShvLGkpO2ZvcihsZXQgQT0wO0E8aSpvO18rPWgseSs9aCxnKz1oLHgrPWgsQSsrKW4uZGF0YVtfXT0oZS5kYXRhWyQrK10tbVswXSkqcFswXSxuLmRhdGFbeV09KGUuZGF0YVt2KytdLW1bMV0pKnBbMV0sbi5kYXRhW2ddPShlLmRhdGFbUysrXS1tWzJdKSpwWzJdLG4uZGF0YVt4XT1UPT09LTE/MjU1OihlLmRhdGFbVCsrXS1tWzNdKSpwWzNdfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKTtyZXR1cm4gbn19KTt2YXIgV24sc2EsdWEsZGEsbGEsY2EscGE9VSgoKT0+e1widXNlIHN0cmljdFwiO3lyKCk7V249KGUsdCk9PntpZihlPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWRcIik7aWYodC5oZWlnaHQ9PT12b2lkIDB8fHQud2lkdGg9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWRcIik7aWYodC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoXCJOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7bGV0e2hlaWdodDpyLHdpZHRoOm59PXQsbz10Lm5vcm0/P3ttZWFuOjI1NSxiaWFzOjB9LGksYTt0eXBlb2Ygby5tZWFuPT1cIm51bWJlclwiP2k9W28ubWVhbixvLm1lYW4sby5tZWFuLG8ubWVhbl06aT1bby5tZWFuWzBdLG8ubWVhblsxXSxvLm1lYW5bMl0sby5tZWFuWzNdPz8yNTVdLHR5cGVvZiBvLmJpYXM9PVwibnVtYmVyXCI/YT1bby5iaWFzLG8uYmlhcyxvLmJpYXMsby5iaWFzXTphPVtvLmJpYXNbMF0sby5iaWFzWzFdLG8uYmlhc1syXSxvLmJpYXNbM10/PzBdO2xldCBkPXQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCQVwiLGw9dC50ZW5zb3JGb3JtYXQhPT12b2lkIDAmJnQudGVuc29yRm9ybWF0IT09dm9pZCAwP3QudGVuc29yRm9ybWF0OlwiUkdCXCIscD1yKm4sbT1sPT09XCJSR0JBXCI/bmV3IEZsb2F0MzJBcnJheShwKjQpOm5ldyBGbG9hdDMyQXJyYXkocCozKSx1PTQsaD0wLF89MSx5PTIsZz0zLHg9MCwkPXAsdj1wKjIsUz0tMTtkPT09XCJSR0JcIiYmKHU9MyxoPTAsXz0xLHk9MixnPS0xKSxsPT09XCJSR0JBXCI/Uz1wKjM6bD09PVwiUkJHXCI/KHg9MCx2PXAsJD1wKjIpOmw9PT1cIkJHUlwiJiYodj0wLCQ9cCx4PXAqMik7Zm9yKGxldCBBPTA7QTxwO0ErKyxoKz11LHkrPXUsXys9dSxnKz11KW1beCsrXT0oZVtoXSthWzBdKS9pWzBdLG1bJCsrXT0oZVtfXSthWzFdKS9pWzFdLG1bdisrXT0oZVt5XSthWzJdKS9pWzJdLFMhPT0tMSYmZyE9PS0xJiYobVtTKytdPShlW2ddK2FbM10pL2lbM10pO3JldHVybiBsPT09XCJSR0JBXCI/bmV3IHplKFwiZmxvYXQzMlwiLG0sWzEsNCxyLG5dKTpuZXcgemUoXCJmbG9hdDMyXCIsbSxbMSwzLHIsbl0pfSxzYT1hc3luYyhlLHQpPT57bGV0IHI9dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8XCJ1XCImJmUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50LG49dHlwZW9mIEltYWdlRGF0YTxcInVcIiYmZSBpbnN0YW5jZW9mIEltYWdlRGF0YSxvPXR5cGVvZiBJbWFnZUJpdG1hcDxcInVcIiYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwLGk9dHlwZW9mIGU9PVwic3RyaW5nXCIsYSxkPXQ/P3t9LGw9KCk9PntpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7aWYodHlwZW9mIE9mZnNjcmVlbkNhbnZhczxcInVcIilyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpO3Rocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkXCIpfSxwPW09PnR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDxcInVcIiYmbSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHxtIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzP20uZ2V0Q29udGV4dChcIjJkXCIpOm51bGw7aWYocil7bGV0IG09bCgpO20ud2lkdGg9ZS53aWR0aCxtLmhlaWdodD1lLmhlaWdodDtsZXQgdT1wKG0pO2lmKHUhPW51bGwpe2xldCBoPWUuaGVpZ2h0LF89ZS53aWR0aDtpZih0IT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiYoaD10LnJlc2l6ZWRIZWlnaHQsXz10LnJlc2l6ZWRXaWR0aCksdCE9PXZvaWQgMCl7aWYoZD10LHQudGVuc29yRm9ybWF0IT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50XCIpO2QudGVuc29yRm9ybWF0PVwiUkdCQVwiLGQuaGVpZ2h0PWgsZC53aWR0aD1ffWVsc2UgZC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9aCxkLndpZHRoPV87dS5kcmF3SW1hZ2UoZSwwLDApLGE9dS5nZXRJbWFnZURhdGEoMCwwLF8saCkuZGF0YX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZSBpZihuKXtsZXQgbSx1O2lmKHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDA/KG09dC5yZXNpemVkSGVpZ2h0LHU9dC5yZXNpemVkV2lkdGgpOihtPWUuaGVpZ2h0LHU9ZS53aWR0aCksdCE9PXZvaWQgMCYmKGQ9dCksZC5mb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9bSxkLndpZHRoPXUsdCE9PXZvaWQgMCl7bGV0IGg9bCgpO2gud2lkdGg9dSxoLmhlaWdodD1tO2xldCBfPXAoaCk7aWYoXyE9bnVsbClfLnB1dEltYWdlRGF0YShlLDAsMCksYT1fLmdldEltYWdlRGF0YSgwLDAsdSxtKS5kYXRhO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIGE9ZS5kYXRhfWVsc2UgaWYobyl7aWYodD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwXCIpO2xldCBtPWwoKTttLndpZHRoPWUud2lkdGgsbS5oZWlnaHQ9ZS5oZWlnaHQ7bGV0IHU9cChtKTtpZih1IT1udWxsKXtsZXQgaD1lLmhlaWdodCxfPWUud2lkdGg7cmV0dXJuIHUuZHJhd0ltYWdlKGUsMCwwLF8saCksYT11LmdldEltYWdlRGF0YSgwLDAsXyxoKS5kYXRhLGQuaGVpZ2h0PWgsZC53aWR0aD1fLFduKGEsZCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2V7aWYoaSlyZXR1cm4gbmV3IFByb21pc2UoKG0sdSk9PntsZXQgaD1sKCksXz1wKGgpO2lmKCFlfHwhXylyZXR1cm4gdSgpO2xldCB5PW5ldyBJbWFnZTt5LmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCIseS5zcmM9ZSx5Lm9ubG9hZD0oKT0+e2gud2lkdGg9eS53aWR0aCxoLmhlaWdodD15LmhlaWdodCxfLmRyYXdJbWFnZSh5LDAsMCxoLndpZHRoLGguaGVpZ2h0KTtsZXQgZz1fLmdldEltYWdlRGF0YSgwLDAsaC53aWR0aCxoLmhlaWdodCk7ZC5oZWlnaHQ9aC5oZWlnaHQsZC53aWR0aD1oLndpZHRoLG0oV24oZy5kYXRhLGQpKX19KTt0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvblwiKX1pZihhIT09dm9pZCAwKXJldHVybiBXbihhLGQpO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfSx1YT0oZSx0KT0+e2xldHt3aWR0aDpyLGhlaWdodDpuLGRvd25sb2FkOm8sZGlzcG9zZTppfT10LGE9WzEsbixyLDRdO3JldHVybiBuZXcgemUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHR5cGU6XCJmbG9hdDMyXCIsdGV4dHVyZTplLGRpbXM6YSxkb3dubG9hZDpvLGRpc3Bvc2U6aX0pfSxkYT0oZSx0KT0+e2xldHtkYXRhVHlwZTpyLGRpbXM6bixkb3dubG9hZDpvLGRpc3Bvc2U6aX09dDtyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIix0eXBlOnI/P1wiZmxvYXQzMlwiLGdwdUJ1ZmZlcjplLGRpbXM6bixkb3dubG9hZDpvLGRpc3Bvc2U6aX0pfSxsYT0oZSx0KT0+e2xldHtkYXRhVHlwZTpyLGRpbXM6bixkb3dubG9hZDpvLGRpc3Bvc2U6aX09dDtyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcIm1sLXRlbnNvclwiLHR5cGU6cj8/XCJmbG9hdDMyXCIsbWxUZW5zb3I6ZSxkaW1zOm4sZG93bmxvYWQ6byxkaXNwb3NlOml9KX0sY2E9KGUsdCxyKT0+bmV3IHplKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIix0eXBlOmUsZGF0YTp0LGRpbXM6cj8/W3QubGVuZ3RoXX0pfSk7dmFyIEl0LEZ0LG1hLGZhLGhhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtJdD1uZXcgTWFwKFtbXCJmbG9hdDMyXCIsRmxvYXQzMkFycmF5XSxbXCJ1aW50OFwiLFVpbnQ4QXJyYXldLFtcImludDhcIixJbnQ4QXJyYXldLFtcInVpbnQxNlwiLFVpbnQxNkFycmF5XSxbXCJpbnQxNlwiLEludDE2QXJyYXldLFtcImludDMyXCIsSW50MzJBcnJheV0sW1wiYm9vbFwiLFVpbnQ4QXJyYXldLFtcImZsb2F0NjRcIixGbG9hdDY0QXJyYXldLFtcInVpbnQzMlwiLFVpbnQzMkFycmF5XSxbXCJpbnQ0XCIsVWludDhBcnJheV0sW1widWludDRcIixVaW50OEFycmF5XV0pLEZ0PW5ldyBNYXAoW1tGbG9hdDMyQXJyYXksXCJmbG9hdDMyXCJdLFtVaW50OEFycmF5LFwidWludDhcIl0sW0ludDhBcnJheSxcImludDhcIl0sW1VpbnQxNkFycmF5LFwidWludDE2XCJdLFtJbnQxNkFycmF5LFwiaW50MTZcIl0sW0ludDMyQXJyYXksXCJpbnQzMlwiXSxbRmxvYXQ2NEFycmF5LFwiZmxvYXQ2NFwiXSxbVWludDMyQXJyYXksXCJ1aW50MzJcIl1dKSxtYT0hMSxmYT0oKT0+e2lmKCFtYSl7bWE9ITA7bGV0IGU9dHlwZW9mIEJpZ0ludDY0QXJyYXk8XCJ1XCImJkJpZ0ludDY0QXJyYXkuZnJvbSx0PXR5cGVvZiBCaWdVaW50NjRBcnJheTxcInVcIiYmQmlnVWludDY0QXJyYXkuZnJvbSxyPXR5cGVvZiBGbG9hdDE2QXJyYXk8XCJ1XCImJkZsb2F0MTZBcnJheS5mcm9tO2UmJihJdC5zZXQoXCJpbnQ2NFwiLEJpZ0ludDY0QXJyYXkpLEZ0LnNldChCaWdJbnQ2NEFycmF5LFwiaW50NjRcIikpLHQmJihJdC5zZXQoXCJ1aW50NjRcIixCaWdVaW50NjRBcnJheSksRnQuc2V0KEJpZ1VpbnQ2NEFycmF5LFwidWludDY0XCIpKSxyPyhJdC5zZXQoXCJmbG9hdDE2XCIsRmxvYXQxNkFycmF5KSxGdC5zZXQoRmxvYXQxNkFycmF5LFwiZmxvYXQxNlwiKSk6SXQuc2V0KFwiZmxvYXQxNlwiLFVpbnQxNkFycmF5KX19fSk7dmFyIGdhLGJhLHlhPVUoKCk9PntcInVzZSBzdHJpY3RcIjt5cigpO2dhPWU9PntsZXQgdD0xO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtsZXQgbj1lW3JdO2lmKHR5cGVvZiBuIT1cIm51bWJlclwifHwhTnVtYmVyLmlzU2FmZUludGVnZXIobikpdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske3J9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtufWApO2lmKG48MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske3J9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtufWApO3QqPW59cmV0dXJuIHR9LGJhPShlLHQpPT57c3dpdGNoKGUubG9jYXRpb24pe2Nhc2VcImNwdVwiOnJldHVybiBuZXcgemUoZS50eXBlLGUuZGF0YSx0KTtjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJjcHUtcGlubmVkXCIsZGF0YTplLmRhdGEsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwidGV4dHVyZVwiOnJldHVybiBuZXcgemUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHRleHR1cmU6ZS50ZXh0dXJlLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIixncHVCdWZmZXI6ZS5ncHVCdWZmZXIsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJtbC10ZW5zb3JcIixtbFRlbnNvcjplLm1sVGVuc29yLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHtlLmxvY2F0aW9ufSBpcyBub3Qgc3VwcG9ydGVkYCl9fX0pO3ZhciB6ZSx5cj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YWEoKTtwYSgpO2hhKCk7eWEoKTt6ZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIsbil7ZmEoKTtsZXQgbyxpO2lmKHR5cGVvZiB0PT1cIm9iamVjdFwiJiZcImxvY2F0aW9uXCJpbiB0KXN3aXRjaCh0aGlzLmRhdGFMb2NhdGlvbj10LmxvY2F0aW9uLG89dC50eXBlLGk9dC5kaW1zLHQubG9jYXRpb24pe2Nhc2VcImNwdS1waW5uZWRcIjp7bGV0IGQ9SXQuZ2V0KG8pO2lmKCFkKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHBpbm5lZCBidWZmZXJgKTtpZighKHQuZGF0YSBpbnN0YW5jZW9mIGQpKXRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2QubmFtZX1gKTt0aGlzLmNwdURhdGE9dC5kYXRhO2JyZWFrfWNhc2VcInRleHR1cmVcIjp7aWYobyE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTt0aGlzLmdwdVRleHR1cmVEYXRhPXQudGV4dHVyZSx0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31jYXNlXCJncHUtYnVmZmVyXCI6e2lmKG8hPT1cImZsb2F0MzJcIiYmbyE9PVwiZmxvYXQxNlwiJiZvIT09XCJpbnQzMlwiJiZvIT09XCJpbnQ2NFwiJiZvIT09XCJ1aW50MzJcIiYmbyE9PVwidWludDhcIiYmbyE9PVwiYm9vbFwiJiZvIT09XCJ1aW50NFwiJiZvIT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gZ3B1IGJ1ZmZlcmApO3RoaXMuZ3B1QnVmZmVyRGF0YT10LmdwdUJ1ZmZlcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31jYXNlXCJtbC10ZW5zb3JcIjp7aWYobyE9PVwiZmxvYXQzMlwiJiZvIT09XCJmbG9hdDE2XCImJm8hPT1cImludDMyXCImJm8hPT1cImludDY0XCImJm8hPT1cInVpbnQzMlwiJiZvIT09XCJ1aW50NjRcIiYmbyE9PVwiaW50OFwiJiZvIT09XCJ1aW50OFwiJiZvIT09XCJib29sXCImJm8hPT1cInVpbnQ0XCImJm8hPT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBNTFRlbnNvcmApO3RoaXMubWxUZW5zb3JEYXRhPXQubWxUZW5zb3IsdGhpcy5kb3dubG9hZGVyPXQuZG93bmxvYWQsdGhpcy5kaXNwb3Nlcj10LmRpc3Bvc2U7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBjb25zdHJ1Y3RvcjogdW5zdXBwb3J0ZWQgbG9jYXRpb24gJyR7dGhpcy5kYXRhTG9jYXRpb259J2ApfWVsc2V7bGV0IGQsbDtpZih0eXBlb2YgdD09XCJzdHJpbmdcIilpZihvPXQsbD1uLHQ9PT1cInN0cmluZ1wiKXtpZighQXJyYXkuaXNBcnJheShyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBzdHJpbmcgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LlwiKTtkPXJ9ZWxzZXtsZXQgcD1JdC5nZXQodCk7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHt0fS5gKTtpZihBcnJheS5pc0FycmF5KHIpKXtpZih0PT09XCJmbG9hdDE2XCImJnA9PT1VaW50MTZBcnJheXx8dD09PVwidWludDRcInx8dD09PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYENyZWF0aW5nIGEgJHt0fSB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSAke3AubmFtZX0gYXMgZGF0YS5gKTt0PT09XCJ1aW50NjRcInx8dD09PVwiaW50NjRcIj9kPXAuZnJvbShyLEJpZ0ludCk6ZD1wLmZyb20ocil9ZWxzZSBpZihyIGluc3RhbmNlb2YgcClkPXI7ZWxzZSBpZihyIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpaWYodD09PVwidWludDhcIilkPVVpbnQ4QXJyYXkuZnJvbShyKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIFVpbnQ4Q2xhbXBlZEFycmF5IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mIHVpbnQ4XCIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke299IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7cH1gKX1lbHNlIGlmKGw9cixBcnJheS5pc0FycmF5KHQpKXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LlwiKTtsZXQgcD10eXBlb2YgdFswXTtpZihwPT09XCJzdHJpbmdcIilvPVwic3RyaW5nXCIsZD10O2Vsc2UgaWYocD09PVwiYm9vbGVhblwiKW89XCJib29sXCIsZD1VaW50OEFycmF5LmZyb20odCk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke3B9LmApfWVsc2UgaWYodCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KW89XCJ1aW50OFwiLGQ9VWludDhBcnJheS5mcm9tKHQpO2Vsc2V7bGV0IHA9RnQuZ2V0KHQuY29uc3RydWN0b3IpO2lmKHA9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7dC5jb25zdHJ1Y3Rvcn0uYCk7bz1wLGQ9dH1pZihsPT09dm9pZCAwKWw9W2QubGVuZ3RoXTtlbHNlIGlmKCFBcnJheS5pc0FycmF5KGwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHRlbnNvcidzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheVwiKTtpPWwsdGhpcy5jcHVEYXRhPWQsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIn1sZXQgYT1nYShpKTtpZih0aGlzLmNwdURhdGEmJmEhPT10aGlzLmNwdURhdGEubGVuZ3RoJiYhKChvPT09XCJ1aW50NFwifHxvPT09XCJpbnQ0XCIpJiZNYXRoLmNlaWwoYS8yKT09PXRoaXMuY3B1RGF0YS5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke2F9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke3RoaXMuY3B1RGF0YS5sZW5ndGh9KS5gKTt0aGlzLnR5cGU9byx0aGlzLmRpbXM9aSx0aGlzLnNpemU9YX1zdGF0aWMgYXN5bmMgZnJvbUltYWdlKHQscil7cmV0dXJuIHNhKHQscil9c3RhdGljIGZyb21UZXh0dXJlKHQscil7cmV0dXJuIHVhKHQscil9c3RhdGljIGZyb21HcHVCdWZmZXIodCxyKXtyZXR1cm4gZGEodCxyKX1zdGF0aWMgZnJvbU1MVGVuc29yKHQscil7cmV0dXJuIGxhKHQscil9c3RhdGljIGZyb21QaW5uZWRCdWZmZXIodCxyLG4pe3JldHVybiBjYSh0LHIsbil9dG9EYXRhVVJMKHQpe3JldHVybiBvYSh0aGlzLHQpfXRvSW1hZ2VEYXRhKHQpe3JldHVybiBpYSh0aGlzLHQpfWdldCBkYXRhKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmNwdURhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IG9uIENQVS4gVXNlIGBnZXREYXRhKClgIHRvIGRvd25sb2FkIEdQVSBkYXRhIHRvIENQVSwgb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LlwiKTtyZXR1cm4gdGhpcy5jcHVEYXRhfWdldCBsb2NhdGlvbigpe3JldHVybiB0aGlzLmRhdGFMb2NhdGlvbn1nZXQgdGV4dHVyZSgpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5ncHVUZXh0dXJlRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR0wgdGV4dHVyZS5cIik7cmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGF9Z2V0IGdwdUJ1ZmZlcigpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5ncHVCdWZmZXJEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHUFUgYnVmZmVyLlwiKTtyZXR1cm4gdGhpcy5ncHVCdWZmZXJEYXRhfWdldCBtbFRlbnNvcigpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5tbFRlbnNvckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYk5OIE1MVGVuc29yLlwiKTtyZXR1cm4gdGhpcy5tbFRlbnNvckRhdGF9YXN5bmMgZ2V0RGF0YSh0KXtzd2l0Y2godGhpcy5lbnN1cmVWYWxpZCgpLHRoaXMuZGF0YUxvY2F0aW9uKXtjYXNlXCJjcHVcIjpjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIHRoaXMuZGF0YTtjYXNlXCJ0ZXh0dXJlXCI6Y2FzZVwiZ3B1LWJ1ZmZlclwiOmNhc2VcIm1sLXRlbnNvclwiOntpZighdGhpcy5kb3dubG9hZGVyKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBub3QgY3JlYXRlZCB3aXRoIGEgc3BlY2lmaWVkIGRhdGEgZG93bmxvYWRlci5cIik7aWYodGhpcy5pc0Rvd25sb2FkaW5nKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLlwiKTt0cnl7dGhpcy5pc0Rvd25sb2FkaW5nPSEwO2xldCByPWF3YWl0IHRoaXMuZG93bmxvYWRlcigpO3JldHVybiB0aGlzLmRvd25sb2FkZXI9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwiY3B1XCIsdGhpcy5jcHVEYXRhPXIsdCYmdGhpcy5kaXNwb3NlciYmKHRoaXMuZGlzcG9zZXIoKSx0aGlzLmRpc3Bvc2VyPXZvaWQgMCkscn1maW5hbGx5e3RoaXMuaXNEb3dubG9hZGluZz0hMX19ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBnZXQgZGF0YSBmcm9tIGxvY2F0aW9uOiAke3RoaXMuZGF0YUxvY2F0aW9ufWApfX1kaXNwb3NlKCl7aWYodGhpcy5pc0Rvd25sb2FkaW5nKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLlwiKTt0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSx0aGlzLmNwdURhdGE9dm9pZCAwLHRoaXMuZ3B1VGV4dHVyZURhdGE9dm9pZCAwLHRoaXMuZ3B1QnVmZmVyRGF0YT12b2lkIDAsdGhpcy5tbFRlbnNvckRhdGE9dm9pZCAwLHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5pc0Rvd25sb2FkaW5nPXZvaWQgMCx0aGlzLmRhdGFMb2NhdGlvbj1cIm5vbmVcIn1lbnN1cmVWYWxpZCgpe2lmKHRoaXMuZGF0YUxvY2F0aW9uPT09XCJub25lXCIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbnNvciBpcyBkaXNwb3NlZC5cIil9cmVzaGFwZSh0KXtpZih0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kb3dubG9hZGVyfHx0aGlzLmRpc3Bvc2VyKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuXCIpO3JldHVybiBiYSh0aGlzLHQpfX19KTt2YXIgRmUsTG49VSgoKT0+e1widXNlIHN0cmljdFwiO3lyKCk7RmU9emV9KTt2YXIgX3IsX2EsTmUsQmUsR249VSgoKT0+e1widXNlIHN0cmljdFwiO1ZuKCk7X3I9KGUsdCk9PnsodHlwZW9mIFVlLnRyYWNlPlwidVwiPyFVZS53YXNtLnRyYWNlOiFVZS50cmFjZSl8fGNvbnNvbGUudGltZVN0YW1wKGAke2V9OjpPUlQ6OiR7dH1gKX0sX2E9KGUsdCk9PntsZXQgcj1uZXcgRXJyb3IoKS5zdGFjaz8uc3BsaXQoL1xcclxcbnxcXHJ8XFxuL2cpfHxbXSxuPSExO2ZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtpZihuJiYhcltvXS5pbmNsdWRlcyhcIlRSQUNFX0ZVTkNcIikpe2xldCBpPWBGVU5DXyR7ZX06OiR7cltvXS50cmltKCkuc3BsaXQoXCIgXCIpWzFdfWA7dCYmKGkrPWA6OiR7dH1gKSxfcihcIkNQVVwiLGkpO3JldHVybn1yW29dLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSYmKG49ITApfX0sTmU9ZT0+eyh0eXBlb2YgVWUudHJhY2U+XCJ1XCI/IVVlLndhc20udHJhY2U6IVVlLnRyYWNlKXx8X2EoXCJCRUdJTlwiLGUpfSxCZT1lPT57KHR5cGVvZiBVZS50cmFjZT5cInVcIj8hVWUud2FzbS50cmFjZTohVWUudHJhY2UpfHxfYShcIkVORFwiLGUpfX0pO3ZhciB3cix3YT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Tm4oKTtMbigpO0duKCk7d3I9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0KXt0aGlzLmhhbmRsZXI9dH1hc3luYyBydW4odCxyLG4pe05lKCk7bGV0IG89e30saT17fTtpZih0eXBlb2YgdCE9XCJvYmplY3RcInx8dD09PW51bGx8fHQgaW5zdGFuY2VvZiBGZXx8QXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIpO2xldCBhPSEwO2lmKHR5cGVvZiByPT1cIm9iamVjdFwiKXtpZihyPT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuXCIpO2lmKHIgaW5zdGFuY2VvZiBGZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtpZihBcnJheS5pc0FycmF5KHIpKXtpZihyLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO2E9ITE7Zm9yKGxldCBwIG9mIHIpe2lmKHR5cGVvZiBwIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO2lmKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihwKT09PS0xKXRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtwfS5gKTtvW3BdPW51bGx9aWYodHlwZW9mIG49PVwib2JqZWN0XCImJm4hPT1udWxsKWk9bjtlbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2V7bGV0IHA9ITEsbT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKTtmb3IobGV0IHUgb2YgdGhpcy5vdXRwdXROYW1lcylpZihtLmluZGV4T2YodSkhPT0tMSl7bGV0IGg9clt1XTsoaD09PW51bGx8fGggaW5zdGFuY2VvZiBGZSkmJihwPSEwLGE9ITEsb1t1XT1oKX1pZihwKXtpZih0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpaT1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpPXJ9fWVsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgJ2ZldGNoZXMnIG9yICdvcHRpb25zJy5cIik7Zm9yKGxldCBwIG9mIHRoaXMuaW5wdXROYW1lcylpZih0eXBlb2YgdFtwXT5cInVcIil0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke3B9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7aWYoYSlmb3IobGV0IHAgb2YgdGhpcy5vdXRwdXROYW1lcylvW3BdPW51bGw7bGV0IGQ9YXdhaXQgdGhpcy5oYW5kbGVyLnJ1bih0LG8saSksbD17fTtmb3IobGV0IHAgaW4gZClpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChkLHApKXtsZXQgbT1kW3BdO20gaW5zdGFuY2VvZiBGZT9sW3BdPW06bFtwXT1uZXcgRmUobS50eXBlLG0uZGF0YSxtLmRpbXMpfXJldHVybiBCZSgpLGx9YXN5bmMgcmVsZWFzZSgpe3JldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpfXN0YXRpYyBhc3luYyBjcmVhdGUodCxyLG4sbyl7TmUoKTtsZXQgaSxhPXt9O2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKXtpZihpPXQsdHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKWE9cjtlbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe2lmKGk9dCx0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcjxcInVcIiYmdCBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKXtsZXQgbT10LHU9MCxoPXQuYnl0ZUxlbmd0aDtpZih0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI9PVwibnVtYmVyXCIpe2lmKHU9ciwhTnVtYmVyLmlzU2FmZUludGVnZXIodSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZih1PDB8fHU+PW0uYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHttLmJ5dGVMZW5ndGh9KS5gKTtpZihoPXQuYnl0ZUxlbmd0aC11LHR5cGVvZiBuPT1cIm51bWJlclwiKXtpZihoPW4sIU51bWJlci5pc1NhZmVJbnRlZ2VyKGgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYoaDw9MHx8dStoPm0uYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHttLmJ5dGVMZW5ndGgtdX1dLmApO2lmKHR5cGVvZiBvPT1cIm9iamVjdFwiJiZvIT09bnVsbClhPW87ZWxzZSBpZih0eXBlb2YgbzxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIil9ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtpPW5ldyBVaW50OEFycmF5KG0sdSxoKX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7bGV0W2QsbF09YXdhaXQgWGkoYSkscD1hd2FpdCBkLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGksbCk7cmV0dXJuIEJlKCksbmV3IGUocCl9c3RhcnRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKX1lbmRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCl9Z2V0IGlucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXN9Z2V0IG91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lc319fSk7dmFyIEZwLHZhPVUoKCk9PntcInVzZSBzdHJpY3RcIjt3YSgpO0ZwPXdyfSk7dmFyICRhPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciB4YT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgU2E9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIFRhPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBIbj17fTtIdChIbix7SW5mZXJlbmNlU2Vzc2lvbjooKT0+RnAsVFJBQ0U6KCk9Pl9yLFRSQUNFX0ZVTkNfQkVHSU46KCk9Pk5lLFRSQUNFX0ZVTkNfRU5EOigpPT5CZSxUZW5zb3I6KCk9PkZlLGVudjooKT0+X2UscmVnaXN0ZXJCYWNrZW5kOigpPT5UdH0pO3ZhciBMZT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SmkoKTtuYSgpO3ZhKCk7TG4oKTskYSgpO3hhKCk7R24oKTtTYSgpO1RhKCl9KTt2YXIgdnI9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIGthPXt9O0h0KGthLHtkZWZhdWx0OigpPT5xcH0pO3ZhciBDYSxBYSxxcCxFYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Rm4oKTtndCgpOyRyKCk7Q2E9XCJvcnQtd2FzbS1wcm94eS13b3JrZXJcIixBYT1nbG9iYWxUaGlzLnNlbGY/Lm5hbWU9PT1DYTtBYSYmKHNlbGYub25tZXNzYWdlPWU9PntsZXR7dHlwZTp0LGluOnJ9PWUuZGF0YTt0cnl7c3dpdGNoKHQpe2Nhc2VcImluaXQtd2FzbVwiOnhyKHIud2FzbSkudGhlbigoKT0+e1NyKHIpLnRoZW4oKCk9Pntwb3N0TWVzc2FnZSh7dHlwZTp0fSl9LG49Pntwb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpufSl9KX0sbj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOm59KX0pO2JyZWFrO2Nhc2VcImluaXQtZXBcIjp7bGV0e2VwTmFtZTpuLGVudjpvfT1yO1RyKG8sbikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0saT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOml9KX0pO2JyZWFrfWNhc2VcImNvcHktZnJvbVwiOntsZXR7YnVmZmVyOm59PXIsbz1xdChuKTtwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDpvfSk7YnJlYWt9Y2FzZVwiY3JlYXRlXCI6e2xldHttb2RlbDpuLG9wdGlvbnM6b309cjtJcihuLG8pLnRoZW4oaT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0Oml9KX0saT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOml9KX0pO2JyZWFrfWNhc2VcInJlbGVhc2VcIjpDcihyKSxwb3N0TWVzc2FnZSh7dHlwZTp0fSk7YnJlYWs7Y2FzZVwicnVuXCI6e2xldHtzZXNzaW9uSWQ6bixpbnB1dEluZGljZXM6byxpbnB1dHM6aSxvdXRwdXRJbmRpY2VzOmEsb3B0aW9uczpkfT1yO0FyKG4sbyxpLGEsbmV3IEFycmF5KGEubGVuZ3RoKS5maWxsKG51bGwpLGQpLnRoZW4obD0+e2wuc29tZShwPT5wWzNdIT09XCJjcHVcIik/cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6XCJQcm94eSBkb2VzIG5vdCBzdXBwb3J0IG5vbi1jcHUgdGVuc29yIGxvY2F0aW9uLlwifSk6cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6bH0sRXIoWy4uLmksLi4ubF0pKX0sbD0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOmx9KX0pO2JyZWFrfWNhc2VcImVuZC1wcm9maWxpbmdcIjprcihyKSxwb3N0TWVzc2FnZSh7dHlwZTp0fSk7YnJlYWs7ZGVmYXVsdDp9fWNhdGNoKG4pe3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOm59KX19KTtxcD1BYT9udWxsOmU9Pm5ldyBXb3JrZXIoZT8/VmUse3R5cGU6XCJtb2R1bGVcIixuYW1lOkNhfSl9KTt2YXIgemE9e307SHQoemEse2RlZmF1bHQ6KCk9PktwfSk7dmFyIHFuLFBhLEtwLE9hPVUoKCk9PntcInVzZSBzdHJpY3RcIjtQYT0ocW49aW1wb3J0Lm1ldGEudXJsLGFzeW5jIGZ1bmN0aW9uKGU9e30pe2Z1bmN0aW9uIHQoKXtyZXR1cm4gSy5idWZmZXIhPVEuYnVmZmVyJiZwZSgpLFF9ZnVuY3Rpb24gcigpe3JldHVybiBLLmJ1ZmZlciE9US5idWZmZXImJnBlKCksaWV9ZnVuY3Rpb24gbigpe3JldHVybiBLLmJ1ZmZlciE9US5idWZmZXImJnBlKCksdGV9ZnVuY3Rpb24gbygpe3JldHVybiBLLmJ1ZmZlciE9US5idWZmZXImJnBlKCksYmV9ZnVuY3Rpb24gaSgpe3JldHVybiBLLmJ1ZmZlciE9US5idWZmZXImJnBlKCksT2V9ZnVuY3Rpb24gYSgpe3JldHVybiBLLmJ1ZmZlciE9US5idWZmZXImJnBlKCksdmV9ZnVuY3Rpb24gZCgpe3JldHVybiBLLmJ1ZmZlciE9US5idWZmZXImJnBlKCksZGV9ZnVuY3Rpb24gbCgpe3JldHVybiBLLmJ1ZmZlciE9US5idWZmZXImJnBlKCksaGV9dmFyIHAsbSx1PU9iamVjdC5hc3NpZ24oe30sZSksaD1uZXcgUHJvbWlzZSgocyxjKT0+e3A9cyxtPWN9KSxfPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIseT10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLGc9eSYmc2VsZi5uYW1lPT1cImVtLXB0aHJlYWRcIjt1Lm1vdW50RXh0ZXJuYWxEYXRhPShzLGMpPT57cy5zdGFydHNXaXRoKFwiLi9cIikmJihzPXMuc3Vic3RyaW5nKDIpKSwodS5GYnx8KHUuRmI9bmV3IE1hcCkpLnNldChzLGMpfSx1LnVubW91bnRFeHRlcm5hbERhdGE9KCk9PntkZWxldGUgdS5GYn07dmFyIHg9Z2xvYmFsVGhpcy5TaGFyZWRBcnJheUJ1ZmZlcj8/bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDowLG1heGltdW06MCxzaGFyZWQ6ITB9KS5idWZmZXIuY29uc3RydWN0b3I7bGV0ICQ9KCk9PntsZXQgcz0oZixiLHcpPT4oLi4uSSk9PntsZXQgTz1YZSxCPWI/LigpO0k9ZiguLi5JKTtsZXQgRz1iPy4oKTtyZXR1cm4gQiE9PUcmJihmPUcsdyhCKSxiPXc9bnVsbCksWGUhPU8/bmV3IFByb21pc2UoKEYsWCk9Pntrbj17cmVzb2x2ZTpGLHJlamVjdDpYfX0pOkl9LGM9Zj0+YXN5bmMoLi4uYik9Pnt0cnl7aWYodS5HYil0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCB3PXUuR2I9e2hjOmJbMF0sZXJyb3JzOltdfSxJPWF3YWl0IGYoLi4uYik7aWYodS5HYiE9PXcpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO3UuSGI/LmZsdXNoKCk7bGV0IE89dy5lcnJvcnM7aWYoMDxPLmxlbmd0aCl7bGV0IEI9YXdhaXQgUHJvbWlzZS5hbGwoTyk7aWYoQj1CLmZpbHRlcihHPT5HKSwwPEIubGVuZ3RoKXRocm93IEVycm9yKEIuam9pbihgXG5gKSl9cmV0dXJuIEl9ZmluYWxseXt1LkdiPW51bGx9fTt1Ll9PcnRDcmVhdGVTZXNzaW9uPXModS5fT3J0Q3JlYXRlU2Vzc2lvbiwoKT0+dS5fT3J0Q3JlYXRlU2Vzc2lvbixmPT51Ll9PcnRDcmVhdGVTZXNzaW9uPWYpLHUuX09ydFJ1bj1jKHModS5fT3J0UnVuLCgpPT51Ll9PcnRSdW4sZj0+dS5fT3J0UnVuPWYpKSx1Ll9PcnRSdW5XaXRoQmluZGluZz1jKHModS5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PnUuX09ydFJ1bldpdGhCaW5kaW5nLGY9PnUuX09ydFJ1bldpdGhCaW5kaW5nPWYpKSx1Ll9PcnRCaW5kSW5wdXQ9cyh1Ll9PcnRCaW5kSW5wdXQsKCk9PnUuX09ydEJpbmRJbnB1dCxmPT51Ll9PcnRCaW5kSW5wdXQ9ZiksJD12b2lkIDB9O3UuanNlcEluaXQ9KHMsYyk9PntpZigkPy4oKSxzPT09XCJ3ZWJncHVcIil7W3UuSGIsdS5WYix1LlpiLHUuT2IsdS5ZYix1LmtiLHUuJGIsdS5jYyx1LldiLHUuWGIsdS5hY109YztsZXQgZj11LkhiO3UuanNlcFJlZ2lzdGVyQnVmZmVyPShiLHcsSSxPKT0+Zi5yZWdpc3RlckJ1ZmZlcihiLHcsSSxPKSx1LmpzZXBHZXRCdWZmZXI9Yj0+Zi5nZXRCdWZmZXIoYiksdS5qc2VwQ3JlYXRlRG93bmxvYWRlcj0oYix3LEkpPT5mLmNyZWF0ZURvd25sb2FkZXIoYix3LEkpLHUuanNlcE9uQ3JlYXRlU2Vzc2lvbj1iPT57Zi5vbkNyZWF0ZVNlc3Npb24oYil9LHUuanNlcE9uUmVsZWFzZVNlc3Npb249Yj0+e2Yub25SZWxlYXNlU2Vzc2lvbihiKX0sdS5qc2VwT25SdW5TdGFydD1iPT5mLm9uUnVuU3RhcnQoYiksdS5kYz0oYix3KT0+e2YudXBsb2FkKGIsdyl9fWVsc2UgaWYocz09PVwid2Vibm5cIil7W3UuSGIsdS5iYyx1LlBiLHUuanNlcEVuc3VyZVRlbnNvcix1LmVjLHUuanNlcERvd25sb2FkVGVuc29yXT1jLHUuanNlcFJlbGVhc2VUZW5zb3JJZD11LlBiO2xldCBmPXUuSGI7dS5qc2VwT25SdW5TdGFydD1iPT5mLm9uUnVuU3RhcnQoYiksdS5qc2VwUmVnaXN0ZXJNTENvbnRleHQ9KGIsdyk9PntmLnJlZ2lzdGVyTUxDb250ZXh0KGIsdyl9LHUuanNlcE9uUmVsZWFzZVNlc3Npb249Yj0+e2Yub25SZWxlYXNlU2Vzc2lvbihiKX0sdS5qc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyPShiLHcpPT5mLmNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcihiLHcpLHUuanNlcFJlZ2lzdGVyTUxUZW5zb3I9KGIsdyxJKT0+Zi5yZWdpc3Rlck1MVGVuc29yKGIsdyxJKSx1LmpzZXBDcmVhdGVNTENvbnRleHQ9Yj0+Zi5jcmVhdGVNTENvbnRleHQoYiksdS5qc2VwUmVnaXN0ZXJNTENvbnN0YW50PShiLHcsSSxPLEIpPT5mLnJlZ2lzdGVyTUxDb25zdGFudChiLHcsSSxPLEIsdS5GYil9fTt2YXIgdixTLFQ9T2JqZWN0LmFzc2lnbih7fSx1KSxBPShzLGMpPT57dGhyb3cgY30sQz1cIlwiOyhffHx5KSYmKHk/Qz1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoQz1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYykscW4mJihDPXFuKSxDPUMuc3RhcnRzV2l0aChcImJsb2I6XCIpP1wiXCI6Qy5zdWJzdHIoMCxDLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpLHkmJihTPXM9Pnt2YXIgYz1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGMub3BlbihcIkdFVFwiLHMsITEpLGMucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixjLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoYy5yZXNwb25zZSl9KSx2PShzLGMsZik9Pnt2YXIgYj1uZXcgWE1MSHR0cFJlcXVlc3Q7Yi5vcGVuKFwiR0VUXCIscywhMCksYi5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGIub25sb2FkPSgpPT57Yi5zdGF0dXM9PTIwMHx8Yi5zdGF0dXM9PTAmJmIucmVzcG9uc2U/YyhiLnJlc3BvbnNlKTpmKCl9LGIub25lcnJvcj1mLGIuc2VuZChudWxsKX0pO3ZhciBQLEQ9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxSPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxIPUQsTD1SO2lmKE9iamVjdC5hc3NpZ24odSxUKSxUPW51bGwsZyl7bGV0IHM9ZnVuY3Rpb24oYyl7dHJ5e3ZhciBmPWMuZGF0YSxiPWYuY21kO2lmKGI9PT1cImxvYWRcIil7bGV0IHc9W107c2VsZi5vbm1lc3NhZ2U9ST0+dy5wdXNoKEkpLHNlbGYuc3RhcnRXb3JrZXI9KCk9Pntwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtmb3IobGV0IEkgb2YgdylzKEkpO3NlbGYub25tZXNzYWdlPXN9O2ZvcihsZXQgSSBvZiBmLmhhbmRsZXJzKXVbSV0mJiF1W0ldLnByb3h5fHwodVtJXT0oLi4uTyk9Pntwb3N0TWVzc2FnZSh7TmI6XCJjYWxsSGFuZGxlclwiLHBjOkksYXJnczpPfSl9LEk9PVwicHJpbnRcIiYmKEg9dVtJXSksST09XCJwcmludEVyclwiJiYoTD11W0ldKSk7Sz1mLndhc21NZW1vcnkscGUoKSxyZShmLndhc21Nb2R1bGUpfWVsc2UgaWYoYj09PVwicnVuXCIpe09uKGYucHRocmVhZF9wdHIsMCwwLDEsMCwwKSxDbihmLnB0aHJlYWRfcHRyKSx4YygpLEdvKCksVnx8KFZpKCksVj0hMCk7dHJ5e1NjKGYuc3RhcnRfcm91dGluZSxmLmFyZyl9Y2F0Y2godyl7aWYodyE9XCJ1bndpbmRcIil0aHJvdyB3fX1lbHNlIGI9PT1cImNhbmNlbFwiP1J0KCkmJmZyKC0xKTpmLnRhcmdldCE9PVwic2V0aW1tZWRpYXRlXCImJihiPT09XCJjaGVja01haWxib3hcIj9WJiZvcigpOmImJihMKGB3b3JrZXI6IHJlY2VpdmVkIHVua25vd24gY29tbWFuZCAke2J9YCksTChmKSkpfWNhdGNoKHcpe3Rocm93IFdpKCksd319O3ZhciB3Zz1zLHJlLFY9ITE7TD1mdW5jdGlvbiguLi5jKXtjPWMuam9pbihcIiBcIiksY29uc29sZS5lcnJvcihjKX0sc2VsZi5hbGVydD1mdW5jdGlvbiguLi5jKXtwb3N0TWVzc2FnZSh7TmI6XCJhbGVydFwiLHRleHQ6Yy5qb2luKFwiIFwiKSxyYzpSdCgpfSl9LHUuaW5zdGFudGlhdGVXYXNtPShjLGYpPT5uZXcgUHJvbWlzZShiPT57cmU9dz0+e3c9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKHcsVW8oKSksZih3KSxiKCl9fSksc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1jPT57dGhyb3cgYy5yZWFzb258fGN9LHNlbGYub25tZXNzYWdlPXN9dS53YXNtQmluYXJ5JiYoUD11Lndhc21CaW5hcnkpO3ZhciBLLHdlLGosUSxpZSx0ZSxiZSxPZSx2ZSxkZSxXLFksaGUsRGU9ITE7ZnVuY3Rpb24gcGUoKXt2YXIgcz1LLmJ1ZmZlcjt1LkhFQVA4PVE9bmV3IEludDhBcnJheShzKSx1LkhFQVAxNj10ZT1uZXcgSW50MTZBcnJheShzKSx1LkhFQVBVOD1pZT1uZXcgVWludDhBcnJheShzKSx1LkhFQVBVMTY9YmU9bmV3IFVpbnQxNkFycmF5KHMpLHUuSEVBUDMyPU9lPW5ldyBJbnQzMkFycmF5KHMpLHUuSEVBUFUzMj12ZT1uZXcgVWludDMyQXJyYXkocyksdS5IRUFQRjMyPWRlPW5ldyBGbG9hdDMyQXJyYXkocyksdS5IRUFQRjY0PWhlPW5ldyBGbG9hdDY0QXJyYXkocyksdS5IRUFQNjQ9Vz1uZXcgQmlnSW50NjRBcnJheShzKSx1LkhFQVBVNjQ9WT1uZXcgQmlnVWludDY0QXJyYXkocyl9aWYoIWcpe2lmKCEoKEs9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDoyNTYsbWF4aW11bTo2NTUzNixzaGFyZWQ6ITB9KSkuYnVmZmVyIGluc3RhbmNlb2YgeCkpdGhyb3cgTChcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7cGUoKX12YXIgSWU9W10sSGU9W10sbW49W10sd3Q9MCxmbj1udWxsLEd0PW51bGw7ZnVuY3Rpb24gT28oKXtpZigtLXd0PT0wJiYoZm4hPT1udWxsJiYoY2xlYXJJbnRlcnZhbChmbiksZm49bnVsbCksR3QpKXt2YXIgcz1HdDtHdD1udWxsLHMoKX19ZnVuY3Rpb24gY3Qocyl7dGhyb3cgTChzPVwiQWJvcnRlZChcIitzK1wiKVwiKSxEZT0hMCxqPTEscz1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHMrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLG0ocyksc312YXIgaG4sRG89cz0+cy5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKSxCbz1zPT5zLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpO2Z1bmN0aW9uIE1vKHMpe2lmKHM9PWhuJiZQKXJldHVybiBuZXcgVWludDhBcnJheShQKTtpZihTKXJldHVybiBTKHMpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIFJvKHMsYyxmKXtyZXR1cm4gZnVuY3Rpb24oYil7aWYoIVAmJihffHx5KSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiFCbyhiKSlyZXR1cm4gZmV0Y2goYix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbih3PT57aWYoIXcub2spdGhyb3dgZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnJHtifSdgO3JldHVybiB3LmFycmF5QnVmZmVyKCl9KS5jYXRjaCgoKT0+TW8oYikpO2lmKHYpcmV0dXJuIG5ldyBQcm9taXNlKCh3LEkpPT57dihiLE89PncobmV3IFVpbnQ4QXJyYXkoTykpLEkpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pk1vKGIpKX0ocykudGhlbihiPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiLGMpKS50aGVuKGYsYj0+e0woYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7Yn1gKSxjdChiKX0pfWZ1bmN0aW9uIFVvKCl7cmV0dXJue2E6e086JGMsQWE6dmMsYjpJYyxhYTpLbyxCOlpvLHFhOlFvLFk6Sm8sXzplaSxyYTp0aSxvYTpyaSxoYTpuaSxuYTpvaSxMOmlpLFo6YWksVzpzaSxwYTp1aSxYOmRpLHZhOkNjLEY6a2MsUTpFYyxQOnpjLEU6RGMsdTpCYyxxOk1jLEc6UmMsQTpIYyxSOkZjLHVhOnFjLGthOktjLFU6amMsYmE6WWMsSDpaYyxqYTpDbix0YTpRYyx0OlhjLEJhOkpjLHg6cnAsbzpucCxtOmlwLGM6VG4sbjphcCxrOmRwLHc6bHAscDpjcCxmOnBwLHM6bXAsbDpmcCxlOmhwLGo6Z3AsaTpicCxnOnlwLGQ6X3AsZWE6d3AsZmE6dnAsZ2E6JHAsY2E6eGksZGE6U2ksVDp4cCxoOlNwLEQ6VHAsSTpJcCxNOkNwLHk6QXAsc2E6a3AsVjpFcCx2OklpLHo6UHAsTjp6cCxTOk9wLHphOkRwLHlhOkJwLGxhOmtpLG1hOkVpLCQ6d24sQzpQaSxLOnppLGlhOk9pLEo6RGksYTpLLHhhOl9uLHdhOlJpLHI6VXB9fX12YXIgZ249ezkxNjg2ODoocyxjLGYsYix3KT0+e2lmKHU9PT12b2lkIDB8fCF1LkZiKXJldHVybiAxO2lmKChzPUNlKE51bWJlcihzPj4+MCkpKS5zdGFydHNXaXRoKFwiLi9cIikmJihzPXMuc3Vic3RyaW5nKDIpKSwhKHM9dS5GYi5nZXQocykpKXJldHVybiAyO2lmKGM9TnVtYmVyKGM+Pj4wKSxmPU51bWJlcihmPj4+MCksYj1OdW1iZXIoYj4+PjApLGMrZj5zLmJ5dGVMZW5ndGgpcmV0dXJuIDM7dHJ5e2xldCBJPXMuc3ViYXJyYXkoYyxjK2YpO3N3aXRjaCh3KXtjYXNlIDA6cigpLnNldChJLGI+Pj4wKTticmVhaztjYXNlIDE6dS5kYyhiLEkpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIDR9cmV0dXJuIDB9Y2F0Y2h7cmV0dXJuIDR9fSw5MTc1ODM6KHMsYyxmKT0+e3UuZWMocyxyKCkuc3ViYXJyYXkoYz4+PjAsYytmPj4+MCkpfSw5MTc2NDY6KCk9PnUuYmMoKSw5MTc2ODc6cz0+e3UuUGIocyl9LDkxNzcyMzooKT0+e3UuV2IoKX0sOTE3NzU0OigpPT57dS5YYigpfSw5MTc3ODM6KCk9Pnt1LmFjKCl9LDkxNzgwODpzPT51LlZiKHMpLDkxNzg0MTpzPT51LlpiKHMpLDkxNzg3MzoocyxjLGYpPT57dS5PYihOdW1iZXIocyksTnVtYmVyKGMpLE51bWJlcihmKSwhMCl9LDkxNzkzNjoocyxjLGYpPT57dS5PYihOdW1iZXIocyksTnVtYmVyKGMpLE51bWJlcihmKSl9LDkxNzk5MzooKT0+dHlwZW9mIHdhc21PZmZzZXRDb252ZXJ0ZXI8XCJ1XCIsOTE4MDUwOnM9Pnt1LmtiKFwiQWJzXCIscyx2b2lkIDApfSw5MTgxMDE6cz0+e3Uua2IoXCJOZWdcIixzLHZvaWQgMCl9LDkxODE1MjpzPT57dS5rYihcIkZsb29yXCIscyx2b2lkIDApfSw5MTgyMDU6cz0+e3Uua2IoXCJDZWlsXCIscyx2b2lkIDApfSw5MTgyNTc6cz0+e3Uua2IoXCJSZWNpcHJvY2FsXCIscyx2b2lkIDApfSw5MTgzMTU6cz0+e3Uua2IoXCJTcXJ0XCIscyx2b2lkIDApfSw5MTgzNjc6cz0+e3Uua2IoXCJFeHBcIixzLHZvaWQgMCl9LDkxODQxODpzPT57dS5rYihcIkVyZlwiLHMsdm9pZCAwKX0sOTE4NDY5OnM9Pnt1LmtiKFwiU2lnbW9pZFwiLHMsdm9pZCAwKX0sOTE4NTI0OihzLGMsZik9Pnt1LmtiKFwiSGFyZFNpZ21vaWRcIixzLHthbHBoYTpjLGJldGE6Zn0pfSw5MTg2MDM6cz0+e3Uua2IoXCJMb2dcIixzLHZvaWQgMCl9LDkxODY1NDpzPT57dS5rYihcIlNpblwiLHMsdm9pZCAwKX0sOTE4NzA1OnM9Pnt1LmtiKFwiQ29zXCIscyx2b2lkIDApfSw5MTg3NTY6cz0+e3Uua2IoXCJUYW5cIixzLHZvaWQgMCl9LDkxODgwNzpzPT57dS5rYihcIkFzaW5cIixzLHZvaWQgMCl9LDkxODg1OTpzPT57dS5rYihcIkFjb3NcIixzLHZvaWQgMCl9LDkxODkxMTpzPT57dS5rYihcIkF0YW5cIixzLHZvaWQgMCl9LDkxODk2MzpzPT57dS5rYihcIlNpbmhcIixzLHZvaWQgMCl9LDkxOTAxNTpzPT57dS5rYihcIkNvc2hcIixzLHZvaWQgMCl9LDkxOTA2NzpzPT57dS5rYihcIkFzaW5oXCIscyx2b2lkIDApfSw5MTkxMjA6cz0+e3Uua2IoXCJBY29zaFwiLHMsdm9pZCAwKX0sOTE5MTczOnM9Pnt1LmtiKFwiQXRhbmhcIixzLHZvaWQgMCl9LDkxOTIyNjpzPT57dS5rYihcIlRhbmhcIixzLHZvaWQgMCl9LDkxOTI3ODpzPT57dS5rYihcIk5vdFwiLHMsdm9pZCAwKX0sOTE5MzI5OihzLGMsZik9Pnt1LmtiKFwiQ2xpcFwiLHMse21pbjpjLG1heDpmfSl9LDkxOTM5ODpzPT57dS5rYihcIkNsaXBcIixzLHZvaWQgMCl9LDkxOTQ1MDoocyxjKT0+e3Uua2IoXCJFbHVcIixzLHthbHBoYTpjfSl9LDkxOTUwODpzPT57dS5rYihcIkdlbHVcIixzLHZvaWQgMCl9LDkxOTU2MDpzPT57dS5rYihcIlJlbHVcIixzLHZvaWQgMCl9LDkxOTYxMjoocyxjKT0+e3Uua2IoXCJMZWFreVJlbHVcIixzLHthbHBoYTpjfSl9LDkxOTY3NjoocyxjKT0+e3Uua2IoXCJUaHJlc2hvbGRlZFJlbHVcIixzLHthbHBoYTpjfSl9LDkxOTc0NjoocyxjKT0+e3Uua2IoXCJDYXN0XCIscyx7dG86Y30pfSw5MTk4MDQ6cz0+e3Uua2IoXCJBZGRcIixzLHZvaWQgMCl9LDkxOTg1NTpzPT57dS5rYihcIlN1YlwiLHMsdm9pZCAwKX0sOTE5OTA2OnM9Pnt1LmtiKFwiTXVsXCIscyx2b2lkIDApfSw5MTk5NTc6cz0+e3Uua2IoXCJEaXZcIixzLHZvaWQgMCl9LDkyMDAwODpzPT57dS5rYihcIlBvd1wiLHMsdm9pZCAwKX0sOTIwMDU5OnM9Pnt1LmtiKFwiRXF1YWxcIixzLHZvaWQgMCl9LDkyMDExMjpzPT57dS5rYihcIkdyZWF0ZXJcIixzLHZvaWQgMCl9LDkyMDE2NzpzPT57dS5rYihcIkdyZWF0ZXJPckVxdWFsXCIscyx2b2lkIDApfSw5MjAyMjk6cz0+e3Uua2IoXCJMZXNzXCIscyx2b2lkIDApfSw5MjAyODE6cz0+e3Uua2IoXCJMZXNzT3JFcXVhbFwiLHMsdm9pZCAwKX0sOTIwMzQwOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZU1lYW5cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjA1MTU6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlTWF4XCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTIwNjg5OihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZU1pblwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkyMDg2MzoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VQcm9kXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTIxMDM4OihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZVN1bVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkyMTIxMjoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMMVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkyMTM4NToocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMMlwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkyMTU1ODoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMb2dTdW1cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjE3MzU6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlU3VtU3F1YXJlXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTIxOTE1OihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZUxvZ1N1bUV4cFwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkyMjA5NTpzPT57dS5rYihcIldoZXJlXCIscyx2b2lkIDApfSw5MjIxNDg6KHMsYyxmKT0+e3Uua2IoXCJUcmFuc3Bvc2VcIixzLHtwZXJtOmM/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIoZik+Pj4wKSk6W119KX0sOTIyMjcyOihzLGMsZixiKT0+e3Uua2IoXCJEZXB0aFRvU3BhY2VcIixzLHtibG9ja3NpemU6Yyxtb2RlOkNlKGYpLGZvcm1hdDpiP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMjQwNToocyxjLGYsYik9Pnt1LmtiKFwiRGVwdGhUb1NwYWNlXCIscyx7YmxvY2tzaXplOmMsbW9kZTpDZShmKSxmb3JtYXQ6Yj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjI1Mzg6KHMsYyxmLGIsdyxJLE8sQixHLEYsWCxsZSxnZSx6LHVlKT0+e3Uua2IoXCJDb252VHJhbnNwb3NlXCIscyx7Zm9ybWF0Okc/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpbZl0sZ3JvdXA6YixrZXJuZWxTaGFwZTpbd10scGFkczpbSSxPXSxzdHJpZGVzOltCXSx3SXNDb25zdDooKT0+ISF0KClbRj4+PjBdLG91dHB1dFBhZGRpbmc6WD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcihsZSk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Z2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGdlKT4+PjAsTnVtYmVyKHopPj4+MCkpOltdLGFjdGl2YXRpb246Q2UodWUpfSl9LDkyMjk3MToocyxjLGYsYix3LEksTyxCLEcsRixYLGxlLGdlLHopPT57dS5rYihcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6Qj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihmKT4+PjAsMisoTnVtYmVyKGYpPj4+MCk+Pj4wKSksZ3JvdXA6YixrZXJuZWxTaGFwZTpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIodyk+Pj4wLDIrKE51bWJlcih3KT4+PjApPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCw0KyhOdW1iZXIoSSk+Pj4wKT4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihPKT4+PjAsMisoTnVtYmVyKE8pPj4+MCk+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhdCgpW0c+Pj4wXSxvdXRwdXRQYWRkaW5nOkY/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEYpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6bGU/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGxlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXSxhY3RpdmF0aW9uOkNlKHopfSl9LDkyMzYzMjoocyxjLGYsYix3LEksTyxCLEcsRixYLGxlLGdlLHosdWUpPT57dS5rYihcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6Rz9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOltmXSxncm91cDpiLGtlcm5lbFNoYXBlOlt3XSxwYWRzOltJLE9dLHN0cmlkZXM6W0JdLHdJc0NvbnN0OigpPT4hIXQoKVtGPj4+MF0sb3V0cHV0UGFkZGluZzpYP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKGxlKT4+PjApKTpbXSxvdXRwdXRTaGFwZTpnZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZ2UpPj4+MCxOdW1iZXIoeik+Pj4wKSk6W10sYWN0aXZhdGlvbjpDZSh1ZSl9KX0sOTI0MDY1OihzLGMsZixiLHcsSSxPLEIsRyxGLFgsbGUsZ2Useik9Pnt1LmtiKFwiQ29udlRyYW5zcG9zZVwiLHMse2Zvcm1hdDpCP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGYpPj4+MCwyKyhOdW1iZXIoZik+Pj4wKT4+PjApKSxncm91cDpiLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcih3KT4+PjAsMisoTnVtYmVyKHcpPj4+MCk+Pj4wKSkscGFkczpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLDQrKE51bWJlcihJKT4+PjApPj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKE8pPj4+MCwyKyhOdW1iZXIoTyk+Pj4wKT4+PjApKSx3SXNDb25zdDooKT0+ISF0KClbRz4+PjBdLG91dHB1dFBhZGRpbmc6Rj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoRik+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxvdXRwdXRTaGFwZTpsZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIobGUpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdLGFjdGl2YXRpb246Q2Uoeil9KX0sOTI0NzI2OihzLGMpPT57dS5rYihcIkdsb2JhbEF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI0ODE3OihzLGMsZixiLHcsSSxPLEIsRyxGLFgsbGUsZ2Useik9Pnt1LmtiKFwiQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOmIsc3RvcmFnZV9vcmRlcjp3LGRpbGF0aW9uczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLGtlcm5lbF9zaGFwZTpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEcpPj4+MCkpOltdLHBhZHM6Rj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoRik+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxzdHJpZGVzOmxlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihsZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W119KX0sOTI1Mjk2OihzLGMpPT57dS5rYihcIkdsb2JhbEF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI1Mzg3OihzLGMsZixiLHcsSSxPLEIsRyxGLFgsbGUsZ2Useik9Pnt1LmtiKFwiQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOmIsc3RvcmFnZV9vcmRlcjp3LGRpbGF0aW9uczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLGtlcm5lbF9zaGFwZTpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEcpPj4+MCkpOltdLHBhZHM6Rj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoRik+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxzdHJpZGVzOmxlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihsZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W119KX0sOTI1ODY2OihzLGMpPT57dS5rYihcIkdsb2JhbE1heFBvb2xcIixzLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjU5NTM6KHMsYyxmLGIsdyxJLE8sQixHLEYsWCxsZSxnZSx6KT0+e3Uua2IoXCJNYXhQb29sXCIscyx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDpiLHN0b3JhZ2Vfb3JkZXI6dyxkaWxhdGlvbnM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihHKT4+PjApKTpbXSxwYWRzOkY/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEYpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sc3RyaWRlczpsZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIobGUpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdfSl9LDkyNjQyODoocyxjKT0+e3Uua2IoXCJHbG9iYWxNYXhQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI2NTE1OihzLGMsZixiLHcsSSxPLEIsRyxGLFgsbGUsZ2Useik9Pnt1LmtiKFwiTWF4UG9vbFwiLHMse2Zvcm1hdDp6P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6YixzdG9yYWdlX29yZGVyOncsZGlsYXRpb25zOkk/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCxOdW1iZXIoTyk+Pj4wKSk6W10sa2VybmVsX3NoYXBlOkI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEIpPj4+MCxOdW1iZXIoRyk+Pj4wKSk6W10scGFkczpGP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihGKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLHN0cmlkZXM6bGU/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGxlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXX0pfSw5MjY5OTA6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiR2VtbVwiLHMse2FscGhhOmMsYmV0YTpmLHRyYW5zQTpiLHRyYW5zQjp3fSl9LDkyNzA5NDpzPT57dS5rYihcIk1hdE11bFwiLHMsdm9pZCAwKX0sOTI3MTQ4OihzLGMsZixiKT0+e3Uua2IoXCJBcmdNYXhcIixzLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhZixheGlzOmJ9KX0sOTI3MjU2OihzLGMsZixiKT0+e3Uua2IoXCJBcmdNaW5cIixzLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhZixheGlzOmJ9KX0sOTI3MzY0OihzLGMpPT57dS5rYihcIlNvZnRtYXhcIixzLHtheGlzOmN9KX0sOTI3NDI3OihzLGMpPT57dS5rYihcIkNvbmNhdFwiLHMse2F4aXM6Y30pfSw5Mjc0ODc6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiU3BsaXRcIixzLHtheGlzOmMsbnVtT3V0cHV0czpmLHNwbGl0U2l6ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5Mjc2NDM6cz0+e3Uua2IoXCJFeHBhbmRcIixzLHZvaWQgMCl9LDkyNzY5NzoocyxjKT0+e3Uua2IoXCJHYXRoZXJcIixzLHtheGlzOk51bWJlcihjKX0pfSw5Mjc3Njg6KHMsYyk9Pnt1LmtiKFwiR2F0aGVyRWxlbWVudHNcIixzLHtheGlzOk51bWJlcihjKX0pfSw5Mjc4NDc6KHMsYyk9Pnt1LmtiKFwiR2F0aGVyTkRcIixzLHtiYXRjaF9kaW1zOk51bWJlcihjKX0pfSw5Mjc5MjY6KHMsYyxmLGIsdyxJLE8sQixHLEYsWCk9Pnt1LmtiKFwiUmVzaXplXCIscyx7YW50aWFsaWFzOmMsYXhlczpmP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihmKT4+PjAsTnVtYmVyKGIpPj4+MCkpOltdLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOkNlKHcpLGN1YmljQ29lZmZBOkksZXhjbHVkZU91dHNpZGU6TyxleHRyYXBvbGF0aW9uVmFsdWU6QixrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6Q2UoRyksbW9kZTpDZShGKSxuZWFyZXN0TW9kZTpDZShYKX0pfSw5MjgyODg6KHMsYyxmLGIsdyxJLE8pPT57dS5rYihcIlNsaWNlXCIscyx7c3RhcnRzOmM/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIoZik+Pj4wKSk6W10sZW5kczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdLGF4ZXM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXX0pfSw5Mjg1NTI6cz0+e3Uua2IoXCJUaWxlXCIscyx2b2lkIDApfSw5Mjg2MDQ6KHMsYyxmKT0+e3Uua2IoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsZm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI4NzE4OihzLGMsZik9Pnt1LmtiKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLGZvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyODgzMjpzPT57dS5rYihcIlJhbmdlXCIscyx2b2lkIDApfSw5Mjg4ODU6KHMsYyk9Pnt1LmtiKFwiRWluc3VtXCIscyx7ZXF1YXRpb246Q2UoYyl9KX0sOTI4OTY2OihzLGMsZixiLHcpPT57dS5rYihcIlBhZFwiLHMse21vZGU6Yyx2YWx1ZTpmLHBhZHM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjkxMDk6KHMsYyxmLGIsdyxJKT0+e3Uua2IoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsbW9tZW50dW06ZixzcGF0aWFsOiEhdyx0cmFpbmluZ01vZGU6ISFiLGZvcm1hdDpJP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyOTI3ODoocyxjLGYsYix3LEkpPT57dS5rYihcIkJhdGNoTm9ybWFsaXphdGlvblwiLHMse2Vwc2lsb246Yyxtb21lbnR1bTpmLHNwYXRpYWw6ISF3LHRyYWluaW5nTW9kZTohIWIsZm9ybWF0Okk/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI5NDQ3OihzLGMsZik9Pnt1LmtiKFwiQ3VtU3VtXCIscyx7ZXhjbHVzaXZlOk51bWJlcihjKSxyZXZlcnNlOk51bWJlcihmKX0pfSw5Mjk1NDQ6KHMsYyxmKT0+e3Uua2IoXCJEZXF1YW50aXplTGluZWFyXCIscyx7YXhpczpjLGJsb2NrU2l6ZTpmfSl9LDkyOTYzNDoocyxjLGYsYix3KT0+e3Uua2IoXCJHcmlkU2FtcGxlXCIscyx7YWxpZ25fY29ybmVyczpjLG1vZGU6Q2UoZikscGFkZGluZ19tb2RlOkNlKGIpLGZvcm1hdDp3P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyOTgwNDoocyxjLGYsYix3KT0+e3Uua2IoXCJHcmlkU2FtcGxlXCIscyx7YWxpZ25fY29ybmVyczpjLG1vZGU6Q2UoZikscGFkZGluZ19tb2RlOkNlKGIpLGZvcm1hdDp3P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyOTk3NDoocyxjLGYsYix3LEksTyxCLEcpPT57dS5rYihcIkF0dGVudGlvblwiLHMse251bUhlYWRzOmMsaXNVbmlkaXJlY3Rpb25hbDpmLG1hc2tGaWx0ZXJWYWx1ZTpiLHNjYWxlOncsZG9Sb3Rhcnk6SSxxa3ZIaWRkZW5TaXplczpPP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEIpK08+Pj4wKSk6W10scGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohIUd9KX0sOTMwMjQ2OnM9Pnt1LmtiKFwiQmlhc0FkZFwiLHMsdm9pZCAwKX0sOTMwMzAxOnM9Pnt1LmtiKFwiQmlhc1NwbGl0R2VsdVwiLHMsdm9pZCAwKX0sOTMwMzYyOnM9Pnt1LmtiKFwiRmFzdEdlbHVcIixzLHZvaWQgMCl9LDkzMDQxODoocyxjLGYsYix3LEksTyxCLEcsRixYLGxlLGdlLHosdWUsU2UpPT57dS5rYihcIkNvbnZcIixzLHtmb3JtYXQ6bGU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxkaWxhdGlvbnM6Zj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZik+Pj4wLE51bWJlcihiKT4+PjApKTpbXSxncm91cDp3LGtlcm5lbF9zaGFwZTpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLHBhZHM6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihHKT4+PjApKTpbXSxzdHJpZGVzOkY/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEYpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sd19pc19jb25zdDooKT0+ISF0KClbTnVtYmVyKGdlKT4+PjBdLGFjdGl2YXRpb246Q2UoeiksYWN0aXZhdGlvbl9wYXJhbXM6dWU/QXJyYXkuZnJvbShkKCkuc3ViYXJyYXkoTnVtYmVyKHVlKT4+PjAsTnVtYmVyKFNlKT4+PjApKTpbXX0pfSw5MzEwMDI6cz0+e3Uua2IoXCJHZWx1XCIscyx2b2lkIDApfSw5MzEwNTQ6KHMsYyxmLGIsdyxJLE8sQixHKT0+e3Uua2IoXCJHcm91cFF1ZXJ5QXR0ZW50aW9uXCIscyx7bnVtSGVhZHM6Yyxrdk51bUhlYWRzOmYsc2NhbGU6Yixzb2Z0Y2FwOncsZG9Sb3Rhcnk6SSxyb3RhcnlJbnRlcmxlYXZlZDpPLHNtb290aFNvZnRtYXg6Qixsb2NhbFdpbmRvd1NpemU6R30pfSw5MzEyNzE6KHMsYyxmLGIpPT57dS5rYihcIkxheWVyTm9ybWFsaXphdGlvblwiLHMse2F4aXM6YyxlcHNpbG9uOmYsc2ltcGxpZmllZDohIWJ9KX0sOTMxMzgyOihzLGMsZixiKT0+e3Uua2IoXCJMYXllck5vcm1hbGl6YXRpb25cIixzLHtheGlzOmMsZXBzaWxvbjpmLHNpbXBsaWZpZWQ6ISFifSl9LDkzMTQ5MzoocyxjLGYsYix3LEkpPT57dS5rYihcIk1hdE11bE5CaXRzXCIscyx7azpjLG46ZixhY2N1cmFjeUxldmVsOmIsYml0czp3LGJsb2NrU2l6ZTpJfSl9LDkzMTYyMDoocyxjLGYsYix3LEkpPT57dS5rYihcIk11bHRpSGVhZEF0dGVudGlvblwiLHMse251bUhlYWRzOmMsaXNVbmlkaXJlY3Rpb25hbDpmLG1hc2tGaWx0ZXJWYWx1ZTpiLHNjYWxlOncsZG9Sb3Rhcnk6SX0pfSw5MzE3Nzk6KHMsYyk9Pnt1LmtiKFwiUXVpY2tHZWx1XCIscyx7YWxwaGE6Y30pfSw5MzE4NDM6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUm90YXJ5RW1iZWRkaW5nXCIscyx7aW50ZXJsZWF2ZWQ6ISFjLG51bUhlYWRzOmYscm90YXJ5RW1iZWRkaW5nRGltOmIsc2NhbGU6d30pfSw5MzE5ODI6KHMsYyxmKT0+e3Uua2IoXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLHNpbXBsaWZpZWQ6ISFmfSl9LDkzMjA4NDoocyxjLGYpPT57dS5rYihcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsc2ltcGxpZmllZDohIWZ9KX0sOTMyMTg2OihzLGMsZixiKT0+e3Uua2IoXCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLHMse2dhdGhlckF4aXM6YyxxdWFudGl6ZUF4aXM6ZixibG9ja1NpemU6Yn0pfSw5MzIzMDc6cz0+e3UuJGIocyl9LDkzMjM0MToocyxjKT0+dS5jYyhOdW1iZXIocyksTnVtYmVyKGMpLHUuR2IuaGMsdS5HYi5lcnJvcnMpfTtmdW5jdGlvbiB2YyhzLGMsZil7cmV0dXJuIHlpKGFzeW5jKCk9Pnthd2FpdCB1LlliKE51bWJlcihzKSxOdW1iZXIoYyksTnVtYmVyKGYpKX0pfWZ1bmN0aW9uICRjKCl7cmV0dXJuIHR5cGVvZiB3YXNtT2Zmc2V0Q29udmVydGVyPFwidVwifWZ1bmN0aW9uIGJuKHMpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtzfSlgLHRoaXMuc3RhdHVzPXN9dmFyIHluPXM9PntzLnRlcm1pbmF0ZSgpLHMub25tZXNzYWdlPSgpPT57fX0sTm89cz0+e3B0Lmxlbmd0aD09MCYmKEZvKCksSG8ocHRbMF0pKTt2YXIgYz1wdC5wb3AoKTtpZighYylyZXR1cm4gNjskdC5wdXNoKGMpLFplW3MuQmJdPWMsYy5CYj1zLkJiO3ZhciBmPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOnMuaWMsYXJnOnMuUmIscHRocmVhZF9wdHI6cy5CYn07cmV0dXJuIGMucG9zdE1lc3NhZ2UoZixzLm5jKSwwfSx2dD0wLCRlPShzLGMsLi4uZik9Pntmb3IodmFyIGI9MipmLmxlbmd0aCx3PU1uKCksST1Cbig4KmIpLE89ST4+PjMsQj0wO0I8Zi5sZW5ndGg7QisrKXt2YXIgRz1mW0JdO3R5cGVvZiBHPT1cImJpZ2ludFwiPyhXW08rMipCXT0xbixXW08rMipCKzFdPUcpOihXW08rMipCXT0wbixsKClbTysyKkIrMT4+PjBdPUcpfXJldHVybiBzPUxpKHMsMCxiLEksYyksaHIodyksc307ZnVuY3Rpb24gX24ocyl7aWYoZylyZXR1cm4gJGUoMCwxLHMpO2lmKGo9cywhKDA8dnQpKXtmb3IodmFyIGMgb2YgJHQpeW4oYyk7Zm9yKGMgb2YgcHQpeW4oYyk7cHQ9W10sJHQ9W10sWmU9W10sRGU9ITB9QSgwLG5ldyBibihzKSl9ZnVuY3Rpb24gVm8ocyl7aWYoZylyZXR1cm4gJGUoMSwwLHMpO3duKHMpfXZhciB3bj1zPT57aWYoaj1zLGcpdGhyb3cgVm8ocyksXCJ1bndpbmRcIjtfbihzKX0scHQ9W10sJHQ9W10sV289W10sWmU9e30sTG89cz0+e3ZhciBjPXMuQmI7ZGVsZXRlIFplW2NdLHB0LnB1c2gocyksJHQuc3BsaWNlKCR0LmluZGV4T2YocyksMSkscy5CYj0wLERuKGMpfTtmdW5jdGlvbiBHbygpe1dvLmZvckVhY2gocz0+cygpKX12YXIgSG89cz0+bmV3IFByb21pc2UoYz0+e3Mub25tZXNzYWdlPXc9Pnt2YXIgST0odz13LmRhdGEpLmNtZDtpZih3LnRhcmdldFRocmVhZCYmdy50YXJnZXRUaHJlYWQhPVJ0KCkpe3ZhciBPPVplW3cudGFyZ2V0VGhyZWFkXTtPP08ucG9zdE1lc3NhZ2Uodyx3LnRyYW5zZmVyTGlzdCk6TChgSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIiR7SX1cIiB0byB0YXJnZXQgcHRocmVhZCAke3cudGFyZ2V0VGhyZWFkfSwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhYCl9ZWxzZSBJPT09XCJjaGVja01haWxib3hcIj9vcigpOkk9PT1cInNwYXduVGhyZWFkXCI/Tm8odyk6ST09PVwiY2xlYW51cFRocmVhZFwiP0xvKFplW3cudGhyZWFkXSk6ST09PVwia2lsbFRocmVhZFwiPyh3PXcudGhyZWFkLEk9WmVbd10sZGVsZXRlIFplW3ddLHluKEkpLERuKHcpLCR0LnNwbGljZSgkdC5pbmRleE9mKEkpLDEpLEkuQmI9MCk6ST09PVwiY2FuY2VsVGhyZWFkXCI/WmVbdy50aHJlYWRdLnBvc3RNZXNzYWdlKHtjbWQ6XCJjYW5jZWxcIn0pOkk9PT1cImxvYWRlZFwiPyhzLmxvYWRlZD0hMCxjKHMpKTpJPT09XCJhbGVydFwiP2FsZXJ0KGBUaHJlYWQgJHt3LnRocmVhZElkfTogJHt3LnRleHR9YCk6dy50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwiP3MucG9zdE1lc3NhZ2Uodyk6ST09PVwiY2FsbEhhbmRsZXJcIj91W3cuaGFuZGxlcl0oLi4udy5hcmdzKTpJJiZMKGB3b3JrZXIgc2VudCBhbiB1bmtub3duIGNvbW1hbmQgJHtJfWApfSxzLm9uZXJyb3I9dz0+e3Rocm93IEwoYHdvcmtlciBzZW50IGFuIGVycm9yISAke3cuZmlsZW5hbWV9OiR7dy5saW5lbm99OiAke3cubWVzc2FnZX1gKSx3fTt2YXIgZixiPVtdO2ZvcihmIG9mW10pdS5oYXNPd25Qcm9wZXJ0eShmKSYmYi5wdXNoKGYpO3MucG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRcIixoYW5kbGVyczpiLHdhc21NZW1vcnk6Syx3YXNtTW9kdWxlOndlfSl9KTtmdW5jdGlvbiBGbygpe3ZhciBzPW5ldyBXb3JrZXIoaW1wb3J0Lm1ldGEudXJsLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKT9uZXcgVVJMKFwib3J0LndlYmdwdS5idW5kbGUubWluLm1qc1wiLGltcG9ydC5tZXRhLnVybCk6bmV3IFVSTChpbXBvcnQubWV0YS51cmwpLHt0eXBlOlwibW9kdWxlXCIsd29ya2VyRGF0YTpcImVtLXB0aHJlYWRcIixuYW1lOlwiZW0tcHRocmVhZFwifSk7cHQucHVzaChzKX12YXIgbnI9cz0+e2Zvcig7MDxzLmxlbmd0aDspcy5zaGlmdCgpKHUpfSx4Yz0oKT0+e3ZhciBzPVJ0KCksYz1hKClbcys1Mj4+PjI+Pj4wXTtzPWEoKVtzKzU2Pj4+Mj4+PjBdLEhpKGMsYy1zKSxocihjKX0sU2M9KHMsYyk9Pnt2dD0wLHM9RmkocyxjKSwwPHZ0P2o9czpmcihzKX07Y2xhc3MgVGN7Y29uc3RydWN0b3IoYyl7dGhpcy5LYj1jLTI0fX1mdW5jdGlvbiBJYyhzLGMsZil7dmFyIGI9bmV3IFRjKHM+Pj49MCk7dGhyb3cgYz4+Pj0wLGY+Pj49MCxhKClbYi5LYisxNj4+PjI+Pj4wXT0wLGEoKVtiLktiKzQ+Pj4yPj4+MF09YyxhKClbYi5LYis4Pj4+Mj4+PjBdPWYsc31mdW5jdGlvbiBxbyhzLGMsZixiKXtyZXR1cm4gZz8kZSgyLDEscyxjLGYsYik6S28ocyxjLGYsYil9ZnVuY3Rpb24gS28ocyxjLGYsYil7aWYocz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wLHg9PT12b2lkIDApcmV0dXJuIEwoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciB3PVtdO3JldHVybiBnJiZ3Lmxlbmd0aD09PTA/cW8ocyxjLGYsYik6KHM9e2ljOmYsQmI6cyxSYjpiLG5jOnd9LGc/KHMuTmI9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHMsdyksMCk6Tm8ocykpfXZhciBqbz10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsWW89KHMsYyxmKT0+e3ZhciBiPShjPj4+PTApK2Y7Zm9yKGY9YztzW2ZdJiYhKGY+PWIpOykrK2Y7aWYoMTY8Zi1jJiZzLmJ1ZmZlciYmam8pcmV0dXJuIGpvLmRlY29kZShzLmJ1ZmZlciBpbnN0YW5jZW9mIHg/cy5zbGljZShjLGYpOnMuc3ViYXJyYXkoYyxmKSk7Zm9yKGI9XCJcIjtjPGY7KXt2YXIgdz1zW2MrK107aWYoMTI4Jncpe3ZhciBJPTYzJnNbYysrXTtpZigoMjI0JncpPT0xOTIpYis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmdyk8PDZ8SSk7ZWxzZXt2YXIgTz02MyZzW2MrK107NjU1MzY+KHc9KDI0MCZ3KT09MjI0PygxNSZ3KTw8MTJ8STw8NnxPOig3JncpPDwxOHxJPDwxMnxPPDw2fDYzJnNbYysrXSk/Yis9U3RyaW5nLmZyb21DaGFyQ29kZSh3KToody09NjU1MzYsYis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx3Pj4xMCw1NjMyMHwxMDIzJncpKX19ZWxzZSBiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpfXJldHVybiBifSxDZT0ocyxjKT0+KHM+Pj49MCk/WW8ocigpLHMsYyk6XCJcIjtmdW5jdGlvbiBabyhzLGMsZil7cmV0dXJuIGc/JGUoMywxLHMsYyxmKTowfWZ1bmN0aW9uIFFvKHMsYyl7aWYoZylyZXR1cm4gJGUoNCwxLHMsYyl9dmFyIHZuPXM9Pntmb3IodmFyIGM9MCxmPTA7ZjxzLmxlbmd0aDsrK2Ype3ZhciBiPXMuY2hhckNvZGVBdChmKTsxMjc+PWI/YysrOjIwNDc+PWI/Yys9Mjo1NTI5Njw9YiYmNTczNDM+PWI/KGMrPTQsKytmKTpjKz0zfXJldHVybiBjfSxYbz0ocyxjLGYsYik9PntpZighKDA8YikpcmV0dXJuIDA7dmFyIHc9Zj4+Pj0wO2I9ZitiLTE7Zm9yKHZhciBJPTA7STxzLmxlbmd0aDsrK0kpe3ZhciBPPXMuY2hhckNvZGVBdChJKTtpZig1NTI5Njw9TyYmNTczNDM+PU8mJihPPTY1NTM2KygoMTAyMyZPKTw8MTApfDEwMjMmcy5jaGFyQ29kZUF0KCsrSSkpLDEyNz49Tyl7aWYoZj49YilicmVhaztjW2YrKz4+PjBdPU99ZWxzZXtpZigyMDQ3Pj1PKXtpZihmKzE+PWIpYnJlYWs7Y1tmKys+Pj4wXT0xOTJ8Tz4+Nn1lbHNle2lmKDY1NTM1Pj1PKXtpZihmKzI+PWIpYnJlYWs7Y1tmKys+Pj4wXT0yMjR8Tz4+MTJ9ZWxzZXtpZihmKzM+PWIpYnJlYWs7Y1tmKys+Pj4wXT0yNDB8Tz4+MTgsY1tmKys+Pj4wXT0xMjh8Tz4+MTImNjN9Y1tmKys+Pj4wXT0xMjh8Tz4+NiY2M31jW2YrKz4+PjBdPTEyOHw2MyZPfX1yZXR1cm4gY1tmPj4+MF09MCxmLXd9LER0PShzLGMsZik9PlhvKHMscigpLGMsZik7ZnVuY3Rpb24gSm8ocyxjKXtpZihnKXJldHVybiAkZSg1LDEscyxjKX1mdW5jdGlvbiBlaShzLGMsZil7aWYoZylyZXR1cm4gJGUoNiwxLHMsYyxmKX1mdW5jdGlvbiB0aShzLGMsZil7cmV0dXJuIGc/JGUoNywxLHMsYyxmKTowfWZ1bmN0aW9uIHJpKHMsYyl7aWYoZylyZXR1cm4gJGUoOCwxLHMsYyl9ZnVuY3Rpb24gbmkocyxjLGYpe2lmKGcpcmV0dXJuICRlKDksMSxzLGMsZil9ZnVuY3Rpb24gb2kocyxjLGYsYil7aWYoZylyZXR1cm4gJGUoMTAsMSxzLGMsZixiKX1mdW5jdGlvbiBpaShzLGMsZixiKXtpZihnKXJldHVybiAkZSgxMSwxLHMsYyxmLGIpfWZ1bmN0aW9uIGFpKHMsYyxmLGIpe2lmKGcpcmV0dXJuICRlKDEyLDEscyxjLGYsYil9ZnVuY3Rpb24gc2kocyl7aWYoZylyZXR1cm4gJGUoMTMsMSxzKX1mdW5jdGlvbiB1aShzLGMpe2lmKGcpcmV0dXJuICRlKDE0LDEscyxjKX1mdW5jdGlvbiBkaShzLGMsZil7aWYoZylyZXR1cm4gJGUoMTUsMSxzLGMsZil9dmFyIGxpLG10LENjPSgpPT57Y3QoXCJcIil9LFFlPXM9Pntmb3IodmFyIGM9XCJcIjtyKClbcz4+PjBdOyljKz1saVtyKClbcysrPj4+MF1dO3JldHVybiBjfSwkbj17fSx4bj17fSxBYz17fTtmdW5jdGlvbiBzdChzLGMsZj17fSl7aWYoIShcImFyZ1BhY2tBZHZhbmNlXCJpbiBjKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZVwiKTtyZXR1cm4gZnVuY3Rpb24oYix3LEk9e30pe3ZhciBPPXcubmFtZTtpZighYil0aHJvdyBuZXcgbXQoYHR5cGUgXCIke099XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO2lmKHhuLmhhc093blByb3BlcnR5KGIpKXtpZihJLlRiKXJldHVybjt0aHJvdyBuZXcgbXQoYENhbm5vdCByZWdpc3RlciB0eXBlICcke099JyB0d2ljZWApfXhuW2JdPXcsZGVsZXRlIEFjW2JdLCRuLmhhc093blByb3BlcnR5KGIpJiYodz0kbltiXSxkZWxldGUgJG5bYl0sdy5mb3JFYWNoKEI9PkIoKSkpfShzLGMsZil9dmFyIGNpPShzLGMsZik9Pntzd2l0Y2goYyl7Y2FzZSAxOnJldHVybiBmP2I9PnQoKVtiPj4+MF06Yj0+cigpW2I+Pj4wXTtjYXNlIDI6cmV0dXJuIGY/Yj0+bigpW2I+Pj4xPj4+MF06Yj0+bygpW2I+Pj4xPj4+MF07Y2FzZSA0OnJldHVybiBmP2I9PmkoKVtiPj4+Mj4+PjBdOmI9PmEoKVtiPj4+Mj4+PjBdO2Nhc2UgODpyZXR1cm4gZj9iPT5XW2I+Pj4zXTpiPT5ZW2I+Pj4zXTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgaW50ZWdlciB3aWR0aCAoJHtjfSk6ICR7c31gKX19O2Z1bmN0aW9uIGtjKHMsYyxmKXtmPj4+PTAsc3Qocz4+Pj0wLHtuYW1lOmM9UWUoYz4+PjApLGZyb21XaXJlVHlwZTpiPT5iLHRvV2lyZVR5cGU6ZnVuY3Rpb24oYix3KXtpZih0eXBlb2YgdyE9XCJiaWdpbnRcIiYmdHlwZW9mIHchPVwibnVtYmVyXCIpdGhyb3cgdz13PT09bnVsbD9cIm51bGxcIjooYj10eXBlb2Ygdyk9PVwib2JqZWN0XCJ8fGI9PT1cImFycmF5XCJ8fGI9PT1cImZ1bmN0aW9uXCI/dy50b1N0cmluZygpOlwiXCIrdyxuZXcgVHlwZUVycm9yKGBDYW5ub3QgY29udmVydCBcIiR7d31cIiB0byAke3RoaXMubmFtZX1gKTtyZXR1cm4gdHlwZW9mIHc9PVwibnVtYmVyXCImJih3PUJpZ0ludCh3KSksd30sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6Y2koYyxmLGMuaW5kZXhPZihcInVcIik9PS0xKSxFYjpudWxsfSl9dmFyIGZ0PTg7ZnVuY3Rpb24gRWMocyxjLGYsYil7c3Qocz4+Pj0wLHtuYW1lOmM9UWUoYz4+PjApLGZyb21XaXJlVHlwZTpmdW5jdGlvbih3KXtyZXR1cm4hIXd9LHRvV2lyZVR5cGU6ZnVuY3Rpb24odyxJKXtyZXR1cm4gST9mOmJ9LGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZ1bmN0aW9uKHcpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShyKClbdz4+PjBdKX0sRWI6bnVsbH0pfXZhciBTbj1bXSx1dD1bXTtmdW5jdGlvbiBUbihzKXs5PChzPj4+PTApJiYtLXV0W3MrMV09PTAmJih1dFtzXT12b2lkIDAsU24ucHVzaChzKSl9dmFyIFJlPXM9PntpZighcyl0aHJvdyBuZXcgbXQoXCJDYW5ub3QgdXNlIGRlbGV0ZWQgdmFsLiBoYW5kbGUgPSBcIitzKTtyZXR1cm4gdXRbc119LFdlPXM9Pntzd2l0Y2gocyl7Y2FzZSB2b2lkIDA6cmV0dXJuIDI7Y2FzZSBudWxsOnJldHVybiA0O2Nhc2UhMDpyZXR1cm4gNjtjYXNlITE6cmV0dXJuIDg7ZGVmYXVsdDpsZXQgYz1Tbi5wb3AoKXx8dXQubGVuZ3RoO3JldHVybiB1dFtjXT1zLHV0W2MrMV09MSxjfX07ZnVuY3Rpb24gSW4ocyl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKGEoKVtzPj4+Mj4+PjBdKX12YXIgUGM9e25hbWU6XCJlbXNjcmlwdGVuOjp2YWxcIixmcm9tV2lyZVR5cGU6cz0+e3ZhciBjPVJlKHMpO3JldHVybiBUbihzKSxjfSx0b1dpcmVUeXBlOihzLGMpPT5XZShjKSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpJbixFYjpudWxsfTtmdW5jdGlvbiB6YyhzKXtyZXR1cm4gc3Qocz4+PjAsUGMpfXZhciBPYz0ocyxjKT0+e3N3aXRjaChjKXtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShkKClbZj4+PjI+Pj4wXSl9O2Nhc2UgODpyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKGwoKVtmPj4+Mz4+PjBdKX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGZsb2F0IHdpZHRoICgke2N9KTogJHtzfWApfX07ZnVuY3Rpb24gRGMocyxjLGYpe2Y+Pj49MCxzdChzPj4+PTAse25hbWU6Yz1RZShjPj4+MCksZnJvbVdpcmVUeXBlOmI9PmIsdG9XaXJlVHlwZTooYix3KT0+dyxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpPYyhjLGYpLEViOm51bGx9KX1mdW5jdGlvbiBCYyhzLGMsZixiLHcpe2lmKHM+Pj49MCxmPj4+PTAsYz1RZShjPj4+MCksdz09PS0xJiYodz00Mjk0OTY3Mjk1KSx3PUI9PkIsYj09PTApe3ZhciBJPTMyLTgqZjt3PUI9PkI8PEk+Pj5JfXZhciBPPWMuaW5jbHVkZXMoXCJ1bnNpZ25lZFwiKT9mdW5jdGlvbihCLEcpe3JldHVybiBHPj4+MH06ZnVuY3Rpb24oQixHKXtyZXR1cm4gR307c3Qocyx7bmFtZTpjLGZyb21XaXJlVHlwZTp3LHRvV2lyZVR5cGU6TyxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpjaShjLGYsYiE9PTApLEViOm51bGx9KX1mdW5jdGlvbiBNYyhzLGMsZil7ZnVuY3Rpb24gYihJKXt2YXIgTz1hKClbST4+PjI+Pj4wXTtyZXR1cm4gST1hKClbSSs0Pj4+Mj4+PjBdLG5ldyB3KHQoKS5idWZmZXIsSSxPKX12YXIgdz1bSW50OEFycmF5LFVpbnQ4QXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXksQmlnSW50NjRBcnJheSxCaWdVaW50NjRBcnJheV1bY107c3Qocz4+Pj0wLHtuYW1lOmY9UWUoZj4+PjApLGZyb21XaXJlVHlwZTpiLGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmJ9LHtUYjohMH0pfWZ1bmN0aW9uIFJjKHMsYyl7cz4+Pj0wO3ZhciBmPShjPVFlKGM+Pj4wKSk9PT1cInN0ZDo6c3RyaW5nXCI7c3Qocyx7bmFtZTpjLGZyb21XaXJlVHlwZTpmdW5jdGlvbihiKXt2YXIgdz1hKClbYj4+PjI+Pj4wXSxJPWIrNDtpZihmKWZvcih2YXIgTz1JLEI9MDtCPD13OysrQil7dmFyIEc9SStCO2lmKEI9PXd8fHIoKVtHPj4+MF09PTApe2lmKE89Q2UoTyxHLU8pLEY9PT12b2lkIDApdmFyIEY9TztlbHNlIEYrPVN0cmluZy5mcm9tQ2hhckNvZGUoMCksRis9TztPPUcrMX19ZWxzZXtmb3IoRj1BcnJheSh3KSxCPTA7Qjx3OysrQilGW0JdPVN0cmluZy5mcm9tQ2hhckNvZGUocigpW0krQj4+PjBdKTtGPUYuam9pbihcIlwiKX1yZXR1cm4gSmUoYiksRn0sdG9XaXJlVHlwZTpmdW5jdGlvbihiLHcpe3cgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKHc9bmV3IFVpbnQ4QXJyYXkodykpO3ZhciBJPXR5cGVvZiB3PT1cInN0cmluZ1wiO2lmKCEoSXx8dyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fHcgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8dyBpbnN0YW5jZW9mIEludDhBcnJheSkpdGhyb3cgbmV3IG10KFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZ1wiKTt2YXIgTz1mJiZJP3ZuKHcpOncubGVuZ3RoLEI9bXIoNCtPKzEpLEc9Qis0O2lmKGEoKVtCPj4+Mj4+PjBdPU8sZiYmSSlEdCh3LEcsTysxKTtlbHNlIGlmKEkpZm9yKEk9MDtJPE87KytJKXt2YXIgRj13LmNoYXJDb2RlQXQoSSk7aWYoMjU1PEYpdGhyb3cgSmUoRyksbmV3IG10KFwiU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzXCIpO3IoKVtHK0k+Pj4wXT1GfWVsc2UgZm9yKEk9MDtJPE87KytJKXIoKVtHK0k+Pj4wXT13W0ldO3JldHVybiBiIT09bnVsbCYmYi5wdXNoKEplLEIpLEJ9LGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOkluLEViKGIpe0plKGIpfX0pfXZhciBwaT10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmLTE2bGVcIik6dm9pZCAwLFVjPShzLGMpPT57Zm9yKHZhciBmPXM+PjEsYj1mK2MvMjshKGY+PWIpJiZvKClbZj4+PjBdOykrK2Y7aWYoMzI8KGY8PD0xKS1zJiZwaSlyZXR1cm4gcGkuZGVjb2RlKHIoKS5zbGljZShzLGYpKTtmb3IoZj1cIlwiLGI9MDshKGI+PWMvMik7KytiKXt2YXIgdz1uKClbcysyKmI+Pj4xPj4+MF07aWYodz09MClicmVhaztmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpfXJldHVybiBmfSxOYz0ocyxjLGYpPT57aWYoZj8/PTIxNDc0ODM2NDcsMj5mKXJldHVybiAwO3ZhciBiPWM7Zj0oZi09Mik8MipzLmxlbmd0aD9mLzI6cy5sZW5ndGg7Zm9yKHZhciB3PTA7dzxmOysrdyl7dmFyIEk9cy5jaGFyQ29kZUF0KHcpO24oKVtjPj4+MT4+PjBdPUksYys9Mn1yZXR1cm4gbigpW2M+Pj4xPj4+MF09MCxjLWJ9LFZjPXM9PjIqcy5sZW5ndGgsV2M9KHMsYyk9Pntmb3IodmFyIGY9MCxiPVwiXCI7IShmPj1jLzQpOyl7dmFyIHc9aSgpW3MrNCpmPj4+Mj4+PjBdO2lmKHc9PTApYnJlYWs7KytmLDY1NTM2PD13Pyh3LT02NTUzNixiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fHc+PjEwLDU2MzIwfDEwMjMmdykpOmIrPVN0cmluZy5mcm9tQ2hhckNvZGUodyl9cmV0dXJuIGJ9LExjPShzLGMsZik9PntpZihjPj4+PTAsZj8/PTIxNDc0ODM2NDcsND5mKXJldHVybiAwO3ZhciBiPWM7Zj1iK2YtNDtmb3IodmFyIHc9MDt3PHMubGVuZ3RoOysrdyl7dmFyIEk9cy5jaGFyQ29kZUF0KHcpO2lmKDU1Mjk2PD1JJiY1NzM0Mz49SSYmKEk9NjU1MzYrKCgxMDIzJkkpPDwxMCl8MTAyMyZzLmNoYXJDb2RlQXQoKyt3KSksaSgpW2M+Pj4yPj4+MF09SSwoYys9NCkrND5mKWJyZWFrfXJldHVybiBpKClbYz4+PjI+Pj4wXT0wLGMtYn0sR2M9cz0+e2Zvcih2YXIgYz0wLGY9MDtmPHMubGVuZ3RoOysrZil7dmFyIGI9cy5jaGFyQ29kZUF0KGYpOzU1Mjk2PD1iJiY1NzM0Mz49YiYmKytmLGMrPTR9cmV0dXJuIGN9O2Z1bmN0aW9uIEhjKHMsYyxmKXtpZihzPj4+PTAsYz4+Pj0wLGY9UWUoZj4+Pj0wKSxjPT09Mil2YXIgYj1VYyx3PU5jLEk9VmMsTz1CPT5vKClbQj4+PjE+Pj4wXTtlbHNlIGM9PT00JiYoYj1XYyx3PUxjLEk9R2MsTz1CPT5hKClbQj4+PjI+Pj4wXSk7c3Qocyx7bmFtZTpmLGZyb21XaXJlVHlwZTpCPT57Zm9yKHZhciBHLEY9YSgpW0I+Pj4yPj4+MF0sWD1CKzQsbGU9MDtsZTw9RjsrK2xlKXt2YXIgZ2U9Qis0K2xlKmM7bGUhPUYmJk8oZ2UpIT0wfHwoWD1iKFgsZ2UtWCksRz09PXZvaWQgMD9HPVg6KEcrPVN0cmluZy5mcm9tQ2hhckNvZGUoMCksRys9WCksWD1nZStjKX1yZXR1cm4gSmUoQiksR30sdG9XaXJlVHlwZTooQixHKT0+e2lmKHR5cGVvZiBHIT1cInN0cmluZ1wiKXRocm93IG5ldyBtdChgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtmfWApO3ZhciBGPUkoRyksWD1tcig0K0YrYyk7cmV0dXJuIGEoKVtYPj4+Mj4+PjBdPUYvYyx3KEcsWCs0LEYrYyksQiE9PW51bGwmJkIucHVzaChKZSxYKSxYfSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpJbixFYihCKXtKZShCKX19KX1mdW5jdGlvbiBGYyhzLGMpe3N0KHM+Pj49MCx7VWI6ITAsbmFtZTpjPVFlKGM+Pj4wKSxhcmdQYWNrQWR2YW5jZTowLGZyb21XaXJlVHlwZTooKT0+e30sdG9XaXJlVHlwZTooKT0+e319KX12YXIgcWM9KCk9PjE7ZnVuY3Rpb24gS2Mocyl7T24ocz4+PjAsIXksMSwhXywxMzEwNzIsITEpLEdvKCl9dmFyIG1pPXM9PntpZighRGUpdHJ5e2lmKHMoKSwhKDA8dnQpKXRyeXtnP2ZyKGopOnduKGopfWNhdGNoKGMpe2MgaW5zdGFuY2VvZiBibnx8Yz09XCJ1bndpbmRcInx8QSgwLGMpfX1jYXRjaChjKXtjIGluc3RhbmNlb2YgYm58fGM9PVwidW53aW5kXCJ8fEEoMCxjKX19O2Z1bmN0aW9uIENuKHMpe3M+Pj49MCx0eXBlb2YgQXRvbWljcy5vYz09XCJmdW5jdGlvblwiJiYoQXRvbWljcy5vYyhpKCkscz4+PjIscykudmFsdWUudGhlbihvcikscys9MTI4LEF0b21pY3Muc3RvcmUoaSgpLHM+Pj4yLDEpKX12YXIgb3I9KCk9Pnt2YXIgcz1SdCgpO3MmJihDbihzKSxtaShHaSkpfTtmdW5jdGlvbiBqYyhzLGMpeyhzPj4+PTApPT1jPj4+MD9zZXRUaW1lb3V0KG9yKTpnP3Bvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6cyxjbWQ6XCJjaGVja01haWxib3hcIn0pOihzPVplW3NdKSYmcy5wb3N0TWVzc2FnZSh7Y21kOlwiY2hlY2tNYWlsYm94XCJ9KX12YXIgQW49W107ZnVuY3Rpb24gWWMocyxjLGYsYix3KXtmb3IoYz4+Pj0wLGIvPTIsQW4ubGVuZ3RoPWIsZj13Pj4+MD4+PjMsdz0wO3c8Yjt3KyspQW5bd109V1tmKzIqd10/V1tmKzIqdysxXTpsKClbZisyKncrMT4+PjBdO3JldHVybihjP2duW2NdOk5wW3NdKSguLi5Bbil9ZnVuY3Rpb24gWmMocyl7cz4+Pj0wLGc/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6c30pOkxvKFplW3NdKX1mdW5jdGlvbiBRYyhzKXt9dmFyIGlyPShzLGMpPT57dmFyIGY9eG5bc107aWYoZj09PXZvaWQgMCl0aHJvdyBzPU5pKHMpLGY9UWUocyksSmUocyksbmV3IG10KGAke2N9IGhhcyB1bmtub3duIHR5cGUgJHtmfWApO3JldHVybiBmfSxmaT0ocyxjLGYpPT57dmFyIGI9W107cmV0dXJuIHM9cy50b1dpcmVUeXBlKGIsZiksYi5sZW5ndGgmJihhKClbYz4+PjI+Pj4wXT1XZShiKSksc307ZnVuY3Rpb24gWGMocyxjLGYpe3JldHVybiBjPj4+PTAsZj4+Pj0wLHM9UmUocz4+PjApLGM9aXIoYyxcImVtdmFsOjphc1wiKSxmaShjLGYscyl9ZnVuY3Rpb24gSmMocyxjKXtyZXR1cm4gYz4+Pj0wLHM9UmUocz4+PjApLChjPWlyKGMsXCJlbXZhbDo6YXNcIikpLnRvV2lyZVR5cGUobnVsbCxzKX12YXIgYXI9cz0+e3RyeXtzKCl9Y2F0Y2goYyl7Y3QoYyl9fSxodD0wLFhlPW51bGwsaGk9MCxzcj1bXSxnaT17fSxiaT17fSxlcD0wLGtuPW51bGwsdHA9W107ZnVuY3Rpb24geWkocyl7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKCFEZSl7aWYoaHQ9PT0wKXt2YXIgZj0hMSxiPSExO2MoKHc9MCk9PntpZighRGUmJihoaT13LGY9ITAsYikpe2h0PTIsYXIoKCk9PmppKFhlKSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuTGIuU2ImJkJyb3dzZXIuTGIucmVzdW1lKCksdz0hMTt0cnl7dmFyIEk9ZnVuY3Rpb24oKXt2YXIgRz1pKClbWGUrOD4+PjI+Pj4wXTtyZXR1cm4gRz1aW2JpW0ddXSwtLXZ0LEcoKX0oKX1jYXRjaChHKXtJPUcsdz0hMH12YXIgTz0hMTtpZighWGUpe3ZhciBCPWtuO0ImJihrbj1udWxsLCh3P0IucmVqZWN0OkIucmVzb2x2ZSkoSSksTz0hMCl9aWYodyYmIU8pdGhyb3cgSX19KSxiPSEwLGZ8fChodD0xLFhlPWZ1bmN0aW9uKCl7dmFyIHc9bXIoNjU1NDgpLEk9dysxMjthKClbdz4+PjI+Pj4wXT1JLGEoKVt3KzQ+Pj4yPj4+MF09SSs2NTUzNixJPXNyWzBdO3ZhciBPPWdpW0ldO3JldHVybiBPPT09dm9pZCAwJiYoTz1lcCsrLGdpW0ldPU8sYmlbT109SSksST1PLGkoKVt3Kzg+Pj4yPj4+MF09SSx3fSgpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLkxiLlNiJiZCcm93c2VyLkxiLnBhdXNlKCksYXIoKCk9PnFpKFhlKSkpfWVsc2UgaHQ9PT0yPyhodD0wLGFyKFlpKSxKZShYZSksWGU9bnVsbCx0cC5mb3JFYWNoKG1pKSk6Y3QoYGludmFsaWQgc3RhdGU6ICR7aHR9YCk7cmV0dXJuIGhpfX0oYz0+e3MoKS50aGVuKGMpfSl9ZnVuY3Rpb24gcnAocyl7cmV0dXJuIHM+Pj49MCx5aSgoKT0+KHM9UmUocykpLnRoZW4oV2UpKX12YXIgdXI9W107ZnVuY3Rpb24gbnAocyxjLGYsYil7cmV0dXJuIGY+Pj49MCxiPj4+PTAsKHM9dXJbcz4+PjBdKShudWxsLGM9UmUoYz4+PjApLGYsYil9dmFyIG9wPXt9LGRyPXM9Pnt2YXIgYz1vcFtzXTtyZXR1cm4gYz09PXZvaWQgMD9RZShzKTpjfTtmdW5jdGlvbiBpcChzLGMsZixiLHcpe3JldHVybiBmPj4+PTAsYj4+Pj0wLHc+Pj49MCwocz11cltzPj4+MF0pKGM9UmUoYz4+PjApLGNbZj1kcihmKV0sYix3KX12YXIgX2k9KCk9PnR5cGVvZiBnbG9iYWxUaGlzPT1cIm9iamVjdFwiP2dsb2JhbFRoaXM6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO2Z1bmN0aW9uIGFwKHMpe3JldHVybihzPj4+PTApPT0wP1dlKF9pKCkpOihzPWRyKHMpLFdlKF9pKClbc10pKX12YXIgc3A9cz0+e3ZhciBjPXVyLmxlbmd0aDtyZXR1cm4gdXIucHVzaChzKSxjfSx1cD0ocyxjKT0+e2Zvcih2YXIgZj1BcnJheShzKSxiPTA7YjxzOysrYilmW2JdPWlyKGEoKVtjKzQqYj4+PjI+Pj4wXSxcInBhcmFtZXRlciBcIitiKTtyZXR1cm4gZn0sd2k9KHMsYyk9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLFwibmFtZVwiLHt2YWx1ZTpzfSk7ZnVuY3Rpb24gZHAocyxjLGYpe3ZhciBiPShjPXVwKHMsYz4+PjApKS5zaGlmdCgpO3MtLTt2YXIgdz1gcmV0dXJuIGZ1bmN0aW9uIChvYmosIGZ1bmMsIGRlc3RydWN0b3JzUmVmLCBhcmdzKSB7XG5gLEk9MCxPPVtdO2Y9PT0wJiZPLnB1c2goXCJvYmpcIik7Zm9yKHZhciBCPVtcInJldFR5cGVcIl0sRz1bYl0sRj0wO0Y8czsrK0YpTy5wdXNoKFwiYXJnXCIrRiksQi5wdXNoKFwiYXJnVHlwZVwiK0YpLEcucHVzaChjW0ZdKSx3Kz1gICB2YXIgYXJnJHtGfSA9IGFyZ1R5cGUke0Z9LnJlYWRWYWx1ZUZyb21Qb2ludGVyKGFyZ3Mke0k/XCIrXCIrSTpcIlwifSk7XG5gLEkrPWNbRl0uYXJnUGFja0FkdmFuY2U7cmV0dXJuIHcrPWAgIHZhciBydiA9ICR7Zj09PTE/XCJuZXcgZnVuY1wiOlwiZnVuYy5jYWxsXCJ9KCR7Ty5qb2luKFwiLCBcIil9KTtcbmAsYi5VYnx8KEIucHVzaChcImVtdmFsX3JldHVyblZhbHVlXCIpLEcucHVzaChmaSksdys9YCAgcmV0dXJuIGVtdmFsX3JldHVyblZhbHVlKHJldFR5cGUsIGRlc3RydWN0b3JzUmVmLCBydik7XG5gKSxCLnB1c2godytgfTtcbmApLHM9ZnVuY3Rpb24oWCl7dmFyIGxlPUZ1bmN0aW9uO2lmKCEobGUgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihgbmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICR7dHlwZW9mIGxlfSB3aGljaCBpcyBub3QgYSBmdW5jdGlvbmApO3ZhciBnZT13aShsZS5uYW1lfHxcInVua25vd25GdW5jdGlvbk5hbWVcIixmdW5jdGlvbigpe30pO3JldHVybiBnZS5wcm90b3R5cGU9bGUucHJvdG90eXBlLGdlPW5ldyBnZSwoWD1sZS5hcHBseShnZSxYKSlpbnN0YW5jZW9mIE9iamVjdD9YOmdlfShCKSguLi5HKSxmPWBtZXRob2RDYWxsZXI8KCR7Yy5tYXAoWD0+WC5uYW1lKS5qb2luKFwiLCBcIil9KSA9PiAke2IubmFtZX0+YCxzcCh3aShmLHMpKX1mdW5jdGlvbiBscChzKXtyZXR1cm4gcz1kcihzPj4+MCksV2UodVtzXSl9ZnVuY3Rpb24gY3AocyxjKXtyZXR1cm4gYz4+Pj0wLHM9UmUocz4+PjApLGM9UmUoYyksV2Uoc1tjXSl9ZnVuY3Rpb24gcHAocyl7OTwocz4+Pj0wKSYmKHV0W3MrMV0rPTEpfWZ1bmN0aW9uIG1wKCl7cmV0dXJuIFdlKFtdKX1mdW5jdGlvbiBmcChzKXtzPVJlKHM+Pj4wKTtmb3IodmFyIGM9QXJyYXkocy5sZW5ndGgpLGY9MDtmPHMubGVuZ3RoO2YrKyljW2ZdPXNbZl07cmV0dXJuIFdlKGMpfWZ1bmN0aW9uIGhwKHMpe3JldHVybiBXZShkcihzPj4+MCkpfWZ1bmN0aW9uIGdwKCl7cmV0dXJuIFdlKHt9KX1mdW5jdGlvbiBicChzKXtmb3IodmFyIGM9UmUocz4+Pj0wKTtjLmxlbmd0aDspe3ZhciBmPWMucG9wKCk7Yy5wb3AoKShmKX1UbihzKX1mdW5jdGlvbiB5cChzLGMsZil7Yz4+Pj0wLGY+Pj49MCxzPVJlKHM+Pj4wKSxjPVJlKGMpLGY9UmUoZiksc1tjXT1mfWZ1bmN0aW9uIF9wKHMsYyl7cmV0dXJuIGM+Pj49MCxzPShzPWlyKHM+Pj4wLFwiX2VtdmFsX3Rha2VfdmFsdWVcIikpLnJlYWRWYWx1ZUZyb21Qb2ludGVyKGMpLFdlKHMpfWZ1bmN0aW9uIHdwKHMsYyl7cz0tOTAwNzE5OTI1NDc0MDk5Mj5zfHw5MDA3MTk5MjU0NzQwOTkyPHM/TmFOOk51bWJlcihzKSxjPj4+PTAscz1uZXcgRGF0ZSgxZTMqcyksaSgpW2M+Pj4yPj4+MF09cy5nZXRVVENTZWNvbmRzKCksaSgpW2MrND4+PjI+Pj4wXT1zLmdldFVUQ01pbnV0ZXMoKSxpKClbYys4Pj4+Mj4+PjBdPXMuZ2V0VVRDSG91cnMoKSxpKClbYysxMj4+PjI+Pj4wXT1zLmdldFVUQ0RhdGUoKSxpKClbYysxNj4+PjI+Pj4wXT1zLmdldFVUQ01vbnRoKCksaSgpW2MrMjA+Pj4yPj4+MF09cy5nZXRVVENGdWxsWWVhcigpLTE5MDAsaSgpW2MrMjQ+Pj4yPj4+MF09cy5nZXRVVENEYXkoKSxzPShzLmdldFRpbWUoKS1EYXRlLlVUQyhzLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLGkoKVtjKzI4Pj4+Mj4+PjBdPXN9dmFyIEJ0PXM9PnMlND09MCYmKHMlMTAwIT0wfHxzJTQwMD09MCksdmk9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0sJGk9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07ZnVuY3Rpb24gdnAocyxjKXtzPS05MDA3MTk5MjU0NzQwOTkyPnN8fDkwMDcxOTkyNTQ3NDA5OTI8cz9OYU46TnVtYmVyKHMpLGM+Pj49MCxzPW5ldyBEYXRlKDFlMypzKSxpKClbYz4+PjI+Pj4wXT1zLmdldFNlY29uZHMoKSxpKClbYys0Pj4+Mj4+PjBdPXMuZ2V0TWludXRlcygpLGkoKVtjKzg+Pj4yPj4+MF09cy5nZXRIb3VycygpLGkoKVtjKzEyPj4+Mj4+PjBdPXMuZ2V0RGF0ZSgpLGkoKVtjKzE2Pj4+Mj4+PjBdPXMuZ2V0TW9udGgoKSxpKClbYysyMD4+PjI+Pj4wXT1zLmdldEZ1bGxZZWFyKCktMTkwMCxpKClbYysyND4+PjI+Pj4wXT1zLmdldERheSgpO3ZhciBmPShCdChzLmdldEZ1bGxZZWFyKCkpP3ZpOiRpKVtzLmdldE1vbnRoKCldK3MuZ2V0RGF0ZSgpLTF8MDtpKClbYysyOD4+PjI+Pj4wXT1mLGkoKVtjKzM2Pj4+Mj4+PjBdPS02MCpzLmdldFRpbWV6b25lT2Zmc2V0KCksZj1uZXcgRGF0ZShzLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBiPW5ldyBEYXRlKHMuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7cz0wfChmIT1iJiZzLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKGIsZikpLGkoKVtjKzMyPj4+Mj4+PjBdPXN9ZnVuY3Rpb24gJHAocyl7cz4+Pj0wO3ZhciBjPW5ldyBEYXRlKGkoKVtzKzIwPj4+Mj4+PjBdKzE5MDAsaSgpW3MrMTY+Pj4yPj4+MF0saSgpW3MrMTI+Pj4yPj4+MF0saSgpW3MrOD4+PjI+Pj4wXSxpKClbcys0Pj4+Mj4+PjBdLGkoKVtzPj4+Mj4+PjBdLDApLGY9aSgpW3MrMzI+Pj4yPj4+MF0sYj1jLmdldFRpbWV6b25lT2Zmc2V0KCksdz1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEk9bmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxPPU1hdGgubWluKEksdyk7cmV0dXJuIDA+Zj9pKClbcyszMj4+PjI+Pj4wXT0rKHchPUkmJk89PWIpOjA8ZiE9KE89PWIpJiYodz1NYXRoLm1heChJLHcpLGMuc2V0VGltZShjLmdldFRpbWUoKSs2ZTQqKCgwPGY/Tzp3KS1iKSkpLGkoKVtzKzI0Pj4+Mj4+PjBdPWMuZ2V0RGF5KCksZj0oQnQoYy5nZXRGdWxsWWVhcigpKT92aTokaSlbYy5nZXRNb250aCgpXStjLmdldERhdGUoKS0xfDAsaSgpW3MrMjg+Pj4yPj4+MF09ZixpKClbcz4+PjI+Pj4wXT1jLmdldFNlY29uZHMoKSxpKClbcys0Pj4+Mj4+PjBdPWMuZ2V0TWludXRlcygpLGkoKVtzKzg+Pj4yPj4+MF09Yy5nZXRIb3VycygpLGkoKVtzKzEyPj4+Mj4+PjBdPWMuZ2V0RGF0ZSgpLGkoKVtzKzE2Pj4+Mj4+PjBdPWMuZ2V0TW9udGgoKSxpKClbcysyMD4+PjI+Pj4wXT1jLmdldFllYXIoKSxzPWMuZ2V0VGltZSgpLEJpZ0ludChpc05hTihzKT8tMTpzLzFlMyl9ZnVuY3Rpb24geGkocyxjLGYsYix3LEksTyl7cmV0dXJuIGc/JGUoMTYsMSxzLGMsZixiLHcsSSxPKTotNTJ9ZnVuY3Rpb24gU2kocyxjLGYsYix3LEkpe2lmKGcpcmV0dXJuICRlKDE3LDEscyxjLGYsYix3LEkpfWZ1bmN0aW9uIHhwKHMsYyxmLGIpe3M+Pj49MCxjPj4+PTAsZj4+Pj0wLGI+Pj49MDt2YXIgdz1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksST1uZXcgRGF0ZSh3LDAsMSksTz1uZXcgRGF0ZSh3LDYsMSk7dz1JLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEI9Ty5nZXRUaW1lem9uZU9mZnNldCgpLEc9TWF0aC5tYXgodyxCKTthKClbcz4+PjI+Pj4wXT02MCpHLGkoKVtjPj4+Mj4+PjBdPSsodyE9QiksST0ocz1GPT5GLnRvTG9jYWxlVGltZVN0cmluZyh2b2lkIDAse2hvdXIxMjohMSx0aW1lWm9uZU5hbWU6XCJzaG9ydFwifSkuc3BsaXQoXCIgXCIpWzFdKShJKSxPPXMoTyksQjx3PyhEdChJLGYsMTcpLER0KE8sYiwxNykpOihEdChJLGIsMTcpLER0KE8sZiwxNykpfXZhciBFbj1bXSxUaT0ocyxjKT0+e0VuLmxlbmd0aD0wO2Zvcih2YXIgZjtmPXIoKVtzKys+Pj4wXTspe3ZhciBiPWYhPTEwNTtjKz0oYiY9ZiE9MTEyKSYmYyU4PzQ6MCxFbi5wdXNoKGY9PTExMj9hKClbYz4+PjI+Pj4wXTpmPT0xMDY/V1tjPj4+M106Zj09MTA1P2koKVtjPj4+Mj4+PjBdOmwoKVtjPj4+Mz4+PjBdKSxjKz1iPzg6NH1yZXR1cm4gRW59O2Z1bmN0aW9uIFNwKHMsYyxmKXtyZXR1cm4gcz4+Pj0wLGM9VGkoYz4+PjAsZj4+PjApLGduW3NdKC4uLmMpfWZ1bmN0aW9uIFRwKHMsYyxmKXtyZXR1cm4gcz4+Pj0wLGM9VGkoYz4+PjAsZj4+PjApLGduW3NdKC4uLmMpfXZhciBJcD0oKT0+e30sQ3A9KCk9PkRhdGUubm93KCk7ZnVuY3Rpb24gQXAocyxjKXtyZXR1cm4gTChDZShzPj4+MCxjPj4+MCkpfXZhciBJaSxrcD0oKT0+e3Rocm93IHZ0Kz0xLFwidW53aW5kXCJ9O2Z1bmN0aW9uIEVwKCl7cmV0dXJuIDQyOTQ5MDE3NjB9SWk9KCk9PnBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCk7dmFyIFBwPSgpPT5uYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtmdW5jdGlvbiB6cCgpe3JldHVybiBjdChcIkNhbm5vdCB1c2UgZW1zY3JpcHRlbl9wY19nZXRfZnVuY3Rpb24gd2l0aG91dCAtc1VTRV9PRkZTRVRfQ09OVkVSVEVSXCIpLDB9ZnVuY3Rpb24gT3Aocyl7cz4+Pj0wO3ZhciBjPXIoKS5sZW5ndGg7aWYoczw9Y3x8NDI5NDkwMTc2MDxzKXJldHVybiExO2Zvcih2YXIgZj0xOzQ+PWY7Zio9Mil7dmFyIGI9YyooMSsuMi9mKTtiPU1hdGgubWluKGIscysxMDA2NjMyOTYpO3ZhciB3PU1hdGg7Yj1NYXRoLm1heChzLGIpO2U6e3c9KHcubWluLmNhbGwodyw0Mjk0OTAxNzYwLGIrKDY1NTM2LWIlNjU1MzYpJTY1NTM2KS1LLmJ1ZmZlci5ieXRlTGVuZ3RoKzY1NTM1KS82NTUzNjt0cnl7Sy5ncm93KHcpLHBlKCk7dmFyIEk9MTticmVhayBlfWNhdGNoe31JPXZvaWQgMH1pZihJKXJldHVybiEwfXJldHVybiExfXZhciBscj0oKT0+KGN0KFwiQ2Fubm90IHVzZSBjb252ZXJ0RnJhbWVUb1BDIChuZWVkZWQgYnkgX19idWlsdGluX3JldHVybl9hZGRyZXNzKSB3aXRob3V0IC1zVVNFX09GRlNFVF9DT05WRVJURVJcIiksMCksTXQ9e30sQ2k9cz0+e3MuZm9yRWFjaChjPT57dmFyIGY9bHIoKTtmJiYoTXRbZl09Yyl9KX07ZnVuY3Rpb24gRHAoKXt2YXIgcz1FcnJvcigpLnN0YWNrLnRvU3RyaW5nKCkuc3BsaXQoYFxuYCk7cmV0dXJuIHNbMF09PVwiRXJyb3JcIiYmcy5zaGlmdCgpLENpKHMpLE10LlFiPWxyKCksTXQuZmM9cyxNdC5RYn1mdW5jdGlvbiBCcChzLGMsZil7aWYocz4+Pj0wLGM+Pj49MCxNdC5RYj09cyl2YXIgYj1NdC5mYztlbHNlKGI9RXJyb3IoKS5zdGFjay50b1N0cmluZygpLnNwbGl0KGBcbmApKVswXT09XCJFcnJvclwiJiZiLnNoaWZ0KCksQ2koYik7Zm9yKHZhciB3PTM7Ylt3XSYmbHIoKSE9czspKyt3O2ZvcihzPTA7czxmJiZiW3Mrd107KytzKWkoKVtjKzQqcz4+PjI+Pj4wXT1scigpO3JldHVybiBzfXZhciBQbix6bj17fSxBaT0oKT0+e2lmKCFQbil7dmFyIHMsYz17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzoodHlwZW9mIG5hdmlnYXRvcj09XCJvYmplY3RcIiYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpcIi4vdGhpcy5wcm9ncmFtXCJ9O2ZvcihzIGluIHpuKXpuW3NdPT09dm9pZCAwP2RlbGV0ZSBjW3NdOmNbc109em5bc107dmFyIGY9W107Zm9yKHMgaW4gYylmLnB1c2goYCR7c309JHtjW3NdfWApO1BuPWZ9cmV0dXJuIFBufTtmdW5jdGlvbiBraShzLGMpe2lmKGcpcmV0dXJuICRlKDE4LDEscyxjKTtzPj4+PTAsYz4+Pj0wO3ZhciBmPTA7cmV0dXJuIEFpKCkuZm9yRWFjaCgoYix3KT0+e3ZhciBJPWMrZjtmb3Iodz1hKClbcys0Knc+Pj4yPj4+MF09SSxJPTA7STxiLmxlbmd0aDsrK0kpdCgpW3crKz4+PjBdPWIuY2hhckNvZGVBdChJKTt0KClbdz4+PjBdPTAsZis9Yi5sZW5ndGgrMX0pLDB9ZnVuY3Rpb24gRWkocyxjKXtpZihnKXJldHVybiAkZSgxOSwxLHMsYyk7cz4+Pj0wLGM+Pj49MDt2YXIgZj1BaSgpO2EoKVtzPj4+Mj4+PjBdPWYubGVuZ3RoO3ZhciBiPTA7cmV0dXJuIGYuZm9yRWFjaCh3PT5iKz13Lmxlbmd0aCsxKSxhKClbYz4+PjI+Pj4wXT1iLDB9ZnVuY3Rpb24gUGkocyl7cmV0dXJuIGc/JGUoMjAsMSxzKTo1Mn1mdW5jdGlvbiB6aShzLGMsZixiKXtyZXR1cm4gZz8kZSgyMSwxLHMsYyxmLGIpOjUyfWZ1bmN0aW9uIE9pKHMsYyxmLGIpe3JldHVybiBnPyRlKDIyLDEscyxjLGYsYik6NzB9dmFyIE1wPVtudWxsLFtdLFtdXTtmdW5jdGlvbiBEaShzLGMsZixiKXtpZihnKXJldHVybiAkZSgyMywxLHMsYyxmLGIpO2M+Pj49MCxmPj4+PTAsYj4+Pj0wO2Zvcih2YXIgdz0wLEk9MDtJPGY7SSsrKXt2YXIgTz1hKClbYz4+PjI+Pj4wXSxCPWEoKVtjKzQ+Pj4yPj4+MF07Yys9ODtmb3IodmFyIEc9MDtHPEI7RysrKXt2YXIgRj1yKClbTytHPj4+MF0sWD1NcFtzXTtGPT09MHx8Rj09PTEwPygocz09PTE/SDpMKShZbyhYLDApKSxYLmxlbmd0aD0wKTpYLnB1c2goRil9dys9Qn1yZXR1cm4gYSgpW2I+Pj4yPj4+MF09dywwfXZhciBCaT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLE1pPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sUnA9KHMsYyk9Pnt0KCkuc2V0KHMsYz4+PjApfTtmdW5jdGlvbiBSaShzLGMsZixiKXtmdW5jdGlvbiB3KHosdWUsU2Upe2Zvcih6PXR5cGVvZiB6PT1cIm51bWJlclwiP3oudG9TdHJpbmcoKTp6fHxcIlwiO3oubGVuZ3RoPHVlOyl6PVNlWzBdK3o7cmV0dXJuIHp9ZnVuY3Rpb24gSSh6LHVlKXtyZXR1cm4gdyh6LHVlLFwiMFwiKX1mdW5jdGlvbiBPKHosdWUpe2Z1bmN0aW9uIFNlKFFpKXtyZXR1cm4gMD5RaT8tMTowPFFpPzE6MH12YXIgeHQ7cmV0dXJuKHh0PVNlKHouZ2V0RnVsbFllYXIoKS11ZS5nZXRGdWxsWWVhcigpKSk9PT0wJiYoeHQ9U2Uoei5nZXRNb250aCgpLXVlLmdldE1vbnRoKCkpKT09PTAmJih4dD1TZSh6LmdldERhdGUoKS11ZS5nZXREYXRlKCkpKSx4dH1mdW5jdGlvbiBCKHope3N3aXRjaCh6LmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHo7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIEcoeil7dmFyIHVlPXouQ2I7Zm9yKHo9bmV3IERhdGUobmV3IERhdGUoei5EYisxOTAwLDAsMSkuZ2V0VGltZSgpKTswPHVlOyl7dmFyIFNlPXouZ2V0TW9udGgoKSx4dD0oQnQoei5nZXRGdWxsWWVhcigpKT9CaTpNaSlbU2VdO2lmKCEodWU+eHQtei5nZXREYXRlKCkpKXt6LnNldERhdGUoei5nZXREYXRlKCkrdWUpO2JyZWFrfXVlLT14dC16LmdldERhdGUoKSsxLHouc2V0RGF0ZSgxKSwxMT5TZT96LnNldE1vbnRoKFNlKzEpOih6LnNldE1vbnRoKDApLHouc2V0RnVsbFllYXIoei5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gU2U9bmV3IERhdGUoei5nZXRGdWxsWWVhcigpKzEsMCw0KSx1ZT1CKG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKSwwLDQpKSxTZT1CKFNlKSwwPj1PKHVlLHopPzA+PU8oU2Useik/ei5nZXRGdWxsWWVhcigpKzE6ei5nZXRGdWxsWWVhcigpOnouZ2V0RnVsbFllYXIoKS0xfXM+Pj49MCxjPj4+PTAsZj4+Pj0wLGI+Pj49MDt2YXIgRj1hKClbYis0MD4+PjI+Pj4wXTtmb3IodmFyIFggaW4gYj17bGM6aSgpW2I+Pj4yPj4+MF0sa2M6aSgpW2IrND4+PjI+Pj4wXSxJYjppKClbYis4Pj4+Mj4+PjBdLE1iOmkoKVtiKzEyPj4+Mj4+PjBdLEpiOmkoKVtiKzE2Pj4+Mj4+PjBdLERiOmkoKVtiKzIwPj4+Mj4+PjBdLHZiOmkoKVtiKzI0Pj4+Mj4+PjBdLENiOmkoKVtiKzI4Pj4+Mj4+PjBdLHNjOmkoKVtiKzMyPj4+Mj4+PjBdLGpjOmkoKVtiKzM2Pj4+Mj4+PjBdLG1jOkY/Q2UoRik6XCJcIn0sZj1DZShmKSxGPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn0pZj1mLnJlcGxhY2UobmV3IFJlZ0V4cChYLFwiZ1wiKSxGW1hdKTt2YXIgbGU9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxnZT1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKFggaW4gRj17XCIlYVwiOno9PmxlW3oudmJdLnN1YnN0cmluZygwLDMpLFwiJUFcIjp6PT5sZVt6LnZiXSxcIiViXCI6ej0+Z2Vbei5KYl0uc3Vic3RyaW5nKDAsMyksXCIlQlwiOno9PmdlW3ouSmJdLFwiJUNcIjp6PT5JKCh6LkRiKzE5MDApLzEwMHwwLDIpLFwiJWRcIjp6PT5JKHouTWIsMiksXCIlZVwiOno9Pncoei5NYiwyLFwiIFwiKSxcIiVnXCI6ej0+Ryh6KS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVHXCI6RyxcIiVIXCI6ej0+SSh6LkliLDIpLFwiJUlcIjp6PT4oKHo9ei5JYik9PTA/ej0xMjoxMjx6JiYoei09MTIpLEkoeiwyKSksXCIlalwiOno9Pntmb3IodmFyIHVlPTAsU2U9MDtTZTw9ei5KYi0xO3VlKz0oQnQoei5EYisxOTAwKT9CaTpNaSlbU2UrK10pO3JldHVybiBJKHouTWIrdWUsMyl9LFwiJW1cIjp6PT5JKHouSmIrMSwyKSxcIiVNXCI6ej0+SSh6LmtjLDIpLFwiJW5cIjooKT0+YFxuYCxcIiVwXCI6ej0+MDw9ei5JYiYmMTI+ei5JYj9cIkFNXCI6XCJQTVwiLFwiJVNcIjp6PT5JKHoubGMsMiksXCIldFwiOigpPT5cIlx0XCIsXCIldVwiOno9PnoudmJ8fDcsXCIlVVwiOno9PkkoTWF0aC5mbG9vcigoei5DYis3LXoudmIpLzcpLDIpLFwiJVZcIjp6PT57dmFyIHVlPU1hdGguZmxvb3IoKHouQ2IrNy0oei52Yis2KSU3KS83KTtpZigyPj0oei52YiszNzEtei5DYi0yKSU3JiZ1ZSsrLHVlKXVlPT01MyYmKChTZT0oei52YiszNzEtei5DYiklNyk9PTR8fFNlPT0zJiZCdCh6LkRiKXx8KHVlPTEpKTtlbHNle3VlPTUyO3ZhciBTZT0oei52Yis3LXouQ2ItMSklNzsoU2U9PTR8fFNlPT01JiZCdCh6LkRiJTQwMC0xKSkmJnVlKyt9cmV0dXJuIEkodWUsMil9LFwiJXdcIjp6PT56LnZiLFwiJVdcIjp6PT5JKE1hdGguZmxvb3IoKHouQ2IrNy0oei52Yis2KSU3KS83KSwyKSxcIiV5XCI6ej0+KHouRGIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOno9PnouRGIrMTkwMCxcIiV6XCI6ej0+e3ZhciB1ZT0wPD0oej16LmpjKTtyZXR1cm4gej1NYXRoLmFicyh6KS82MCwodWU/XCIrXCI6XCItXCIpKyhcIjAwMDBcIisoei82MCoxMDAreiU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOno9PnoubWMsXCIlJVwiOigpPT5cIiVcIn0sZj1mLnJlcGxhY2UoLyUlL2csXCJcXDBcXDBcIiksRilmLmluY2x1ZGVzKFgpJiYoZj1mLnJlcGxhY2UobmV3IFJlZ0V4cChYLFwiZ1wiKSxGW1hdKGIpKSk7cmV0dXJuIFg9ZnVuY3Rpb24oeil7dmFyIHVlPUFycmF5KHZuKHopKzEpO3JldHVybiBYbyh6LHVlLDAsdWUubGVuZ3RoKSx1ZX0oZj1mLnJlcGxhY2UoL1xcMFxcMC9nLFwiJVwiKSksWC5sZW5ndGg+Yz8wOihScChYLHMpLFgubGVuZ3RoLTEpfWZ1bmN0aW9uIFVwKHMsYyxmLGIpe3JldHVybiBSaShzPj4+MCxjPj4+MCxmPj4+MCxiPj4+MCl9Z3x8ZnVuY3Rpb24oKXtmb3IodmFyIHM9dS5udW1UaHJlYWRzLTE7cy0tOylGbygpO0llLnVuc2hpZnQoKCk9Pnt3dCsrLGZ1bmN0aW9uKGMpe2c/YygpOlByb21pc2UuYWxsKHB0Lm1hcChIbykpLnRoZW4oYyl9KCgpPT5PbygpKX0pfSgpO2Zvcih2YXIgVWk9QXJyYXkoMjU2KSxjcj0wOzI1Nj5jcjsrK2NyKVVpW2NyXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGNyKTtsaT1VaSxtdD11LkJpbmRpbmdFcnJvcj1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHMpe3N1cGVyKHMpLHRoaXMubmFtZT1cIkJpbmRpbmdFcnJvclwifX0sdS5JbnRlcm5hbEVycm9yPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3Iocyl7c3VwZXIocyksdGhpcy5uYW1lPVwiSW50ZXJuYWxFcnJvclwifX0sdXQucHVzaCgwLDEsdm9pZCAwLDEsbnVsbCwxLCEwLDEsITEsMSksdS5jb3VudF9lbXZhbF9oYW5kbGVzPSgpPT51dC5sZW5ndGgvMi01LVNuLmxlbmd0aDt2YXIgTnA9W19uLFZvLHFvLFpvLFFvLEpvLGVpLHRpLHJpLG5pLG9pLGlpLGFpLHNpLHVpLGRpLHhpLFNpLGtpLEVpLFBpLHppLE9pLERpXSxaPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcyhmLGIpe3JldHVybiBaPWYuZXhwb3J0cyxaPWZ1bmN0aW9uKCl7dmFyIHc9WixJPXt9O2ZvcihsZXRbTyxCXW9mIE9iamVjdC5lbnRyaWVzKHcpKUlbT109dHlwZW9mIEI9PVwiZnVuY3Rpb25cIj8oLi4uRyk9Pntzci5wdXNoKE8pO3RyeXtyZXR1cm4gQiguLi5HKX1maW5hbGx5e0RlfHwoc3IucG9wKCksWGUmJmh0PT09MSYmc3IubGVuZ3RoPT09MCYmKGh0PTAsdnQrPTEsYXIoS2kpLHR5cGVvZiBGaWJlcnM8XCJ1XCImJkZpYmVycy50YygpKSl9fTpCO3JldHVybiBJfSgpLFo9ZnVuY3Rpb24oKXt2YXIgdz1aLEk9Qj0+Rz0+QihHKT4+PjAsTz1CPT4oKT0+QigpPj4+MDtyZXR1cm4odz1PYmplY3QuYXNzaWduKHt9LHcpKS5EYT1JKHcuRGEpLHcuZ2I9Tyh3LmdiKSx3LmliPUkody5pYiksdy5lbXNjcmlwdGVuX21haW5fcnVudGltZV90aHJlYWRfaWQ9Tyh3LmVtc2NyaXB0ZW5fbWFpbl9ydW50aW1lX3RocmVhZF9pZCksdy50Yj1JKHcudGIpLHcudWI9Tyh3LnViKSx3fSgpLFdvLnB1c2goWi5qYiksSGUudW5zaGlmdChaLkNhKSx3ZT1iLE9vKCksWn12YXIgYz1VbygpO2lmKHd0KyssdS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiB1Lmluc3RhbnRpYXRlV2FzbShjLHMpfWNhdGNoKGYpe0woYE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICR7Zn1gKSxtKGYpfXJldHVybiBobnx8PXUubG9jYXRlRmlsZT9EbyhcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIpP1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21cIjp1LmxvY2F0ZUZpbGU/dS5sb2NhdGVGaWxlKFwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21cIixDKTpDK1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21cIjpuZXcgVVJMKFwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21cIixpbXBvcnQubWV0YS51cmwpLmhyZWYsZnVuY3Rpb24oZixiKXt2YXIgdz1objtyZXR1cm4gUHx8dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nIT1cImZ1bmN0aW9uXCJ8fERvKHcpfHxCbyh3KXx8dHlwZW9mIGZldGNoIT1cImZ1bmN0aW9uXCI/Um8odyxmLGIpOmZldGNoKHcse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oST0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoSSxmKS50aGVuKGIsZnVuY3Rpb24oTyl7cmV0dXJuIEwoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke099YCksTChcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLFJvKHcsZixiKX0pKX0oYyxmdW5jdGlvbihmKXtzKGYuaW5zdGFuY2UsZi5tb2R1bGUpfSkuY2F0Y2gobSkse319KCksTmk9cz0+KE5pPVouRGEpKHMpLFZpPSgpPT4oVmk9Wi5FYSkoKTt1Ll9PcnRJbml0PShzLGMpPT4odS5fT3J0SW5pdD1aLkZhKShzLGMpLHUuX09ydEdldExhc3RFcnJvcj0ocyxjKT0+KHUuX09ydEdldExhc3RFcnJvcj1aLkdhKShzLGMpLHUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShzLGMsZixiLHcsSSxPLEIsRyxGKT0+KHUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPVouSGEpKHMsYyxmLGIsdyxJLE8sQixHLEYpLHUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPShzLGMpPT4odS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9Wi5JYSkocyxjKSx1Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9KHMsYyxmKT0+KHUuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT1aLkphKShzLGMsZiksdS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShzLGMsZik9Pih1Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9Wi5LYSkocyxjLGYpLHUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1zPT4odS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPVouTGEpKHMpLHUuX09ydENyZWF0ZVNlc3Npb249KHMsYyxmKT0+KHUuX09ydENyZWF0ZVNlc3Npb249Wi5NYSkocyxjLGYpLHUuX09ydFJlbGVhc2VTZXNzaW9uPXM9Pih1Ll9PcnRSZWxlYXNlU2Vzc2lvbj1aLk5hKShzKSx1Ll9PcnRHZXRJbnB1dE91dHB1dENvdW50PShzLGMsZik9Pih1Ll9PcnRHZXRJbnB1dE91dHB1dENvdW50PVouT2EpKHMsYyxmKSx1Ll9PcnRHZXRJbnB1dE5hbWU9KHMsYyk9Pih1Ll9PcnRHZXRJbnB1dE5hbWU9Wi5QYSkocyxjKSx1Ll9PcnRHZXRPdXRwdXROYW1lPShzLGMpPT4odS5fT3J0R2V0T3V0cHV0TmFtZT1aLlFhKShzLGMpLHUuX09ydEZyZWU9cz0+KHUuX09ydEZyZWU9Wi5SYSkocyksdS5fT3J0Q3JlYXRlVGVuc29yPShzLGMsZixiLHcsSSk9Pih1Ll9PcnRDcmVhdGVUZW5zb3I9Wi5TYSkocyxjLGYsYix3LEkpLHUuX09ydEdldFRlbnNvckRhdGE9KHMsYyxmLGIsdyk9Pih1Ll9PcnRHZXRUZW5zb3JEYXRhPVouVGEpKHMsYyxmLGIsdyksdS5fT3J0UmVsZWFzZVRlbnNvcj1zPT4odS5fT3J0UmVsZWFzZVRlbnNvcj1aLlVhKShzKSx1Ll9PcnRDcmVhdGVSdW5PcHRpb25zPShzLGMsZixiKT0+KHUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9Wi5WYSkocyxjLGYsYiksdS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KHMsYyxmKT0+KHUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PVouV2EpKHMsYyxmKSx1Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucz1zPT4odS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9Wi5YYSkocyksdS5fT3J0Q3JlYXRlQmluZGluZz1zPT4odS5fT3J0Q3JlYXRlQmluZGluZz1aLllhKShzKSx1Ll9PcnRCaW5kSW5wdXQ9KHMsYyxmKT0+KHUuX09ydEJpbmRJbnB1dD1aLlphKShzLGMsZiksdS5fT3J0QmluZE91dHB1dD0ocyxjLGYsYik9Pih1Ll9PcnRCaW5kT3V0cHV0PVouX2EpKHMsYyxmLGIpLHUuX09ydENsZWFyQm91bmRPdXRwdXRzPXM9Pih1Ll9PcnRDbGVhckJvdW5kT3V0cHV0cz1aLiRhKShzKSx1Ll9PcnRSZWxlYXNlQmluZGluZz1zPT4odS5fT3J0UmVsZWFzZUJpbmRpbmc9Wi5hYikocyksdS5fT3J0UnVuV2l0aEJpbmRpbmc9KHMsYyxmLGIsdyk9Pih1Ll9PcnRSdW5XaXRoQmluZGluZz1aLmJiKShzLGMsZixiLHcpLHUuX09ydFJ1bj0ocyxjLGYsYix3LEksTyxCKT0+KHUuX09ydFJ1bj1aLmNiKShzLGMsZixiLHcsSSxPLEIpLHUuX09ydEVuZFByb2ZpbGluZz1zPT4odS5fT3J0RW5kUHJvZmlsaW5nPVouZGIpKHMpLHUuX0pzZXBPdXRwdXQ9KHMsYyxmKT0+KHUuX0pzZXBPdXRwdXQ9Wi5lYikocyxjLGYpLHUuX0pzZXBHZXROb2RlTmFtZT1zPT4odS5fSnNlcEdldE5vZGVOYW1lPVouZmIpKHMpO3ZhciBwcixSdD0oKT0+KFJ0PVouZ2IpKCksSmU9dS5fZnJlZT1zPT4oSmU9dS5fZnJlZT1aLmhiKShzKSxtcj11Ll9tYWxsb2M9cz0+KG1yPXUuX21hbGxvYz1aLmliKShzKSxPbj0ocyxjLGYsYix3LEkpPT4oT249Wi5sYikocyxjLGYsYix3LEkpLFdpPSgpPT4oV2k9Wi5tYikoKSxMaT0ocyxjLGYsYix3KT0+KExpPVoubmIpKHMsYyxmLGIsdyksRG49cz0+KERuPVoub2IpKHMpLGZyPXM9Pihmcj1aLnBiKShzKSxHaT0oKT0+KEdpPVoucWIpKCksSGk9KHMsYyk9PihIaT1aLnJiKShzLGMpLGhyPXM9Pihocj1aLnNiKShzKSxCbj1zPT4oQm49Wi50YikocyksTW49KCk9PihNbj1aLnViKSgpLEZpPXUuZHluQ2FsbF9paT0ocyxjKT0+KEZpPXUuZHluQ2FsbF9paT1aLndiKShzLGMpLHFpPXM9PihxaT1aLnhiKShzKSxLaT0oKT0+KEtpPVoueWIpKCksamk9cz0+KGppPVouemIpKHMpLFlpPSgpPT4oWWk9Wi5BYikoKTtmdW5jdGlvbiBaaSgpezA8d3R8fChnPyhwKHUpLGd8fG5yKEhlKSxzdGFydFdvcmtlcih1KSk6KG5yKEllKSwwPHd0fHxwcnx8KHByPSEwLHUuY2FsbGVkUnVuPSEwLERlfHwoZ3x8bnIoSGUpLHAodSksZ3x8bnIobW4pKSkpKX1yZXR1cm4gdS5fX19zdGFydF9lbV9qcz05MzI0NjksdS5fX19zdG9wX2VtX2pzPTkzMjcxNSx1LnN0YWNrU2F2ZT0oKT0+TW4oKSx1LnN0YWNrUmVzdG9yZT1zPT5ocihzKSx1LnN0YWNrQWxsb2M9cz0+Qm4ocyksdS5zZXRWYWx1ZT1mdW5jdGlvbihzLGMsZj1cImk4XCIpe3N3aXRjaChmLmVuZHNXaXRoKFwiKlwiKSYmKGY9XCIqXCIpLGYpe2Nhc2VcImkxXCI6Y2FzZVwiaThcIjp0KClbcz4+PjBdPWM7YnJlYWs7Y2FzZVwiaTE2XCI6bigpW3M+Pj4xPj4+MF09YzticmVhaztjYXNlXCJpMzJcIjppKClbcz4+PjI+Pj4wXT1jO2JyZWFrO2Nhc2VcImk2NFwiOldbcz4+PjNdPUJpZ0ludChjKTticmVhaztjYXNlXCJmbG9hdFwiOmQoKVtzPj4+Mj4+PjBdPWM7YnJlYWs7Y2FzZVwiZG91YmxlXCI6bCgpW3M+Pj4zPj4+MF09YzticmVhaztjYXNlXCIqXCI6YSgpW3M+Pj4yPj4+MF09YzticmVhaztkZWZhdWx0OmN0KGBpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiAke2Z9YCl9fSx1LmdldFZhbHVlPWZ1bmN0aW9uKHMsYz1cImk4XCIpe3N3aXRjaChjLmVuZHNXaXRoKFwiKlwiKSYmKGM9XCIqXCIpLGMpe2Nhc2VcImkxXCI6Y2FzZVwiaThcIjpyZXR1cm4gdCgpW3M+Pj4wXTtjYXNlXCJpMTZcIjpyZXR1cm4gbigpW3M+Pj4xPj4+MF07Y2FzZVwiaTMyXCI6cmV0dXJuIGkoKVtzPj4+Mj4+PjBdO2Nhc2VcImk2NFwiOnJldHVybiBXW3M+Pj4zXTtjYXNlXCJmbG9hdFwiOnJldHVybiBkKClbcz4+PjI+Pj4wXTtjYXNlXCJkb3VibGVcIjpyZXR1cm4gbCgpW3M+Pj4zPj4+MF07Y2FzZVwiKlwiOnJldHVybiBhKClbcz4+PjI+Pj4wXTtkZWZhdWx0OmN0KGBpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAke2N9YCl9fSx1LlVURjhUb1N0cmluZz1DZSx1LnN0cmluZ1RvVVRGOD1EdCx1Lmxlbmd0aEJ5dGVzVVRGOD12bixHdD1mdW5jdGlvbiBzKCl7cHJ8fFppKCkscHJ8fChHdD1zKX0sWmkoKSx1LlBUUl9TSVpFPTQsaH0pLEtwPVBhO2dsb2JhbFRoaXMuc2VsZj8ubmFtZT09PVwiZW0tcHRocmVhZFwiJiZQYSgpfSk7dmFyIE1hLGpwLFZlLFJhLEtuLFlwLFpwLFVhLFFwLERhLE5hLEJhLFZhLCRyPVUoKCk9PntcInVzZSBzdHJpY3RcIjt2cigpO01hPSExfHx0eXBlb2YgbG9jYXRpb24+XCJ1XCI/dm9pZCAwOmxvY2F0aW9uLm9yaWdpbixqcD0oKT0+e2lmKCEhMSlyZXR1cm4gaW1wb3J0Lm1ldGEudXJsPy5zdGFydHNXaXRoKFwiZmlsZTpcIik/bmV3IFVSTChuZXcgVVJMKFwib3J0LndlYmdwdS5idW5kbGUubWluLm1qc1wiLGltcG9ydC5tZXRhLnVybCkuaHJlZixNYSkuaHJlZjppbXBvcnQubWV0YS51cmx9LFZlPWpwKCksUmE9KCk9PntpZihWZSYmIVZlLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSlyZXR1cm4gVmUuc3Vic3RyaW5nKDAsVmUubGFzdEluZGV4T2YoXCIvXCIpKzEpfSxLbj0oZSx0KT0+e3RyeXtsZXQgcj10Pz9WZTtyZXR1cm4ocj9uZXcgVVJMKGUscik6bmV3IFVSTChlKSkub3JpZ2luPT09TWF9Y2F0Y2h7cmV0dXJuITF9fSxZcD0oZSx0KT0+e2xldCByPXQ/P1ZlO3RyeXtyZXR1cm4ocj9uZXcgVVJMKGUscik6bmV3IFVSTChlKSkuaHJlZn1jYXRjaHtyZXR1cm59fSxacD0oZSx0KT0+YCR7dD8/XCIuL1wifSR7ZX1gLFVhPWFzeW5jIGU9PntsZXQgcj1hd2FpdChhd2FpdCBmZXRjaChlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KSkuYmxvYigpO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKHIpfSxRcD1hc3luYyBlPT4oYXdhaXQgaW1wb3J0KC8qd2VicGFja0lnbm9yZTp0cnVlKi9lKSkuZGVmYXVsdCxEYT0oRWEoKSxncihrYSkpLmRlZmF1bHQsTmE9YXN5bmMoKT0+e2lmKCFWZSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBwcm94eSB3b3JrZXI6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIHNjcmlwdCBzb3VyY2UgVVJMLlwiKTtpZihLbihWZSkpcmV0dXJuW3ZvaWQgMCxEYSgpXTtsZXQgZT1hd2FpdCBVYShWZSk7cmV0dXJuW2UsRGEoZSldfSxCYT0oT2EoKSxncih6YSkpLmRlZmF1bHQsVmE9YXN5bmMoZSx0LHIpPT57aWYoIWUmJiF0JiZCYSYmVmUmJktuKFZlKSlyZXR1cm5bdm9pZCAwLEJhXTt7bGV0IG49XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAubWpzXCIsbz1lPz9ZcChuLHQpLGk9ISExJiZyJiZvJiYhS24obyx0KSxhPWk/YXdhaXQgVWEobyk6bz8/WnAobix0KTtyZXR1cm5baT9hOnZvaWQgMCxhd2FpdCBRcChhKV19fX0pO3ZhciBqbixZbixQcixXYSxYcCxKcCx4cixUZSxndD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHIoKTtZbj0hMSxQcj0hMSxXYT0hMSxYcD0oKT0+e2lmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIilyZXR1cm4hMTt0cnl7cmV0dXJuIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbDxcInVcIiYmbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sSnA9KCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0seHI9YXN5bmMgZT0+e2lmKFluKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihQcil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtpZihXYSl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtQcj0hMDtsZXQgdD1lLmluaXRUaW1lb3V0LHI9ZS5udW1UaHJlYWRzO2lmKCFKcCgpKXRocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cIik7bGV0IG49WHAoKTtyPjEmJiFuJiYodHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQmJmNvbnNvbGUud2FybihcImVudi53YXNtLm51bVRocmVhZHMgaXMgc2V0IHRvIFwiK3IrXCIsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiBTZWUgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGZvciBtb3JlIGluZm8uXCIpLGNvbnNvbGUud2FybihcIldlYkFzc2VtYmx5IG11bHRpLXRocmVhZGluZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBGYWxsaW5nIGJhY2sgdG8gc2luZ2xlLXRocmVhZGluZy5cIiksZS5udW1UaHJlYWRzPXI9MSk7bGV0IG89ZS53YXNtUGF0aHMsaT10eXBlb2Ygbz09XCJzdHJpbmdcIj9vOnZvaWQgMCxhPW8/Lm1qcyxkPWE/LmhyZWY/P2EsbD1vPy53YXNtLHA9bD8uaHJlZj8/bCxtPWUud2FzbUJpbmFyeSxbdSxoXT1hd2FpdCBWYShkLGkscj4xKSxfPSExLHk9W107aWYodD4wJiZ5LnB1c2gobmV3IFByb21pc2UoZz0+e3NldFRpbWVvdXQoKCk9PntfPSEwLGcoKX0sdCl9KSkseS5wdXNoKG5ldyBQcm9taXNlKChnLHgpPT57bGV0ICQ9e251bVRocmVhZHM6cn07aWYobSkkLndhc21CaW5hcnk9bTtlbHNlIGlmKHB8fGkpJC5sb2NhdGVGaWxlPXY9PnA/P2krdjtlbHNlIGlmKGQmJmQuaW5kZXhPZihcImJsb2I6XCIpIT09MCkkLmxvY2F0ZUZpbGU9dj0+bmV3IFVSTCh2LGQpLmhyZWY7ZWxzZSBpZih1KXtsZXQgdj1SYSgpO3YmJigkLmxvY2F0ZUZpbGU9Uz0+ditTKX1oKCQpLnRoZW4odj0+e1ByPSExLFluPSEwLGpuPXYsZygpLHUmJlVSTC5yZXZva2VPYmplY3RVUkwodSl9LHY9PntQcj0hMSxXYT0hMCx4KHYpfSl9KSksYXdhaXQgUHJvbWlzZS5yYWNlKHkpLF8pdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dH1tc2ApfSxUZT0oKT0+e2lmKFluJiZqbilyZXR1cm4gam47dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9fSk7dmFyIGtlLEt0LGNlLHpyPVUoKCk9PntcInVzZSBzdHJpY3RcIjtndCgpO2tlPShlLHQpPT57bGV0IHI9VGUoKSxuPXIubGVuZ3RoQnl0ZXNVVEY4KGUpKzEsbz1yLl9tYWxsb2Mobik7cmV0dXJuIHIuc3RyaW5nVG9VVEY4KGUsbyxuKSx0LnB1c2gobyksb30sS3Q9KGUsdCxyLG4pPT57aWYodHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsKXtpZihyLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9uc1wiKTtyLmFkZChlKX1PYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbbyxpXSk9PntsZXQgYT10P3QrbzpvO2lmKHR5cGVvZiBpPT1cIm9iamVjdFwiKUt0KGksYStcIi5cIixyLG4pO2Vsc2UgaWYodHlwZW9mIGk9PVwic3RyaW5nXCJ8fHR5cGVvZiBpPT1cIm51bWJlclwiKW4oYSxpLnRvU3RyaW5nKCkpO2Vsc2UgaWYodHlwZW9mIGk9PVwiYm9vbGVhblwiKW4oYSxpP1wiMVwiOlwiMFwiKTtlbHNlIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiBpfWApfSl9LGNlPWU9PntsZXQgdD1UZSgpLHI9dC5zdGFja1NhdmUoKTt0cnl7bGV0IG49dC5QVFJfU0laRSxvPXQuc3RhY2tBbGxvYygyKm4pO3QuX09ydEdldExhc3RFcnJvcihvLG8rbik7bGV0IGk9TnVtYmVyKHQuZ2V0VmFsdWUobyxuPT09ND9cImkzMlwiOlwiaTY0XCIpKSxhPXQuZ2V0VmFsdWUobytuLFwiKlwiKSxkPWE/dC5VVEY4VG9TdHJpbmcoYSk6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gRVJST1JfQ09ERTogJHtpfSwgRVJST1JfTUVTU0FHRTogJHtkfWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fX0pO3ZhciBMYSxHYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z3QoKTt6cigpO0xhPWU9PntsZXQgdD1UZSgpLHI9MCxuPVtdLG89ZXx8e307dHJ5e2lmKGU/LmxvZ1NldmVyaXR5TGV2ZWw9PT12b2lkIDApby5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZih0eXBlb2YgZS5sb2dTZXZlcml0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1NldmVyaXR5TGV2ZWwpfHxlLmxvZ1NldmVyaXR5TGV2ZWw8MHx8ZS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYoZT8ubG9nVmVyYm9zaXR5TGV2ZWw9PT12b2lkIDApby5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYodHlwZW9mIGUubG9nVmVyYm9zaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dWZXJib3NpdHlMZXZlbH1gKTtlPy50ZXJtaW5hdGU9PT12b2lkIDAmJihvLnRlcm1pbmF0ZT0hMSk7bGV0IGk9MDtyZXR1cm4gZT8udGFnIT09dm9pZCAwJiYoaT1rZShlLnRhZyxuKSkscj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKG8ubG9nU2V2ZXJpdHlMZXZlbCxvLmxvZ1ZlcmJvc2l0eUxldmVsLCEhby50ZXJtaW5hdGUsaSkscj09PTAmJmNlKFwiQ2FuJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKSxlPy5leHRyYSE9PXZvaWQgMCYmS3QoZS5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LChhLGQpPT57bGV0IGw9a2UoYSxuKSxwPWtlKGQsbik7dC5fT3J0QWRkUnVuQ29uZmlnRW50cnkocixsLHApIT09MCYmY2UoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7YX0gLSAke2R9LmApfSksW3Isbl19Y2F0Y2goaSl7dGhyb3cgciE9PTAmJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKHIpLG4uZm9yRWFjaChhPT50Ll9mcmVlKGEpKSxpfX19KTt2YXIgZW0sdG0scm0sbm0sSGEsRmE9VSgoKT0+e1widXNlIHN0cmljdFwiO2d0KCk7enIoKTtlbT1lPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSx0bT1lPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0scm09ZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKHI9Pih0eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnIubmFtZSk9PT1cIndlYmdwdVwiKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9LG5tPShlLHQscik9Pntmb3IobGV0IG4gb2YgdCl7bGV0IG89dHlwZW9mIG49PVwic3RyaW5nXCI/bjpuLm5hbWU7c3dpdGNoKG8pe2Nhc2VcIndlYm5uXCI6aWYobz1cIldFQk5OXCIsdHlwZW9mIG4hPVwic3RyaW5nXCIpe2xldCBkPW4/LmRldmljZVR5cGU7aWYoZCl7bGV0IGw9a2UoXCJkZXZpY2VUeXBlXCIscikscD1rZShkLHIpO1RlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGwscCkhPT0wJiZjZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdkZXZpY2VUeXBlJyAtICR7ZH0uYCl9fWJyZWFrO2Nhc2VcIndlYmdwdVwiOmlmKG89XCJKU1wiLHR5cGVvZiBuIT1cInN0cmluZ1wiKXtsZXQgYT1uO2lmKGE/LnByZWZlcnJlZExheW91dCl7aWYoYS5wcmVmZXJyZWRMYXlvdXQhPT1cIk5DSFdcIiYmYS5wcmVmZXJyZWRMYXlvdXQhPT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciAnTkNIVycgb3IgJ05IV0MnOiAke2EucHJlZmVycmVkTGF5b3V0fWApO2xldCBkPWtlKFwicHJlZmVycmVkTGF5b3V0XCIsciksbD1rZShhLnByZWZlcnJlZExheW91dCxyKTtUZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxkLGwpIT09MCYmY2UoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncHJlZmVycmVkTGF5b3V0JyAtICR7YS5wcmVmZXJyZWRMYXlvdXR9LmApfX1icmVhaztjYXNlXCJ3YXNtXCI6Y2FzZVwiY3B1XCI6Y29udGludWU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke299YCl9bGV0IGk9a2UobyxyKTtUZSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihlLGkpIT09MCYmY2UoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7b30uYCl9fSxIYT1lPT57bGV0IHQ9VGUoKSxyPTAsbj1bXSxvPWV8fHt9O3JtKG8pO3RyeXtsZXQgaT1lbShvLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/P1wiYWxsXCIpLGE9dG0oby5leGVjdXRpb25Nb2RlPz9cInNlcXVlbnRpYWxcIiksZD10eXBlb2Ygby5sb2dJZD09XCJzdHJpbmdcIj9rZShvLmxvZ0lkLG4pOjAsbD1vLmxvZ1NldmVyaXR5TGV2ZWw/PzI7aWYoIU51bWJlci5pc0ludGVnZXIobCl8fGw8MHx8bD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bH1gKTtsZXQgcD1vLmxvZ1ZlcmJvc2l0eUxldmVsPz8wO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHApfHxwPDB8fHA+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3B9YCk7bGV0IG09dHlwZW9mIG8ub3B0aW1pemVkTW9kZWxGaWxlUGF0aD09XCJzdHJpbmdcIj9rZShvLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsbik6MDtpZihyPXQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKGksISFvLmVuYWJsZUNwdU1lbUFyZW5hLCEhby5lbmFibGVNZW1QYXR0ZXJuLGEsISFvLmVuYWJsZVByb2ZpbGluZywwLGQsbCxwLG0pLHI9PT0wJiZjZShcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuXCIpLG8uZXhlY3V0aW9uUHJvdmlkZXJzJiZubShyLG8uZXhlY3V0aW9uUHJvdmlkZXJzLG4pLG8uZW5hYmxlR3JhcGhDYXB0dXJlIT09dm9pZCAwKXtpZih0eXBlb2Ygby5lbmFibGVHcmFwaENhcHR1cmUhPVwiYm9vbGVhblwiKXRocm93IG5ldyBFcnJvcihgZW5hYmxlR3JhcGhDYXB0dXJlIG11c3QgYmUgYSBib29sZWFuIHZhbHVlOiAke28uZW5hYmxlR3JhcGhDYXB0dXJlfWApO2xldCB1PWtlKFwiZW5hYmxlR3JhcGhDYXB0dXJlXCIsbiksaD1rZShvLmVuYWJsZUdyYXBoQ2FwdHVyZS50b1N0cmluZygpLG4pO3QuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShyLHUsaCkhPT0wJiZjZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdlbmFibGVHcmFwaENhcHR1cmUnIC0gJHtvLmVuYWJsZUdyYXBoQ2FwdHVyZX0uYCl9aWYoby5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKWZvcihsZXRbdSxoXW9mIE9iamVjdC5lbnRyaWVzKG8uZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpe2lmKHR5cGVvZiB1IT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke3V9YCk7aWYodHlwZW9mIGghPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGgpfHxoPDApdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7aH1gKTtsZXQgXz1rZSh1LG4pO3QuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShyLF8saCkhPT0wJiZjZShgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7dX0gLSAke2h9LmApfXJldHVybiBvLmV4dHJhIT09dm9pZCAwJiZLdChvLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKHUsaCk9PntsZXQgXz1rZSh1LG4pLHk9a2UoaCxuKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkocixfLHkpIT09MCYmY2UoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke3V9IC0gJHtofS5gKX0pLFtyLG5dfWNhdGNoKGkpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMocikhPT0wJiZjZShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKSxuLmZvckVhY2goYT0+dC5fZnJlZShhKSksaX19fSk7dmFyIGp0LGJ0LEF0LE9yLFl0LERyLEJyLFpuLEo9VSgoKT0+e1widXNlIHN0cmljdFwiO2p0PWU9Pntzd2l0Y2goZSl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiAxMDtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztjYXNlXCJpbnQ0XCI6cmV0dXJuIDIyO2Nhc2VcInVpbnQ0XCI6cmV0dXJuIDIxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LGJ0PWU9Pntzd2l0Y2goZSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxMDpyZXR1cm5cImZsb2F0MTZcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtjYXNlIDIyOnJldHVyblwiaW50NFwiO2Nhc2UgMjE6cmV0dXJuXCJ1aW50NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LEF0PShlLHQpPT57bGV0IHI9Wy0xLDQsMSwxLDIsMiw0LDgsLTEsMSwyLDgsNCw4LC0xLC0xLC0xLC0xLC0xLC0xLC0xLC41LC41XVtlXSxuPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dC5yZWR1Y2UoKG8saSk9Pm8qaSwxKTtyZXR1cm4gcj4wP01hdGguY2VpbChuKnIpOnZvaWQgMH0sT3I9ZT0+e3N3aXRjaChlKXtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIHR5cGVvZiBGbG9hdDE2QXJyYXk8XCJ1XCImJkZsb2F0MTZBcnJheS5mcm9tP0Zsb2F0MTZBcnJheTpVaW50MTZBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHtlfWApfX0sWXQ9ZT0+e3N3aXRjaChlKXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKX19LERyPWU9PmU9PT1cImZsb2F0MzJcInx8ZT09PVwiZmxvYXQxNlwifHxlPT09XCJpbnQzMlwifHxlPT09XCJpbnQ2NFwifHxlPT09XCJ1aW50MzJcInx8ZT09PVwidWludDhcInx8ZT09PVwiYm9vbFwifHxlPT09XCJ1aW50NFwifHxlPT09XCJpbnQ0XCIsQnI9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50NjRcInx8ZT09PVwiaW50OFwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixabj1lPT57c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm4gMDtjYXNlXCJjcHVcIjpyZXR1cm4gMTtjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIDI7Y2FzZVwidGV4dHVyZVwiOnJldHVybiAzO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm4gNDtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm4gNTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSBsb2NhdGlvbjogJHtlfWApfX19KTt2YXIgWnQsUW49VSgoKT0+e1widXNlIHN0cmljdFwiO3ZyKCk7WnQ9YXN5bmMgZT0+e2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKWlmKCExKXRyeXtsZXR7cmVhZEZpbGU6dH09VW4oXCJub2RlOmZzL3Byb21pc2VzXCIpO3JldHVybiBuZXcgVWludDhBcnJheShhd2FpdCB0KGUpKX1jYXRjaCh0KXtpZih0LmNvZGU9PT1cIkVSUl9GU19GSUxFX1RPT19MQVJHRVwiKXtsZXR7Y3JlYXRlUmVhZFN0cmVhbTpyfT1VbihcIm5vZGU6ZnNcIiksbj1yKGUpLG89W107Zm9yIGF3YWl0KGxldCBpIG9mIG4pby5wdXNoKGkpO3JldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KG8pKX10aHJvdyB0fWVsc2V7bGV0IHQ9YXdhaXQgZmV0Y2goZSk7aWYoIXQub2spdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZX1gKTtsZXQgcj10LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIiksbj1yP3BhcnNlSW50KHIsMTApOjA7aWYobjwxMDczNzQxODI0KXJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCB0LmFycmF5QnVmZmVyKCkpO3tpZighdC5ib2R5KXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2V9LCBubyByZXNwb25zZSBib2R5LmApO2xldCBvPXQuYm9keS5nZXRSZWFkZXIoKSxpO3RyeXtpPW5ldyBBcnJheUJ1ZmZlcihuKX1jYXRjaChkKXtpZihkIGluc3RhbmNlb2YgUmFuZ2VFcnJvcil7bGV0IGw9TWF0aC5jZWlsKG4vNjU1MzYpO2k9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpsLG1heGltdW06bH0pLmJ1ZmZlcn1lbHNlIHRocm93IGR9bGV0IGE9MDtmb3IoOzspe2xldHtkb25lOmQsdmFsdWU6bH09YXdhaXQgby5yZWFkKCk7aWYoZClicmVhaztsZXQgcD1sLmJ5dGVMZW5ndGg7bmV3IFVpbnQ4QXJyYXkoaSxhLHApLnNldChsKSxhKz1wfXJldHVybiBuZXcgVWludDhBcnJheShpLDAsbil9fWVsc2UgcmV0dXJuIGUgaW5zdGFuY2VvZiBCbG9iP25ldyBVaW50OEFycmF5KGF3YWl0IGUuYXJyYXlCdWZmZXIoKSk6ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/ZTpuZXcgVWludDhBcnJheShlKX19KTt2YXIgb20saW0scWEsS2EsTXIsYW0sc2UsZXQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtvbT1bXCJWXCIsXCJJXCIsXCJXXCIsXCJFXCIsXCJGXCJdLGltPShlLHQpPT57Y29uc29sZS5sb2coYFske29tW2VdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHt0fWApfSxNcj0oZSx0KT0+e3FhPWUsS2E9dH0sYW09KGUsdCk9PntsZXQgcj1ZdChlKSxuPVl0KHFhKTtyPj1uJiZpbShyLHR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/dCgpOnQpfSxzZT0oLi4uZSk9PntLYSYmYW0oLi4uZSl9fSk7dmFyIFJyLFhuPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7UnI9KGUsdCk9Pm5ldyhPcih0KSkoZSl9KTt2YXIgVXI9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIGphLEpuLGVvLHNtLHVtLFlhLHJvLHRvLFFhLFhhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtldCgpO1VyKCk7amE9bmV3IE1hcChbWzY0LDI1MF0sWzEyOCwyMDBdLFsyNTYsMjAwXSxbNTEyLDIwMF0sWzIwNDgsMjMwXSxbNDA5NiwyMDBdLFs4MTkyLDUwXSxbMTYzODQsNTBdLFszMjc2OCw1MF0sWzY1NTM2LDUwXSxbMTMxMDcyLDUwXSxbMjYyMTQ0LDUwXSxbNTI0Mjg4LDUwXSxbMTA0ODU3Niw1MF0sWzIwOTcxNTIsMzBdLFs0MTk0MzA0LDIwXSxbODM4ODYwOCwxMF0sWzEyNTgyOTEyLDEwXSxbMTY3NzcyMTYsMTBdLFsyNjIxNDQwMCwxNV0sWzMzNTU0NDMyLDIyXSxbNDQyMzY4MDAsMl0sWzU4OTgyNDAwLDZdLFs2NzEwODg2NCw2XSxbMTM0MjE3NzI4LDZdLFsxNjc3NzIxNjAsNl1dKSxKbj1bXSxlbz1lPT5NYXRoLmNlaWwoTnVtYmVyKGUpLzE2KSoxNixzbT1lPT57Zm9yKGxldCB0PTA7dDxKbi5sZW5ndGg7dCsrKXtsZXQgcj1Kblt0XTtpZihlPD1yKXJldHVybiByfXJldHVybiBNYXRoLmNlaWwoZS8xNikqMTZ9LHVtPTEsWWE9KCk9PnVtKysscm89YXN5bmMoZSx0LHIsbik9PntsZXQgbz1lbyhyKSxpPWUuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpvLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfSk7dHJ5e2xldCBhPWUuZ2V0Q29tbWFuZEVuY29kZXIoKTtlLmVuZENvbXB1dGVQYXNzKCksYS5jb3B5QnVmZmVyVG9CdWZmZXIodCwwLGksMCxvKSxlLmZsdXNoKCksYXdhaXQgaS5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO2xldCBkPWkuZ2V0TWFwcGVkUmFuZ2UoKTtpZihuKXtsZXQgbD1uKCk7cmV0dXJuIGwuc2V0KG5ldyBVaW50OEFycmF5KGQsMCxyKSksbH1lbHNlIHJldHVybiBuZXcgVWludDhBcnJheShkLnNsaWNlKDAscikpfWZpbmFsbHl7aS5kZXN0cm95KCl9fSx0bz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuYnVmZmVyc1BlbmRpbmc9W10sdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzPW5ldyBNYXA7Zm9yKGxldFtyXW9mIGphKUpuLnB1c2gociksdGhpcy5mcmVlQnVmZmVycy5zZXQocixbXSksdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuc2V0KHIsW10pO3RoaXMuc2Vzc2lvbkNvdW50PTB9dXBsb2FkKHQscil7bGV0IG49ci5idWZmZXIsbz1yLmJ5dGVPZmZzZXQsaT1yLmJ5dGVMZW5ndGgsYT1lbyhpKSxkPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighZCl0aHJvdyBuZXcgRXJyb3IoXCJncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0XCIpO2lmKE51bWJlcihkLm9yaWdpbmFsU2l6ZSkhPT1pKXRocm93IG5ldyBFcnJvcihgaW5jb25zaXN0ZW50IGRhdGEgc2l6ZS4gZ3B1IGRhdGEgc2l6ZT0ke2Qub3JpZ2luYWxTaXplfSwgZGF0YSBzaXplPSR7aX1gKTtsZXQgbD10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7bWFwcGVkQXRDcmVhdGlvbjohMCxzaXplOmEsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1dSSVRFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSkscD1sLmdldE1hcHBlZFJhbmdlKCk7bmV3IFVpbnQ4QXJyYXkocCkuc2V0KG5ldyBVaW50OEFycmF5KG4sbyxpKSksbC51bm1hcCgpO2xldCBtPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTttLmNvcHlCdWZmZXJUb0J1ZmZlcihsLDAsZC5ncHVEYXRhLmJ1ZmZlciwwLGEpLHRoaXMuYmFja2VuZC5kZXZpY2UucXVldWUuc3VibWl0KFttLmZpbmlzaCgpXSksbC5kZXN0cm95KCksc2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51cGxvYWQoaWQ9JHt0fSlgKX1tZW1jcHkodCxyKXtsZXQgbj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7bGV0IG89dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHIpO2lmKCFvKXRocm93IG5ldyBFcnJvcihcImRlc3RpbmF0aW9uIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7aWYobi5vcmlnaW5hbFNpemUhPT1vLm9yaWdpbmFsU2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbmNvbnNpc3RlbnQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBncHUgZGF0YSBzaXplXCIpO2xldCBpPWVvKG4ub3JpZ2luYWxTaXplKSxhPXRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLGEuY29weUJ1ZmZlclRvQnVmZmVyKG4uZ3B1RGF0YS5idWZmZXIsMCxvLmdwdURhdGEuYnVmZmVyLDAsaSl9cmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0LHIsbil7bGV0IG87aWYobil7aWYobz1uWzBdLHQ9PT1uWzFdKXJldHVybiBzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke3J9KSA9PiBpZD0ke299LCBidWZmZXIgaXMgdGhlIHNhbWUsIHNraXAuYCksbztpZih0aGlzLmJhY2tlbmQuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXModGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpKXRocm93IG5ldyBFcnJvcihgUmVnaXN0ZXJpbmcgYSBkaWZmZXJlbnQgZXh0ZXJuYWwgYnVmZmVyIHVuZGVyIGdyYXBoIGNhcHR1cmUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cbiAgICAgICAgICAgICBQbGVhc2UgdXNlIHRoZSBwcmV2aW91cyBleHRlcm5hbCBidWZmZXIhYCl9ZWxzZSBvPVlhKCk7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChvLHtncHVEYXRhOntpZDpvLHR5cGU6MCxidWZmZXI6dH0sb3JpZ2luYWxTaXplOnJ9KSxzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke3J9KSA9PiBpZD0ke299LCByZWdpc3RlcmVkLmApLG99dW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQpe3QhPT12b2lkIDAmJih0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUodCksc2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke3R9YCkpfWNyZWF0ZSh0LHI9R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCl7bGV0IG49c20odCksbyxpPShyJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSxhPShyJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STTtpZihpfHxhKXtsZXQgcD0oaT90aGlzLmZyZWVCdWZmZXJzOnRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzKS5nZXQobik7cD9wLmxlbmd0aD4wP289cC5wb3AoKTpvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6cn0pOm89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6bix1c2FnZTpyfSl9ZWxzZSBvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6cn0pO2xldCBkPXtpZDpZYSgpLHR5cGU6MCxidWZmZXI6b307cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChkLmlkLHtncHVEYXRhOmQsb3JpZ2luYWxTaXplOk51bWJlcih0KX0pLHNlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemU9JHt0fSkgPT4gaWQ9JHtkLmlkfWApLGR9Z2V0KHQpe3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk/LmdwdURhdGF9cmVsZWFzZSh0KXtsZXQgcj10eXBlb2YgdD09XCJiaWdpbnRcIj9OdW1iZXIodCk6dCxuPXRoaXMuc3RvcmFnZUNhY2hlLmdldChyKTtpZighbil7aWYodGhpcy5zdG9yYWdlQ2FjaGUuc2l6ZT09PTApcmV0dXJuIDA7dGhyb3cgbmV3IEVycm9yKFwicmVsZWFzaW5nIGRhdGEgZG9lcyBub3QgZXhpc3RcIil9cmV0dXJuIHNlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke3J9KSwgZ3B1RGF0YUlkPSR7bi5ncHVEYXRhLmlkfWApLHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShyKSx0aGlzLmJ1ZmZlcnNQZW5kaW5nLnB1c2gobi5ncHVEYXRhLmJ1ZmZlciksbi5vcmlnaW5hbFNpemV9YXN5bmMgZG93bmxvYWQodCxyKXtsZXQgbj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQoTnVtYmVyKHQpKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGRvZXMgbm90IGV4aXN0XCIpO2F3YWl0IHJvKHRoaXMuYmFja2VuZCxuLmdwdURhdGEuYnVmZmVyLG4ub3JpZ2luYWxTaXplLHIpfXJlZnJlc2hQZW5kaW5nQnVmZmVycygpe2lmKHRoaXMuYnVmZmVyc1BlbmRpbmcubGVuZ3RoIT09MClpZih0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cz09PVwiZGVmYXVsdFwiKXtmb3IobGV0IHQgb2YgdGhpcy5idWZmZXJzUGVuZGluZyl7bGV0IHI9amEuZ2V0KHQuc2l6ZSk7aWYoKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFKXtsZXQgbj10aGlzLmZyZWVCdWZmZXJzLmdldCh0LnNpemUpfHxbXTtyPT09dm9pZCAwfHxuLmxlbmd0aD49cj90LmRlc3Ryb3koKTpuLnB1c2godCl9ZWxzZSBpZigodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pe2xldCBuPXRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmdldCh0LnNpemUpfHxbXTtyPT09dm9pZCAwfHxuLmxlbmd0aD49cj90LmRlc3Ryb3koKTpuLnB1c2godCl9ZWxzZSB0LmRlc3Ryb3koKX10aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfWVsc2V7bGV0IHQ9dGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCk7dHx8KHQ9W10sdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLnNldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCx0KSk7Zm9yKGxldCByIG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpdC5wdXNoKHIpO3RoaXMuYnVmZmVyc1BlbmRpbmc9W119fWRpc3Bvc2UoKXt0aGlzLmZyZWVCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2godD0+e3QuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpfSksdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXAsdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzPW5ldyBNYXB9b25DcmVhdGVTZXNzaW9uKCl7dGhpcy5zZXNzaW9uQ291bnQrPTF9b25SZWxlYXNlU2Vzc2lvbih0KXtsZXQgcj10aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZ2V0KHQpO3ImJihyLmZvckVhY2gobj0+e24uZGVzdHJveSgpfSksdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmRlbGV0ZSh0KSksdGhpcy5zZXNzaW9uQ291bnQtPTEsdGhpcy5zZXNzaW9uQ291bnQ9PT0wJiYoc2UoXCJ3YXJuaW5nXCIsKCk9PlwiW1dlYkdQVV0gQ2xlYXJpbmcgd2ViZ3B1IGJ1ZmZlciBjYWNoZVwiKSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKG49PntuLmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXApfX0sUWE9KC4uLmUpPT5uZXcgdG8oLi4uZSl9KTt2YXIgbm8sZWUseGU9VSgoKT0+e1widXNlIHN0cmljdFwiO25vPWNsYXNze2NvbnN0cnVjdG9yKHQpe09iamVjdC5hc3NpZ24odGhpcyx0KX1nZXQgY2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5rZXl8fCh0aGlzLmtleT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5zb3J0KCkubWFwKHQ9PmAke3RoaXNbdF19YCkuam9pbihcIjtcIikpLHRoaXMua2V5fX0sZWU9ZT0+bmV3IG5vKGUpfSk7dmFyIG9vLHR0LGssa3QsTnIsSmEsZXMsbmU9VSgoKT0+e1widXNlIHN0cmljdFwiO29vPWNsYXNze3N0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxyKXtyZXR1cm4gdFsxXSE9PXJbMF0/dm9pZCAwOlt0WzBdLHJbMV1dfX0sdHQ9Y2xhc3N7c3RhdGljIGNhbGNTaGFwZSh0LHIsbj0hMSl7bGV0IG89dC5sZW5ndGgsaT1yLmxlbmd0aDtpZihvPT09MClyZXR1cm4gcjtpZihpPT09MClyZXR1cm4gdDtsZXQgYT1NYXRoLm1heCh0Lmxlbmd0aCxyLmxlbmd0aCksZD1uZXcgQXJyYXkoYSk7aWYobil7aWYobzwyfHxpPDIpcmV0dXJuO2xldCBsPW9vLmNhbGNNYXRNdWxTaGFwZShbdFtvLTJdLHRbby0xXV0sW3JbaS0yXSxyW2ktMV1dKTtpZihsPT09dm9pZCAwKXJldHVybjtbZFthLTJdLGRbYS0xXV09bH1mb3IobGV0IGw9bj8zOjE7bDw9YTtsKyspe2xldCBwPW8tbDwwPzE6dFtvLWxdLG09aS1sPDA/MTpyW2ktbF07aWYocCE9PW0mJnA+MSYmbT4xKXJldHVybjtsZXQgdT1NYXRoLm1heChwLG0pO2lmKHAmJm0pZFthLWxdPU1hdGgubWF4KHAsbSk7ZWxzZXtpZih1PjEpcmV0dXJuO2RbYS1sXT0wfX1yZXR1cm4gZH1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdCh0LHIpe2xldCBuPXQubGVuZ3RoLG89ci5sZW5ndGg7aWYobj5vKXJldHVybiExO2ZvcihsZXQgaT0xO2k8PW47aSsrKWlmKHRbbi1pXSE9PTEmJnRbbi1pXSE9PXJbby1pXSlyZXR1cm4hMTtyZXR1cm4hMH19LGs9Y2xhc3MgZXtzdGF0aWMgc2l6ZSh0KXtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsMCx0Lmxlbmd0aCl9c3RhdGljIGNvbnZlcnRTaGFwZSh0LHI9NCl7bGV0IG49dC5sZW5ndGg7aWYobj09PTApcmV0dXJuW107bGV0IG89bmV3IEFycmF5KG4pLGk9bi0xO2Zvcig7aT49MDspe2lmKHRbaV0lcj09PTApe29baV09dFtpXS9yO2JyZWFrfWlmKHIldFtpXSE9PTApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnZlcnQgc2hhcGVcIik7b1tpXT0xLHIvPXRbaV0saS0tfWZvcihpLS07aT49MDtpLS0pb1tpXT10W2ldO3JldHVybiBvfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LHIpe2lmKHI8MHx8cj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7cn0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscix0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LHIpe2lmKHI8MHx8cj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7cn0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAscil9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxyLG4pe2xldCBvPTE7Zm9yKGxldCBpPXI7aTxuO2krKyl7aWYodFtpXTwwKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBnZXQgdmFsaWQgc2l6ZSBmcm9tIHNwZWNpZmllZCBkaW1lbnNpb24gcmFuZ2UuIE1vc3QgbGlrZWx5IHRoZSByYW5nZSBjb250YWlucyBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7byo9TnVtYmVyKHRbaV0pfXJldHVybiBvfXN0YXRpYyBjb21wdXRlU3RyaWRlcyh0KXtsZXQgcj10Lmxlbmd0aDtpZihyPT09MClyZXR1cm5bXTtpZihyPT09MSlyZXR1cm5bMV07bGV0IG49bmV3IEFycmF5KHIpO25bci0xXT0xLG5bci0yXT10W3ItMV07Zm9yKGxldCBvPXItMztvPj0wOy0tbyluW29dPW5bbysxXSp0W28rMV07cmV0dXJuIG59c3RhdGljIG5vcm1hbGl6ZUF4aXModCxyKXtpZih0PC1yJiZ0Pj1yKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gdDwwP3Qrcjp0fXN0YXRpYyBub3JtYWxpemVBeGVzKHQscil7cmV0dXJuIHQubWFwKG49PnRoaXMubm9ybWFsaXplQXhpcyhuLHI/P3QubGVuZ3RoKSl9c3RhdGljIHNvcnRCYXNlZE9uUGVybSh0LHIpe3JldHVybiByP3IubWFwKG49PnRbbl0pOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQscil7bGV0IG49dC5sZW5ndGg7cmV0dXJuIHQubWFwKChvLGkpPT5vK3JbaV0rcltpK25dKX1zdGF0aWMgYXJlRXF1YWwodCxyKXtyZXR1cm4gdC5sZW5ndGghPT1yLmxlbmd0aD8hMTp0LmV2ZXJ5KChuLG8pPT5uPT09cltvXSl9fSxrdD1jbGFzcyBle3N0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyh0LHIsbixvLGksYSl7aWYoIXQmJm4ubGVuZ3RoIT09ci5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3BlY2lmaWVkIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIDIgbGVzcyB0aGFuIGxlbmd0aCBvZiBpbnB1dCBkaW1lbnNpb25zXCIpO2lmKHQpZm9yKGxldCBkPTA7ZDxyLmxlbmd0aC0yO2QrKylkPj1uLmxlbmd0aD9uLnB1c2gocltkKzJdKTpuW2RdPXJbZCsyXTtmb3IobGV0IGQ9MDtkPG4ubGVuZ3RoO2QrKylpZihkPG8ubGVuZ3RoKXtpZihvW2RdPDApdGhyb3cgbmV3IEVycm9yKFwic3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBvLnB1c2goMSk7Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aDtkKyspaWYoZDxpLmxlbmd0aCl7aWYoaVtkXTwwKXRocm93IG5ldyBFcnJvcihcImRpbGF0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBpLnB1c2goMSk7Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aCoyO2QrKylpZihkPGEubGVuZ3RoKXtpZihhW2RdPDApdGhyb3cgbmV3IEVycm9yKFwicGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGEucHVzaCgwKTtmb3IobGV0IGQ9MDtkPG4ubGVuZ3RoO2QrKyl7aWYobltkXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDBcIik7aWYoYVtkXT49bltkXXx8YVtkK24ubGVuZ3RoXT49bltkXSl0aHJvdyBuZXcgRXJyb3IoXCJwYWRzIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4ga2VybmVsXCIpfX1zdGF0aWMgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHQscixuLG8saSxhLGQpe2lmKGQpe2lmKGkubGVuZ3RoIT09MioodC5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKHIubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoby5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IGw9MDtsPHQubGVuZ3RoLTI7bCsrKWUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFtsKyhhPzE6MildLHJbbF0sbltsXSxvW2xdLGksbCxsK3QubGVuZ3RoLTIsZCl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKHQscixuLG8saSxhLGQpe2lmKHIubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtsZXQgbD1bclswXSxyWzFdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIodCxyLGwsbixvLGksYSxkKSxsfXN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKHQscixuLG8saSxhLGQpe2lmKHQubGVuZ3RoPD0wfHxyLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zXCIpO2xldCBsPVt0WzBdLHJbMF1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcighMSx0LGwsbixvLGksYSxkKSxsfXN0YXRpYyBjb21wdXRlU2hhcGVIZWxwZXIodCxyLG4sbyxpLGEsZCxsKXtpZih0KWZvcihsZXQgcD0wO3A8ci5sZW5ndGgtMjtwKyspbi5wdXNoKDEpO2Vsc2UgZm9yKGxldCBwPTA7cDxyLmxlbmd0aC0yO3ArKyluLnB1c2goZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShyW3ArMl0sb1twXSxpW3BdLGFbcF0sZCxwLHArci5sZW5ndGgtMixsKSl9c3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKHQscixuLG8saSxhLGQsbCl7bGV0IHA9biooby0xKSsxO2lmKGwmJmwhPT1cIk5PVFNFVFwiKXN3aXRjaChsKXtjYXNlXCJWQUxJRFwiOnJldHVybiBpW2FdPTAsaVtkXT0wLE1hdGguZmxvb3IoKHQtcCkvcisxKTtjYXNlXCJTQU1FX0xPV0VSXCI6Y2FzZVwiU0FNRV9VUFBFUlwiOmlmKG4hPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbGF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIFNBTUVfVVBQRVIgb3IgU0FNRV9MT1dFUlwiKTt7bGV0IHU9KCh0K3ItMSkvci0xKSpyK28tdDtyZXR1cm4gaVthXT1NYXRoLmZsb29yKGw9PT1cIlNBTUVfTE9XRVJcIj8odSsxKS8yOnUvMiksaVtkXT11LWlbYV0sTWF0aC5mbG9vcigodCt1LW8pL3IrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9ZWxzZSByZXR1cm4gTWF0aC5mbG9vcigodCtpW2FdK2lbZF0tcCkvcisxKX19LE5yPWNsYXNze3N0YXRpYyBnZXRTaGFwZU9mR2VtbVJlc3VsdCh0LHIsbixvLGkpe2lmKHQubGVuZ3RoIT09Mnx8bi5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyXCIpO2xldCBhLGQsbDtyPyhhPXRbMV0sZD10WzBdKTooYT10WzBdLGQ9dFsxXSk7bGV0IHA9LTE7aWYobz8obD1uWzBdLHA9MSk6KGw9blsxXSxwPTApLG5bcF0hPT1kKXRocm93IG5ldyBFcnJvcihcImRpbWVuc2lvbiBtaXNtYXRjaFwiKTtpZihhPD0wfHxsPD0wfHxkPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2hhcGUgc3BlY2lmaWVkXCIpO2lmKGkmJiF0dC5pc1ZhbGlkQnJvYWRjYXN0KGksW2EsbF0pKXRocm93IG5ldyBFcnJvcihcImdlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0XCIpO3JldHVyblthLGwsZF19fSxKYT0tMzQwMjgyMzQ2NjM4NTI4ODZlMjIsZXM9MzQwMjgyMzQ2NjM4NTI4ODZlMjJ9KTt2YXIgRXQsYW8seWUsRWUsTixtZSxzbyxQdCxxZSxxLFZyLEUsTSx0cyxXcixpbyxycyxhZT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7RXQ9NjQsYW89KGUsdCk9PntpZih0PT09Myl0aHJvdyBuZXcgRXJyb3IoXCJ2ZWMzIGhhcyBzYW1lIGFsaWdubWVudCBhcyB2ZWM0LCB1c2UgdmVjNCBpbnN0ZWFkXCIpO3N3aXRjaChOdW1iZXIoZSkpe2Nhc2UgMTA6cmV0dXJuIHQ+MT9gdmVjJHt0fTxmMTY+YDpcImYxNlwiO2Nhc2UgMTpyZXR1cm4gdD4xP2B2ZWMke3R9PGYzMj5gOlwiZjMyXCI7Y2FzZSA2OnJldHVybiB0PjE/YHZlYyR7dH08aTMyPmA6XCJpMzJcIjtjYXNlIDEyOnJldHVybiB0PjE/YHZlYyR7dH08dTMyPmA6XCJ1MzJcIjtjYXNlIDc6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcImkzMlwiXTtjYXNlIDEzOmlmKHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXRcIik7cmV0dXJuW1widmVjMjx1MzI+XCIsXCJ1MzJcIl07Y2FzZSA5OmlmKHQhPT00KXRocm93IG5ldyBFcnJvcihcImJvb2wgbXVzdCBiZSB2ZWM0XCIpO3JldHVybltcInUzMlwiLFwidmVjNDxib29sPlwiXTtjYXNlIDIyOnJldHVyblwiaTMyXCI7Y2FzZSAyMTpyZXR1cm5cInUzMlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHtlfWApfX0seWU9KGUsdD0xKT0+e2xldCByPWFvKGUsdCk7cmV0dXJuIHR5cGVvZiByPT1cInN0cmluZ1wiP3I6clswXX0sRWU9KGUsdD0xKT0+e2xldCByPWFvKGUsdCk7cmV0dXJuIHR5cGVvZiByPT1cInN0cmluZ1wiP3I6clsxXX0sTj0oLi4uZSk9PntsZXQgdD1bXTtyZXR1cm4gZS5mb3JFYWNoKHI9PntyLmxlbmd0aCE9PTAmJnQucHVzaCh7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6ay5jb21wdXRlU3RyaWRlcyhyKX0pfSksdH0sbWU9ZT0+ZSU0PT09MD80OmUlMj09PTA/MjoxLHNvPShlPVwiZjMyXCIsdCxyPVwiMFwiKT0+IXR8fHQ9PT0xP2Ake2V9KCR7cn0pYDpgdmVjJHt0fTwke2V9Pigke3J9KWAsUHQ9KGUsdCxyKT0+ZT09PVwiZjMyXCI/cjp0PT09MT9gZjMyKCR7cn0pYDpgdmVjJHt0fTxmMzI+KCR7cn0pYCxxZT0oZSx0KT0+dD09PTQ/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnogKyAke2V9LncpYDp0PT09Mj9gKCR7ZX0ueCArICR7ZX0ueSlgOnQ9PT0zP2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56KWA6ZSxxPShlLHQscixuKT0+ZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZyPjQ/dHlwZW9mIHQ9PVwic3RyaW5nXCI/bj09PVwiZjE2XCI/YCR7ZX1bKCR7dH0pIC8gOF1bKCR7dH0pICUgOCAvIDRdWygke3R9KSAlIDggJSA0XWA6YCR7ZX1bKCR7dH0pIC8gNF1bKCR7dH0pICUgNF1gOm49PT1cImYxNlwiP2Ake2V9WyR7TWF0aC5mbG9vcih0LzgpfV1bJHtNYXRoLmZsb29yKHQlOC80KX1dWyR7dCU4JTR9XWA6YCR7ZX1bJHtNYXRoLmZsb29yKHQvNCl9XVske3QlNH1dYDpyPjE/YCR7ZX1bJHt0fV1gOmUsVnI9KGUsdCxyLG4sbyk9PntsZXQgaT10eXBlb2Ygcj09XCJudW1iZXJcIixhPWk/cjpyLmxlbmd0aCxkPVsuLi5uZXcgQXJyYXkoYSkua2V5cygpXSxsPWE8Mj9cInUzMlwiOmE8PTQ/YHZlYyR7YX08dTMyPmA6YGFycmF5PHUzMiwgJHthfT5gLHA9YW8odCxvKSxtPXR5cGVvZiBwPT1cInN0cmluZ1wiP3A6cFsxXSx1PXR5cGVvZiBwPT1cInN0cmluZ1wiP3A6cFswXSxoPXtpbmRpY2VzOmwsdmFsdWU6bSxzdG9yYWdlOnUsdGVuc29yOnR9LF89Vz0+dHlwZW9mIFc9PVwic3RyaW5nXCI/VzpgJHtXfXVgLHk9e29mZnNldFRvSW5kaWNlczohMSxpbmRpY2VzVG9PZmZzZXQ6ITEsYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6ITEsc2V0OiExLHNldEJ5SW5kaWNlczohMSxnZXQ6ITEsZ2V0QnlJbmRpY2VzOiExfSxnPWk/XCJ1bmlmb3Jtcy5cIjpcIlwiLHg9YCR7Z30ke2V9X3NoYXBlYCwkPWAke2d9JHtlfV9zdHJpZGVzYCx2PVwiXCI7Zm9yKGxldCBXPTA7VzxhLTE7VysrKXYrPWBcbiAgICBsZXQgZGltJHtXfSA9IGN1cnJlbnQgLyAke3EoJCxXLGEpfTtcbiAgICBsZXQgcmVzdCR7V30gPSBjdXJyZW50ICUgJHtxKCQsVyxhKX07XG4gICAgaW5kaWNlc1ske1d9XSA9IGRpbSR7V307XG4gICAgY3VycmVudCA9IHJlc3Qke1d9O1xuICAgIGA7dis9YGluZGljZXNbJHthLTF9XSA9IGN1cnJlbnQ7YDtsZXQgUz1hPDI/XCJcIjpgXG4gIGZuIG8yaV8ke2V9KG9mZnNldDogdTMyKSAtPiAke2guaW5kaWNlc30ge1xuICAgIHZhciBpbmRpY2VzOiAke2guaW5kaWNlc307XG4gICAgdmFyIGN1cnJlbnQgPSBvZmZzZXQ7XG4gICAgJHt2fVxuICAgIHJldHVybiBpbmRpY2VzO1xuICB9YCxUPVc9Pih5Lm9mZnNldFRvSW5kaWNlcz0hMCxhPDI/VzpgbzJpXyR7ZX0oJHtXfSlgKSxBPVtdO2lmKGE+PTIpZm9yKGxldCBXPWEtMTtXPj0wO1ctLSlBLnB1c2goYCR7cSgkLFcsYSl9ICogKGluZGljZXNbJHtXfV0pYCk7bGV0IEM9YTwyP1wiXCI6YFxuICBmbiBpMm9fJHtlfShpbmRpY2VzOiAke2guaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgcmV0dXJuICR7QS5qb2luKFwiK1wiKX07XG4gIH1gLFA9Vz0+KHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGE8Mj9XOmBpMm9fJHtlfSgke1d9KWApLEQ9KC4uLlcpPT5hPT09MD9cIjB1XCI6YCR7aC5pbmRpY2VzfSgke1cubWFwKF8pLmpvaW4oXCIsXCIpfSlgLFI9KFcsWSk9PmE8Mj9gJHtXfWA6YCR7cShXLFksYSl9YCxIPShXLFksaGUpPT5hPDI/YCR7V309JHtoZX07YDpgJHtxKFcsWSxhKX09JHtoZX07YCxMPXt9LHJlPShXLFkpPT57eS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldD0hMDtsZXQgaGU9YCR7WS5uYW1lfWJyb2FkY2FzdGVkSW5kaWNlc1RvJHtlfU9mZnNldGA7aWYoaGUgaW4gTClyZXR1cm5gJHtoZX0oJHtXfSlgO2xldCBEZT1bXTtmb3IobGV0IHBlPWEtMTtwZT49MDtwZS0tKXtsZXQgSWU9WS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLHBlK1kucmFuay1hKTtEZS5wdXNoKGAke1IoJCxwZSl9ICogKCR7SWV9ICUgJHtSKHgscGUpfSlgKX1yZXR1cm4gTFtoZV09YGZuICR7aGV9KG91dHB1dEluZGljZXM6ICR7WS50eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgICAgICAgICAgIHJldHVybiAke0RlLmxlbmd0aD4wP0RlLmpvaW4oXCIrXCIpOlwiMHVcIn07XG4gICAgICAgICAgIH1gLGAke2hlfSgke1d9KWB9LFY9KFcsWSk9PigoKT0+e2lmKGguc3RvcmFnZT09PWgudmFsdWUpcmV0dXJuYCR7ZX1bJHtXfV09JHtZfTtgO2lmKGguc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmgudmFsdWU9PT1cImkzMlwiKXJldHVybmAke2V9WyR7V31dPXZlYzI8dTMyPih1MzIoJHtZfSksIHNlbGVjdCgwdSwgMHhGRkZGRkZGRnUsICR7WX0gPCAwKSk7YDtpZihoLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZoLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gJHtlfVske1d9XT12ZWMyPHUzMj4odTMyKCR7WX0pLCAwdSk7YDtpZihoLnN0b3JhZ2U9PT1cInUzMlwiJiZoLnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYCR7ZX1bJHtXfV09ZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oJHtZfSkpO2A7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke2guc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHtoLnZhbHVlfSB5ZXRgKX0pKCksSz1XPT4oKCk9PntpZihoLnN0b3JhZ2U9PT1oLnZhbHVlKXJldHVybmAke2V9WyR7V31dYDtpZihoLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZoLnZhbHVlPT09XCJpMzJcIilyZXR1cm5gaTMyKCR7ZX1bJHtXfV0ueClgO2lmKGguc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmgudmFsdWU9PT1cInUzMlwiKXJldHVybmB1MzIoJHtlfVske1d9XS54KWA7aWYoaC5zdG9yYWdlPT09XCJ1MzJcIiYmaC52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmB2ZWM0PGJvb2w+KGJvb2woJHtlfVske1d9XSAmIDB4RkZ1KSwgYm9vbCgke2V9WyR7V31dICYgMHhGRjAwdSksIGJvb2woJHtlfVske1d9XSAmIDB4RkYwMDAwdSksIGJvb2woJHtlfVske1d9XSAmIDB4RkYwMDAwMDB1KSlgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHtoLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7aC52YWx1ZX0geWV0YCl9KSgpLHdlPWE8Mj9cIlwiOmBcbiAgZm4gZ2V0XyR7ZX1CeUluZGljZXMoaW5kaWNlczogJHtoLmluZGljZXN9KSAtPiAke219IHtcbiAgICByZXR1cm4gJHtLKGBpMm9fJHtlfShpbmRpY2VzKWApfTtcbiAgfWAsaj1hPDI/XCJcIjooKCk9PntsZXQgVz1kLm1hcChoZT0+YGQke2hlfTogdTMyYCkuam9pbihcIiwgXCIpLFk9ZC5tYXAoaGU9PmBkJHtoZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxuICBmbiBnZXRfJHtlfSgke1d9KSAtPiAke219IHtcbiAgICByZXR1cm4gZ2V0XyR7ZX1CeUluZGljZXMoJHtEKFkpfSk7XG4gIH1gfSkoKSxRPSguLi5XKT0+e2lmKFcubGVuZ3RoIT09YSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHthfWApO2xldCBZPVcubWFwKF8pLmpvaW4oXCIsXCIpO3JldHVybiBhPT09MD9LKFwiMHVcIik6YT09PTE/SyhZWzBdKTooeS5nZXQ9ITAseS5nZXRCeUluZGljZXM9ITAseS5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9KCR7WX0pYCl9LGllPVc9PmE8Mj9LKFcpOih5LmdldEJ5SW5kaWNlcz0hMCx5LmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX1CeUluZGljZXMoJHtXfSlgKSx0ZT1hPDI/XCJcIjpgXG4gIGZuIHNldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7aC5pbmRpY2VzfSwgdmFsdWU6ICR7bX0pIHtcbiAgICAke1YoYGkyb18ke2V9KGluZGljZXMpYCxcInZhbHVlXCIpfVxuICB9YCxiZT1hPDI/XCJcIjooKCk9PntsZXQgVz1kLm1hcChoZT0+YGQke2hlfTogdTMyYCkuam9pbihcIiwgXCIpLFk9ZC5tYXAoaGU9PmBkJHtoZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxuICBmbiBzZXRfJHtlfSgke1d9LCB2YWx1ZTogJHttfSkge1xuICAgIHNldF8ke2V9QnlJbmRpY2VzKCR7RChZKX0sIHZhbHVlKTtcbiAgfWB9KSgpO3JldHVybntpbXBsOigpPT57bGV0IFc9W10sWT0hMTtyZXR1cm4geS5vZmZzZXRUb0luZGljZXMmJihXLnB1c2goUyksWT0hMCkseS5pbmRpY2VzVG9PZmZzZXQmJihXLnB1c2goQyksWT0hMCkseS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCYmKE9iamVjdC52YWx1ZXMoTCkuZm9yRWFjaChoZT0+Vy5wdXNoKGhlKSksWT0hMCkseS5zZXQmJihXLnB1c2goYmUpLFk9ITApLHkuc2V0QnlJbmRpY2VzJiYoVy5wdXNoKHRlKSxZPSEwKSx5LmdldCYmKFcucHVzaChqKSxZPSEwKSx5LmdldEJ5SW5kaWNlcyYmKFcucHVzaCh3ZSksWT0hMCksIWkmJlkmJlcudW5zaGlmdChgY29uc3QgJHt4fSA9ICR7aC5pbmRpY2VzfSgke3Iuam9pbihcIixcIil9KTtgLGBjb25zdCAkeyR9ID0gJHtoLmluZGljZXN9KCR7ay5jb21wdXRlU3RyaWRlcyhyKS5qb2luKFwiLFwiKX0pO2ApLFcuam9pbihgXG5gKX0sdHlwZTpoLG9mZnNldFRvSW5kaWNlczpULGluZGljZXNUb09mZnNldDpQLGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OnJlLGluZGljZXM6RCxpbmRpY2VzR2V0OlIsaW5kaWNlc1NldDpILHNldDooLi4uVyk9PntpZihXLmxlbmd0aCE9PWErMSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHthfWApO2xldCBZPVdbYV07aWYodHlwZW9mIFkhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7bGV0IGhlPVcuc2xpY2UoMCxhKS5tYXAoXykuam9pbihcIixcIik7cmV0dXJuIGE9PT0wP1YoXCIwdVwiLFkpOmE9PT0xP1YoaGVbMF0sWSk6KHkuc2V0PSEwLHkuc2V0QnlJbmRpY2VzPSEwLHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfSgke2hlfSwgJHtZfSlgKX0sc2V0QnlPZmZzZXQ6VixzZXRCeUluZGljZXM6KFcsWSk9PmE8Mj9WKFcsWSk6KHkuc2V0QnlJbmRpY2VzPSEwLHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfUJ5SW5kaWNlcygke1d9LCAke1l9KTtgKSxnZXQ6USxnZXRCeU9mZnNldDpLLGdldEJ5SW5kaWNlczppZSx1c2FnZTpuLG5hbWU6ZSxzdHJpZGVzOiQsc2hhcGU6eCxyYW5rOmF9fSxFPShlLHQscixuPTEpPT5WcihlLHQscixcImlucHV0XCIsbiksTT0oZSx0LHIsbj0xKT0+VnIoZSx0LHIsXCJvdXRwdXRcIixuKSx0cz0oZSx0LHIpPT5WcihlLHQscixcImF0b21pY091dHB1dFwiLDEpLFdyPShlLHQscixuPTEpPT5WcihlLHQscixcImludGVybmFsXCIsbiksaW89Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwPXQ7dGhpcy5saW1pdHM9cjt0aGlzLmludGVybmFsVmFyaWFibGVzPVtdO3RoaXMudmFyaWFibGVzPVtdO3RoaXMudW5pZm9ybXM9W107dGhpcy52YXJpYWJsZUluZGV4PTB9Z3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh0KXtyZXR1cm5gaWYgKGdsb2JhbF9pZHggPj0gJHt0eXBlb2YgdD09XCJudW1iZXJcIj9gJHt0fXVgOnR9KSB7IHJldHVybjsgfWB9bWFpblN0YXJ0KHQ9RXQpe2xldCByPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dFswXSxuPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsxXSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsyXTtpZihyPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWHx8bj50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl8fG8+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaKXRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7cn0sICR7bn0sICR7b31dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIHNpemUgWyR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfSwgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn1dLmApO2lmKHIqbipvPnRoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCl0aHJvdyBuZXcgRXJyb3IoYHdvcmtncm91cCBzaXplIFske3J9LCAke259LCAke299XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBpbnZvY2F0aW9ucyAke3RoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cH0uYCk7bGV0IGk9dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXT09PTEmJnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl09PT0xLGE9aT9gQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj5gOmBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBudW1fd29ya2dyb3VwcyA6IHZlYzM8dTMyPmAsZD1pP2BsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1xuICAgICAgICAgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC54O2A6YGxldCB3b3JrZ3JvdXBfaW5kZXggPSB3b3JrZ3JvdXBfaWQueiAqIG51bV93b3JrZ3JvdXBzWzBdICogbnVtX3dvcmtncm91cHNbMV0gK1xuICAgICAgICAgICAgIHdvcmtncm91cF9pZC55ICogbnVtX3dvcmtncm91cHNbMF0gKyB3b3JrZ3JvdXBfaWQueDtcbiAgICAgICAgIGxldCBnbG9iYWxfaWR4ID0gd29ya2dyb3VwX2luZGV4ICogJHtyKm4qb311ICsgbG9jYWxfaWR4O2A7cmV0dXJuYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3J9LCAke259LCAke299KVxuICBmbiBtYWluKCR7YX0pIHtcbiAgICAke2R9XG4gIGB9YXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KXt0LnJhbmshPT0wJiYodC5zaGFwZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zaGFwZS5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTpcInUzMlwiLGxlbmd0aDp0LnJhbmt9KSx0LnN0cmlkZXMuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc3RyaWRlcy5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTpcInUzMlwiLGxlbmd0aDp0LnJhbmt9KSl9ZGVjbGFyZVZhcmlhYmxlKHQscil7aWYodC51c2FnZT09PVwiaW50ZXJuYWxcIil0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIGludGVybmFsIHZhcmlhYmxlIHdpdGggZGVjbGFyZVZhcmlhYmxlKCkuIHVzZSByZWdpc3RlckludGVybmFsVmFyaWFibGVzKCkgaW5zdGVhZC5cIik7dGhpcy52YXJpYWJsZXMucHVzaCh0KSx0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCk7bGV0IG49dC51c2FnZT09PVwiaW5wdXRcIj9cInJlYWRcIjpcInJlYWRfd3JpdGVcIixvPXQudXNhZ2U9PT1cImF0b21pY091dHB1dFwiP1wiYXRvbWljPGkzMj5cIjp0LnR5cGUuc3RvcmFnZTtyZXR1cm5gQGdyb3VwKDApIEBiaW5kaW5nKCR7cn0pIHZhcjxzdG9yYWdlLCAke259PiAke3QubmFtZX06IGFycmF5PCR7b30+O2B9ZGVjbGFyZVZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5tYXAocj0+dGhpcy5kZWNsYXJlVmFyaWFibGUocix0aGlzLnZhcmlhYmxlSW5kZXgrKykpLmpvaW4oYFxuYCl9cmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHQpe2lmKHQudXNhZ2UhPT1cImludGVybmFsXCIpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBpbnB1dCBvciBvdXRwdXQgdmFyaWFibGUgd2l0aCByZWdpc3RlckludGVybmFsVmFyaWFibGUoKS4gdXNlIGRlY2xhcmVWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLmludGVybmFsVmFyaWFibGVzLnB1c2godCksdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpfXJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQuZm9yRWFjaChyPT50aGlzLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZShyKSksdGhpc31yZWdpc3RlclVuaWZvcm0odCxyLG49MSl7cmV0dXJuIHRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LHR5cGU6cixsZW5ndGg6bn0pLHRoaXN9cmVnaXN0ZXJVbmlmb3Jtcyh0KXtyZXR1cm4gdGhpcy51bmlmb3Jtcz10aGlzLnVuaWZvcm1zLmNvbmNhdCh0KSx0aGlzfXVuaWZvcm1EZWNsYXJhdGlvbigpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm5cIlwiO2xldCB0PVtdO2ZvcihsZXR7bmFtZTpyLHR5cGU6bixsZW5ndGg6b31vZiB0aGlzLnVuaWZvcm1zKWlmKG8mJm8+NCluPT09XCJmMTZcIj90LnB1c2goYEBhbGlnbigxNikgJHtyfTphcnJheTxtYXQyeDQ8JHtufT4sICR7TWF0aC5jZWlsKG8vOCl9PmApOnQucHVzaChgJHtyfTphcnJheTx2ZWM0PCR7bn0+LCAke01hdGguY2VpbChvLzQpfT5gKTtlbHNle2xldCBpPW89PW51bGx8fG89PT0xP246YHZlYyR7b308JHtufT5gO3QucHVzaChgJHtyfToke2l9YCl9cmV0dXJuYFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt0LmpvaW4oXCIsIFwiKX0gfTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YH1nZXQgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucygpe3JldHVybiB0aGlzLnVuaWZvcm1EZWNsYXJhdGlvbigpK3RoaXMudmFyaWFibGVzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKSt0aGlzLmludGVybmFsVmFyaWFibGVzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKX1nZXQgdmFyaWFibGVzSW5mbygpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm47bGV0IHQ9cj0+WzEyLDEwLDEsNl1bW1widTMyXCIsXCJmMTZcIixcImYzMlwiLFwiaTMyXCJdLmluZGV4T2YocildO3JldHVybiB0aGlzLnVuaWZvcm1zLm1hcChyPT5bdChyLnR5cGUpLHIubGVuZ3RoPz8xXSl9fSxycz0oZSx0KT0+bmV3IGlvKGUsdCl9KTt2YXIgZG0sbnMsbG0sY20scG0sbW0sUGUsb3MsaXMsZHQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtkbT0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKHQubGVuZ3RoIT09MCYmdC5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgcGVybSBzaXplICR7dC5sZW5ndGh9IGRvZXMgbm90IG1hdGNoIGlucHV0IHJhbmsgJHtlWzBdLmRpbXMubGVuZ3RofWApfSxucz0oZSx0KT0+dC5sZW5ndGghPT0wP3Q6Wy4uLm5ldyBBcnJheShlKS5rZXlzKCldLnJldmVyc2UoKSxsbT0oZSx0KT0+ay5zb3J0QmFzZWRPblBlcm0oZSxucyhlLmxlbmd0aCx0KSksY209KGUsdCxyLG4pPT57bGV0IG89YGZuIHBlcm0oaTogJHtuLnR5cGUuaW5kaWNlc30pIC0+ICR7ci50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtyLnR5cGUuaW5kaWNlc307YDtmb3IobGV0IGk9MDtpPHQ7KytpKW8rPWBhWyR7ZVtpXX1dPWlbJHtpfV07YDtyZXR1cm4gbys9XCJyZXR1cm4gYTt9XCJ9LHBtPShlLHQpPT57bGV0IHI9W10sbj1bXTtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyllW29dIT09MSYmci5wdXNoKGVbb10pLGVbdFtvXV0hPT0xJiZuLnB1c2godFtvXSk7cmV0dXJue25ld1NoYXBlOnIsbmV3UGVybTpufX0sbW09KGUsdCk9PntsZXQgcj0wO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKWlmKHRbZVtuXV0hPT0xKXtpZihlW25dPHIpcmV0dXJuITE7cj1lW25dfXJldHVybiEwfSxQZT0oZSx0KT0+e2xldCByPWUuZGF0YVR5cGUsbj1lLmRpbXMubGVuZ3RoLG89bnMobix0KSxpPWxtKGUuZGltcyxvKSxhPWUuZGltcyxkPWksbD1uPDJ8fG1tKG8sZS5kaW1zKSxwO2lmKGwpcmV0dXJuIHA9Zz0+e2xldCB4PUUoXCJpbnB1dFwiLHIsYSw0KSwkPU0oXCJvdXRwdXRcIixyLGQsNCk7cmV0dXJuYFxuICAke2cucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHgsJCl9XG4gICR7Zy5tYWluU3RhcnQoKX1cbiAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1xuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VDb3B5XCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgZz1rLnNpemUoaSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGcvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoZy80KX1dfX0sZ2V0U2hhZGVyU291cmNlOnB9O2xldHtuZXdTaGFwZTptLG5ld1Blcm06dX09cG0oZS5kaW1zLG8pLGg9ay5hcmVFcXVhbCh1LFsyLDMsMV0pLF89ay5hcmVFcXVhbCh1LFszLDEsMl0pO2lmKG0ubGVuZ3RoPT09Mnx8aHx8Xyl7YT1oP1ttWzBdLG1bMV0qbVsyXV06Xz9bbVswXSptWzFdLG1bMl1dOm0sZD1bYVsxXSxhWzBdXTtsZXQgZz0xNjtyZXR1cm4gcD14PT57bGV0ICQ9RShcImFcIixyLGEubGVuZ3RoKSx2PU0oXCJvdXRwdXRcIixyLGQubGVuZ3RoKTtyZXR1cm5gXG4gICR7eC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoJCx2KX1cbiAgdmFyPHdvcmtncm91cD4gdGlsZSA6IGFycmF5PGFycmF5PCR7di50eXBlLnZhbHVlfSwgJHtnKzF9PiwgJHtnfT47XG4gICR7eC5tYWluU3RhcnQoW2csZywxXSl9XG4gICAgbGV0IHN0cmlkZSA9ICh1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0gLSAxKSAvICR7Z30gKyAxO1xuICAgIGxldCB3b3JrZ3JvdXBfaWRfeCA9IHdvcmtncm91cF9pbmRleCAlIHN0cmlkZTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3kgPSB3b3JrZ3JvdXBfaW5kZXggLyBzdHJpZGU7XG4gICAgbGV0IGlucHV0X2NvbCA9IHdvcmtncm91cF9pZF95ICogJHtnfXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBpbnB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeCAqICR7Z311ICsgbG9jYWxfaWQueTtcbiAgICBpZiAoaW5wdXRfcm93IDwgdW5pZm9ybXMuYV9zaGFwZVswXSAmJiBpbnB1dF9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzFdKSB7XG4gICAgICB0aWxlW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHskLmdldEJ5SW5kaWNlcyhgJHskLnR5cGUuaW5kaWNlc30oaW5wdXRfcm93LCBpbnB1dF9jb2wpYCl9O1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBsZXQgb3V0cHV0X2NvbCA9IHdvcmtncm91cF9pZF94ICogJHtnfXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBvdXRwdXRfcm93ID0gd29ya2dyb3VwX2lkX3kgKiAke2d9dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKG91dHB1dF9yb3cgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMF0gJiYgb3V0cHV0X2NvbCA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSkge1xuICAgICAgJHt2LnNldEJ5SW5kaWNlcyhgJHt2LnR5cGUuaW5kaWNlc30ob3V0cHV0X3Jvdywgb3V0cHV0X2NvbClgLFwidGlsZVtsb2NhbF9pZC54XVtsb2NhbF9pZC55XVwiKX1cbiAgICB9XG4gIH1gfSx7bmFtZTpcIlRyYW5zcG9zZVNoYXJlZFwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IHg9ay5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkWzFdL2cpLHk6TWF0aC5jZWlsKGRbMF0vZyl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTp4fSwuLi5OKGEsZCldfX0sZ2V0U2hhZGVyU291cmNlOnB9fXJldHVybiBwPWc9PntsZXQgeD1FKFwiYVwiLHIsYS5sZW5ndGgpLCQ9TShcIm91dHB1dFwiLHIsZC5sZW5ndGgpO3JldHVybmBcbiAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh4LCQpfVxuXG4gICR7Y20obyxuLHgsJCl9XG5cbiAgJHtnLm1haW5TdGFydCgpfVxuICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7JC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHskLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHguZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIikpfVxuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCBnPWsuc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZy82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpnfSwuLi5OKGEsZCldfX0sZ2V0U2hhZGVyU291cmNlOnB9fSxvcz0oZSx0KT0+e2RtKGUuaW5wdXRzLHQucGVybSksZS5jb21wdXRlKFBlKGUuaW5wdXRzWzBdLHQucGVybSkpfSxpcz1lPT5lZSh7cGVybTplLnBlcm19KX0pO3ZhciBmbSxobSxnbSxibSx5bSxfbSx3bSx2bSwkbSx4bSxydCxhcyxzcyx1cyxkcyxscyxjcyxwcyxtcyxmcyxocyxncz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7YWUoKTtMcigpO2R0KCk7Zm09e21heDpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKVwiLG1pbjpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKVwiLG1lYW46XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixzdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixwcm9kOlwiYmVzdFZhbHVlICogY2FuZGlkYXRlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlXCIsbG9nU3VtRXhwOlwiYmVzdFZhbHVlICsgZXhwKGNhbmRpZGF0ZSlcIixsMTpcImJlc3RWYWx1ZSArIGFicyhjYW5kaWRhdGUpXCIsbDI6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIn0saG09e21heDpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKVwiLG1pbjpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKVwiLG1lYW46XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixzdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixwcm9kOlwiYmVzdFZhbHVlICogY2FuZGlkYXRlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtRXhwOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbDE6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxnbT17bWF4OlwiX0Fbb2Zmc2V0XVwiLG1pbjpcIl9BW29mZnNldF1cIixtZWFuOlwiMFwiLHN1bTpcIjBcIixwcm9kOlwiMVwiLHN1bVNxdWFyZTpcIjBcIixsb2dTdW1FeHA6XCIwXCIsbDE6XCIwXCIsbDI6XCIwXCIsbG9nU3VtOlwiMFwifSxibT17bWF4OlwiYmVzdFZhbHVlXCIsbWluOlwiYmVzdFZhbHVlXCIsc3VtOlwiYmVzdFZhbHVlXCIscHJvZDpcImJlc3RWYWx1ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZVwiLGxvZ1N1bUV4cDpcImxvZyhiZXN0VmFsdWUpXCIsbDE6XCJiZXN0VmFsdWVcIixsMjpcInNxcnQoYmVzdFZhbHVlKVwiLGxvZ1N1bTpcImxvZyhiZXN0VmFsdWUpXCJ9LHltPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuPXQtZTtuPHQ7KytuKXIucHVzaChuKTtyZXR1cm4gcn0sX209KGUsdCk9PntsZXQgcj1bXSxuPWUubGVuZ3RoO2ZvcihsZXQgaT0wO2k8bjtpKyspdC5pbmRleE9mKGkpPT09LTEmJnIucHVzaChlW2ldKTtsZXQgbz10Lm1hcChpPT5lW2ldKTtyZXR1cm5bcixvXX0sd209KGUsdCk9PntsZXQgcj1lLmxlbmd0aCt0Lmxlbmd0aCxuPVtdLG89MDtmb3IobGV0IGk9MDtpPHI7aSsrKXQuaW5kZXhPZihpKT09PS0xP24ucHVzaChlW28rK10pOm4ucHVzaCgxKTtyZXR1cm4gbn0sdm09KGUsdCk9Pntmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcilpZihlW2UubGVuZ3RoLXItMV0hPT10LTEtcilyZXR1cm4hMTtyZXR1cm4hMH0sJG09KGUsdCk9PntsZXQgcj1bXTtpZighdm0oZSx0KSl7Zm9yKGxldCBuPTA7bjx0OysrbillLmluZGV4T2Yobik9PT0tMSYmci5wdXNoKG4pO2UuZm9yRWFjaChuPT5yLnB1c2gobikpfXJldHVybiByfSx4bT0oZSx0LHIsbixvLGksYSk9PntsZXQgZD1yWzBdLmRpbXMsbD1rLnNpemUoaSkscD1rLnNpemUoYSksbT1FKFwiX0FcIixyWzBdLmRhdGFUeXBlLGQpLHU9TShcIm91dHB1dFwiLG8saSksaD02NDtsPT09MSYmKGg9MjU2KTtsZXQgXz1gXG4gICAgICAgICAgdmFyPHdvcmtncm91cD4gYUJlc3RWYWx1ZXMgOiBhcnJheTxmMzIsICR7aH0+O1xuICAgICAgIGAseT1nPT5gXG4gICAgICAgICR7Zy5yZWdpc3RlclVuaWZvcm0oXCJyZWR1Y2VTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhtLHUpfVxuICAgICAgICAke199XG4gICAgICAgIGZuIERJVl9DRUlMKGEgOiB1MzIsIGIgOiB1MzIpIC0+IHUzMiB7XG4gICAgICAgICAgcmV0dXJuICgoYSAtIDF1KSAvIGIgKyAxdSk7XG4gICAgICAgICB9XG4gICAgICAgICAke2cubWFpblN0YXJ0KGgpfVxuXG4gICAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gZ2xvYmFsX2lkeCAvICR7aH07XG4gICAgICAgICAgbGV0IG9mZnNldCA9IG91dHB1dEluZGV4ICogdW5pZm9ybXMucmVkdWNlU2l6ZTtcblxuICAgICAgICAgIHZhciBiZXN0VmFsdWUgPSBmMzIoJHtnbVtuXX0pO1xuICAgICAgICAgIGxldCBMZW5ndGggPSB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuICAgICAgICAgIGZvciAodmFyIGsgPSBsb2NhbF9pZHg7IGsgPCBMZW5ndGg7IGsgPSBrICsgJHtofSkge1xuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gZjMyKCR7bS5nZXRCeU9mZnNldChcIm9mZnNldCArIGtcIil9KTtcbiAgICAgICAgICAgYmVzdFZhbHVlID0gJHtmbVtuXX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihMZW5ndGgsICR7aH11KTtcbiAgICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XG4gICAgICAgICAgICAgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnUpIHtcbiAgICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xuICAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgY3VycmVudFNpemUpIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBhQmVzdFZhbHVlc1tsb2NhbF9pZHggKyBpbnRlcnZhbF07XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSAke2htW25dfTtcbiAgICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmVkdWNlU2l6ZSA9IGludGVydmFsO1xuICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChsb2NhbF9pZHggPT0gMHUpIHtcbiAgICAgICAgICAke3Uuc2V0QnlPZmZzZXQoXCJvdXRwdXRJbmRleFwiLGAke249PT1cIm1lYW5cIj9gJHt1LnR5cGUuc3RvcmFnZX0oYmVzdFZhbHVlIC8gZjMyKHVuaWZvcm1zLnJlZHVjZVNpemUpKWA6YCR7dS50eXBlLnN0b3JhZ2V9KCR7Ym1bbl19KWB9YCl9O1xuICAgICAgICAgfVxuICAgICAgICB9YDtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke3R9OyR7aH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFNoYWRlclNvdXJjZTp5LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpsfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6cH1dfSl9fSxydD0oZSx0LHIsbik9PntsZXQgbz1lLmlucHV0cy5sZW5ndGg9PT0xP3I6dW8oZS5pbnB1dHMsciksaT1vLmF4ZXM7aS5sZW5ndGg9PT0wJiYhby5ub29wV2l0aEVtcHR5QXhlcyYmKGk9ZS5pbnB1dHNbMF0uZGltcy5tYXAoKF8seSk9PnkpKTtsZXQgYT1rLm5vcm1hbGl6ZUF4ZXMoaSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCksZD1hLGw9ZS5pbnB1dHNbMF0scD0kbShkLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtwLmxlbmd0aD4wJiYobD1lLmNvbXB1dGUoUGUoZS5pbnB1dHNbMF0scCkse2lucHV0czpbMF0sb3V0cHV0czpbLTFdfSlbMF0sZD15bShkLmxlbmd0aCxsLmRpbXMubGVuZ3RoKSk7bGV0W20sdV09X20obC5kaW1zLGQpLGg9bTtvLmtlZXBEaW1zJiYoaD13bShtLGEpKSxlLmNvbXB1dGUoeG0odCxvLmNhY2hlS2V5LFtsXSxuLGUuaW5wdXRzWzBdLmRhdGFUeXBlLGgsdSkse2lucHV0czpbbF19KX0sYXM9KGUsdCk9PntydChlLFwiUmVkdWNlTWVhblNoYXJlZFwiLHQsXCJtZWFuXCIpfSxzcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VMMVNoYXJlZFwiLHQsXCJsMVwiKX0sdXM9KGUsdCk9PntydChlLFwiUmVkdWNlTDJTaGFyZWRcIix0LFwibDJcIil9LGRzPShlLHQpPT57cnQoZSxcIlJlZHVjZUxvZ1N1bUV4cFNoYXJlZFwiLHQsXCJsb2dTdW1FeHBcIil9LGxzPShlLHQpPT57cnQoZSxcIlJlZHVjZU1heFNoYXJlZFwiLHQsXCJtYXhcIil9LGNzPShlLHQpPT57cnQoZSxcIlJlZHVjZU1pblNoYXJlZFwiLHQsXCJtaW5cIil9LHBzPShlLHQpPT57cnQoZSxcIlJlZHVjZVByb2RTaGFyZWRcIix0LFwicHJvZFwiKX0sbXM9KGUsdCk9PntydChlLFwiUmVkdWNlU3VtU2hhcmVkXCIsdCxcInN1bVwiKX0sZnM9KGUsdCk9PntydChlLFwiUmVkdWNlU3VtU3F1YXJlU2hhcmVkXCIsdCxcInN1bVNxdWFyZVwiKX0saHM9KGUsdCk9PntydChlLFwiUmVkdWNlTG9nU3VtU2hhcmVkXCIsdCxcImxvZ1N1bVwiKX19KTt2YXIgbnQsU20sR3IsdW8sb3QsVG0sSW0sQ20sQW0sa20sRW0sUG0sem0sT20sRG0saXQsYnMseXMsX3Msd3MsdnMsJHMseHMsU3MsVHMsSXMsTHI9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtncygpO250PWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTImJmVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhlcyBpbnB1dCBkaW1zLlwiKX0sU209ZT0+W1wiXCIsXCJcIixgdmFyIHZhbHVlID0gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0sR3I9KGUsdCxyLG4sbyxpLGE9ITEsZD0hMSk9PntsZXQgbD1bXSxwPXJbMF0uZGltcyxtPXAubGVuZ3RoLHU9ay5ub3JtYWxpemVBeGVzKG8sbSksaD0hZCYmdS5sZW5ndGg9PT0wO3AuZm9yRWFjaCgoeCwkKT0+e2h8fHUuaW5kZXhPZigkKT49MD9hJiZsLnB1c2goMSk6bC5wdXNoKHgpfSk7bGV0IF89bC5sZW5ndGgseT1rLnNpemUobCk7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp0LGdldFNoYWRlclNvdXJjZTp4PT57bGV0ICQ9W10sdj1FKFwiX0FcIixyWzBdLmRhdGFUeXBlLG0pLFM9TShcIm91dHB1dFwiLGksXyksVD1uKHYsUyx1KSxBPVRbMl07Zm9yKGxldCBDPTAsUD0wO0M8bTtDKyspaHx8dS5pbmRleE9mKEMpPj0wPyhhJiZQKyssQT1gZm9yKHZhciBqJHtDfTogdTMyID0gMDsgaiR7Q30gPCAke3BbQ119OyBqJHtDfSsrKSB7XG4gICAgICAgICAgICAgICAgICAke1RbMl0uaW5jbHVkZXMoXCJsYXN0X2luZGV4XCIpP2BsZXQgbGFzdF9pbmRleCA9IGoke0N9O2A6XCJcIn1cbiAgICAgICAgICAgICAgICAgICR7di5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLEMsYGoke0N9YCl9XG4gICAgICAgICAgICAgICAgICAke0F9XG4gICAgICAgICAgICAgICAgfWApOigkLnB1c2goYCR7di5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLEMsUy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixQKSl9O2ApLFArKyk7cmV0dXJuYFxuXG4gICAgICAgICR7eC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModixTKX1cblxuICAgICAgICAke3gubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHt4Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHt2LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgJHskLmpvaW4oYFxuYCl9XG4gICAgICAgICAgJHtUWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cbiAgICAgICAgICAke1RbMV19XG4gICAgICAgICAgJHtBfVxuICAgICAgICAgICR7VFszXX1cbiAgICAgICAgICAke1QubGVuZ3RoPT09ND9TLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIik6VC5zbGljZSg0KS5qb2luKGBcbmApfVxuICAgICAgICB9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOml9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOnl9LC4uLk4ocCxsKV19KX19LHVvPShlLHQpPT57bGV0IHI9W107cmV0dXJuIGVbMV0uZGltc1swXT4wJiZlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG49PnIucHVzaChOdW1iZXIobikpKSxlZSh7YXhlczpyLGtlZXBEaW1zOnQua2VlcERpbXMsbm9vcFdpdGhFbXB0eUF4ZXM6dC5ub29wV2l0aEVtcHR5QXhlc30pfSxvdD0oZSx0LHIsbik9PntsZXQgbz1lLmlucHV0cyxpPW8ubGVuZ3RoPT09MT9yOnVvKG8scik7ZS5jb21wdXRlKEdyKHQse2hpbnQ6aS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbb1swXV0saS5ub29wV2l0aEVtcHR5QXhlcyYmaS5heGVzLmxlbmd0aD09PTA/U206bixpLmF4ZXMsb1swXS5kYXRhVHlwZSxpLmtlZXBEaW1zLGkubm9vcFdpdGhFbXB0eUF4ZXMpLHtpbnB1dHM6WzBdfSl9LFRtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VMb2dTdW1cIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sSW09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZUwxXCIsdCwobixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGFicygke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl0pfSxDbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTDJcIix0LChuLG8pPT5bYHZhciB0ID0gJHtvLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9OyB2YWx1ZSArPSAodCAqIHQpO2AsXCJ2YWx1ZSA9IHNxcnQodmFsdWUpO1wiXSl9LEFtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VMb2dTdW1FeHBcIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gZXhwKCR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxrbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTWF4XCIsdCwobixvLGkpPT57bGV0IGE9W107Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJmEucHVzaChuLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCwwKSk7cmV0dXJuW2Ake2Euam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxgdmFsdWUgPSBtYXgodmFsdWUsICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXX0pfSxFbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTWVhblwiLHQsKG4sbyxpKT0+e2xldCBhPTE7Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJihhKj1lLmlucHV0c1swXS5kaW1zW2RdKTtyZXR1cm5bXCJ2YXIgc3VtID0gZjMyKDApO1wiLFwiXCIsYHN1bSArPSBmMzIoJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLGBsZXQgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oc3VtIC8gJHthfSk7YF19KX0sUG09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZU1pblwiLHQsKG4sbyxpKT0+e2xldCBhPVtdO2ZvcihsZXQgZD0wO2Q8bi5yYW5rO2QrKykoaS5pbmRleE9mKGQpPj0wfHxpLmxlbmd0aD09PTApJiZhLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHthLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsYHZhbHVlID0gbWluKHZhbHVlLCAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl19KX0sem09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZVByb2RcIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDEpO2AsXCJcIixgdmFsdWUgKj0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSxPbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlU3VtXCIsdCwobixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdKX0sRG09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZVN1bVNxdWFyZVwiLHQsKG4sbyk9PltgdmFyIHQgPSAke28udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9IHQgKiB0O2AsXCJcIl0pfSxpdD0oZSx0LHIpPT57aWYodC5sZW5ndGg9PT0wKXJldHVybiByO2xldCBuPTEsbz0xO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXQuaW5kZXhPZihpKT09PS0xP24qPWVbaV06byo9ZVtpXTtyZXR1cm4gbzwzMiYmbj4xMDI0fSxicz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0VtKGUsdCk6YXMoZSx0KX0seXM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9JbShlLHQpOnNzKGUsdCl9LF9zPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Q20oZSx0KTp1cyhlLHQpfSx3cz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0FtKGUsdCk6ZHMoZSx0KX0sdnM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9rbShlLHQpOmxzKGUsdCl9LCRzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/UG0oZSx0KTpjcyhlLHQpfSx4cz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3ptKGUsdCk6cHMoZSx0KX0sU3M9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9PbShlLHQpOm1zKGUsdCl9LFRzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/RG0oZSx0KTpmcyhlLHQpfSxJcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP1RtKGUsdCk6aHMoZSx0KX19KTt2YXIgQ3MsQXMsa3MsbG8sRXM9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTt4ZSgpO0xyKCk7Q3M9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiQXJnTWluTWF4T3Agb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy5cIik7aWYoZVswXS5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sQXM9KGUsdCk9PntDcyhlLmlucHV0cyk7bGV0IHI9KG4sbyxpKT0+e2xldCBhPVtdO2ZvcihsZXQgZD0wO2Q8bi5yYW5rO2QrKykoaS5pbmRleE9mKGQpPj0wfHxpLmxlbmd0aD09PTApJiZhLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHthLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsYGlmICgke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPD1cIjpcIjxcIn0gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcIlwiLG8uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0X2luZGV4XCIpXX07ZS5jb21wdXRlKEdyKFwiQXJnTWluXCIse2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbZS5pbnB1dHNbMF1dLHIsW3QuYXhpc10sNyx0LmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxrcz0oZSx0KT0+e0NzKGUuaW5wdXRzKTtsZXQgcj0obixvLGkpPT57bGV0IGE9W107Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJmEucHVzaChgaW5wdXRfaW5kaWNlc1ske2R9XSA9IDA7YCk7cmV0dXJuW2Ake2Euam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI+PVwiOlwiPlwifSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xuICAgICAgIH1gLFwiXCIsby5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RfaW5kZXhcIildfTtlLmNvbXB1dGUoR3IoXCJhcmdNYXhcIix7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtlLmlucHV0c1swXV0scixbdC5heGlzXSw3LHQua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LGxvPWU9PmVlKGUpfSk7dmFyIEJtLGNvLE1tLFJtLFVtLFV0LE5tLFBzLEhyPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTtVcigpO2FlKCk7Qm09KGUsdCk9PntsZXQgcj1lWzBdLG49ZVsxXSxvPWVbMl0saT1lWzNdLGE9ZVs0XSxkPWVbNV07aWYoYSYmZCl0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbnRpb24gY2Fubm90IGhhdmUgYm90aCBwYXN0IGFuZCBhdHRlbnRpb25fYmlhc1wiKTtpZihyLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiaW5wdXRcIiBtdXN0IGhhdmUgMyBkaW1lbnNpb25zJyk7bGV0IGw9ci5kaW1zWzBdLHA9ci5kaW1zWzFdLG09ci5kaW1zWzJdO2lmKG8uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtpZihuLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwid2VpZ2h0c1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zJyk7aWYobi5kaW1zWzBdIT09bSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCAxIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAyIG9mIGlucHV0IDBcIik7aWYoby5kaW1zWzBdIT09bi5kaW1zWzFdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDEgb2YgaW5wdXQgXCJ3ZWlnaHRzXCInKTtsZXQgdT1vLmRpbXNbMF0vMyxoPXUsXz1oO2lmKHQucWt2SGlkZGVuU2l6ZXMubGVuZ3RoPjApe2lmKHQucWt2SGlkZGVuU2l6ZXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIGF0dHJpYnV0ZSBzaG91bGQgaGF2ZSAzIGVsZW1lbnRzXCIpO2ZvcihsZXQgUyBvZiB0LnFrdkhpZGRlblNpemVzKWlmKFMldC5udW1IZWFkcyE9PTApdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBzaG91bGQgYmUgZGl2aXNpYmxlIGJ5IG51bV9oZWFkc1wiKTt1PXQucWt2SGlkZGVuU2l6ZXNbMF0saD10LnFrdkhpZGRlblNpemVzWzFdLF89dC5xa3ZIaWRkZW5TaXplc1syXX1sZXQgeT1wO2lmKHUhPT1oKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgZmlyc3QgZWxlbWVudCBzaG91bGQgYmUgc2FtZSBhcyB0aGUgc2Vjb25kXCIpO2lmKG8uZGltc1swXSE9PXUraCtfKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgc3VtIG9mIFEvSy9WIGhpZGRlbiBzaXplcycpO2xldCBnPTA7aWYoYSl7aWYoaCE9PV8pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBleHBlY3Qga19oaWRkZW5fc2l6ZSA9PSB2X2hpZGRlbl9zaXplJyk7aWYoYS5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBtdXN0IGhhdmUgNSBkaW1lbnNpb25zJyk7aWYoYS5kaW1zWzBdIT09Mil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpcnN0IGRpbWVuc2lvbiBtdXN0IGJlIDInKTtpZihhLmRpbXNbMV0hPT1sKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgc2Vjb25kIGRpbWVuc2lvbiBtdXN0IGJlIGJhdGNoX3NpemUnKTtpZihhLmRpbXNbMl0hPT10Lm51bUhlYWRzKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgdGhpcmQgZGltZW5zaW9uIG11c3QgYmUgbnVtX2hlYWRzJyk7aWYoYS5kaW1zWzRdIT09aC90Lm51bUhlYWRzKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlmdGggZGltZW5zaW9uIG11c3QgYmUga19oaWRkZW5fc2l6ZSAvIG51bV9oZWFkcycpO3QucGFzdFByZXNlbnRTaGFyZUJ1ZmZlcnx8KGc9YS5kaW1zWzNdKX1sZXQgeD15K2csJD0tMSx2PTA7aWYoaSl0aHJvdyBuZXcgRXJyb3IoXCJNYXNrIG5vdCBzdXBwb3J0ZWRcIik7aWYoYSl0aHJvdyBuZXcgRXJyb3IoXCJwYXN0IGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZCl7aWYoZC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImF0dGVudGlvbl9iaWFzXCIgbXVzdCBoYXZlIDQgZGltZW5zaW9ucycpO2lmKGQuZGltc1swXSE9PWx8fGQuZGltc1sxXSE9PXQubnVtSGVhZHN8fGQuZGltc1syXSE9PXB8fGQuZGltc1szXSE9PXgpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJhdHRlbnRpb25fYmlhc1wiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpfXJldHVybntiYXRjaFNpemU6bCxzZXF1ZW5jZUxlbmd0aDpwLHBhc3RTZXF1ZW5jZUxlbmd0aDpnLGt2U2VxdWVuY2VMZW5ndGg6eSx0b3RhbFNlcXVlbmNlTGVuZ3RoOngsbWF4U2VxdWVuY2VMZW5ndGg6JCxpbnB1dEhpZGRlblNpemU6bSxoaWRkZW5TaXplOnUsdkhpZGRlblNpemU6XyxoZWFkU2l6ZTpNYXRoLmZsb29yKHUvdC5udW1IZWFkcyksdkhlYWRTaXplOk1hdGguZmxvb3IoXy90Lm51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGlzVW5pZGlyZWN0aW9uYWw6ITEscGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohMSxtYXNrRmlsdGVyVmFsdWU6dC5tYXNrRmlsdGVyVmFsdWUsbWFza1R5cGU6dixzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6ITEscGFzc1Bhc3RJbkt2OiExLHFrdkZvcm1hdDoxfX0sY289KGUsdCxyKT0+dCYmZT9gXG4gICAgICBsZXQgdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0ID0gdTMyKCR7dC5nZXRCeU9mZnNldChcIjBcIil9KTtcbiAgICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IG1heCh0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQsIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKTtcbiAgICAgIGxldCBpc19zdWJzZXF1ZW50X3Byb21wdDogYm9vbCA9IHNlcXVlbmNlX2xlbmd0aCA+IDEgJiYgc2VxdWVuY2VfbGVuZ3RoICE9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dDtcbiAgICAgIGxldCBpc19maXJzdF9wcm9tcHQ6IGJvb2wgPSBpc19zdWJzZXF1ZW50X3Byb21wdCA9PSBmYWxzZSAmJiBzZXF1ZW5jZV9sZW5ndGggPT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdTMyKCR7ZT8uZ2V0QnlPZmZzZXQoXCJiYXRjaElkeFwiKX0pICsgMTtcbiAgICAgIHZhciBwYXN0X3NlcXVlbmNlX2xlbmd0aDogdTMyID0gMDtcbiAgICAgIGlmIChpc19maXJzdF9wcm9tcHQgPT0gZmFsc2UpIHtcbiAgICAgICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggLSBzZXF1ZW5jZV9sZW5ndGg7XG4gICAgICB9XG4gICAgICAgYDpgXG4gICAgJHtyP1wibGV0IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGhcIjpcIlwifTtcbiAgICBsZXQgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XG4gICAgYCxNbT0oZSx0LHIsbixvLGksYSxkKT0+e2xldCBsPW1lKGE/MTppKSxwPTY0LG09aS9sO208cCYmKHA9MzIpO2xldCB1PU1hdGguY2VpbChpL2wvcCksaD1be3R5cGU6MTIsZGF0YTp0fSx7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOm19LHt0eXBlOjEyLGRhdGE6dX1dLF89eWUoZS5kYXRhVHlwZSxsKSx5PUVlKDEsbCksZz1bXCJ0eXBlXCJdO2EmJmcucHVzaChcInR5cGVcIiksZCYmZy5wdXNoKFwidHlwZVwiKTtsZXQgeD0kPT57bGV0IHY9TShcInhcIixlLmRhdGFUeXBlLGUuZGltcyxsKSxTPVt2XSxUPWE/RShcInNlcV9sZW5zXCIsYS5kYXRhVHlwZSxhLmRpbXMpOnZvaWQgMDtUJiZTLnB1c2goVCk7bGV0IEE9ZD9FKFwidG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0XCIsZC5kYXRhVHlwZSxkLmRpbXMpOnZvaWQgMDtBJiZTLnB1c2goQSk7bGV0IEM9RWUoZS5kYXRhVHlwZSksUD1be25hbWU6XCJiYXRjaF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwidG90YWxfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImVsZW1lbnRzX3Blcl90aHJlYWRcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IHRocmVhZF9tYXg6IGFycmF5PGYzMiwgJHtwfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRocmVhZF9zdW06IGFycmF5PGYzMiwgJHtwfT47XG4gICR7JC5yZWdpc3RlclVuaWZvcm1zKFApLmRlY2xhcmVWYXJpYWJsZXMoLi4uUyl9XG4gICR7JC5tYWluU3RhcnQoW3AsMSwxXSl9XG4gICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoO1xuICAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XG4gICAgJHtjbyhULEEsITEpfVxuICAgIGxldCBsb2NhbF9vZmZzZXQgPSBsb2NhbF9pZHggKiB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkO1xuICAgIGxldCBvZmZzZXQgPSAoZ2xvYmFsX2lkeCAvICR7cH0pICogdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoICsgbG9jYWxfb2Zmc2V0O1xuICAgIGxldCBzZXFfY2F1c2FsX2xlbmd0aCA9ICR7YT9cInUzMihwYXN0X3NlcXVlbmNlX2xlbmd0aCArIHdvcmtncm91cF9pZC55ICsgMSlcIjpcInRvdGFsX3NlcXVlbmNlX2xlbmd0aFwifTtcbiAgICB2YXIgdGhyZWFkX21heF92ZWN0b3IgPSAke3l9KC0zLjQwMjgyM2UrMzhmKTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgdGhyZWFkX21heF92ZWN0b3IgPSBtYXgoJHt5fSh4W29mZnNldCArIGldKSwgdGhyZWFkX21heF92ZWN0b3IpO1xuICAgIH1cbiAgICB0aHJlYWRfbWF4W2xvY2FsX2lkeF0gPSAkeygoKT0+e3N3aXRjaChsKXtjYXNlIDE6cmV0dXJuXCJ0aHJlYWRfbWF4X3ZlY3RvclwiO2Nhc2UgMjpyZXR1cm5cIm1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KVwiO2Nhc2UgNDpyZXR1cm5cIm1heChtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSksIG1heCh0aHJlYWRfbWF4X3ZlY3Rvci56LCB0aHJlYWRfbWF4X3ZlY3Rvci53KSlcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtsfWApfX0pKCl9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBtYXhfdmFsdWUgPSAgZjMyKC0zLjQwMjgyM2UrMzhmKTtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3B9OyBpKyspIHtcbiAgICAgIG1heF92YWx1ZSA9IG1heCh0aHJlYWRfbWF4W2ldLCBtYXhfdmFsdWUpO1xuICAgIH1cblxuICAgIHZhciBzdW1fdmVjdG9yID0gJHt5fSgwKTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgc3VtX3ZlY3RvciArPSBleHAoJHt5fSh4W29mZnNldCArIGldKSAtIG1heF92YWx1ZSk7XG4gICAgfVxuICAgIHRocmVhZF9zdW1bbG9jYWxfaWR4XSA9ICR7KCgpPT57c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5cInN1bV92ZWN0b3JcIjtjYXNlIDI6cmV0dXJuXCJzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnlcIjtjYXNlIDQ6cmV0dXJuXCJzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnkgKyBzdW1fdmVjdG9yLnogKyBzdW1fdmVjdG9yLndcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtsfWApfX0pKCl9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBzdW06IGYzMiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtwfTsgaSsrKSB7XG4gICAgICBzdW0gKz0gdGhyZWFkX3N1bVtpXTtcbiAgICB9XG5cbiAgICBpZiAoc3VtID09IDApIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke3YudHlwZS52YWx1ZX0oJHtDfSgxLjApIC8gJHtDfShzZXFfY2F1c2FsX2xlbmd0aCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZjMyaW5wdXQgPSAke3l9KHhbb2Zmc2V0ICsgaV0pO1xuICAgICAgICB4W29mZnNldCArIGldID0gJHt2LnR5cGUudmFsdWV9KGV4cChmMzJpbnB1dCAtIG1heF92YWx1ZSkgLyBzdW0pO1xuICAgICAgfVxuICAgIH1cbiAgICAgICR7YT9gXG4gICAgICAgIGZvciAodmFyIHRvdGFsX3NlcV9pZDogdTMyID0gc2VxX2NhdXNhbF9sZW5ndGg7IHRvdGFsX3NlcV9pZCArIGxvY2FsX29mZnNldCA8IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgdG90YWxfc2VxX2lkKyspIHtcbiAgICAgICAgICB4W29mZnNldCArIHRvdGFsX3NlcV9pZF0gPSAke3YudHlwZS52YWx1ZX0oJHtDfSgwKSk7XG4gICAgICAgIH1gOlwiXCJ9O1xuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25Qcm9ic1NvZnRtYXhcIixzaGFkZXJDYWNoZTp7aGludDpgJHtwfTske199OyR7bH1gLGlucHV0RGVwZW5kZW5jaWVzOmd9LGdldFNoYWRlclNvdXJjZTp4LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbXSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChpL3ApLHk6byx6OnQqcn0scHJvZ3JhbVVuaWZvcm1zOmh9KX19LFJtPShlLHQscixuLG8saSxhLGQsbCk9PntsZXQgcD1hK2kua3ZTZXF1ZW5jZUxlbmd0aCxtPVtpLmJhdGNoU2l6ZSxpLm51bUhlYWRzLGkuc2VxdWVuY2VMZW5ndGgscF0sdT1lPjEmJm4saD1pLmt2TnVtSGVhZHM/aS5rdk51bUhlYWRzOmkubnVtSGVhZHMsXz11P1tpLmJhdGNoU2l6ZSxoLHAsaS5oZWFkU2l6ZV06dm9pZCAwLHk9aS5uUmVwcz9pLm5SZXBzOjEsZz1pLnNjYWxlPT09MD8xL01hdGguc3FydChpLmhlYWRTaXplKTppLnNjYWxlLHg9bWUoaS5oZWFkU2l6ZSksJD1pLmhlYWRTaXplL3gsdj0xMixTPXt4Ok1hdGguY2VpbChwL3YpLHk6TWF0aC5jZWlsKGkuc2VxdWVuY2VMZW5ndGgvdiksejppLmJhdGNoU2l6ZSppLm51bUhlYWRzfSxUPVt7dHlwZToxMixkYXRhOmkuc2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6JH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxMixkYXRhOmkubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6aS5oZWFkU2l6ZX0se3R5cGU6MSxkYXRhOmd9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTppLmt2U2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6eX1dLEE9dSYmbiYmay5zaXplKG4uZGltcyk+MCxDPVtcInR5cGVcIixcInR5cGVcIl07QSYmQy5wdXNoKFwidHlwZVwiKSxvJiZDLnB1c2goXCJ0eXBlXCIpLGQmJkMucHVzaChcInR5cGVcIiksbCYmQy5wdXNoKFwidHlwZVwiKTtsZXQgUD1be2RpbXM6bSxkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XTt1JiZQLnB1c2goe2RpbXM6XyxkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9KTtsZXQgRD1SPT57bGV0IEg9RShcInFcIix0LmRhdGFUeXBlLHQuZGltcyx4KSxMPUUoXCJrZXlcIixyLmRhdGFUeXBlLHIuZGltcyx4KSxyZT1bSCxMXTtpZihBKXtsZXQgdGU9RShcInBhc3Rfa2V5XCIsbi5kYXRhVHlwZSxuLmRpbXMseCk7cmUucHVzaCh0ZSl9byYmcmUucHVzaChFKFwiYXR0ZW50aW9uX2JpYXNcIixvLmRhdGFUeXBlLG8uZGltcykpO2xldCBWPWQ/RShcInNlcV9sZW5zXCIsZC5kYXRhVHlwZSxkLmRpbXMpOnZvaWQgMDtWJiZyZS5wdXNoKFYpO2xldCBLPWw/RShcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLGwuZGF0YVR5cGUsbC5kaW1zKTp2b2lkIDA7SyYmcmUucHVzaChLKTtsZXQgd2U9TShcIm91dHB1dFwiLHQuZGF0YVR5cGUsbSksaj1bd2VdO3UmJmoucHVzaChNKFwicHJlc2VudF9rZXlcIix0LmRhdGFUeXBlLF8seCkpO2xldCBRPUVlKDEseCksaWU9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke3Z9dTtcblxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtILnR5cGUuc3RvcmFnZX0sICR7dip2fT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke0gudHlwZS5zdG9yYWdlfSwgJHt2KnZ9PjtcbiAgJHtSLnJlZ2lzdGVyVW5pZm9ybXMoaWUpLmRlY2xhcmVWYXJpYWJsZXMoLi4ucmUsLi4uail9XG4gICR7Ui5tYWluU3RhcnQoW3YsdiwxXSl9XG4gICAgLy8geCBob2xkcyB0aGUgTiBhbmQgeSBob2xkcyB0aGUgTVxuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGt2SGVhZElkeCA9ICR7eT09PTE/XCJoZWFkSWR4XCI6XCJoZWFkSWR4IC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgIGxldCBrdl9udW1faGVhZHMgPSAke3k9PT0xP1widW5pZm9ybXMubnVtX2hlYWRzXCI6XCJ1bmlmb3Jtcy5udW1faGVhZHMgLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSB3b3JrZ3JvdXBfaWQueSAqIFRJTEVfU0laRTtcbiAgICBsZXQgbiA9IHdvcmtncm91cF9pZC54ICogVElMRV9TSVpFO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5NO1xuICAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5OO1xuICAgICR7Y28oVixLLCEwKX1cbiAgICBsZXQgYWJzS3ZIZWFkSWR4ID0gYmF0Y2hJZHggKiBrdl9udW1faGVhZHMgKyBrdkhlYWRJZHg7XG4gICAgbGV0IHFPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XG4gICAgJHtBJiZ1P1wibGV0IHBhc3RLZXlPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCAqIHVuaWZvcm1zLks7XCI6XCJcIn07XG4gICAgbGV0IGtPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LO1xuICAgICR7dT9cImxldCBwcmVzZW50S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLks7XCI6XCJcIn1cbiAgICB2YXIgdmFsdWUgPSAke1F9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChnbG9iYWxfaWQueSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHFbcU9mZnNldCArIGxvY2FsX2lkLnkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgJHsoKCk9PkEmJnU/YFxuICAgICAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCBwYXN0X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBwYXN0X2tleVtwYXN0S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobiArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgICAgIH1gOmBcbiAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgICAgIH1gKSgpfVxuICAgICAgJHt1P2BpZiAobiArIGxvY2FsX2lkLnkgPCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICBwcmVzZW50X2tleVtwcmVzZW50S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF0gPSB0aWxlS1tpZHhdO1xuICAgICAgfWA6XCJcIn1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJHtRfSh0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC54ICsga10pO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiBnbG9iYWxfaWQueCA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgbGV0IGhlYWRPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgICAgbGV0IG91dHB1dElkeCA9IGhlYWRPZmZzZXQgKyBnbG9iYWxfaWQueSAqIHVuaWZvcm1zLk4gKyBnbG9iYWxfaWQueDtcbiAgICAgIHZhciBzdW06IGYzMiA9ICR7KCgpPT57c3dpdGNoKHgpe2Nhc2UgMTpyZXR1cm5cInZhbHVlXCI7Y2FzZSAyOnJldHVyblwidmFsdWUueCArIHZhbHVlLnlcIjtjYXNlIDQ6cmV0dXJuXCJ2YWx1ZS54ICsgdmFsdWUueSArIHZhbHVlLnogKyB2YWx1ZS53XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7eH1gKX19KSgpfTtcbiAgICAgICAgb3V0cHV0W291dHB1dElkeF0gPSAke3dlLnR5cGUudmFsdWV9IChzdW0gKiB1bmlmb3Jtcy5hbHBoYSkgKyAke28/XCJhdHRlbnRpb25fYmlhc1tvdXRwdXRJZHhdXCI6XCIwLjBcIn07XG4gICAgfVxuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25Qcm9ic1wiLHNoYWRlckNhY2hlOntoaW50OmAke3h9OyR7byE9PXZvaWQgMH07JHtuIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczpDfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6UCxkaXNwYXRjaEdyb3VwOlMscHJvZ3JhbVVuaWZvcm1zOlR9KSxnZXRTaGFkZXJTb3VyY2U6RH19LFVtPShlLHQscixuLG8saSxhPXZvaWQgMCxkPXZvaWQgMCk9PntsZXQgbD1pK28ua3ZTZXF1ZW5jZUxlbmd0aCxwPW8ublJlcHM/by5uUmVwczoxLG09by52SGlkZGVuU2l6ZSpwLHU9ZT4xJiZuLGg9by5rdk51bUhlYWRzP28ua3ZOdW1IZWFkczpvLm51bUhlYWRzLF89dT9bby5iYXRjaFNpemUsaCxsLG8uaGVhZFNpemVdOnZvaWQgMCx5PVtvLmJhdGNoU2l6ZSxvLnNlcXVlbmNlTGVuZ3RoLG1dLGc9MTIseD17eDpNYXRoLmNlaWwoby52SGVhZFNpemUvZykseTpNYXRoLmNlaWwoby5zZXF1ZW5jZUxlbmd0aC9nKSx6Om8uYmF0Y2hTaXplKm8ubnVtSGVhZHN9LCQ9W3t0eXBlOjEyLGRhdGE6by5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOm8udkhlYWRTaXplfSx7dHlwZToxMixkYXRhOm8ubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6by5oZWFkU2l6ZX0se3R5cGU6MTIsZGF0YTptfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6by5rdlNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOnB9XSx2PXUmJm4mJmsuc2l6ZShuLmRpbXMpPjAsUz1bXCJ0eXBlXCIsXCJ0eXBlXCJdO3YmJlMucHVzaChcInR5cGVcIiksYSYmUy5wdXNoKFwidHlwZVwiKSxkJiZTLnB1c2goXCJ0eXBlXCIpO2xldCBUPVt7ZGltczp5LGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO3UmJlQucHVzaCh7ZGltczpfLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBBPUM9PntsZXQgUD1FKFwicHJvYnNcIix0LmRhdGFUeXBlLHQuZGltcyksRD1FKFwidlwiLHIuZGF0YVR5cGUsci5kaW1zKSxSPVtQLERdO3YmJlIucHVzaChFKFwicGFzdF92YWx1ZVwiLG4uZGF0YVR5cGUsbi5kaW1zKSk7bGV0IEg9YT9FKFwic2VxX2xlbnNcIixhLmRhdGFUeXBlLGEuZGltcyk6dm9pZCAwO2EmJlIucHVzaChIKTtsZXQgTD1kP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO2QmJlIucHVzaChMKTtsZXQgVj1bTShcIm91dHB1dFwiLHQuZGF0YVR5cGUseSldO3UmJlYucHVzaChNKFwicHJlc2VudF92YWx1ZVwiLHQuZGF0YVR5cGUsXykpO2xldCBLPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwidl9oaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke2d9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7UC50eXBlLnZhbHVlfSwgJHtnKmd9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVY6IGFycmF5PCR7UC50eXBlLnZhbHVlfSwgJHtnKmd9PjtcbiAgJHtDLnJlZ2lzdGVyVW5pZm9ybXMoSykuZGVjbGFyZVZhcmlhYmxlcyguLi5SLC4uLlYpfVxuICAke0MubWFpblN0YXJ0KFtnLGcsMV0pfVxuICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGt2SGVhZElkeCA9ICR7cD09PTE/XCJoZWFkSWR4XCI6XCJoZWFkSWR4IC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgbGV0IGt2X251bV9oZWFkcyA9ICR7cD09PTE/XCJ1bmlmb3Jtcy5udW1faGVhZHNcIjpcInVuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuSztcbiAgICR7Y28oSCxMLCEwKX1cbiAgIGxldCBvZmZzZXRBID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4OyAvLyBrdkhlYWRJZHggaXMgcmVsYXRpdmUgdG8gdGhlIGJhdGNoXG4gICAke3YmJnU/XCJsZXQgcGFzdFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgbjtcIjpcIlwifTtcbiAgIGxldCB2T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCArIG47XG4gICAke3U/XCJsZXQgcHJlc2VudFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLksgKyBuO1wiOlwiXCJ9XG4gICB2YXIgdmFsdWUgPSAke1AudHlwZS5zdG9yYWdlfSgwKTtcbiAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcHJvYnNbb2Zmc2V0QSArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgICAkeygoKT0+diYmdT9gXG4gICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHBhc3RfdmFsdWVbcGFzdFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9IGVsc2UgaWYgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH1cbiAgICAgIGA6YFxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgICAgICB9YCkoKX1cbiAgICAgICAgJHt1P2BcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgcHJlc2VudF92YWx1ZVtwcmVzZW50VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl0gPSB0aWxlVltpZHhdO1xuICAgICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZVZbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplICsgbSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemVcbiAgICAgICArIGhlYWRJZHggKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgb3V0cHV0W291dHB1dElkeF0gPSB2YWx1ZTtcbiAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiQXR0ZW50aW9uU2NvcmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHtuIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczpTfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOngscHJvZ3JhbVVuaWZvcm1zOiR9KSxnZXRTaGFkZXJTb3VyY2U6QX19LFV0PShlLHQscixuLG8saSxhLGQsbCxwLG09dm9pZCAwLHU9dm9pZCAwKT0+e2xldCBoPU1hdGgubWluKGUub3V0cHV0Q291bnQsMSsoYT8xOjApKyhkPzE6MCkpLF89aD4xP3AucGFzdFNlcXVlbmNlTGVuZ3RoOjAseT1fK3Aua3ZTZXF1ZW5jZUxlbmd0aCxnPWwmJmsuc2l6ZShsLmRpbXMpPjA/bDp2b2lkIDAseD1bdCxyXTtoPjEmJmEmJmsuc2l6ZShhLmRpbXMpPjAmJngucHVzaChhKSxnJiZ4LnB1c2goZyksbSYmeC5wdXNoKG0pLHUmJngucHVzaCh1KTtsZXQgJD1lLmNvbXB1dGUoUm0oaCx0LHIsYSxnLHAsXyxtLHUpLHtpbnB1dHM6eCxvdXRwdXRzOmg+MT9bLTEsMV06Wy0xXX0pWzBdO2UuY29tcHV0ZShNbSgkLHAuYmF0Y2hTaXplLHAubnVtSGVhZHMsXyxwLnNlcXVlbmNlTGVuZ3RoLHksbSx1KSx7aW5wdXRzOm0mJnU/WyQsbSx1XTpbJF0sb3V0cHV0czpbXX0pO2xldCB2PVskLG5dO2g+MSYmZCYmay5zaXplKGQuZGltcyk+MCYmdi5wdXNoKGQpLG0mJnYucHVzaChtKSx1JiZ2LnB1c2godSksZS5jb21wdXRlKFVtKGgsJCxuLGQscCxfLG0sdSkse2lucHV0czp2LG91dHB1dHM6aD4xP1swLDJdOlswXX0pfSxObT0oZSx0KT0+e2xldCByPVt0LmJhdGNoU2l6ZSx0Lm51bUhlYWRzLHQuc2VxdWVuY2VMZW5ndGgsdC5oZWFkU2l6ZV0sbj10LnNlcXVlbmNlTGVuZ3RoLG89dC5pbnB1dEhpZGRlblNpemUsaT10LmhlYWRTaXplLGE9MTIsZD17eDpNYXRoLmNlaWwodC5oZWFkU2l6ZS9hKSx5Ok1hdGguY2VpbCh0LnNlcXVlbmNlTGVuZ3RoL2EpLHo6dC5iYXRjaFNpemUqdC5udW1IZWFkc30sbD1bZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0sZS5pbnB1dHNbMl1dLHA9W3t0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6dC5udW1IZWFkc30se3R5cGU6MTIsZGF0YTp0LmhlYWRTaXplfSx7dHlwZToxMixkYXRhOnQuaGlkZGVuU2l6ZX0se3R5cGU6MTIsZGF0YTp0LmhpZGRlblNpemUrdC5oaWRkZW5TaXplK3QudkhpZGRlblNpemV9XSxtPXU9PntsZXQgaD1NKFwib3V0cHV0X3FcIixsWzBdLmRhdGFUeXBlLHIpLF89TShcIm91dHB1dF9rXCIsbFswXS5kYXRhVHlwZSxyKSx5PU0oXCJvdXRwdXRfdlwiLGxbMF0uZGF0YVR5cGUsciksZz1FKFwiaW5wdXRcIixsWzBdLmRhdGFUeXBlLGxbMF0uZGltcykseD1FKFwid2VpZ2h0XCIsbFsxXS5kYXRhVHlwZSxsWzFdLmRpbXMpLCQ9RShcImJpYXNcIixsWzJdLmRhdGFUeXBlLGxbMl0uZGltcyksdj1nLnR5cGUuc3RvcmFnZSxTPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibGRiXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke2F9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUlucHV0OiBhcnJheTwke3Z9LCAke2EqYX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHt2fSwgJHthKmF9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7dn0sICR7YSphfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRWOiBhcnJheTwke3Z9LCAke2EqYX0+O1xuICAke3UucmVnaXN0ZXJVbmlmb3JtcyhTKS5kZWNsYXJlVmFyaWFibGVzKGcseCwkLGgsXyx5KX1cbiAgJHt1Lm1haW5TdGFydChbYSxhLDFdKX1cbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkTnVtYmVyID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmF0Y2hJbmRleCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgICBsZXQgYmlhc09mZnNldFEgPSBoZWFkTnVtYmVyICogdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIGxldCBiaWFzT2Zmc2V0SyA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldFE7XG4gICAgbGV0IGJpYXNPZmZzZXRWID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0SztcblxuICAgIHZhciB2YWx1ZVEgPSAke3Z9KDApO1xuICAgIHZhciB2YWx1ZUsgPSAke3Z9KDApO1xuICAgIHZhciB2YWx1ZVYgPSAke3Z9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZUlucHV0W1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGlucHV0W2lucHV0T2Zmc2V0ICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gbiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5sZGI7XG4gICAgICAgIHRpbGVXZWlnaHRRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0USArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0SyArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRWW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0ViArIG9mZnNldF07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIGxldCBpbnB1dFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgaztcbiAgICAgICAgbGV0IHdlaWdodFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueDtcbiAgICAgICAgdmFsdWVRICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFFbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlSyArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRLW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZVYgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0Vlt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gKG0gKiB1bmlmb3Jtcy5OICsgbikgJSB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgdmFsdWVRICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRRXTtcbiAgICB2YWx1ZUsgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldEtdO1xuICAgIHZhbHVlViArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0Vl07XG5cbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBvZmZzZXQgKyBtICogdW5pZm9ybXMuTiArIG47XG4gICAgICBvdXRwdXRfcVtvdXRwdXRJZHhdID0gdmFsdWVRO1xuICAgICAgb3V0cHV0X2tbb3V0cHV0SWR4XSA9IHZhbHVlSztcbiAgICAgIG91dHB1dF92W291dHB1dElkeF0gPSB2YWx1ZVY7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkF0dGVudGlvblByZXBhcmVcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9LHtkaW1zOnIsZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0se2RpbXM6cixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDpkLHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOm19LHtpbnB1dHM6bCxvdXRwdXRzOlstMSwtMSwtMV19KX0sUHM9KGUsdCk9PntsZXQgcj1CbShlLmlucHV0cyx0KSxbbixvLGldPU5tKGUscik7cmV0dXJuIFV0KGUsbixvLGksZS5pbnB1dHNbNF0sdm9pZCAwLHZvaWQgMCx2b2lkIDAsZS5pbnB1dHNbNV0scil9fSk7dmFyIFZtLFdtLExtLHpzLE9zPVUoKCk9PntcInVzZSBzdHJpY3RcIjtMZSgpO0ooKTtuZSgpO3hlKCk7YWUoKTtWbT0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzXCIpO2xldCByPShuLG8saSk9PntsZXQgYT1vLmxlbmd0aDtpZihhIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGAke2l9OiBudW0gZGltZW5zaW9ucyAhPSAke2F9YCk7by5mb3JFYWNoKChkLGwpPT57aWYoZCE9PW5bbF0pdGhyb3cgbmV3IEVycm9yKGAke2l9OiBkaW1bJHtsfV0gZG8gbm90IG1hdGNoYCl9KX07aWYoZVswXS5kaW1zLmxlbmd0aD4xKXtsZXQgbj10LmZvcm1hdD09PVwiTkhXQ1wiP3Quc3BhdGlhbD9lWzBdLmRpbXMuc2xpY2UoLTEpOmVbMF0uZGltcy5zbGljZSgtMSkuY29uY2F0KGVbMF0uZGltcy5zbGljZSgxLGVbMF0uZGltcy5sZW5ndGgtMSkpOmVbMF0uZGltcy5zbGljZSgxLHQuc3BhdGlhbD8yOnZvaWQgMCk7cihlWzFdLmRpbXMsbixcIkludmFsaWQgaW5wdXQgc2NhbGVcIikscihlWzJdLmRpbXMsbixcIkludmFsaWQgaW5wdXQgQlwiKSxyKGVbM10uZGltcyxuLFwiSW52YWxpZCBpbnB1dCBtZWFuXCIpLHIoZVs0XS5kaW1zLG4sXCJJbnZhbGlkIGlucHV0IHZhclwiKX1lbHNlIHIoZVsxXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgc2NhbGVcIikscihlWzJdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBCXCIpLHIoZVszXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgbWVhblwiKSxyKGVbNF0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IHZhclwiKX0sV209KGUsdCk9PntsZXR7ZXBzaWxvbjpyLHNwYXRpYWw6bixmb3JtYXQ6b309dCxpPWVbMF0uZGltcyxhPW4/bWUoaVtpLmxlbmd0aC0xXSk6MSxkPW89PT1cIk5IV0NcIiYmaS5sZW5ndGg+MT9hOjEsbD1rLnNpemUoaSkvYSxwPW4sbT1wP2kubGVuZ3RoOmksdT1FKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLGEpLGg9RShcInNjYWxlXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMsZCksXz1FKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGQpLHk9RShcImlucHV0TWVhblwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLGQpLGc9RShcImlucHV0VmFyXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsZCkseD1NKFwieVwiLGVbMF0uZGF0YVR5cGUsbSxhKSwkPSgpPT57bGV0IFM9XCJcIjtpZihuKVM9YGxldCBjT2Zmc2V0ID0gJHtpLmxlbmd0aD09PTE/XCIwdVwiOm89PT1cIk5IV0NcIj9gb3V0cHV0SW5kaWNlc1ske2kubGVuZ3RoLTF9XSAvICR7YX1gOlwib3V0cHV0SW5kaWNlc1sxXVwifTtgO2Vsc2UgaWYobz09PVwiTkNIV1wiKVM9YFxuICAgICAgICAgICAgJHt4LmluZGljZXNTZXQoXCJvdXRwdXRJbmRpY2VzXCIsXCIwXCIsXCIwXCIpfVxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke3guaW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiKX07YDtlbHNle1M9YHZhciBjSW5kaWNlcyA9ICR7aC50eXBlLmluZGljZXN9KDApO1xuICAgICAgICAgICAgICAgICAgICAgICBjSW5kaWNlc1swXSA9IG91dHB1dEluZGljZXNbJHtpLmxlbmd0aC0xfV07YDtmb3IobGV0IFQ9MTtUPGgucmFuaztUKyspUys9YGNJbmRpY2VzWyR7VH1dID0gb3V0cHV0SW5kaWNlc1ske1R9XTtgO1MrPWBsZXQgY09mZnNldCA9ICR7aC5pbmRpY2VzVG9PZmZzZXQoXCJjSW5kaWNlc1wiKX07YH1yZXR1cm4gU30sdj1TPT5gXG4gIGNvbnN0IGVwc2lsb24gPSAke3J9O1xuICAke1MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModSxoLF8seSxnLHgpfVxuICAke1MubWFpblN0YXJ0KCl9XG4gICR7Uy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7eC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2F9YCl9O1xuICAgICR7JCgpfVxuICAgIGxldCBzY2FsZSA9ICR7aC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBiaWFzID0gJHtfLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IGlucHV0TWVhbiA9ICR7eS5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBpbnB1dFZhciA9ICR7Zy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCB4ID0gJHt1LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IHZhbHVlID0gKHggLSBpbnB1dE1lYW4pICogaW52ZXJzZVNxcnQoaW5wdXRWYXIgKyBlcHNpbG9uKSAqIHNjYWxlICsgYmlhcztcbiAgICAke3guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWA7cmV0dXJue25hbWU6XCJCYXRjaE5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmVwc2lsb259XyR7dC5mb3JtYXR9XyR7bn1fJHthfWAsaW5wdXREZXBlbmRlbmNpZXM6cD9bXCJyYW5rXCIsXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdOnZvaWQgMH0sZ2V0U2hhZGVyU291cmNlOnYsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczplWzBdLmRpbXMsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cD9be3R5cGU6MTIsZGF0YTpsfSwuLi5OKGkpXTpbe3R5cGU6MTIsZGF0YTpsfV19KX19LExtPWU9PmVlKGUpLHpzPShlLHQpPT57bGV0e2lucHV0czpyLG91dHB1dENvdW50Om59PWUsbz1MbSh7Li4udCxvdXRwdXRDb3VudDpufSk7aWYoX2Uud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiZWbShyLG8pLHQudHJhaW5pbmdNb2RlKXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiB0cmFpbmluZ01vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2UuY29tcHV0ZShXbShyLG8pKX19KTt2YXIgR20sSG0sRHMsQnM9VSgoKT0+e1widXNlIHN0cmljdFwiO25lKCk7YWUoKTtHbT1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMzIwLDY0MCwxMjgwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcIm51bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxIbT1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9ZVswXS5kaW1zWzJdLG49ay5zaXplKHQpLzQsbz1lWzBdLmRhdGFUeXBlLGk9RShcImlucHV0XCIsbyx0LDQpLGE9RShcImJpYXNcIixvLFtyXSw0KSxkPUUoXCJyZXNpZHVhbFwiLG8sdCw0KSxsPU0oXCJvdXRwdXRcIixvLHQsNCk7cmV0dXJue25hbWU6XCJCaWFzQWRkXCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6bT0+YFxuICBjb25zdCBjaGFubmVscyA9ICR7cn11IC8gNDtcbiAgJHttLmRlY2xhcmVWYXJpYWJsZXMoaSxhLGQsbCl9XG5cbiAgJHttLm1haW5TdGFydCgpfVxuICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG4pfVxuICAgIGxldCB2YWx1ZSA9ICR7aS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9XG4gICAgICArICR7YS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggJSBjaGFubmVsc1wiKX0gKyAke2QuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke2wuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWB9fSxEcz1lPT57R20oZS5pbnB1dHMpLGUuY29tcHV0ZShIbShlLmlucHV0cykpfX0pO3ZhciBGbSxmZSxNcyxScyxVcyxOcyxWcyxXcyxMcyxHcyxIcyxxbSxGcyxxcyxLcyxqcyxRdCxZcyxGcixacyxRcyxYcyxKcyxldSx0dSxydSxudSxvdSxpdSxhdSxzdSx1dSxkdSxsdSxjdSxwdSxtdSxwbyxtbyxmdSxodSxndSxLbSxqbSxidSxxcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTthZSgpO0ZtPShlLHQscixuLG8saSxhKT0+e2xldCBkPU1hdGguY2VpbCh0LzQpLGw9XCJcIjt0eXBlb2Ygbz09XCJzdHJpbmdcIj9sPWAke299KGEpYDpsPW8oXCJhXCIpO2xldCBwPUUoXCJpbnB1dERhdGFcIixyLFtkXSw0KSxtPU0oXCJvdXRwdXREYXRhXCIsbixbZF0sNCksdT1be25hbWU6XCJ2ZWNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybiBhJiZ1LnB1c2goLi4uYSksYFxuICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXModSkuZGVjbGFyZVZhcmlhYmxlcyhwLG0pfVxuXG4gICR7aT8/XCJcIn1cblxuICAke2UubWFpblN0YXJ0KCl9XG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cblxuICAgIGxldCBhID0gJHtwLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHttLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGwpfVxuICB9YH0sZmU9KGUsdCxyLG4sbyxpPWUuZGF0YVR5cGUsYSxkKT0+e2xldCBsPVt7dHlwZToxMixkYXRhOk1hdGguY2VpbChrLnNpemUoZS5kaW1zKS80KX1dO3JldHVybiBhJiZsLnB1c2goLi4uYSkse25hbWU6dCxzaGFkZXJDYWNoZTp7aGludDpvLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFNoYWRlclNvdXJjZTpwPT5GbShwLGsuc2l6ZShlLmRpbXMpLGUuZGF0YVR5cGUsaSxyLG4sZCksZ2V0UnVuRGF0YTpwPT4oe291dHB1dHM6W3tkaW1zOmUuZGltcyxkYXRhVHlwZTppfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoay5zaXplKHBbMF0uZGltcykvNjQvNCl9LHByb2dyYW1Vbmlmb3JtczpsfSl9fSxNcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQWJzXCIsXCJhYnNcIikpfSxScz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQWNvc1wiLFwiYWNvc1wiKSl9LFVzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBY29zaFwiLFwiYWNvc2hcIikpfSxOcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQXNpblwiLFwiYXNpblwiKSl9LFZzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBc2luaFwiLFwiYXNpbmhcIikpfSxXcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQXRhblwiLFwiYXRhblwiKSl9LExzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBdGFuaFwiLFwiYXRhbmhcIikpfSxHcz1lPT5lZShlKSxIcz0oZSx0KT0+e2xldCByO3N3aXRjaCh0LnRvKXtjYXNlIDEwOnI9XCJ2ZWM0PGYxNj5cIjticmVhaztjYXNlIDE6cj1cInZlYzQ8ZjMyPlwiO2JyZWFrO2Nhc2UgMTI6cj1cInZlYzQ8dTMyPlwiO2JyZWFrO2Nhc2UgNjpyPVwidmVjNDxpMzI+XCI7YnJlYWs7Y2FzZSA5OnI9XCJ2ZWM0PGJvb2w+XCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbm90IHN1cHBvcnRlZCB0eXBlIChzcGVjaWZpZWQgaW4gYXR0cmlidXRlICd0bycgZnJvbSAnQ2FzdCcgb3BlcmF0b3IpOiAke3QudG99YCl9ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQ2FzdFwiLHIsdm9pZCAwLHQuY2FjaGVLZXksdC50bykpfSxxbT1lPT57bGV0IHQscixuPWUubGVuZ3RoPj0yJiZlWzFdLmRhdGEhPT0wLG89ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YSE9PTA7c3dpdGNoKGVbMF0uZGF0YVR5cGUpe2Nhc2UgMTp0PW4/ZVsxXS5nZXRGbG9hdDMyQXJyYXkoKVswXTotMzQwMjgyMzQ2NjM4NTI4ODZlMjIscj1vP2VbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06MzQwMjgyMzQ2NjM4NTI4ODZlMjI7YnJlYWs7Y2FzZSAxMDp0PW4/ZVsxXS5nZXRVaW50MTZBcnJheSgpWzBdOjY0NTExLHI9bz9lWzJdLmdldFVpbnQxNkFycmF5KClbMF06MzE3NDM7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnQgZGF0YSB0eXBlXCIpfXJldHVybiBlZSh7bWluOnQsbWF4OnJ9KX0sRnM9KGUsdCk9PntsZXQgcj10fHxxbShlLmlucHV0cyksbj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQ2xpcFwiLG89PmBjbGFtcCgke299LCB2ZWM0PCR7bn0+KHVuaWZvcm1zLm1pbiksIHZlYzQ8JHtufT4odW5pZm9ybXMubWF4KSlgLHZvaWQgMCxyLmNhY2hlS2V5LHZvaWQgMCxbe3R5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZGF0YTpyLm1pbn0se3R5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZGF0YTpyLm1heH1dLFt7bmFtZTpcIm1pblwiLHR5cGU6bn0se25hbWU6XCJtYXhcIix0eXBlOm59XSkse2lucHV0czpbMF19KX0scXM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkNlaWxcIixcImNlaWxcIikpfSxLcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQ29zXCIsXCJjb3NcIikpfSxqcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQ29zaFwiLFwiY29zaFwiKSl9LFF0PWU9PmVlKGUpLFlzPShlLHQpPT57bGV0IHI9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkVsdVwiLG49PmBlbHVfdmYzMigke259KWAsYFxuICBjb25zdCBlbHVfYWxwaGFfID0gJHtyfSgke3QuYWxwaGF9KTtcblxuICBmbiBlbHVfZjMyKGE6ICR7cn0pIC0+ICR7cn0ge1xuICByZXR1cm4gc2VsZWN0KChleHAoYSkgLSAxLjApICogZWx1X2FscGhhXywgYSwgYSA+PSAwLjApO1xuICB9XG5cbiAgZm4gZWx1X3ZmMzIodjogdmVjNDwke3J9PikgLT4gdmVjNDwke3J9PiB7XG4gIHJldHVybiB2ZWM0KGVsdV9mMzIodi54KSwgZWx1X2YzMih2LnkpLCBlbHVfZjMyKHYueiksIGVsdV9mMzIodi53KSk7XG4gIH1gLHQuY2FjaGVLZXkpKX0sRnI9KGU9XCJmMzJcIik9PmBcbmNvbnN0IHIwOiAke2V9ID0gMC4zMjc1OTExO1xuY29uc3QgcjE6ICR7ZX0gPSAwLjI1NDgyOTU5MjtcbmNvbnN0IHIyOiAke2V9ID0gLTAuMjg0NDk2NzM2O1xuY29uc3QgcjM6ICR7ZX0gPSAxLjQyMTQxMzc0MTtcbmNvbnN0IHI0OiAke2V9ID0gLTEuNDUzMTUyMDI3O1xuY29uc3QgcjU6ICR7ZX0gPSAxLjA2MTQwNTQyOTtcblxuZm4gZXJmX3ZmMzIodjogdmVjNDwke2V9PikgLT4gdmVjNDwke2V9PiB7XG4gIGxldCBhYnN2ID0gYWJzKHYpO1xuICBsZXQgeCA9IDEuMCAvICgxLjAgKyByMCAqIGFic3YpO1xuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcbn1gLFpzPWU9PntsZXQgdD1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiRXJmXCIscj0+YGVyZl92ZjMyKCR7cn0pYCxGcih0KSkpfSxRcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiRXhwXCIsXCJleHBcIikpfSxYcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiRmxvb3JcIixcImZsb29yXCIpKX0sSnM9ZT0+e2xldCB0PUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJHZWx1XCIscj0+YDAuNSAqICR7cn0gKiAoMS4wICsgZXJmX3ZmMzIoJHtyfSAqIDAuNzA3MTA2NzgxMTg2NTQ3NSkpYCxGcih0KSkpfSxldT0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJMZWFreVJlbHVcIixuPT5gc2VsZWN0KGxlYWt5X3JlbHVfYWxwaGFfICogJHtufSwgJHtufSwgJHtufSA+PSB2ZWM0PCR7cn0+KDAuMCkpYCxgY29uc3QgbGVha3lfcmVsdV9hbHBoYV8gPSAke3J9KCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpfSx0dT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiTm90XCIsdD0+YCEke3R9YCkpfSxydT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiTmVnXCIsdD0+YC0ke3R9YCkpfSxudT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiUmVjaXByb2NhbFwiLHQ9PmAxLjAvJHt0fWApKX0sb3U9ZT0+e2xldCB0PUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJSZWx1XCIscj0+YHNlbGVjdCh2ZWM0PCR7dH0+KDAuMCksICR7cn0sICR7cn0gPiB2ZWM0PCR7dH0+KDAuMCkpYCkpfSxpdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiU2lnbW9pZFwiLHQ9PmAoMS4wIC8gKDEuMCArIGV4cCgtJHt0fSkpKWApKX0sYXU9ZT0+ZWUoZSksc3U9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiSGFyZFNpZ21vaWRcIixuPT5gbWF4KHZlYzQ8JHtyfT4oMC4wKSwgbWluKHZlYzQ8JHtyfT4oMS4wKSwgJHt0LmFscGhhfSAqICR7bn0gKyB2ZWM0PCR7cn0+KCR7dC5iZXRhfSkpKWAsdm9pZCAwLHQuY2FjaGVLZXkpKX0sdXU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlNpblwiLFwic2luXCIpKX0sZHU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlNpbmhcIixcInNpbmhcIikpfSxsdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiU3FydFwiLFwic3FydFwiKSl9LGN1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJUYW5cIixcInRhblwiKSl9LHB1PWU9PmBzaWduKCR7ZX0pICogKDEgLSBleHAoLTIgKiBhYnMoJHtlfSkpKSAvICgxICsgZXhwKC0yICogYWJzKCR7ZX0pKSlgLG11PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJUYW5oXCIscHUpKX0scG89KGU9XCJmMzJcIik9PmBcbmNvbnN0IGZhc3RfZ2VsdV9hOiAke2V9ID0gMC41O1xuY29uc3QgZmFzdF9nZWx1X2I6ICR7ZX0gPSAwLjc5Nzg4NDU2MDgwMjg2NTQ7XG5jb25zdCBmYXN0X2dlbHVfYzogJHtlfSA9IDAuMDM1Njc3NDA4MTM2MzAwMTI1O1xuXG5mbiB0YW5oX3YodjogdmVjNDwke2V9PikgLT4gdmVjNDwke2V9PiB7XG4gIHJldHVybiAke3B1KFwidlwiKX07XG59XG5gLG1vPWU9PmAoZmFzdF9nZWx1X2EgKyBmYXN0X2dlbHVfYSAqIHRhbmhfdigke2V9ICogKGZhc3RfZ2VsdV9jICogJHtlfSAqICR7ZX0gKyBmYXN0X2dlbHVfYikpKSAqICR7ZX1gLGZ1PWU9PntsZXQgdD1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiRmFzdEdlbHVcIixtbyxwbyh0KSx2b2lkIDAsZS5pbnB1dHNbMF0uZGF0YVR5cGUpKX0saHU9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7cmV0dXJuIGUuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlRocmVzaG9sZGVkUmVsdVwiLG49PmBzZWxlY3QodmVjNDwke3J9PigwLjApLCAke259LCAke259ID4gdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8pYCxgY29uc3QgdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8gPSB2ZWM0PCR7cn0+KCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpLDB9LGd1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJMb2dcIixcImxvZ1wiKSl9LEttPShlLHQpPT5gXG5jb25zdCBhbHBoYSA9IHZlYzQ8JHtlfT4oJHt0fSk7XG5jb25zdCBvbmUgPSAke2V9KDEuMCk7XG5jb25zdCB6ZXJvID0gJHtlfSgwLjApO1xuXG5mbiBxdWlja19nZWx1X2ltcGwoeDogdmVjNDwke2V9PikgLT4gdmVjNDwke2V9PiB7XG4gIGxldCB2ID0geCAqYWxwaGE7XG4gIHZhciB4MSA6IHZlYzQ8JHtlfT47XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSA9IGkgKyAxKSB7XG4gICAgaWYgKHZbaV0gPj0gemVybykge1xuICAgICAgeDFbaV0gPSBvbmUgLyAob25lICsgZXhwKC12W2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHgxW2ldID0gb25lIC0gb25lIC8gKG9uZSArIGV4cCh2W2ldKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB4ICogeDE7XG59XG5gLGptPWU9PmBxdWlja19nZWx1X2ltcGwoJHtlfSlgLGJ1PShlLHQpPT57bGV0IHI9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlF1aWNrR2VsdVwiLGptLEttKHIsdC5hbHBoYSksdC5jYWNoZUtleSxlLmlucHV0c1swXS5kYXRhVHlwZSkpfX0pO3ZhciBZbSxabSxfdSx3dT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bmUoKTthZSgpO3FyKCk7WW09ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzI1NjAsNTEyMCwxMDI0MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJoaWRkZW4gc3RhdGUgc2hvdWxkIGJlIDI1NjAsIDUxMjAgb3IgMTAyNDBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sWm09ZT0+e2xldCB0PWVbMF0uZGltcy5zbGljZSgpO3RbMl09dFsyXS8yO2xldCByPUUoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLDQpLG49RShcImJpYXNcIixlWzBdLmRhdGFUeXBlLFtlWzBdLmRpbXNbMl1dLDQpLG89TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdCw0KSxpPWsuc2l6ZSh0KS80LGE9eWUoZVswXS5kYXRhVHlwZSk7cmV0dXJue25hbWU6XCJCaWFzU3BsaXRHZWx1XCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChpLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6bD0+YFxuICBjb25zdCBNX1NRUlQyID0gc3FydCgyLjApO1xuICBjb25zdCBoYWxmQ2hhbm5lbHMgPSAke2VbMF0uZGltc1syXS80LzJ9dTtcblxuICAke2wuZGVjbGFyZVZhcmlhYmxlcyhyLG4sbyl9XG5cbiAgJHtGcihhKX1cblxuICAke2wubWFpblN0YXJ0KCl9XG4gICAgJHtsLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoaSl9XG4gICAgbGV0IGJpYXNJZHggPSBnbG9iYWxfaWR4ICUgaGFsZkNoYW5uZWxzO1xuICAgIGxldCBiYXRjaEluZGV4ID0gZ2xvYmFsX2lkeCAvIGhhbGZDaGFubmVscztcbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiaWFzSWR4ICsgYmF0Y2hJbmRleCAqIGhhbGZDaGFubmVscyAqIDI7XG4gICAgbGV0IHZhbHVlTGVmdCA9IGlucHV0W2lucHV0T2Zmc2V0XSArIGJpYXNbYmlhc0lkeF07XG4gICAgbGV0IHZhbHVlUmlnaHQgPSBpbnB1dFtpbnB1dE9mZnNldCArIGhhbGZDaGFubmVsc10gKyBiaWFzW2JpYXNJZHggKyBoYWxmQ2hhbm5lbHNdO1xuICAgIGxldCBnZWx1UmlnaHQgPSB2YWx1ZVJpZ2h0ICogMC41ICogKGVyZl92ZjMyKHZhbHVlUmlnaHQgLyBNX1NRUlQyKSArIDEpO1xuXG4gICAgJHtvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVMZWZ0ICogZ2VsdVJpZ2h0XCIpfVxuICB9YH19LF91PWU9PntZbShlLmlucHV0cyksZS5jb21wdXRlKFptKGUuaW5wdXRzKSl9fSk7dmFyIFFtLFhtLGF0LHZ1LCR1LHh1LFN1LFR1LEl1LEN1LEF1LGt1LEV1LFB1PVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO1FtPShlLHQscixuLG8saSxhLGQsbCxwLG0sdSk9PntsZXQgaCxfO3R5cGVvZiBkPT1cInN0cmluZ1wiP2g9Xz0odixTKT0+YCR7ZH0oKCR7dn0pLCgke1N9KSlgOnR5cGVvZiBkPT1cImZ1bmN0aW9uXCI/aD1fPWQ6KGg9ZC5zY2FsYXIsXz1kLnZlY3Rvcik7bGV0IHk9TShcIm91dHB1dERhdGFcIixtLG4ubGVuZ3RoLDQpLGc9RShcImFEYXRhXCIsbCx0Lmxlbmd0aCw0KSx4PUUoXCJiRGF0YVwiLHAsci5sZW5ndGgsNCksJDtpZihvKWlmKGkpe2xldCB2PWsuc2l6ZSh0KT09PTEsUz1rLnNpemUocik9PT0xLFQ9dC5sZW5ndGg+MCYmdFt0Lmxlbmd0aC0xXSU0PT09MCxBPXIubGVuZ3RoPjAmJnJbci5sZW5ndGgtMV0lND09PTA7dnx8Uz8kPXkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyh2P2Ake2cudHlwZS52YWx1ZX0oJHtnLmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOmcuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLFM/YCR7eC50eXBlLnZhbHVlfSgke3guZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6eC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTokPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHggKiA0dVwiKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7Zy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIix5KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9ICR7eC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIix5KX07XG4gICAgICAgICAgICAke3kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyhhfHxUP2cuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIik6YCR7Zy50eXBlLnZhbHVlfSgke2cuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIil9W29mZnNldEEgJSA0dV0pYCxhfHxBP3guZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIik6YCR7eC50eXBlLnZhbHVlfSgke3guZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIil9W29mZnNldEIgJSA0dV0pYCkpfVxuICAgICAgICAgIGB9ZWxzZSAkPXkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyhnLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSx4LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwibm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uXCIpO2xldCB2PShTLFQsQT1cIlwiKT0+e2xldCBDPWBhRGF0YVtpbmRleEEke1R9XVtjb21wb25lbnRBJHtUfV1gLFA9YGJEYXRhW2luZGV4QiR7VH1dW2NvbXBvbmVudEIke1R9XWA7cmV0dXJuYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke1R9ID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtUfXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7VH0gPSAke2cuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke1R9YCx5KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7VH0gPSAke3guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke1R9YCx5KX07XG4gICAgICAgICAgICBsZXQgaW5kZXhBJHtUfSA9IG9mZnNldEEke1R9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhCJHtUfSA9IG9mZnNldEIke1R9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7VH0gPSBvZmZzZXRBJHtUfSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke1R9ID0gb2Zmc2V0QiR7VH0gJSA0dTtcbiAgICAgICAgICAgICR7U31bJHtUfV0gPSAke0F9KCR7aChDLFApfSk7XG4gICAgICAgICAgYH07bT09PTk/JD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7dihcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOiQ9YFxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxuICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGcseCx5KX1cblxuICAgICAgICAke3U/P1wiXCJ9XG5cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAkeyR9XG4gICAgICB9YH0sWG09KGUsdCxyLG4sbyxpLGE9ci5kYXRhVHlwZSk9PntsZXQgZD1yLmRpbXMubWFwKGc9Pk51bWJlcihnKT8/MSksbD1uLmRpbXMubWFwKGc9Pk51bWJlcihnKT8/MSkscD0hay5hcmVFcXVhbChkLGwpLG09ZCx1PWsuc2l6ZShkKSxoPSExLF89ITEseT1bcF07aWYocCl7bGV0IGc9dHQuY2FsY1NoYXBlKGQsbCwhMSk7aWYoIWcpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bT1nLnNsaWNlKCksdT1rLnNpemUobSk7bGV0IHg9ay5zaXplKGQpPT09MSwkPWsuc2l6ZShsKT09PTEsdj1kLmxlbmd0aD4wJiZkW2QubGVuZ3RoLTFdJTQ9PT0wLFM9bC5sZW5ndGg+MCYmbFtsLmxlbmd0aC0xXSU0PT09MDt5LnB1c2goeCkseS5wdXNoKCQpLHkucHVzaCh2KSx5LnB1c2goUyk7bGV0IFQ9MTtmb3IobGV0IEE9MTtBPG0ubGVuZ3RoO0ErKyl7bGV0IEM9ZFtkLmxlbmd0aC1BXSxQPWxbbC5sZW5ndGgtQV07aWYoQz09PVApVCo9QztlbHNlIGJyZWFrfVQlND09PTA/KF89ITAsaD0hMCk6KHh8fCR8fHZ8fFMpJiYoaD0hMCl9ZWxzZSBoPSEwO3JldHVybiB5LnB1c2goaCkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDp0K3kubWFwKGc9PmcudG9TdHJpbmcoKSkuam9pbihcIl9cIiksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOmc9PlFtKGcsZCxsLG0saCxwLF8sbyxyLmRhdGFUeXBlLG4uZGF0YVR5cGUsYSxpKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoay5zaXplKG0pLzQpfSwuLi5OKGQsbCxtKV19KX19LGF0PShlLHQscixuLG8saSk9PntlLmNvbXB1dGUoWG0odCxvPz9cIlwiLGUuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLHIsbixpKSl9LHZ1PWU9PnthdChlLFwiQWRkXCIsKHQscik9PmAke3R9KyR7cn1gKX0sJHU9ZT0+e2F0KGUsXCJEaXZcIiwodCxyKT0+YCR7dH0vJHtyfWApfSx4dT1lPT57YXQoZSxcIkVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PT0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH09PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sU3U9ZT0+e2F0KGUsXCJNdWxcIiwodCxyKT0+YCR7dH0qJHtyfWApfSxUdT1lPT57bGV0IHQ9RShcImlucHV0XCIsZS5pbnB1dHNbMF0uZGF0YVR5cGUsZS5pbnB1dHNbMF0uZGltcykudHlwZS52YWx1ZTthdChlLFwiUG93XCIse3NjYWxhcjoobixvKT0+YHBvd19jdXN0b20oJHtufSwke299KWAsdmVjdG9yOihuLG8pPT5gcG93X3ZlY3Rvcl9jdXN0b20oJHtufSwke299KWB9LGBcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R9LCBiIDogJHt0fSkgLT4gJHt0fSB7XG4gICAgICBpZiAoYiA9PSAke3R9KDAuMCkpIHtcbiAgICAgICAgcmV0dXJuICR7dH0oMS4wKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dH0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xuICAgICAgICByZXR1cm4gJHt0fShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dH0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dH0oMi4wKSkpICE9IDEuMCkgKiAke3R9KCR7dD09PVwiaTMyXCI/XCJyb3VuZFwiOlwiXCJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xuICAgIH1cbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R9PiwgYiA6IHZlYzQ8JHt0fT4pIC0+IHZlYzQ8JHt0fT4ge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XG4gICAgICByZXR1cm4gdmVjNDwke3R9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XG4gICAgfVxuICAgICAgYCl9LEl1PWU9PnthdChlLFwiU3ViXCIsKHQscik9PmAke3R9LSR7cn1gKX0sQ3U9ZT0+e2F0KGUsXCJHcmVhdGVyXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PiR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT4ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LEF1PWU9PnthdChlLFwiTGVzc1wiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTwke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxrdT1lPT57YXQoZSxcIkdyZWF0ZXJPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9Pj0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH0+PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sRXU9ZT0+e2F0KGUsXCJMZXNzT3JFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTw9JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PD0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9fSk7dmFyIGVmLHRmLHJmLG5mLHp1LE91LER1PVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7ZWY9KGUsdCk9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtsZXQgcj0wLG49ZVtyXSxvPW4uZGF0YVR5cGUsaT1uLmRpbXMubGVuZ3RoO2UuZm9yRWFjaCgoYSxkKT0+e2lmKGQhPT1yKXtpZihhLmRhdGFUeXBlIT09byl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihhLmRpbXMubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpO2EuZGltcy5mb3JFYWNoKChsLHApPT57aWYocCE9PXQmJmwhPT1uLmRpbXNbcF0pdGhyb3cgbmV3IEVycm9yKFwibm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2hcIil9KX19KX0sdGY9KGUsdCk9PmBcbiAgZm4gY2FsY3VsYXRlSW5wdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke2V9dT4oJHt0fSk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9OyBpICs9IDF1ICkge1xuICAgICAgaWYgKGluZGV4IDwgc2l6ZUluQ29uY2F0QXhpc1tpXSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7ZX11O1xuICB9YCxyZj0oZSx0KT0+e2xldCByPWUubGVuZ3RoLG49W107Zm9yKGxldCBvPTA7bzxyOysrbyl7bGV0IGk9dC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixlW29dLmdldEJ5SW5kaWNlcyhcImluZGljZXNcIikpO3I9PT0xP24ucHVzaChpKTpvPT09MD9uLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7b311KSB7ICR7aX0gfWApOm89PT1yLTE/bi5wdXNoKGBlbHNlIHsgJHtpfSB9YCk6bi5wdXNoKGBlbHNlIGlmIChpbnB1dEluZGV4ID09ICR7b30pIHsgJHtpfSB9YCl9cmV0dXJuIG4uam9pbihgXG5gKX0sbmY9KGUsdCxyLG4pPT57bGV0IG89ay5zaXplKHIpLGk9bmV3IEFycmF5KGUubGVuZ3RoKSxhPW5ldyBBcnJheShlLmxlbmd0aCksZD0wLGw9W10scD1bXSxtPVt7dHlwZToxMixkYXRhOm99XTtmb3IobGV0IGc9MDtnPGUubGVuZ3RoOysrZylkKz1lW2ddLmRpbXNbdF0saVtnXT1kLHAucHVzaChlW2ddLmRpbXMubGVuZ3RoKSxhW2ddPUUoYGlucHV0JHtnfWAsbixwW2ddKSxsLnB1c2goXCJyYW5rXCIpLG0ucHVzaCh7dHlwZToxMixkYXRhOmlbZ119KTtmb3IobGV0IGc9MDtnPGUubGVuZ3RoOysrZyltLnB1c2goLi4uTihlW2ddLmRpbXMpKTttLnB1c2goLi4uTihyKSk7bGV0IHU9TShcIm91dHB1dFwiLG4sci5sZW5ndGgpLGg9dS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLHQpLF89QXJyYXkuZnJvbShBcnJheShpLmxlbmd0aCkua2V5cygpKS5tYXAoZz0+YHVuaWZvcm1zLnNpemVJbkNvbmNhdEF4aXMke2d9YCkuam9pbihcIixcIikseT1nPT5gXG5cbiAgJHsoKCk9PntnLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKTtmb3IobGV0IHg9MDt4PGUubGVuZ3RoO3grKylnLnJlZ2lzdGVyVW5pZm9ybShgc2l6ZUluQ29uY2F0QXhpcyR7eH1gLFwidTMyXCIpO3JldHVybiBnLmRlY2xhcmVWYXJpYWJsZXMoLi4uYSx1KX0pKCl9XG5cbiAgJHt0ZihpLmxlbmd0aCxfKX1cblxuICAke2cubWFpblN0YXJ0KCl9XG4gICAgJHtnLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuXG4gICAgdmFyIGluZGljZXMgPSAke3Uub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICBsZXQgaW5wdXRJbmRleCA9IGNhbGN1bGF0ZUlucHV0SW5kZXgoJHtofSk7XG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcbiAgICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke2kubGVuZ3RofXU+KCR7X30pO1xuICAgICAgJHtofSAtPSBzaXplSW5Db25jYXRBeGlzW2lucHV0SW5kZXggLSAxdV07XG4gICAgfVxuXG4gICAgJHtyZihhLHUpfVxuICB9YDtyZXR1cm57bmFtZTpcIkNvbmNhdFwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YCxpbnB1dERlcGVuZGVuY2llczpsfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6bn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pLGdldFNoYWRlclNvdXJjZTp5fX0senU9KGUsdCk9PntsZXQgcj1lLmlucHV0cyxuPXJbMF0uZGltcyxvPWsubm9ybWFsaXplQXhpcyh0LmF4aXMsbi5sZW5ndGgpO2VmKHIsbyk7bGV0IGk9bi5zbGljZSgpO2lbb109ci5yZWR1Y2UoKGQsbCk9PmQrKGwuZGltcy5sZW5ndGg+bz9sLmRpbXNbb106MCksMCk7bGV0IGE9ci5maWx0ZXIoZD0+ay5zaXplKGQuZGltcyk+MCk7ZS5jb21wdXRlKG5mKGEsbyxpLHJbMF0uZGF0YVR5cGUpLHtpbnB1dHM6YX0pfSxPdT1lPT5lZSh7YXhpczplLmF4aXN9KX0pO3ZhciBLZSxqZSxZZSxLcix5dD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7S2U9KGUsdCxyPVwiZjMyXCIpPT57c3dpdGNoKGUuYWN0aXZhdGlvbil7Y2FzZVwiUmVsdVwiOnJldHVybmB2YWx1ZSA9IG1heCh2YWx1ZSwgJHt0fSgwLjApKTtgO2Nhc2VcIlNpZ21vaWRcIjpyZXR1cm5gdmFsdWUgPSAoJHt0fSgxLjApIC8gKCR7dH0oMS4wKSArIGV4cCgtdmFsdWUpKSk7YDtjYXNlXCJDbGlwXCI6cmV0dXJuYHZhbHVlID0gY2xhbXAodmFsdWUsICR7dH0oJHtyfSh1bmlmb3Jtcy5jbGlwX21pbikpLCAke3R9KCR7cn0odW5pZm9ybXMuY2xpcF9tYXgpKSk7YDtjYXNlXCJIYXJkU2lnbW9pZFwiOnJldHVybmB2YWx1ZSA9IG1heCgke3R9KDAuMCksIG1pbigke3R9KDEuMCksICR7cn0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUgKyAke3J9KHVuaWZvcm1zLmJldGEpKSk7YDtjYXNlXCJMZWFreVJlbHVcIjpyZXR1cm5gdmFsdWUgPSBzZWxlY3QoJHtyfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSwgdmFsdWUsIHZhbHVlID49ICR7dH0oMC4wKSk7YDtjYXNlXCJUYW5oXCI6cmV0dXJuYGxldCBlMnggPSBleHAoLTIuMCAqIGFicyh2YWx1ZSkpO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHNpZ24odmFsdWUpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcbiAgICAgICAgYDtjYXNlXCJcIjpyZXR1cm5cIlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhY3RpdmF0aW9uICR7ZS5hY3RpdmF0aW9ufWApfX0samU9KGUsdCk9PntlLmFjdGl2YXRpb249PT1cIkNsaXBcIj90LnB1c2goe3R5cGU6MSxkYXRhOmUuY2xpcE1heH0se3R5cGU6MSxkYXRhOmUuY2xpcE1pbn0pOmUuYWN0aXZhdGlvbj09PVwiSGFyZFNpZ21vaWRcIj90LnB1c2goe3R5cGU6MSxkYXRhOmUuYWxwaGF9LHt0eXBlOjEsZGF0YTplLmJldGF9KTplLmFjdGl2YXRpb249PT1cIkxlYWt5UmVsdVwiJiZ0LnB1c2goe3R5cGU6MSxkYXRhOmUuYWxwaGF9KX0sWWU9KGUsdCk9PntlLmFjdGl2YXRpb249PT1cIkNsaXBcIj90LnB1c2goe25hbWU6XCJjbGlwX21heFwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJjbGlwX21pblwiLHR5cGU6XCJmMzJcIn0pOmUuYWN0aXZhdGlvbj09PVwiSGFyZFNpZ21vaWRcIj90LnB1c2goe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifSk6ZS5hY3RpdmF0aW9uPT09XCJMZWFreVJlbHVcIiYmdC5wdXNoKHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9KX0sS3I9ZT0+e2xldCB0PWU/LmFjdGl2YXRpb258fFwiXCI7aWYodD09PVwiSGFyZFNpZ21vaWRcIil7bGV0W3Isbl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFsuMiwuNV07cmV0dXJue2FjdGl2YXRpb246dCxhbHBoYTpyLGJldGE6bn19ZWxzZSBpZih0PT09XCJDbGlwXCIpe2xldFtyLG5dPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbSmEsZXNdO3JldHVybnthY3RpdmF0aW9uOnQsY2xpcE1heDpuLGNsaXBNaW46cn19ZWxzZSBpZih0PT09XCJMZWFreVJlbHVcIil7bGV0W3JdPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbLjAxXTtyZXR1cm57YWN0aXZhdGlvbjp0LGFscGhhOnJ9fXJldHVybnthY3RpdmF0aW9uOnR9fX0pO3ZhciBBZSxCdSxqcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7QWU9KGUsdCk9Pntzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm5gdmVjMjwke3R9PmA7Y2FzZSAzOnJldHVybmB2ZWMzPCR7dH0+YDtjYXNlIDQ6cmV0dXJuYHZlYzQ8JHt0fT5gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2V9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0sQnU9ZT0+YFxuICAgICAgJHtlP1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpO1wiOlwiXCJ9XG4gICAgICBgfSk7dmFyIE11LFJ1PVUoKCk9PntcInVzZSBzdHJpY3RcIjtNdT1lPT5gXG5mbiBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMgOiB2ZWM0PGkzMj4sIHNoYXBlIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgICAgc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS56ICogc2hhcGUudywgc2hhcGUudywgMSkpO1xufVxuZm4gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICBpMzIoJHtlfS54KSwgaTMyKCR7ZX0ueSksIGkzMigke2V9LnopLCAxKSk7XG59XG5gfSk7dmFyIFh0LFlyLFpyPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO3l0KCk7WHQ9KGUsdCxyLG4sbyk9PntsZXQgaT1uLXI7cmV0dXJuYFxuICAgICAgJHtBcnJheS5mcm9tKHtsZW5ndGg6cn0pLm1hcCgoYSxkKT0+YFxuICAgICAgaWYgKCR7cSh0LnNoYXBlLGQsdC5yYW5rKX0gIT0gMSkge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGQscShvLGQraSxuKSl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGQsMCl9XG4gICAgICB9YCkuam9pbihcIlwiKX1cbmB9LFlyPShlLHQscixuLG89ITEsaSk9PntsZXQgYT1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD1hW2EubGVuZ3RoLTJdLHA9ZFtkLmxlbmd0aC0xXSxtPWFbYS5sZW5ndGgtMV0sdT1tZShwKSxoPW1lKG0pLF89bWUobCkseT1rLnNpemUocikvdS9fLGc9ZS5sZW5ndGg+Mix4PW4/bi5zbGljZSgwLC0yKTpyLnNsaWNlKDAsLTIpLHY9W2suc2l6ZSh4KSxsLHBdLFM9W3t0eXBlOjEyLGRhdGE6eX0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6bX1dO2plKHQsUyksUy5wdXNoKC4uLk4oeCxhLGQpKSxnJiZTLnB1c2goLi4uTihlWzJdLmRpbXMpKSxTLnB1c2goLi4uTih2KSk7bGV0IFQ9QT0+e2xldCBDPVdyKFwiYmF0Y2hfZGltc1wiLGVbMF0uZGF0YVR5cGUseC5sZW5ndGgpLFA9RShcImFcIixlWzBdLmRhdGFUeXBlLGEubGVuZ3RoLGgpLEQ9RShcImJcIixlWzFdLmRhdGFUeXBlLGQubGVuZ3RoLHUpLFI9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdi5sZW5ndGgsdSksSD15ZShSLnR5cGUudGVuc29yKSxMPUtlKHQsUi50eXBlLnZhbHVlLEgpLHJlPVtQLERdLFY9XCJcIjtpZihnKXtsZXQgaj1vP3U6MTtyZS5wdXNoKEUoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLGopKSxWPWAke28/YHZhbHVlICs9IGJpYXNbY29sIC8gJHtqfV07YDpgdmFsdWUgKz0gJHtSLnR5cGUudmFsdWV9KGJpYXNbcm93ICsgaV0pO2B9YH1sZXQgSz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn1dO1llKHQsSyk7bGV0IHdlPSgpPT57bGV0IGo9YHZhciBhX2RhdGE6ICR7UC50eXBlLnZhbHVlfTtgO2ZvcihsZXQgUT0wO1E8aDtRKyspais9YFxuICAgICAgICAgICAgICBsZXQgYl9kYXRhJHtRfSA9IGJbKGJfb2Zmc2V0ICsgKGsgKyAke1F9KSAqIHVuaWZvcm1zLk4gKyBjb2wpIC8gJHt1fV07YDtmb3IobGV0IFE9MDtRPF87USsrKXtqKz1gYV9kYXRhID0gYVsoYV9vZmZzZXQgKyAocm93ICsgJHtRfSkgKiB1bmlmb3Jtcy5LICsgaykgLyAke2h9XTtgO2ZvcihsZXQgaWU9MDtpZTxoO2llKyspais9YFxuICAgICAgICAgICAgdmFsdWVzWyR7UX1dID0gZm1hKCR7RC50eXBlLnZhbHVlfShhX2RhdGEke2g9PT0xP1wiXCI6YFske2llfV1gfSksIGJfZGF0YSR7aWV9LCB2YWx1ZXNbJHtRfV0pO1xuYH1yZXR1cm4gan07cmV0dXJuYFxuICAke0EucmVnaXN0ZXJVbmlmb3JtcyhLKS5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKEMpLmRlY2xhcmVWYXJpYWJsZXMoLi4ucmUsUil9XG4gICR7QS5tYWluU3RhcnQoKX1cbiAgICAke0EuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBjb2wgPSAoZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5OIC8gJHt1fSkpICogJHt1fTtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5OIC8gJHt1fSk7XG4gICAgbGV0IHN0cmlkZTEgPSB1bmlmb3Jtcy5NIC8gJHtffTtcbiAgICBsZXQgcm93ID0gKGluZGV4MSAlIHN0cmlkZTEpICogJHtffTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyBzdHJpZGUxO1xuXG4gICAgJHtyLmxlbmd0aD09PTI/XCJcIjpgbGV0IGJhdGNoX2luZGljZXMgPSAke0Mub2Zmc2V0VG9JbmRpY2VzKFwiYmF0Y2hcIil9O2B9XG5cbiAgICB2YXIgYV9pbmRpY2VzOiAke1AudHlwZS5pbmRpY2VzfTtcbiAgICAke1h0KFwiYV9pbmRpY2VzXCIsUCxQLnJhbmstMixDLnJhbmssXCJiYXRjaF9pbmRpY2VzXCIpfVxuICAgICR7UC5pbmRpY2VzU2V0KFwiYV9pbmRpY2VzXCIsUC5yYW5rLTIsMCl9XG4gICAgJHtQLmluZGljZXNTZXQoXCJhX2luZGljZXNcIixQLnJhbmstMSwwKX1cbiAgICBsZXQgYV9vZmZzZXQgPSAke1AuaW5kaWNlc1RvT2Zmc2V0KFwiYV9pbmRpY2VzXCIpfTtcblxuICAgIHZhciBiX2luZGljZXM6ICR7RC50eXBlLmluZGljZXN9O1xuICAgICR7WHQoXCJiX2luZGljZXNcIixELEQucmFuay0yLEMucmFuayxcImJhdGNoX2luZGljZXNcIil9XG4gICAgJHtELmluZGljZXNTZXQoXCJiX2luZGljZXNcIixELnJhbmstMiwwKX1cbiAgICAke0QuaW5kaWNlc1NldChcImJfaW5kaWNlc1wiLEQucmFuay0xLDApfVxuICAgIGxldCBiX29mZnNldCA9ICR7RC5pbmRpY2VzVG9PZmZzZXQoXCJiX2luZGljZXNcIil9O1xuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7Ui50eXBlLnZhbHVlfSwgJHtffT47XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrID0gayArICR7aH0pIHtcbiAgICAgICR7d2UoKX1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtffXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtWfVxuICAgICAgJHtMfVxuICAgICAgbGV0IGN1cl9pbmRpY2VzID0gJHtSLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdyArIGksIGNvbCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gJHtSLmluZGljZXNUb09mZnNldChcImN1cl9pbmRpY2VzXCIpfTtcbiAgICAgICR7Ui5zZXRCeU9mZnNldChgb2Zmc2V0IC8gJHt1fWAsXCJ2YWx1ZVwiKX07XG4gICAgfVxuICB9XG4gIGB9O3JldHVybntuYW1lOlwiTWF0TXVsTmFpdmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmFjdGl2YXRpb259OyR7dX07JHtofTske199OyR7b31gLGlucHV0RGVwZW5kZW5jaWVzOmc/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmk/aShyKTpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlN9KSxnZXRTaGFkZXJTb3VyY2U6VH19fSk7dmFyIG9mLGFmLGZvLFV1LHNmLGhvLHVmLEp0LFFyPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO3l0KCk7WnIoKTtqcigpO29mPShlLHQpPT5lP2BcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgZ2xvYmFsUm93U3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgYDpgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGdsb2JhbFJvdyArIGlubmVyUm93LFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICBgLGFmPShlLHQpPT5lP2BcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xuICAgICAgICAke3Q9PT0zP1wiXCI6XCJsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddO1wifVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkMFtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQxW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZDJbaV0gKyBhY2NbaV07XG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkM1tpXSArIGFjY1tpXTtcIn1cbiAgICAgICAgfWA6YFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpXVtrXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQueCArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQueSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQueiArIGFjY1tpXTtcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQudyArIGFjY1tpXTtcIn1cbiAgICAgICAgfWAsZm89KGUsdCxyPVwiZjMyXCIsbixvPSExLGk9MzIsYT0hMSxkPTMyKT0+e2xldCBsPXRbMV0qZVsxXSxwPXRbMF0qZVswXSxtPW8/bDppLHU9bz9pOmwsaD1tL3RbMF0sXz1pL3RbMV07aWYoISgobyYmaD09PTQmJmVbMV09PT00fHwhbyYmKGg9PT0zfHxoPT09NCkpJiZtJXRbMF09PT0wJiZpJXRbMV09PT0wJiZlWzBdPT09NCkpdGhyb3cgbmV3IEVycm9yKGBJZiB0cmFuc3Bvc2VBICR7b30gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke2h9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7ZVsxXX0gbXVzdCBiZSA0LlxuICAgICAgT3RoZXJ3aXNlLCBpbm5lckVsZW1lbnRTaXplICR7aH0gbXVzdCBiZSAzIG9yIDQuXG4gIHRpbGVBV2lkdGggJHttfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfS4gdGlsZUlubmVyICR7aX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSAke3RbMV19LiBjb2xQZXJUaHJlYWQgJHtlWzBdfSBtdXN0IGJlIDQuYCk7cmV0dXJuYFxudmFyPHdvcmtncm91cD4gbW1fQXN1YjogYXJyYXk8YXJyYXk8dmVjJHtofTwke3J9PiwgJHttL2h9PiwgJHt1fT47XG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7cn0+LCAke3AvZVswXX0+LCAke2l9PjtcblxuY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcbmNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XG5jb25zdCBpbm5lckVsZW1lbnRTaXplID0gJHtofTtcbmNvbnN0IHRpbGVJbm5lciA9ICR7aX07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG5cbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICBsZXQgYmF0Y2ggPSAke2E/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XG4gICR7bj9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7bi5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7bH07XG5cbiAgbGV0IG51bV90aWxlcyA9ICR7YT9gJHtNYXRoLmNlaWwoZC9pKX1gOlwiKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcbiAgdmFyIGtTdGFydCA9ICR7YT9gaTMyKGdsb2JhbElkLnopICogJHtkfWA6XCIwXCJ9O1xuXG4gIHZhciBhY2M6IGFycmF5PHZlYzQ8JHtyfT4sIHJvd1BlclRocmVhZD47XG5cbiAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gIGxldCB0aWxlUm93QiA9IGxvY2FsUm93ICogJHtffTtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93ICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICAke29mKG8sbil9XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke199OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCwga1N0YXJ0ICsgaW5wdXRSb3csIGdsb2JhbENvbCR7bj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyIC8gaW5uZXJFbGVtZW50U2l6ZTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMiA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVt0aWxlQ29sXTtcbiAgICAgICAgICAke2g9PT0zP1wiXCI6XCJsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07XCJ9XG5cbiAgICAgICAgICAke2FmKG8saCl9XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgfVxuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCwgYWNjW2lubmVyUm93XSk7XG4gIH1cbn1gfSxVdT0oZSx0KT0+ZT9gXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgICAgIGA6YFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgICAgICBgLHNmPWU9PmU/XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJba11bdGlsZVJvdyArIGlubmVyUm93XTtcIjpcImxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaW5uZXJSb3ddW2tdO1wiLGhvPShlLHQscj1cImYzMlwiLG4sbz0hMSxpPTMyLGE9ITEsZD0zMixsPSExKT0+e2xldCBwPWVbMV0qdFsxXSxtPWVbMF0qdFswXSx1PW8/cDppLGg9bz9pOnA7aWYoIShoJXRbMV09PT0wJiZ1JXRbMF09PT0wJiZpJXRbMV09PT0wKSl0aHJvdyBuZXcgRXJyb3IoYHRpbGVBSGlnaHQgJHtofSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfSwgdGlsZUFXaWR0aCAke3V9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LCB0aWxlSW5uZXIgJHtpfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfWApO2xldCBfPWgvdFsxXSx5PXUvdFswXSxnPWkvdFsxXSx4PWw/YFxuICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7cH07XG4gICAgbGV0IGdsb2JhbENvbFN0YXJ0ID0gaTMyKHdvcmtncm91cElkLngpICogJHttfTtcblxuICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtofTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcbiAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke3V9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xuICAgICAgICAgICR7VXUobyxuKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke2l9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke219OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICBnbG9iYWxDb2xTdGFydCArIGlucHV0Q29sJHtuP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD47XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3RbMF19XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtvP2BtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XTtgOmBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XVtrXTtgfVxuICAgICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBsZXQgZ1JvdyA9IGdsb2JhbFJvd1N0YXJ0ICsgbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX07XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7dFswXX07XG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnUm93LCBnQ29sLCBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGA6YFxubGV0IHRpbGVSb3cgPSBpMzIobG9jYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5cbmxldCBnbG9iYWxSb3cgPSBpMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpICogY29sUGVyVGhyZWFkO1xubGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtwfTtcblxubGV0IHRpbGVSb3dBID0gaTMyKGxvY2FsSWQueSkgKiAke199O1xubGV0IHRpbGVDb2xBID0gaTMyKGxvY2FsSWQueCkgKiAke3l9O1xubGV0IHRpbGVSb3dCID0gaTMyKGxvY2FsSWQueSkgKiAke2d9O1xuLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG5mb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7X307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8ICR7eX07IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QSArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcbiAgICAgICR7VXUobyxuKX1cbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke2d9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbCArIGlubmVyQ29sO1xuICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICBnbG9iYWxDb2wgKyBpbm5lckNvbCR7bj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgIH1cbiAgfVxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+O1xuICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAke3NmKG8pfVxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG59XG5cbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wgKyBpbm5lckNvbCxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICB9XG59XG5gO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PCR7cn0sICR7dX0+LCAke2h9PjtcbiAgdmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PCR7cn0sICR7bX0+LCAke2l9PjtcbiAgY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcbiAgY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcbiAgY29uc3QgdGlsZUlubmVyID0gJHtpfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICAgIGxldCBiYXRjaCA9ICR7YT9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcbiAgICAke24/YGxldCBiYXRjaEluZGljZXMgPSAke24ub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxuICAgIGxldCBudW1fdGlsZXMgPSAke2E/YCR7TWF0aC5jZWlsKGQvaSl9YDpcIih1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XG4gICAgdmFyIGtTdGFydCA9ICR7YT9gaTMyKGdsb2JhbElkLnopICogJHtkfWA6XCIwXCJ9O1xuXG4gICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD4sIHJvd1BlclRocmVhZD47XG4gICAgJHt4fVxuICB9XG5gfSx1Zj0oZSx0LHIsbixvPSExKT0+e2xldFtpLGEsZCxsXT1uLHA9eWUoblswXS50eXBlLnRlbnNvcik7cmV0dXJuYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7aS50eXBlLmluZGljZXN9KSAtPiAke0FlKGUscCl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7QWUoZSxwKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpXG4gICAgICB7XG4gICAgICAgIHZhciBhSW5kaWNlczogJHthLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7WHQoXCJhSW5kaWNlc1wiLGEsYS5yYW5rLTIsaS5yYW5rLFwiYmF0Y2hJbmRpY2VzXCIpfVxuICAgICAgICAke2EuaW5kaWNlc1NldChcImFJbmRpY2VzXCIsYS5yYW5rLTIsXCJ1MzIocm93KVwiKX1cbiAgICAgICAgJHthLmluZGljZXNTZXQoXCJhSW5kaWNlc1wiLGEucmFuay0xLFwidTMyKGNvbEluKVwiKX1cbiAgICAgICAgdmFsdWUgPSAke2EuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7aS50eXBlLmluZGljZXN9KSAtPiAke0FlKGUscCl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7QWUoZSxwKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICAgIHZhciBiSW5kaWNlczogJHtkLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7WHQoXCJiSW5kaWNlc1wiLGQsZC5yYW5rLTIsaS5yYW5rLFwiYmF0Y2hJbmRpY2VzXCIpfVxuICAgICAgICAke2QuaW5kaWNlc1NldChcImJJbmRpY2VzXCIsZC5yYW5rLTIsXCJ1MzIocm93KVwiKX1cbiAgICAgICAgJHtkLmluZGljZXNTZXQoXCJiSW5kaWNlc1wiLGQucmFuay0xLFwidTMyKGNvbEluKVwiKX1cbiAgICAgICAgdmFsdWUgPSAke2QuZ2V0QnlJbmRpY2VzKFwiYkluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCB2YWx1ZUluOiAke0FlKGUscCl9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sSW4pO1xuICAgICAgICAke3Q/YHZhbHVlID0gdmFsdWUgKyAke28/XCJiaWFzW2NvbEluXVwiOmAke0FlKGUscCl9KGJpYXNbcm93XSlgfTtgOlwiXCJ9XG4gICAgICAgICR7cn1cbiAgICAgICAgJHtsLnNldEJ5SW5kaWNlcyhcInZlYzM8dTMyPihjb29yZHMpXCIsXCJ2YWx1ZVwiKX1cbiAgICAgIH1cbiAgICB9XG4gICAgYH0sSnQ9KGUsdCxyLG4sbz0hMSxpKT0+e2xldCBhPWVbMF0uZGltcyxkPWVbMV0uZGltcyxsPWEuc2xpY2UoMCwtMikscD1kLnNsaWNlKDAsLTIpLG09bj9uLnNsaWNlKDAsLTIpOnIuc2xpY2UoMCwtMiksdT1rLnNpemUobSksaD1hW2EubGVuZ3RoLTJdLF89YVthLmxlbmd0aC0xXSx5PWRbZC5sZW5ndGgtMV0sZz1fJTQ9PT0wJiZ5JTQ9PT0wLHg9aDw9OD9bNCwxLDFdOls0LDQsMV0sJD1bOCw4LDFdLHY9W01hdGguY2VpbCh5LyRbMF0veFswXSksTWF0aC5jZWlsKGgvJFsxXS94WzFdKSxNYXRoLmNlaWwodS8kWzJdL3hbMl0pXSxTPWc/NDoxLFQ9Wy4uLmwsaCxfL1NdLEE9VC5sZW5ndGgsQz1bLi4ucCxfLHkvU10sUD1DLmxlbmd0aCxEPVt1LGgseS9TXSxSPVt7dHlwZTo2LGRhdGE6aH0se3R5cGU6NixkYXRhOnl9LHt0eXBlOjYsZGF0YTpffV07amUodCxSKSxSLnB1c2goLi4uTihtLFQsQykpO2xldCBIPVtcInJhbmtcIixcInJhbmtcIl0sTD1lLmxlbmd0aD4yO0wmJihSLnB1c2goLi4uTihlWzJdLmRpbXMpKSxILnB1c2goXCJyYW5rXCIpKSxSLnB1c2goLi4uTihEKSk7bGV0IHJlPVY9PntsZXQgSz1tLmxlbmd0aCx3ZT1XcihcImJhdGNoRGltc1wiLGVbMF0uZGF0YVR5cGUsSywxKSxqPXllKGVbMF0uZGF0YVR5cGUpLFE9RShcImFcIixlWzBdLmRhdGFUeXBlLEEsUyksaWU9RShcImJcIixlWzFdLmRhdGFUeXBlLFAsUyksdGU9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsRC5sZW5ndGgsUyksYmU9W1EsaWVdO2lmKEwpe2xldCBZPW8/UzoxO2JlLnB1c2goRShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsWSkpfWxldCBPZT1be25hbWU6XCJkaW1fYV9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1fYl9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1faW5uZXJcIix0eXBlOlwiaTMyXCJ9XTtZZSh0LE9lKTtsZXQgdmU9eWUodGUudHlwZS50ZW5zb3IpLGRlPUtlKHQsdGUudHlwZS52YWx1ZSx2ZSksVz11ZihTLEwsZGUsW3dlLFEsaWUsdGVdLG8pO3JldHVybmBcbiAgJHtWLnJlZ2lzdGVyVW5pZm9ybXMoT2UpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMod2UpLmRlY2xhcmVWYXJpYWJsZXMoLi4uYmUsdGUpfVxuICAke1d9XG4gICR7Zz9mbyh4LCQsaix3ZSk6aG8oeCwkLGosd2UpfVxuICAgICAgICAgICAgICAgICAgIGB9O3JldHVybntuYW1lOlwiTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eH07JHt0LmFjdGl2YXRpb259OyR7Z307JHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6SH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppP2kocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDp2WzBdLHk6dlsxXSx6OnZbMl19LHByb2dyYW1Vbmlmb3JtczpSfSksZ2V0U2hhZGVyU291cmNlOnJlfX19KTt2YXIgZGYsTnUsVnU9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtldCgpO2FlKCk7eXQoKTtqcigpO1J1KCk7UXIoKTtkZj0oZSx0LHIsbixvPSExLGksYT00LGQ9NCxsPTQscD1cImYzMlwiKT0+e2xldCBtPUg9Pntzd2l0Y2goSCl7Y2FzZSAxOnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4XTtcIjtjYXNlIDM6cmV0dXJuYHJlc0RhdGEgPSB2ZWMzPCR7cH0+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtjYXNlIDQ6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXggLyA0XTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0h9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSx1PUg9Pntzd2l0Y2goSCl7Y2FzZSAxOnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pICsgY29sSW5dO1wiO2Nhc2UgNDpyZXR1cm5cInJldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSAvIDQgKyBjb2xJbl07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtIfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0saD1lP2BcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XG4gICAgYDpgXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIHhSb3csIHhDb2wpO1xuICAgIGAsXz1lP2BcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3csXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcbiAgICBgLHk9ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzFdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCIsZz1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVszXSlcIix4PWU/XCJyb3dcIjpcImNvbFwiLCQ9ZT9cImNvbFwiOlwicm93XCIsdj1gXG4gICAgbGV0IGluQ2hhbm5lbHMgPSBpMzIodW5pZm9ybXMud19zaGFwZVsyXSk7XG4gICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgIGxldCBvdXRSb3cgPSAke3h9IC8gb3V0V2lkdGg7XG4gICAgbGV0IG91dENvbCA9ICR7eH0gJSBvdXRXaWR0aDtcblxuICAgIGxldCBXUm93ID0gJHskfSAvIChpMzIodW5pZm9ybXMud19zaGFwZVsxXSkgKiBpbkNoYW5uZWxzKTtcbiAgICBsZXQgV0NvbCA9ICR7JH0gLyBpbkNoYW5uZWxzICUgaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pO1xuICAgIGxldCB4Um93ID0gb3V0Um93ICogdW5pZm9ybXMuc3RyaWRlWzBdICsgdW5pZm9ybXMuZGlsYXRpb25bMF0gKiBXUm93IC0gdW5pZm9ybXMucGFkWzBdO1xuICAgIGxldCB4Q29sID0gb3V0Q29sICogdW5pZm9ybXMuc3RyaWRlWzFdICsgdW5pZm9ybXMuZGlsYXRpb25bMV0gKiBXQ29sIC0gdW5pZm9ybXMucGFkWzFdO1xuICAgIGxldCB4Q2ggPSAkeyR9ICUgaW5DaGFubmVscztcbiAgICB2YXIgcmVzRGF0YSA9ICR7QWUoYSxwKX0oMC4wKTtcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7eX0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke2d9KSB7XG4gICAgICAke2h9XG4gICAgICBsZXQgeEluZGV4ID0gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy54X3NoYXBlKSk7XG4gICAgICAke20oYSl9XG4gICAgfVxuICAgIHJldHVybiByZXNEYXRhO2AsUz1lP3QmJm4/YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XG4gICAgJHt2fWA6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xuICAgICAgJHt2fVxuICAgIH1cbiAgICByZXR1cm4gJHtBZShhLHApfSgwLjApO2A6biYmcj9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICAke3Z9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAke3Z9XG4gICAgfVxuICAgIHJldHVybiAke0FlKGEscCl9KDAuMCk7YCxUPWU/biYmcj91KGQpOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7dShkKX1cbiAgICB9XG4gICAgcmV0dXJuICR7QWUoZCxwKX0oMC4wKTtgOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIpIHtcbiAgICAgICR7dShkKX1cbiAgICB9XG4gICAgcmV0dXJuICR7QWUoZCxwKX0oMC4wKTtgLEE9QWUobCxwKSxDPWU/QWUoYSxwKTpBZShkLHApLFA9ZT9BZShkLHApOkFlKGEscCksRD1LZShpLEEscCk7cmV0dXJuYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7Q30ge1xuICAgICAgJHtlP1M6VH1cbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke1B9IHtcbiAgICAgICR7ZT9UOlN9XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7QX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bH07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgICAgJHtffVxuICAgICAgJHtCdShvKX1cbiAgICAgICR7RH1cbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1gfSxOdT0oZSx0LHIsbixvLGksYSxkLGwpPT57bGV0IHA9dC5mb3JtYXQ9PT1cIk5IV0NcIixtPXA/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSx1PXJbMF0saD1wP3JbMl06clszXSxfPXA/clsxXTpyWzJdLHk9cD9yWzNdOnJbMV0sZz1wJiYobSU0PT09MHx8bSUzPT09MCkmJnklND09PTAseD1wP3k6aCpfLCQ9cD9oKl86eSx2PVs4LDgsMV0sUz1uPD04P1s0LDEsMV06WzQsNCwxXSxUPVtNYXRoLmNlaWwoeC92WzBdL1NbMF0pLE1hdGguY2VpbCgkL3ZbMV0vU1sxXSksTWF0aC5jZWlsKHUvdlsyXS9TWzJdKV07c2UoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke1R9YCk7bGV0IEE9Zz9wJiZtJTQhPT0wPzM6NDoxLEM9dlsxXSpTWzFdLFA9dlswXSpTWzBdLEQ9TWF0aC5tYXgodlswXSpBLHZbMV0pLFI9biVDPT09MCxIPW8lUD09PTAsTD1pJUQ9PT0wLHJlPWc/W0EsNCw0XTpbMSwxLDFdLFY9W3t0eXBlOjYsZGF0YTpufSx7dHlwZTo2LGRhdGE6b30se3R5cGU6NixkYXRhOml9LHt0eXBlOjYsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19LHt0eXBlOjYsZGF0YTp0LnN0cmlkZXN9LHt0eXBlOjYsZGF0YTp0LmRpbGF0aW9uc31dO2plKHQsViksVi5wdXNoKC4uLk4oZVswXS5kaW1zLGVbMV0uZGltcykpO2xldCBLPVtcInJhbmtcIixcInJhbmtcIl07YSYmKFYucHVzaCguLi5OKGVbMl0uZGltcykpLEsucHVzaChcInJhbmtcIikpLFYucHVzaCguLi5OKHIpKTtsZXQgd2U9aj0+e2xldCBRPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJwYWRcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwic3RyaWRlXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcImRpbGF0aW9uXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07WWUodCxRKTtsZXQgaWU9Zz80OjEsdGU9eWUoZVswXS5kYXRhVHlwZSksYmU9YFxuICAgICAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogJHtnP2B2ZWM0PCR7dGV9PmA6dGV9KSB7XG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtnP2B2ZWM0PCR7dGV9PmA6dGV9KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7Zz9gdmVjNDwke3RlfT5gOnRlfSkge1xuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAke2c/XCIvIDRcIjpcIlwifSwgdmFsdWUpO1xuICAgICAgfWAsT2U9RShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsQT09PTM/MTpBKSx2ZT1FKFwid1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxpZSksZGU9W09lLHZlXSxXPU0oXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoLGllKTtpZihhKXtsZXQgWT1FKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxpZSk7ZGUucHVzaChZKSxiZSs9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke2c/YHZlYzQ8JHt0ZX0+YDp0ZX0ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke3A/XCJ3XCI6XCJ5XCJ9JHtnP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1yZXR1cm5gXG4gICAgICAgICR7TXUoXCJ1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlc1wiKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7ai5yZWdpc3RlclVuaWZvcm1zKFEpLmRlY2xhcmVWYXJpYWJsZXMoLi4uZGUsVyl9XG4gICAgICAgICR7YmV9XG4gICAgICAgICR7ZGYocCxSLEgsTCxhLHQscmVbMF0scmVbMV0scmVbMl0sdGUpfVxuICAgICAgICAke2c/Zm8oUyx2LHRlLHZvaWQgMCwhcCxEKTpobyhTLHYsdGUsdm9pZCAwLCFwLEQsITEsdm9pZCAwLGQpfWB9O3JldHVybntuYW1lOlwiQ29udjJETWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtBfTske2d9OyR7Un07JHtIfTske0x9OyR7Q307JHtQfTske0R9YCxpbnB1dERlcGVuZGVuY2llczpLfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmw/bChyKTpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OlRbMF0seTpUWzFdLHo6VFsyXX0scHJvZ3JhbVVuaWZvcm1zOlZ9KSxnZXRTaGFkZXJTb3VyY2U6d2V9fX0pO3ZhciBsZixXdSxYcixjZixMdSxwZixHdSxIdSxGdT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO2V0KCk7bmUoKTthZSgpO3l0KCk7anIoKTtsZj1lPT57bGV0IHQ9MTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl0Kj1lW3JdO3JldHVybiB0fSxXdT1lPT50eXBlb2YgZT09XCJudW1iZXJcIj9bZSxlLGVdOmUsWHI9KGUsdCk9PnQ8PTE/ZTplKyhlLTEpKih0LTEpLGNmPShlLHQscixuPTEpPT57bGV0IG89WHIodCxuKTtyZXR1cm4gTWF0aC5mbG9vcigoZVswXSooci0xKS1yK28pLzIpfSxMdT0oZSx0LHIsbixvKT0+e289PW51bGwmJihvPWNmKGUsdFswXSxuWzBdKSk7bGV0IGk9WzAsMCwwLHJdO2ZvcihsZXQgYT0wO2E8MzthKyspZVthXSsyKm8+PXRbYV0mJihpW2FdPU1hdGgudHJ1bmMoKGVbYV0tdFthXSsyKm8pL25bYV0rMSkpO3JldHVybiBpfSxwZj0oZSx0LHIsbixvLGksYSxkLGwscCk9PntsZXQgbSx1LGgsXztpZihlPT09XCJWQUxJRFwiJiYoZT0wKSx0eXBlb2YgZT09XCJudW1iZXJcIil7bT17dG9wOmUsYm90dG9tOmUsbGVmdDplLHJpZ2h0OmUsZnJvbnQ6ZSxiYWNrOmV9O2xldCB5PUx1KFt0LHIsbiwxXSxbZCxsLHBdLDEsW28saSxhXSxlKTt1PXlbMF0saD15WzFdLF89eVsyXX1lbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpe2lmKCFlLmV2ZXJ5KChnLHgsJCk9Pmc9PT0kWzBdKSl0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFkZGluZyBwYXJhbWV0ZXI6ICR7ZX1gKTttPXt0b3A6ZVswXSxib3R0b206ZVsxXSxsZWZ0OmVbMl0scmlnaHQ6ZVszXSxmcm9udDplWzRdLGJhY2s6ZVs1XX07bGV0IHk9THUoW3QscixuLDFdLFtkLGwscF0sMSxbbyxpLGFdLGVbMF0pO3U9eVswXSxoPXlbMV0sXz15WzJdfWVsc2UgaWYoZT09PVwiU0FNRV9VUFBFUlwiKXt1PU1hdGguY2VpbCh0L28pLGg9TWF0aC5jZWlsKHIvaSksXz1NYXRoLmNlaWwobi9hKTtsZXQgeT0odS0xKSpvK2QtdCxnPShoLTEpKmkrbC1yLHg9KF8tMSkqYStwLW4sJD1NYXRoLmZsb29yKHkvMiksdj15LSQsUz1NYXRoLmZsb29yKGcvMiksVD1nLVMsQT1NYXRoLmZsb29yKHgvMiksQz14LUE7bT17dG9wOlMsYm90dG9tOlQsbGVmdDpBLHJpZ2h0OkMsZnJvbnQ6JCxiYWNrOnZ9fWVsc2UgdGhyb3cgRXJyb3IoYFVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6ICR7ZX1gKTtyZXR1cm57cGFkSW5mbzptLG91dERlcHRoOnUsb3V0SGVpZ2h0Omgsb3V0V2lkdGg6X319LEd1PShlLHQscixuLG8saT0hMSxhPVwiY2hhbm5lbHNMYXN0XCIpPT57bGV0IGQsbCxwLG0sdTtpZihhPT09XCJjaGFubmVsc0xhc3RcIilbZCxsLHAsbSx1XT1lO2Vsc2UgaWYoYT09PVwiY2hhbm5lbHNGaXJzdFwiKVtkLHUsbCxwLG1dPWU7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YUZvcm1hdCAke2F9YCk7bGV0W2gsLF8seSxnXT10LFt4LCQsdl09V3UociksW1MsVCxBXT1XdShuKSxDPVhyKF8sUyksUD1Ycih5LFQpLEQ9WHIoZyxBKSx7cGFkSW5mbzpSLG91dERlcHRoOkgsb3V0SGVpZ2h0Okwsb3V0V2lkdGg6cmV9PXBmKG8sbCxwLG0seCwkLHYsQyxQLEQpLFY9aT9oKnU6aCxLPVswLDAsMCwwLDBdO3JldHVybiBhPT09XCJjaGFubmVsc0ZpcnN0XCI/Sz1bZCxWLEgsTCxyZV06YT09PVwiY2hhbm5lbHNMYXN0XCImJihLPVtkLEgsTCxyZSxWXSkse2JhdGNoU2l6ZTpkLGRhdGFGb3JtYXQ6YSxpbkRlcHRoOmwsaW5IZWlnaHQ6cCxpbldpZHRoOm0saW5DaGFubmVsczp1LG91dERlcHRoOkgsb3V0SGVpZ2h0Okwsb3V0V2lkdGg6cmUsb3V0Q2hhbm5lbHM6VixwYWRJbmZvOlIsc3RyaWRlRGVwdGg6eCxzdHJpZGVIZWlnaHQ6JCxzdHJpZGVXaWR0aDp2LGZpbHRlckRlcHRoOl8sZmlsdGVySGVpZ2h0OnksZmlsdGVyV2lkdGg6ZyxlZmZlY3RpdmVGaWx0ZXJEZXB0aDpDLGVmZmVjdGl2ZUZpbHRlckhlaWdodDpQLGVmZmVjdGl2ZUZpbHRlcldpZHRoOkQsZGlsYXRpb25EZXB0aDpTLGRpbGF0aW9uSGVpZ2h0OlQsZGlsYXRpb25XaWR0aDpBLGluU2hhcGU6ZSxvdXRTaGFwZTpLLGZpbHRlclNoYXBlOnR9fSxIdT0oZSx0LHIsbixvLGkpPT57bGV0IGE9aT09PVwiY2hhbm5lbHNMYXN0XCIsZD1hP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sbD0hMSxwPVs2NCwxLDFdLG09e3g6ci5tYXAoKHYsUyk9PlMpfSx1PVtNYXRoLmNlaWwobGYobS54Lm1hcCh2PT5yW3ZdKSkvcFswXSksMSwxXTtzZShcInZlcmJvc2VcIiwoKT0+YFtjb252M2RfbmFpdmVfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7dX1gKTtsZXQgaD1sP2EmJmQlNCE9PTA/Mzo0OjEsXz1rLnNpemUocikseT1be3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTp0LnN0cmlkZXN9LHt0eXBlOjEyLGRhdGE6dC5kaWxhdGlvbnN9XTtqZSh0LHkpLHkucHVzaCguLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMpKTtsZXQgZz1bXCJyYW5rXCIsXCJyYW5rXCJdLHg9ZS5sZW5ndGg9PT0zO3gmJih5LnB1c2goLi4uTihlWzJdLmRpbXMpKSxnLnB1c2goXCJyYW5rXCIpKSx5LnB1c2goLi4uTihyKSk7bGV0ICQ9dj0+e2xldCBTPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpuLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5kaWxhdGlvbnMubGVuZ3RofV07WWUodCxTKTtsZXQgVD1sPzQ6MSxBPXllKGVbMF0uZGF0YVR5cGUpLEM9RShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsaD09PTM/MTpoKSxQPUUoXCJXXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLFQpLEQ9W0MsUF0sUj1NKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxyLmxlbmd0aCxUKSxIPVwiXCI7aWYoeCl7bGV0IFY9RShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsVCk7RC5wdXNoKFYpLEgrPWBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IGFycmF5PHUzMiwgNT4pIC0+ICR7bD9gdmVjNDwke0F9PmA6QX0ge1xuICAgICAgICAgIHJldHVybiBiaWFzWyR7YT9xKFwiY29vcmRzXCIsNCw1KTpxKFwiY29vcmRzXCIsMSw1KX0ke2w/XCIvIDRcIjpcIlwifV07XG4gICAgICAgIH1gfWxldCBMPUFlKGgsQSkscmU9S2UodCxMLEEpO3JldHVybmBcbiAgICAgICAgICAgICR7SH1cbiAgICAgICAgICAgIGZuIGdldFgoZDAgOiB1MzIsIGQxIDogdTMyLCBkMiA6IHUzMiwgZDMgOiB1MzIsIGQ0IDogdTMyKSAtPiBmMzIge1xuICAgICAgICAgICAgICBsZXQgYUluZGljZXMgPSBhcnJheTx1MzIsIDU+KGQwLCBkMSwgZDIsIGQzLCBkNCk7XG4gICAgICAgICAgICAgIHJldHVybiAke0MuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4gZ2V0VyhkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7UC5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgJHt2LnJlZ2lzdGVyVW5pZm9ybXMoUykuZGVjbGFyZVZhcmlhYmxlcyguLi5ELFIpfVxuICAgICAgICAgICR7di5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgICAgICBsZXQgY29vcmRzID0gJHtSLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICBsZXQgYmF0Y2ggPSAke3EoXCJjb29yZHNcIiwwLEMucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgZDIgPSAke2E/cShcImNvb3Jkc1wiLEMucmFuay0xLEMucmFuayk6cShcImNvb3Jkc1wiLDEsQy5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4RlJDQ29ybmVyID0gdmVjMzx1MzI+KCR7YT9xKFwiY29vcmRzXCIsMSxDLnJhbmspOnEoXCJjb29yZHNcIiwyLEMucmFuayl9LFxuICAgICAgICAgICAgICAke2E/cShcImNvb3Jkc1wiLDIsQy5yYW5rKTpxKFwiY29vcmRzXCIsMyxDLnJhbmspfSxcbiAgICAgICAgICAgICAgJHthP3EoXCJjb29yZHNcIiwzLEMucmFuayk6cShcImNvb3Jkc1wiLDQsQy5yYW5rKX0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICAgIGxldCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcbiAgICAgICAgICAgICAgbGV0IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xuICAgICAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVZID0gJHthP3EoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSxDLnJhbmspOnEoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMixDLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVogPSAke2E/cShcInVuaWZvcm1zLnhfc2hhcGVcIiwyLEMucmFuayk6cShcInVuaWZvcm1zLnhfc2hhcGVcIiwzLEMucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlVyA9ICR7YT9xKFwidW5pZm9ybXMueF9zaGFwZVwiLDMsQy5yYW5rKTpxKFwidW5pZm9ybXMueF9zaGFwZVwiLDQsQy5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVVID0gJHthP3EoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsNCxDLnJhbmspOnEoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSxDLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9ICh4U2hhcGVVIC8gNCkgKiA0O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSB4U2hhcGVVICUgNDtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHdGID0gMHU7IHdGIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdGKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeEYgPSB4RkNvcm5lciArIHdGICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0geFNoYXBlWSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwdTsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd1IrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IHhSID0geFJDb3JuZXIgKyB3UiAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0geFNoYXBlWikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwdTsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1syXTsgd0MrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeEMgPSB4Q0Nvcm5lciArIHdDICogdW5pZm9ybXMuZGlsYXRpb25zWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IHhTaGFwZVcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMHU7IGQxIDwgaW5wdXREZXB0aE5lYXJlc3RWZWM0OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHthP2BsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAzLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDIsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAzLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAke2E/YHZhbHVlICs9IGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2A6YHZhbHVlICs9IGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2B9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICR7YT9gbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke2E/YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMikpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHt4P1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpXCI6XCJcIn07XG4gICAgICAgICAgICAgICR7cmV9XG4gICAgICAgICAgICAgIHJlc3VsdFtnbG9iYWxfaWR4XSA9IGYzMih2YWx1ZSk7XG4gICAgICAgICAgfWB9O3JldHVybntuYW1lOlwiQ29udjNETmFpdmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske2F9OyR7aH07JHt4fWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OnVbMF0seTp1WzFdLHo6dVsyXX0scHJvZ3JhbVVuaWZvcm1zOnl9KSxnZXRTaGFkZXJTb3VyY2U6JH19fSk7dmFyIHF1LEt1LGp1PVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO3l0KCk7cXU9KGUsdCxyLG4pPT57bGV0IG89ZS5sZW5ndGg+MixpPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLGE9ZVswXS5kaW1zLGQ9ZVsxXS5kaW1zLGw9dC5mb3JtYXQ9PT1cIk5IV0NcIixwPWw/clszXTpyWzFdLG09cC90Lmdyb3VwLHU9bCYmbT49ND9tZShwKToxLGg9ay5zaXplKHIpL3UsXz1be3R5cGU6MTIsZGF0YTpofSx7dHlwZToxMixkYXRhOnQuZGlsYXRpb25zfSx7dHlwZToxMixkYXRhOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXX0se3R5cGU6MTIsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19LHt0eXBlOjEyLGRhdGE6bX1dO2plKHQsXyksXy5wdXNoKC4uLk4oYSxbZFswXSxkWzFdLGRbMl0sZFszXS91XSkpO2xldCB5PW8/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdO18ucHVzaCguLi5OKFtyWzBdLHJbMV0sclsyXSxyWzNdL3VdKSk7bGV0IGc9eD0+e2xldCAkPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoLHUpLHY9eWUoJC50eXBlLnRlbnNvciksUz1LZSh0LCQudHlwZS52YWx1ZSx2KSxUPUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCksQT1FKFwid1wiLGVbMV0uZGF0YVR5cGUsZC5sZW5ndGgsdSksQz1bVCxBXTtvJiZDLnB1c2goRShcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyx1KSk7bGV0IFA9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LmRpbGF0aW9ucy5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDoyfSx7bmFtZTpcIm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9XTtZZSh0LFApO2xldCBEPWw/YFxuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzBdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG5cbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdXaWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SW5DaGFubmVsKyspIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xuICAgICAgICAgICAgbGV0IHhWYWwgPSAke1QuZ2V0KFwiYmF0Y2hcIixcInhIZWlnaHRcIixcInhXaWR0aFwiLFwiaW5wdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7QS5nZXQoXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIixcIndJbkNoYW5uZWxcIixcIm91dHB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYDpgXG4gICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzNdOyB3V2lkdGgrKykge1xuICAgICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzNdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7VC5nZXQoXCJiYXRjaFwiLFwiaW5wdXRfY2hhbm5lbFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHtBLmdldChcIm91dHB1dF9jaGFubmVsXCIsXCJ3SW5DaGFubmVsXCIsXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIil9O1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgO3JldHVybmBcbiAgJHt4LnJlZ2lzdGVyVW5pZm9ybXMoUCkuZGVjbGFyZVZhcmlhYmxlcyguLi5DLCQpfVxuXG4gICR7eC5tYWluU3RhcnQoKX1cbiAgICAke3guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske2w/MzoxfV07XG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHtsPzE6Mn1dLCBvdXRwdXRJbmRpY2VzWyR7bD8yOjN9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsICogJHt1fSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgdmFyIGluX2NoYW5uZWxfb2Zmc2V0ID0gZ3JvdXBfaWQgKiB1bmlmb3Jtcy53X3NoYXBlWyR7bD8yOjF9XTtcblxuICAgIHZhciB2YWx1ZTogJHskLnR5cGUudmFsdWV9ID0gJHskLnR5cGUudmFsdWV9KDApO1xuICAgICR7RH1cbiAgICAke2l9XG4gICAgJHtTfVxuICAgICR7JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YH07cmV0dXJue25hbWU6XCJHcm91cGVkQ29udlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7dX1gLGlucHV0RGVwZW5kZW5jaWVzOnl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bj9uKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGgvNjQpfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTpnfX0sS3U9KGUsdCxyLG4pPT57bGV0IG89ZS5sZW5ndGg+MixpPW1lKHJbM10pLGE9bWUoclsyXSksZD1rLnNpemUocikvaS9hLGw9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVswXS5kaW1zWzJdLGVbMF0uZGltc1szXS9pXSxwPVtlWzFdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXSxlWzFdLmRpbXNbM10vaV0sbT1bclswXSxyWzFdLHJbMl0sclszXS9pXSx1PVt7dHlwZToxMixkYXRhOmR9LHt0eXBlOjYsZGF0YTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV19LHt0eXBlOjYsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19XTtqZSh0LHUpLHUucHVzaCguLi5OKGwscCxtKSk7bGV0IGg9KGEtMSkqdC5zdHJpZGVzWzFdK3BbMV0sXz15PT57bGV0IGc9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbS5sZW5ndGgsaSkseD15ZShnLnR5cGUudGVuc29yKSwkPUtlKHQsZy50eXBlLnZhbHVlLHgpLHY9RShcInhcIixlWzBdLmRhdGFUeXBlLGwubGVuZ3RoLGkpLFM9RShcIndcIixlWzFdLmRhdGFUeXBlLHAubGVuZ3RoLGkpLFQ9W3YsU107byYmVC5wdXNoKEUoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsaSkpO2xldCBBPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLEM9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07cmV0dXJuIFllKHQsQyksYFxuICAke3kucmVnaXN0ZXJVbmlmb3JtcyhDKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQsZyl9XG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCB3aWR0aDAgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbM107XG4gICAgbGV0IG91dHB1dF9jaGFubmVsID0gZ2xvYmFsX2lkeCAlIHdpZHRoMDtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvIHdpZHRoMDtcbiAgICBsZXQgd2lkdGgxID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdIC8gJHthfXU7XG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHthfXU7XG4gICAgaW5kZXgxID0gaW5kZXgxIC8gd2lkdGgxO1xuICAgIGxldCByb3cgPSBpbmRleDEgJSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdO1xuXG4gICAgbGV0IHhfY29ybmVyID0gdmVjMjxpMzI+KGkzMihyb3cpLCBpMzIoY29sKSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcblxuICAgIHZhciB4X3ZhbHM6IGFycmF5PCR7di50eXBlLnZhbHVlfSwgJHtofT47XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtnLnR5cGUudmFsdWV9LCAke2F9PjtcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xuICAgIC8vIFVzZSBjb25zdGFudCBpbnN0ZWFkIG9mIHVuaWZvcm0gY2FuIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGZvciB3J3MgaGVpZ2h0L3dpZHRoLlxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke3BbMF19OyB3X2hlaWdodCsrKSB7XG4gICAgICBsZXQgeF9oZWlnaHQgPSB4X2Nvcm5lci54ICsgaTMyKHdfaGVpZ2h0KTtcbiAgICAgIGlmICh4X2hlaWdodCA+PSAwICYmIHUzMih4X2hlaWdodCkgPCB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtofTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHhfd2lkdGggPSB4X2Nvcm5lci55ICsgaTtcbiAgICAgICAgICBpZiAoeF93aWR0aCA+PSAwICYmIHUzMih4X3dpZHRoKSA8IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7di5nZXQoXCJiYXRjaFwiLFwidTMyKHhfaGVpZ2h0KVwiLFwidTMyKHhfd2lkdGgpXCIsXCJpbnB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3X3dpZHRoOiB1MzIgPSAwdTsgd193aWR0aCA8ICR7cFsxXX07IHdfd2lkdGgrKykge1xuICAgICAgICAgIGxldCB3X3ZhbCA9ICR7Uy5nZXQoXCJ3X2hlaWdodFwiLFwid193aWR0aFwiLFwiMFwiLFwib3V0cHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7YX11OyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IGZtYSh4X3ZhbHNbaSAqIHUzMih1bmlmb3Jtcy5zdHJpZGVzWzFdKSArIHdfd2lkdGhdLCB3X3ZhbCwgdmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke2F9dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke0F9XG4gICAgICAkeyR9XG4gICAgICAke2cuc2V0KFwiYmF0Y2hcIixcInJvd1wiLFwiY29sICsgaVwiLFwib3V0cHV0X2NoYW5uZWxcIixcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252LVZlY3Rvcml6ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7aX07JHthfTske2h9OyR7cFswXX07JHtwWzFdfWAsaW5wdXREZXBlbmRlbmNpZXM6bz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJ0eXBlXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bj9uKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dX0pLGdldFNoYWRlclNvdXJjZTpffX19KTt2YXIgbWYsZ28sZmYsYm8seW8sWXUsaGYsZ2YsX28sWnU9VSgoKT0+e1widXNlIHN0cmljdFwiO25lKCk7VnUoKTtGdSgpO1FyKCk7anUoKTt5dCgpO1pyKCk7ZHQoKTttZj0oZSx0LHIsbixvLGkpPT57bGV0IGE9ZVswXSxkPWUuc2xpY2UoaT8xOjIsaT8zOjQpLGw9ZC5sZW5ndGgscD10WzBdLHU9dC5zbGljZSgyKS5tYXAoKHksZyk9PnkrKHktMSkqKHJbZ10tMSkpLF89ZC5tYXAoKHksZyk9PnkrbltnXStuW2crbF0pLm1hcCgoeSxnKT0+TWF0aC5mbG9vcigoeS11W2ddK29bZ10pL29bZ10pKTtyZXR1cm4gXy5zcGxpY2UoMCwwLGEpLF8uc3BsaWNlKGk/MzoxLDAscCksX30sZ289WzIsMywxLDBdLGZmPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKFwiZ3JlYXRlciB0aGFuIDVEIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IHI9ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLG49ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYociE9PW4pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsxXS5kaW1zWzBdIT09ZVsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IG89ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7b31EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke299RGApO2lmKHQucGFkcy5sZW5ndGghPT1vKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke28qMn1EYCk7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKX0sYm89KGUsdCk9PntsZXQgcj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7ci5sZW5ndGg8dFsxXS5kaW1zLmxlbmd0aC0yJiZyLnB1c2goLi4uQXJyYXkodFsxXS5kaW1zLmxlbmd0aC0yLXIubGVuZ3RoKS5maWxsKDApKTtmb3IobGV0IGk9MjtpPHRbMV0uZGltcy5sZW5ndGg7KytpKXJbaS0yXT09PTAmJihyW2ktMl09dFsxXS5kaW1zW2ldKTtsZXQgbj1lLnBhZHMuc2xpY2UoKTtrdC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodFswXS5kaW1zLGUuc3RyaWRlcyxlLmRpbGF0aW9ucyxyLG4sZS5mb3JtYXQ9PT1cIk5IV0NcIixlLmF1dG9QYWQpO2xldCBvPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obyx7a2VybmVsU2hhcGU6cixwYWRzOm59KSxvfSx5bz1lPT57bGV0IHQ9S3IoZSkscj1lLmZvcm1hdCxuPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sbz1lLmRpbGF0aW9ucyxpPWUuZ3JvdXAsYT1lLmtlcm5lbF9zaGFwZSxkPWUucGFkcyxsPWUuc3RyaWRlcyxwPWUud19pc19jb25zdCgpO3JldHVybnthdXRvUGFkOm4sZm9ybWF0OnIsZGlsYXRpb25zOm8sZ3JvdXA6aSxrZXJuZWxTaGFwZTphLHBhZHM6ZCxzdHJpZGVzOmwsd0lzQ29uc3Q6cCwuLi50LGNhY2hlS2V5OmAke2UuZm9ybWF0fTske3QuYWN0aXZhdGlvbn07YH19LFl1PShlLHQscixuKT0+e2xldCBvPXIuZm9ybWF0PT09XCJOSFdDXCIsaT1tZih0WzBdLmRpbXMsdFsxXS5kaW1zLHIuZGlsYXRpb25zLHIucGFkcyxyLnN0cmlkZXMsbyk7aWYoci5ncm91cCE9PTEpe2xldCBDPVt0WzBdXTtpZihvKXtsZXQgRD1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShQZSh0WzFdLGdvKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9RCksQy5wdXNoKEQpfWVsc2UgQy5wdXNoKHRbMV0pO3QubGVuZ3RoPT09MyYmQy5wdXNoKHRbMl0pLCFlLmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKFwiYW1wZXJlXCIpJiZvJiZ0WzFdLmRpbXNbMF09PT1yLmdyb3VwJiZ0WzFdLmRpbXNbMV09PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MT9lLmNvbXB1dGUoS3UoQyxyLGksbikse2lucHV0czpDfSk6ZS5jb21wdXRlKHF1KEMscixpLG4pLHtpbnB1dHM6Q30pO3JldHVybn1sZXQgYT10Lmxlbmd0aD09PTMsZD10WzBdLmRpbXNbbz8xOjJdLGw9dFswXS5kaW1zW28/MjozXSxwPXRbMF0uZGltc1tvPzM6MV0sbT10WzFdLmRpbXNbMl0sdT10WzFdLmRpbXNbM10saD1pW28/MToyXSxfPWlbbz8yOjNdLHk9aVtvPzM6MV0sZz1vJiZtPT09ZCYmdT09PWwmJnIucGFkc1swXT09PTAmJnIucGFkc1sxXT09PTA7aWYoZ3x8bT09PTEmJnU9PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MSYmci5zdHJpZGVzWzBdPT09MSYmci5zdHJpZGVzWzFdPT09MSYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MCl7bGV0IEM9aVswXSxQLEQsUixIPVtdO2lmKG8pe2xldCBWPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sZ28pLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07aWYoci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1WKSxnKXtsZXQgSz1kKmwqcDtQPXRbMF0ucmVzaGFwZShbMSxDLEtdKSxEPVYucmVzaGFwZShbMSxLLHldKSxSPVsxLEMseV19ZWxzZSBQPXRbMF0ucmVzaGFwZShbQyxkKmwscF0pLEQ9Vi5yZXNoYXBlKFsxLHAseV0pLFI9W0MsaCpfLHldO0gucHVzaChQKSxILnB1c2goRCl9ZWxzZSBQPXRbMF0ucmVzaGFwZShbQyxwLGQqbF0pLEQ9dFsxXS5yZXNoYXBlKFsxLHkscF0pLFI9W0MseSxoKl9dLEgucHVzaChEKSxILnB1c2goUCk7YSYmSC5wdXNoKHRbMl0pO2xldCBMPVJbMl0scmU9SFswXS5kaW1zW0hbMF0uZGltcy5sZW5ndGgtMV07TDw4JiZyZTw4P2UuY29tcHV0ZShZcihILHIsaSxSLG8sbikse2lucHV0czpIfSk6ZS5jb21wdXRlKEp0KEgscixpLFIsbyxuKSx7aW5wdXRzOkh9KTtyZXR1cm59bGV0IHg9ITAsJD1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShQZSh0WzFdLGdvKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9JCk7bGV0IHY9W3RbMF0sJF07YSYmdi5wdXNoKHRbMl0pO2xldCBTPW8/aCpfOnksVD1vP3k6aCpfLEE9bSp1KnA7ZS5jb21wdXRlKE51KHYscixpLFMsVCxBLGEseCxuKSx7aW5wdXRzOnZ9KX0saGY9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG49W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJm4ucHVzaChlLmlucHV0c1syXSk7bGV0IG89WzAsdC5wYWRzWzBdLDAsdC5wYWRzWzFdXSxpPVsxXS5jb25jYXQodC5zdHJpZGVzKSxhPVsxXS5jb25jYXQodC5kaWxhdGlvbnMpLGQ9WzFdLmNvbmNhdCh0Lmtlcm5lbFNoYXBlKSxsPWJvKHsuLi50LHBhZHM6byxzdHJpZGVzOmksZGlsYXRpb25zOmEsa2VybmVsU2hhcGU6ZH0sbik7WXUoZSxuLGwscD0+cj9bcFswXSxwWzJdLHBbM11dOltwWzBdLHBbMV0scFszXV0pfSxnZj0oZSx0LHIpPT57bGV0IG49ci5mb3JtYXQ9PT1cIk5IV0NcIj9cImNoYW5uZWxzTGFzdFwiOlwiY2hhbm5lbHNGaXJzdFwiLG89Ym8ocix0KSxpPXIuYXV0b1BhZD09PVwiTk9UU0VUXCI/ci5wYWRzOnIuYXV0b1BhZCxhPUd1KHRbMF0uZGltcyx0WzFdLmRpbXMsci5zdHJpZGVzLHIuZGlsYXRpb25zLGksITEsbik7ZS5jb21wdXRlKEh1KHQsbyxhLm91dFNoYXBlLFthLmZpbHRlckRlcHRoLGEuZmlsdGVySGVpZ2h0LGEuZmlsdGVyV2lkdGhdLFthLnBhZEluZm8uZnJvbnQsYS5wYWRJbmZvLnRvcCxhLnBhZEluZm8ubGVmdF0sbikpfSxfbz0oZSx0KT0+e2lmKGZmKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09MyloZihlLHQpO2Vsc2UgaWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KWdmKGUsZS5pbnB1dHMsdCk7ZWxzZXtsZXQgcj1ibyh0LGUuaW5wdXRzKTtZdShlLGUuaW5wdXRzLHIpfX19KTt2YXIgUXUsWHU9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtldCgpO25lKCk7YWUoKTtRdT0oZSx0LHIpPT57bGV0IG49ZS5sZW5ndGg+MixvPXQub3V0cHV0U2hhcGUsaT10LmZvcm1hdD09PVwiTkhXQ1wiLGE9dC5ncm91cCxkPWVbMV0uZGltcyxsPWRbMl0vYSxwPWRbM10sbT1pP21lKGwpOjEsdT1pP21lKHApOjEsaD1pP3A9PT0xP206dToxLF89ay5zaXplKG8pL3UseT1bTWF0aC5jZWlsKF8vNjQpLDEsMV07c2UoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX2JhY2twcm9wX3dlYmdwdV0gZGlzcGF0Y2ggPSAke3l9YCk7bGV0IGc9W1wicmFua1wiLFwicmFua1wiXSx4PVt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXSwkPVt0Lmtlcm5lbFNoYXBlW2k/MToyXSx0Lmtlcm5lbFNoYXBlW2k/MjozXV0sdj1bdC5kaWxhdGlvbnNbMF0sdC5kaWxhdGlvbnNbMV1dLFM9WyRbMF0rKHQuZGlsYXRpb25zWzBdPD0xPzA6KHQua2VybmVsU2hhcGVbaT8xOjJdLTEpKih0LmRpbGF0aW9uc1swXS0xKSksJFsxXSsodC5kaWxhdGlvbnNbMV08PTE/MDoodC5rZXJuZWxTaGFwZVtpPzI6M10tMSkqKHQuZGlsYXRpb25zWzFdLTEpKV0sVD1bU1swXS0xLU1hdGguZmxvb3IoKHQucGFkc1swXSt0LnBhZHNbMl0pLzIpLFNbMV0tMS1NYXRoLmZsb29yKCh0LnBhZHNbMV0rdC5wYWRzWzNdKS8yKV0sQT1be3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOnh9LHt0eXBlOjEyLGRhdGE6JH0se3R5cGU6MTIsZGF0YTp2fSx7dHlwZToxMixkYXRhOlN9LHt0eXBlOjYsZGF0YTpUfSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6cH0sLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zKV07biYmKEEucHVzaCguLi5OKGVbMl0uZGltcykpLGcucHVzaChcInJhbmtcIikpLEEucHVzaCguLi5OKG8pKTtsZXQgQz1QPT57bGV0IEQ9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6eC5sZW5ndGh9LHtuYW1lOlwiZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOiQubGVuZ3RofSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6JC5sZW5ndGh9LHtuYW1lOlwiZWZmZWN0aXZlX2ZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpTLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDpULmxlbmd0aH0se25hbWU6XCJpbnB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwib3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn1dLFI9eWUoZVswXS5kYXRhVHlwZSksSD1pPzE6MixMPWk/MjozLHJlPWk/MzoxLFY9RShcIldcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgsaCksSz1FKFwiRHlcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsbSksd2U9W0ssVl07biYmd2UucHVzaChFKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsW29bcmVdXS5sZW5ndGgsdSkpO2xldCBqPU0oXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoLHUpLFE9KCk9PntsZXQgdGU9XCJcIjtpZihtPT09MSl0ZSs9YFxuICAgICAgICBsZXQgd19vZmZzZXQgPSAke1YuaW5kaWNlc1RvT2Zmc2V0KGAke1YudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9O1xuICAgICAgICBsZXQgd1ZhbHVlID0gJHtWLmdldEJ5T2Zmc2V0KGB3X29mZnNldCAvICR7aH1gKX07XG4gICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlICogd1ZhbHVlO2A7ZWxzZSBpZihwPT09MSl0ZSs9YFxuICAgICAgICAgIGxldCB3VmFsdWUgPSAke1YuZ2V0QnlPZmZzZXQoYCR7Vi5pbmRpY2VzVG9PZmZzZXQoYCR7Vi50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsLCB3T3V0Q2hhbm5lbClgKX0gLyAke2h9YCl9O1xuICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHhWYWx1ZSwgd1ZhbHVlKTtgO2Vsc2UgZm9yKGxldCBiZT0wO2JlPG07YmUrKyl0ZSs9YFxuICAgICAgICAgICAgbGV0IHdWYWx1ZSR7YmV9ID0gJHtWLmdldEJ5T2Zmc2V0KGAke1YuaW5kaWNlc1RvT2Zmc2V0KGAke1YudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCArICR7YmV9LCB3T3V0Q2hhbm5lbClgKX0gLyAke2h9YCl9O1xuICAgICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWVbJHtiZX1dICogd1ZhbHVlJHtiZX07YDtyZXR1cm4gdGV9LGllPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtqLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7dX1gKX07XG4gICAgICAgICAgICBsZXQgYmF0Y2ggPSAke2ouaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIiwwKX07XG4gICAgICAgICAgICBsZXQgZDEgPSAke2ouaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixyZSl9O1xuICAgICAgICAgICAgbGV0IHIgPSAke2ouaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixIKX07XG4gICAgICAgICAgICBsZXQgYyA9ICR7ai5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEwpfTtcbiAgICAgICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSB1bmlmb3Jtcy5wYWRzO1xuICAgICAgICAgICAgbGV0IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgICAgICBsZXQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcbiAgICAgICAgICAgIGxldCBncm91cElkID0gZDEgLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgbGV0IHdPdXRDaGFubmVsID0gZDEgLSBncm91cElkICogdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgICAgICB2YXIgZG90UHJvZCA9ICR7ai50eXBlLnZhbHVlfSgwLjApO1xuICAgICAgICAgICAgdmFyIHdSOiB1MzIgPSAwO1xuICAgICAgICAgICAgaWYgKHVuaWZvcm1zLmRpbGF0aW9ucy54ID09IDEpIHtcbiAgICAgICAgICAgICAgLy8gTWluaW11bSB3UiA+PSAwIHRoYXQgc2F0aXNmaWVzIChkeVJDb3JuZXIgKyB3UikgJSAodW5pZm9ybXMuc3RyaWRlcy54KSA9PSAwXG4gICAgICAgICAgICAgIHdSID0gdTMyKCgoZHlSQ29ybmVyICsgaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkgLSAxKSAvIGkzMih1bmlmb3Jtcy5zdHJpZGVzLngpKSAqIGkzMih1bmlmb3Jtcy5zdHJpZGVzLngpIC0gZHlSQ29ybmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyB3UiA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy54OyB3UiA9IHdSICsgMSkge1xuICAgICAgICAgICAgICBpZiAod1IgJSB1bmlmb3Jtcy5kaWxhdGlvbnMueCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGR5UiA9ICgke1J9KGR5UkNvcm5lcikgKyAke1J9KHdSKSkgLyAke1J9KHVuaWZvcm1zLnN0cmlkZXNbMF0pO1xuICAgICAgICAgICAgICBsZXQgd1JQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueCAtIDEgLSB3UiAvIHVuaWZvcm1zLmRpbGF0aW9ucy54O1xuICAgICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke1J9KHVuaWZvcm1zLkR5X3NoYXBlWyR7SH1dKSB8fCBmcmFjdChkeVIpID4gMC4wIHx8XG4gICAgICAgICAgICAgICAgICB3UlBlcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xuICAgICAgICAgICAgICB2YXIgd0M6IHUzMiA9IDA7XG4gICAgICAgICAgICAgIGlmICh1bmlmb3Jtcy5kaWxhdGlvbnMueSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gTWluaW11bSB3QyA+PSAwIHRoYXQgc2F0aXNmaWVzIChkeUNDb3JuZXIgKyB3QykgJSAodW5pZm9ybXMuc3RyaWRlcy55KSA9PSAwXG4gICAgICAgICAgICAgICAgd0MgPSB1MzIoKChkeUNDb3JuZXIgKyBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSAtIDEpIC8gaTMyKHVuaWZvcm1zLnN0cmlkZXMueSkpICogaTMyKHVuaWZvcm1zLnN0cmlkZXMueSkgLSBkeUNDb3JuZXIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICg7IHdDIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLnk7IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdDICUgdW5pZm9ybXMuZGlsYXRpb25zLnkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkeUMgPSAoJHtSfShkeUNDb3JuZXIpICsgJHtSfSh3QykpIC8gJHtSfSh1bmlmb3Jtcy5zdHJpZGVzLnkpO1xuICAgICAgICAgICAgICAgIGxldCB3Q1Blcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy55IC0gMSAtIHdDIC8gdW5pZm9ybXMuZGlsYXRpb25zLnk7XG4gICAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtSfSh1bmlmb3Jtcy5EeV9zaGFwZVske0x9XSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCB8fCB3Q1Blcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSBncm91cElkICogdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDsgZDIgPSBkMiArICR7bX0pIHtcbiAgICAgICAgICAgICAgICAgIGxldCB4VmFsdWUgPSAke2k/Sy5nZXRCeU9mZnNldChgJHtLLmluZGljZXNUb09mZnNldChgJHtLLnR5cGUuaW5kaWNlc30oYmF0Y2gsIGlkeVIsIGlkeUMsIGlucHV0Q2hhbm5lbClgKX0gLyAke219YCk6Sy5nZXQoXCJiYXRjaFwiLFwiaW5wdXRDaGFubmVsXCIsXCJpZHlSXCIsXCJpZHlDXCIpfTtcbiAgICAgICAgICAgICAgICAgICR7USgpfVxuICAgICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsID0gaW5wdXRDaGFubmVsICsgJHttfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd0MgPSB3QyArIHVuaWZvcm1zLnN0cmlkZXMueSAtIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd1IgPSB3UiArIHVuaWZvcm1zLnN0cmlkZXNbMF0gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZCR7bj9gICsgYmlhc1tkMSAvICR7dX1dYDpcIlwifTtcbiAgICAgICAgICAgICR7ai5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgICAgICAgICBgO3JldHVybmBcbiAgICAke1AucmVnaXN0ZXJVbmlmb3JtcyhEKS5kZWNsYXJlVmFyaWFibGVzKC4uLndlLGopfVxuICAgICAgJHtQLm1haW5TdGFydCgpfVxuICAgICAgJHtQLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX07XG4gICAgJHtpZX19YH07cmV0dXJue25hbWU6XCJDb252VHJhbnNwb3NlMkRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske219JHtofSR7dX0ke3A9PT0xfWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0UnVuRGF0YTooKT0+KHtkaXNwYXRjaEdyb3VwOnt4OnlbMF0seTp5WzFdLHo6eVsyXX0sb3V0cHV0czpbe2RpbXM6cj9yKG8pOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLHByb2dyYW1Vbmlmb3JtczpBfSksZ2V0U2hhZGVyU291cmNlOkN9fX0pO3ZhciBiZix5ZixfZixKdSxlZCx3Zix0ZCx2ZixyZCxuZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7WHUoKTt5dCgpO2R0KCk7YmY9KGUsdCxyLG4sbyxpKT0+KGUtMSkqdCtyKyhuLTEpKm8rMS1pLHlmPShlLHQscixuLG8pPT57bGV0IGk9TWF0aC5mbG9vcihlLzIpO3Q9PT1cIlNBTUVfVVBQRVJcIj8ocltuXT1pLHJbb109ZS1pKTp0PT09XCJTQU1FX0xPV0VSXCImJihyW25dPWUtaSxyW29dPWkpfSxfZj0oZSx0LHIsbixvLGksYSxkLGwscCk9PntsZXQgbT1lLmxlbmd0aC0yLHU9cC5sZW5ndGg9PT0wO2wubGVuZ3RoPG0mJmwucHVzaCguLi5BcnJheShtLWwubGVuZ3RoKS5maWxsKDApKTtsZXQgaD1lWzBdLF89dFtkPzM6MV0qbztmb3IobGV0IHk9MCxnPWUubGVuZ3RoLW0tKGQ/MTowKTt5PG07Kyt5LCsrZyl7bGV0IHg9ZVtnXSwkPXU/eCphW3ldOnBbeV0sdj1iZih4LGFbeV0saVt5XSx0W2ddLHJbeV0sJCk7eWYodixuLGkseSx5K20pLHUmJnAucHVzaChhW3ldKih4LTEpK2xbeV0rKHRbZ10tMSkqclt5XSsxLWlbeV0taVt5K21dKX1wLnNwbGljZSgwLDAsaCkscC5zcGxpY2UoZD8zOjEsMCxfKX0sSnU9KGUsdCk9PntsZXQgcj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7aWYoZS5rZXJuZWxTaGFwZS5sZW5ndGg9PT0wfHxlLmtlcm5lbFNoYXBlLnJlZHVjZSgodSxoKT0+dSpoLDEpPT09MCl7ci5sZW5ndGg9MDtmb3IobGV0IHU9Mjt1PHRbMV0uZGltcy5sZW5ndGg7Kyt1KXIucHVzaCh0WzFdLmRpbXNbdV0pfWxldCBuPWUuZm9ybWF0PT09XCJOSFdDXCI7ci5zcGxpY2UoMCwwLHRbMV0uZGltc1swXSksci5zcGxpY2Uobj8zOjEsMCx0WzFdLmRpbXNbMV0pO2xldCBvPWUucGFkcy5zbGljZSgpLGk9ZS5vdXRwdXRTaGFwZS5zbGljZSgpLGE9ZS5vdXRwdXRQYWRkaW5nLnNsaWNlKCksZD10WzBdLmRpbXMsbD1lLmRpbGF0aW9ucy5zbGljZSgpO2lmKGwucmVkdWNlKCh1LGgpPT51K2gsMCk9PT0wKXtsZXQgdT10WzBdLmRpbXMubGVuZ3RoLTI7bD1uZXcgQXJyYXkodSkuZmlsbCgxKX1sZXQgcD1lLnN0cmlkZXMuc2xpY2UoKTtpZihwLnJlZHVjZSgodSxoKT0+dStoLDApPT09MCl7bGV0IHU9dFswXS5kaW1zLmxlbmd0aC0yO3A9bmV3IEFycmF5KHUpLmZpbGwoMSl9X2YoZCxyLGwsZS5hdXRvUGFkLGUuZ3JvdXAsbyxwLG4sYSxpKTtsZXQgbT1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3QuYXNzaWduKG0se2tlcm5lbFNoYXBlOnIscGFkczpvLG91dHB1dFBhZGRpbmc6YSxvdXRwdXRTaGFwZTppLGRpbGF0aW9uczpsLHN0cmlkZXM6cH0pLG19LGVkPWU9PntsZXQgdD1LcihlKSxyPWUuZm9ybWF0LG49W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVt0eXBlb2YgZS5hdXRvUGFkPlwidVwiPzA6ZS5hdXRvUGFkXSxvPWUuZGlsYXRpb25zLGk9ZS5ncm91cCxhPWUua2VybmVsU2hhcGUsZD1lLnBhZHMsbD1lLnN0cmlkZXMscD1lLndJc0NvbnN0KCksbT1lLm91dHB1dFBhZGRpbmcsdT1lLm91dHB1dFNoYXBlO3JldHVybnthdXRvUGFkOm4sZm9ybWF0OnIsZGlsYXRpb25zOm8sZ3JvdXA6aSxrZXJuZWxTaGFwZTphLG91dHB1dFBhZGRpbmc6bSxvdXRwdXRTaGFwZTp1LHBhZHM6ZCxzdHJpZGVzOmwsd0lzQ29uc3Q6cCwuLi50LGNhY2hlS2V5OmAke2UuZm9ybWF0fTske3QuYWN0aXZhdGlvbn07YH19LHdmPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCYmZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IHI9ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLG49ZVsxXS5kaW1zWzBdO2lmKHIhPT1uKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7bGV0IG89ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYoZS5sZW5ndGg9PT0zJiYoZVsyXS5kaW1zLmxlbmd0aCE9PTF8fGVbMl0uZGltc1swXSE9PW8pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgaT1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMucmVkdWNlKChtLHUpPT5tK3UsMCk+MCYmdC5kaWxhdGlvbnMubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtpfURgKTtpZih0LnN0cmlkZXMucmVkdWNlKChtLHUpPT5tK3UsMCk+MCYmdC5zdHJpZGVzLmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke2l9RGApO2lmKHQucGFkcy5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0LnBhZHMubGVuZ3RoIT09aSoyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtpKjJ9RGApO2lmKHQub3V0cHV0UGFkZGluZy5sZW5ndGghPT1pJiZ0Lm91dHB1dFBhZGRpbmcubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYG91dHB1dF9wYWRkaW5nIHNob3VsZCBiZSAke2l9RGApO2lmKHQua2VybmVsU2hhcGUucmVkdWNlKChtLHUpPT5tK3UsMCk+MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKTtpZih0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PTAmJnQub3V0cHV0U2hhcGUubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3V0cHV0IHNoYXBlXCIpfSx0ZD0oZSx0LHIsbik9PntsZXQgbz1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShQZSh0WzFdLFsyLDMsMCwxXSkse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPW8pO2xldCBpPVt0WzBdLG9dO3QubGVuZ3RoPT09MyYmaS5wdXNoKHRbMl0pLGUuY29tcHV0ZShRdShpLHIsbikse2lucHV0czppfSl9LHZmPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixuPVtlLmlucHV0c1swXS5yZXNoYXBlKHI/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTtlLmlucHV0cy5sZW5ndGg9PT0zJiZuLnB1c2goZS5pbnB1dHNbMl0pO2xldCBvPXQua2VybmVsU2hhcGU7KG8ubGVuZ3RoPT09MHx8b1swXT09PTApJiYobz1bZS5pbnB1dHNbMV0uZGltc1syXV0pO2xldCBpPXQuZGlsYXRpb25zOyhpLmxlbmd0aD09PTB8fGlbMF09PT0wKSYmKGk9WzFdKTtsZXQgYT10LnN0cmlkZXM7KGEubGVuZ3RoPT09MHx8YVswXT09PTApJiYoYT1bMV0pO2xldCBkPXQucGFkcztkLmxlbmd0aD09PTAmJihkPVswLDBdKSxkPVswLGRbMF0sMCxkWzFdXSxhPVsxXS5jb25jYXQoYSksaT1bMV0uY29uY2F0KGkpLG89WzFdLmNvbmNhdChvKTtsZXQgbD10Lm91dHB1dFBhZGRpbmc7bD1bMF0uY29uY2F0KGwpO2xldCBwPUp1KHsuLi50LHBhZHM6ZCxzdHJpZGVzOmEsZGlsYXRpb25zOmksa2VybmVsU2hhcGU6byxvdXRwdXRQYWRkaW5nOmx9LG4pO3RkKGUsbixwLG09PnI/W21bMF0sbVsyXSxtWzNdXTpbbVswXSxtWzFdLG1bM11dKX0scmQ9KGUsdCk9PntpZih3ZihlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTMpdmYoZSx0KTtlbHNle2xldCByPUp1KHQsZS5pbnB1dHMpO3RkKGUsZS5pbnB1dHMscil9fX0pO3ZhciAkZixvZCxpZCxhZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTthZSgpOyRmPShlLHQscixuKT0+e2xldCBvPWsuc2l6ZSh0KSxpPXQubGVuZ3RoLGE9RShcImlucHV0XCIsZSxpKSxkPU0oXCJvdXRwdXRcIixlLGkpLGw9ci5kYXRhVHlwZT09PTY/ci5nZXRJbnQzMkFycmF5KClbMF06TnVtYmVyKHIuZ2V0QmlnSW50NjRBcnJheSgpWzBdKSxwPWsubm9ybWFsaXplQXhpcyhsLGkpLG09dT0+e2xldCBoPWAgaTMyKCR7YS5pbmRpY2VzR2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSkgYCxfPXEoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwidW5pZm9ybXMuYXhpc1wiLGkpLHk9bi5yZXZlcnNlP2grKG4uZXhjbHVzaXZlP1wiICsgMVwiOlwiXCIpOlwiMFwiLGc9bi5yZXZlcnNlP186aCsobi5leGNsdXNpdmU/XCJcIjpcIiArIDFcIik7cmV0dXJuYFxuICAgICAgICAgICAgICAgICR7dS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoYSxkKX1cbiAgICAgICAgICAgICAgICAke3UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9ICR7ZC50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7eX07XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdCA6IGkzMiA9ICR7Z307XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIDogaTMyID0gZmlyc3Q7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJHthLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpKVwiKX07XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArICR7YS5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIil9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDdW1TdW1cIixzaGFkZXJDYWNoZTp7aGludDpuLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOnB9LC4uLk4odCx0KV19KSxnZXRTaGFkZXJTb3VyY2U6bX19LG9kPShlLHQpPT57bGV0IHI9ZS5pbnB1dHNbMF0uZGltcyxuPWUuaW5wdXRzWzBdLmRhdGFUeXBlLG89ZS5pbnB1dHNbMV07ZS5jb21wdXRlKCRmKG4scixvLHQpLHtpbnB1dHM6WzBdfSl9LGlkPWU9PntsZXQgdD1lLmV4Y2x1c2l2ZT09PTEscj1lLnJldmVyc2U9PT0xO3JldHVybiBlZSh7ZXhjbHVzaXZlOnQscmV2ZXJzZTpyfSl9fSk7dmFyIHhmLFNmLFRmLHNkLHVkLGRkPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7eGY9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcIkRlcHRoVG9TcGFjZSByZXF1aXJlcyA0RCBpbnB1dC5cIil9LFNmPShlLHQscixuKT0+e2xldCBvPVtdO28ucHVzaChgZm4gcGVybShpOiAke24udHlwZS5pbmRpY2VzfSkgLT4gJHtyLnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke3IudHlwZS5pbmRpY2VzfTtgKTtmb3IobGV0IGk9MDtpPHQ7KytpKW8ucHVzaChyLmluZGljZXNTZXQoXCJhXCIsZVtpXSxgaVske2l9XWApKTtyZXR1cm4gby5wdXNoKFwicmV0dXJuIGE7fVwiKSxvLmpvaW4oYFxuYCl9LFRmPShlLHQpPT57bGV0IHIsbixvLGksYSxkLGw9dC5mb3JtYXQ9PT1cIk5IV0NcIixwPXQuYmxvY2tzaXplLG09dC5tb2RlPT09XCJEQ1JcIjtsPyhbcixuLG8saV09ZS5kaW1zLGE9bT9bcixuLG8scCxwLGkvcCoqMl06W3IsbixvLGkvcCoqMixwLHBdLGQ9bT9bMCwxLDMsMiw0LDVdOlswLDEsNCwyLDUsM10pOihbcixuLG8saV09W2UuZGltc1swXSxlLmRpbXNbMl0sZS5kaW1zWzNdLGUuZGltc1sxXV0sYT1tP1tyLHAscCxpL3AqKjIsbixvXTpbcixpL3AqKjIscCxwLG4sb10sZD1tP1swLDMsNCwxLDUsMl06WzAsMSw0LDIsNSwzXSk7bGV0IHU9ZS5yZXNoYXBlKGEpLGg9dS5kaW1zLmxlbmd0aCxfPWUuZGF0YVR5cGUseT1FKFwiYVwiLF8saCksZz1NKFwib3V0cHV0XCIsXyxoKSx4PSQ9PmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh5LGcpfVxuXG4gICR7U2YoZCxoLHksZyl9XG5cbiAgJHskLm1haW5TdGFydCgpfVxuICAgICR7JC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7Zy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHtnLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHkuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIikpfVxuICB9YDtyZXR1cm57bmFtZTpcIkRlcHRoVG9TcGFjZVwiLHNoYWRlckNhY2hlOntoaW50OmAke2UuZGltc307JHt0LmJsb2Nrc2l6ZX07JHt0Lm1vZGV9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOiQ9PntsZXQgdj1sP1tyLG4qcCxvKnAsaS9wKioyXTpbcixpL3AqKjIsbipwLG8qcF0sUz1rLnNpemUodiksVD11LmRpbXMsQT1rLnNvcnRCYXNlZE9uUGVybShULGQpO3JldHVybntvdXRwdXRzOlt7ZGltczp2LGRhdGFUeXBlOiRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChTLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOlN9LC4uLk4oVCxBKV19fSxnZXRTaGFkZXJTb3VyY2U6eH19LHNkPShlLHQpPT57eGYoZS5pbnB1dHMpLGUuY29tcHV0ZShUZihlLmlucHV0c1swXSx0KSl9LHVkPWU9PmVlKHtibG9ja3NpemU6ZS5ibG9ja3NpemUsbW9kZTplLm1vZGUsZm9ybWF0OmUuZm9ybWF0fSl9KTt2YXIgd28sSnIsbGQsSWYsQ2Ysdm8sJG8sY2QsQWYscGQsbWQsZmQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTt3bz1cIlthLXpBLVpdfFxcXFwuXFxcXC5cXFxcLlwiLEpyPVwiKFwiK3dvK1wiKStcIixsZD1cIl5cIitKcitcIiRcIixJZj1cIihcIitKcitcIiwpKlwiK0pyLENmPVwiXlwiK0lmK1wiJFwiLHZvPWNsYXNze2NvbnN0cnVjdG9yKHQ9LTEpe3RoaXMuc3ltYm9sVG9JbmRpY2VzPW5ldyBNYXAsdGhpcy5pbnB1dEluZGV4PXR9YWRkU3ltYm9sKHQscil7bGV0IG49dGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHQpO249PT12b2lkIDA/bj1bcl06bi5wdXNoKHIpLHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldCh0LG4pfX0sJG89Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLmVxdWF0aW9uPXI7dGhpcy5oYXNFbGxpcHNpcz0hMSx0aGlzLnN5bWJvbFRvSW5mbz1uZXcgTWFwLHRoaXMubGhzPW5ldyBBcnJheSx0aGlzLm91dHB1dERpbXM9W107bGV0W24sb109ci5pbmNsdWRlcyhcIi0+XCIpP3Iuc3BsaXQoXCItPlwiLDIpOltyLFwiXCJdO2lmKCFuLm1hdGNoKFJlZ0V4cChDZikpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7aWYobi5zcGxpdChcIixcIikuZm9yRWFjaCgoZCxsKT0+e2xldCBwPXRbbF0uZGltcy5zbGljZSgpO2lmKCFkLm1hdGNoKFJlZ0V4cChsZCkpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IG09dGhpcy5wcm9jZXNzVGVybShkLCEwLHAsbCk7dGhpcy5saHMucHVzaChtKX0pLG89PT1cIlwiKW8rPVsuLi50aGlzLnN5bWJvbFRvSW5mby5lbnRyaWVzKCldLmZpbHRlcigoW2QsbF0pPT5sLmNvdW50PT09MXx8ZD09PVwiLi4uXCIpLm1hcCgoW2RdKT0+ZCkuam9pbihcIlwiKTtlbHNlIGlmKCFvLm1hdGNoKFJlZ0V4cChKcikpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTXCIpO28ubWF0Y2goUmVnRXhwKHdvLFwiZ1wiKSk/LmZvckVhY2goZD0+e2lmKGQ9PT1cIi4uLlwiKXRoaXMub3V0cHV0RGltcz10aGlzLm91dHB1dERpbXMuY29uY2F0KHRoaXMuZWxsaXBzaXNEaW1zKTtlbHNle2xldCBsPXRoaXMuc3ltYm9sVG9JbmZvLmdldChkKTtpZihsPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTIHN5bWJvbFwiKTt0aGlzLm91dHB1dERpbXMucHVzaChsLmRpbVZhbHVlKX19KSx0aGlzLnJocz10aGlzLnByb2Nlc3NUZXJtKG8sITEsdGhpcy5vdXRwdXREaW1zKX1hZGRTeW1ib2wodCxyLG4pe2xldCBvPXRoaXMuc3ltYm9sVG9JbmZvLmdldCh0KTtpZihvIT09dm9pZCAwKXtpZihvLmRpbVZhbHVlIT09ciYmby5jb3VudCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uIG1pc21hdGNoXCIpO28uY291bnQrKyxvLmlucHV0SW5kaWNlcy5wdXNoKG4pfWVsc2Ugbz17Y291bnQ6MSxkaW1WYWx1ZTpyLGlucHV0SW5kaWNlczpbbl19O3RoaXMuc3ltYm9sVG9JbmZvLnNldCh0LG8pfXByb2Nlc3NUZXJtKHQscixuLG89LTEpe2xldCBpPW4ubGVuZ3RoLGE9ITEsZD1bXSxsPTA7aWYoIXQubWF0Y2goUmVnRXhwKGxkKSkmJiFyJiZ0IT09XCJcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBwPXQubWF0Y2goUmVnRXhwKHdvLFwiZ1wiKSksbT1uZXcgdm8obyk7cmV0dXJuIHA/LmZvckVhY2goKHUsaCk9PntpZih1PT09XCIuLi5cIil7aWYoYSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBlbGxpcHNpcyBpcyBhbGxvd2VkIHBlciBpbnB1dCB0ZXJtXCIpO2E9ITA7bGV0IF89aS1wLmxlbmd0aCsxO2lmKF88MCl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBvdXQgb2YgYm91bmRzXCIpO2lmKGQ9bi5zbGljZShsLGwrXyksdGhpcy5oYXNFbGxpcHNpcyl7aWYodGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoIT09ZC5sZW5ndGh8fHRoaXMuZWxsaXBzaXNEaW1zLnRvU3RyaW5nKCkhPT1kLnRvU3RyaW5nKCkpdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgZGltZW5zaW9ucyBtaXNtYXRjaFwiKX1lbHNlIGlmKHIpdGhpcy5oYXNFbGxpcHNpcz0hMCx0aGlzLmVsbGlwc2lzRGltcz1kO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIExIU1wiKTtmb3IobGV0IHk9MDt5PGQubGVuZ3RoO3krKyl7bGV0IGc9U3RyaW5nLmZyb21DaGFyQ29kZShcIjBcIi5jaGFyQ29kZUF0KDApK3kpO20uYWRkU3ltYm9sKGcsaCt5KSx0aGlzLmFkZFN5bWJvbChnLG5bbCsrXSxvKX19ZWxzZSBtLmFkZFN5bWJvbCh1LGgrKHRoaXMuaGFzRWxsaXBzaXM/dGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoLTE6MCkpLHRoaXMuYWRkU3ltYm9sKHUsbltsKytdLG8pfSksbX19LGNkPWU9PmUrXCJfbWF4XCIsQWY9KGUsdCxyLG4pPT57bGV0IGk9ZS5tYXAobT0+bS5sZW5ndGgpLm1hcCgobSx1KT0+RShgaW5wdXQke3V9YCx0LG0pKSxhPWsuc2l6ZShuKSxkPU0oXCJvdXRwdXRcIix0LG4ubGVuZ3RoKSxsPVsuLi5yLnN5bWJvbFRvSW5mby5rZXlzKCldLmZpbHRlcihtPT4hci5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhtKSkscD1tPT57bGV0IHU9W10saD1cInZhciBwcm9kID0gMS4wO1wiLF89XCJ2YXIgc3VtID0gMC4wO1wiLHk9XCJzdW0gKz0gcHJvZDtcIixnPVtdLHg9W10sJD1bXSx2PVtdLFM9ci5zeW1ib2xUb0luZm8uc2l6ZT09PXIucmhzLnN5bWJvbFRvSW5kaWNlcy5zaXplO3Iuc3ltYm9sVG9JbmZvLmZvckVhY2goKEEsQyk9PntpZihyLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKEMpKXtsZXQgUD1yLnJocy5zeW1ib2xUb0luZGljZXMuZ2V0KEMpPy5bMF07UCE9PXZvaWQgMCYmci5saHMuZm9yRWFjaCgoRCxSKT0+e2lmKEEuaW5wdXRJbmRpY2VzLmluY2x1ZGVzKFIpKXtsZXQgSD1ELnN5bWJvbFRvSW5kaWNlcy5nZXQoQyk7aWYoSD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtILmZvckVhY2goTD0+e3UucHVzaChgJHtpW1JdLmluZGljZXNTZXQoYGlucHV0JHtSfUluZGljZXNgLEwsZC5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLFApKX1gKX0pfX0pfWVsc2Ugci5saHMuZm9yRWFjaCgoUCxEKT0+e2lmKEEuaW5wdXRJbmRpY2VzLmluY2x1ZGVzKEQpKXtsZXQgUj1QLnN5bWJvbFRvSW5kaWNlcy5nZXQoQyk7aWYoUj09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtSLmZvckVhY2goSD0+e2cucHVzaChgJHtpW0RdLmluZGljZXNTZXQoYGlucHV0JHtEfUluZGljZXNgLEgsYCR7Q31gKX1gKX0pLHYucHVzaChgcHJvZCAqPSAke2lbRF0uZ2V0QnlJbmRpY2VzKGBpbnB1dCR7RH1JbmRpY2VzYCl9O2ApfX0pLHgucHVzaChgZm9yKHZhciAke0N9OiB1MzIgPSAwOyAke0N9IDwgdW5pZm9ybXMuJHtjZChDKX07ICR7Q30rKykge2ApLCQucHVzaChcIn1cIil9KTtsZXQgVD1TP1suLi51LGBsZXQgc3VtID0gJHtpLm1hcCgoQSxDKT0+QS5nZXRCeUluZGljZXMoYGlucHV0JHtDfUluZGljZXNgKSkuam9pbihcIiAqIFwiKX07YF06Wy4uLnUsXywuLi54LC4uLmcsaCwuLi52LHksLi4uJF07cmV0dXJuYFxuICAgICAgICAgICAgJHttLnJlZ2lzdGVyVW5pZm9ybXMobC5tYXAoQT0+KHtuYW1lOmAke2NkKEEpfWAsdHlwZTpcInUzMlwifSkpKS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyguLi5pLGQpfVxuXG4gICAgICAgICAgICAke20ubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICR7aS5tYXAoKEEsQyk9PmB2YXIgaW5wdXQke0N9SW5kaWNlczogJHtpW0NdLnR5cGUuaW5kaWNlc307YCkuam9pbihgXG5gKX1cbiAgICAgICAgICAgICR7VC5qb2luKGBcbmApfTtcbiAgICAgICAgICAgICR7ZC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInN1bVwiKX07XG4gICAgICAgICAgfWB9O3JldHVybntuYW1lOlwiRWluc3VtXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6ci5lcXVhdGlvbixpbnB1dERlcGVuZGVuY2llczplLm1hcCgoKT0+XCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT57bGV0IG09bC5maWx0ZXIoaD0+ci5zeW1ib2xUb0luZm8uaGFzKGgpKS5tYXAoaD0+KHt0eXBlOjEyLGRhdGE6ci5zeW1ib2xUb0luZm8uZ2V0KGgpPy5kaW1WYWx1ZXx8MH0pKTttLnB1c2goe3R5cGU6MTIsZGF0YTphfSk7bGV0IHU9ZS5tYXAoKGgsXyk9PlsuLi5OKGgpXSkucmVkdWNlKChoLF8pPT5oLmNvbmNhdChfKSxtKTtyZXR1cm4gdS5wdXNoKC4uLk4obikpLHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOnR9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnV9fSxnZXRTaGFkZXJTb3VyY2U6cH19LHBkPShlLHQpPT57bGV0IHI9bmV3ICRvKGUuaW5wdXRzLHQuZXF1YXRpb24pLG49ci5vdXRwdXREaW1zLG89ZS5pbnB1dHMubWFwKChpLGEpPT5pLmRpbXMpO2UuY29tcHV0ZShBZihvLGUuaW5wdXRzWzBdLmRhdGFUeXBlLHIsbikpfSxtZD1lPT57bGV0IHQ9ZS5lcXVhdGlvbi5yZXBsYWNlKC9cXHMrL2csXCJcIik7cmV0dXJuIGVlKHtlcXVhdGlvbjp0fSl9fSk7dmFyIGtmLGhkLEVmLFBmLGdkLGJkPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO2tmPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyAyIGlucHV0LlwiKTtsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksbj1yLmxlbmd0aDx0Lmxlbmd0aD8wOnIubGVuZ3RoLXQubGVuZ3RoLG89dC5sZW5ndGg8ci5sZW5ndGg/MDp0Lmxlbmd0aC1yLmxlbmd0aDtmb3IoO248ci5sZW5ndGgmJm88dC5sZW5ndGg7KytuLCsrbylpZihyW25dIT09dFtvXSYmcltuXSE9PTEmJnRbb10hPT0xKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0XCIpfSxoZD0oZSx0KT0+e2xldCByPWUubGVuZ3RoLXQubGVuZ3RoLG49W107Zm9yKGxldCBvPTA7bzxyOysrbyluLnB1c2goZVtvXSk7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDsrK28pbi5wdXNoKHRbb109PT0xP2VbbytyXTp0W29dKTtyZXR1cm4gbn0sRWY9KGUsdCk9PmUubGVuZ3RoPnQubGVuZ3RoP2hkKGUsdCk6aGQodCxlKSxQZj1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLG49RWYodCxyKSxvPWVbMF0uZGF0YVR5cGUsaT1vPT09OXx8ay5zaXplKHQpPT09MSxhPW89PT05fHx0Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdJTQ9PT0wPzQ6MSxkPWl8fG4ubGVuZ3RoPjAmJm5bbi5sZW5ndGgtMV0lND09PTA/NDoxLGw9TWF0aC5jZWlsKGsuc2l6ZShuKS9kKSxwPXU9PntsZXQgaD1FKFwiaW5wdXRcIixvLHQubGVuZ3RoLGEpLF89TShcIm91dHB1dFwiLG8sbi5sZW5ndGgsZCkseTtpZihvPT09OSl7bGV0IGc9KHgsJCx2PVwiXCIpPT5gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMkeyR9ID0gJHtfLm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHskfXVgKX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7JH0gPSAke2guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMkeyR9YCxfKX07XG4gICAgICAgICAgbGV0IGluZGV4JHskfSA9IG9mZnNldCR7JH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHskfSA9IG9mZnNldCR7JH0gJSA0dTtcbiAgICAgICAgICAke3h9WyR7JH1dID0gJHt2fSgke2guZ2V0QnlPZmZzZXQoYGluZGV4JHskfWApfVtjb21wb25lbnQkeyR9XSk7XG4gICAgICAgIGA7eT1gXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtkfTtcbiAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7ZyhcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAke2coXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgJHtnKFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICR7ZyhcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWB9ZWxzZSB5PWBcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke18ub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtkfWApfTtcbiAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gJHtoLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLF8pfTtcbiAgICAgICAgbGV0IGRhdGEgPSAke18udHlwZS52YWx1ZX0oJHtoLmdldEJ5T2Zmc2V0KGBpbnB1dE9mZnNldCAvICR7YX1gKX0pO1xuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWA7cmV0dXJuYFxuICAgICR7dS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoaCxfKX1cbiAgICAke3UubWFpblN0YXJ0KCl9XG4gICAgJHt1Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAke3l9YH0sbT1be3R5cGU6MTIsZGF0YTpsfSwuLi5OKHQsbildO3JldHVybntuYW1lOlwiRXhwYW5kXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bi5sZW5ndGh9OyR7YX0ke2R9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6cCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pfX0sZ2Q9ZT0+e2tmKGUuaW5wdXRzKSxlLmNvbXB1dGUoUGYoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHpmLHlkLF9kPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO3FyKCk7emY9ZT0+e2xldCB0PWVbMF0uZGF0YVR5cGUscj1rLnNpemUoZVswXS5kaW1zKSxuPWsuc2l6ZShlWzFdLmRpbXMpLG89biU0PT09MCxpPWE9PntsZXQgZD1FKFwieFwiLHQsWzFdLDQpLGw9RShcImJpYXNcIix0LFsxXSw0KSxwPU0oXCJ5XCIsdCxbMV0sNCksbT1be25hbWU6XCJvdXRwdXRfdmVjX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmlhc19zaXplXCIsdHlwZTpcInUzMlwifV0sdT1fPT5gXG4gICAgICBsZXQgYmlhcyR7X31fb2Zmc2V0OiB1MzIgPSAoZ2xvYmFsX2lkeCAqIDQgKyAke199KSAlIHVuaWZvcm1zLmJpYXNfc2l6ZTtcbiAgICAgIGxldCBiaWFzJHtffSA9ICR7bC5nZXRCeU9mZnNldChgYmlhcyR7X31fb2Zmc2V0IC8gNGApfVtiaWFzJHtffV9vZmZzZXQgJSA0XTtgLGg9bz9gXG4gICAgICBsZXQgYmlhcyA9ICR7bC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggJSAodW5pZm9ybXMuYmlhc19zaXplIC8gNClcIil9O2A6YCR7dSgwKX0ke3UoMSl9JHt1KDIpfSR7dSgzKX1cbiAgICAgIGxldCBiaWFzID0gJHtkLnR5cGUudmFsdWV9KGJpYXMwLCBiaWFzMSwgYmlhczIsIGJpYXMzKTtgO3JldHVybmAke2EucmVnaXN0ZXJVbmlmb3JtcyhtKS5kZWNsYXJlVmFyaWFibGVzKGQsbCxwKX1cblxuICAgICR7cG8oRWUodCkpfVxuXG4gICAgJHthLm1haW5TdGFydChFdCl9XG4gICAgICAke2EuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF92ZWNfc2l6ZVwiKX1cblxuICAgICAgbGV0IHggPSAke2QuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICR7aH1cbiAgICAgIGxldCB4X2luID0geCArIGJpYXM7XG4gICAgICAke3Auc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbW8oXCJ4X2luXCIpKX1cbiAgICB9YH07cmV0dXJue25hbWU6XCJGYXN0R2VsdVdpdGhCaWFzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7b31gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFNoYWRlclNvdXJjZTppLGdldFJ1bkRhdGE6YT0+KHtvdXRwdXRzOlt7ZGltczphWzBdLmRpbXMsZGF0YVR5cGU6YVswXS5kYXRhVHlwZX1dLHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoci80KX0se3R5cGU6MTIsZGF0YTpufV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoci9FdC80KX19KX19LHlkPWU9PntlLmlucHV0cy5sZW5ndGg8Mnx8ay5zaXplKGUuaW5wdXRzWzFdLmRpbXMpPT09MD9mdShlKTplLmNvbXB1dGUoemYoZS5pbnB1dHMpKX19KTt2YXIgT2YsRGYsd2QsdmQsJGQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtPZj1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuXCIpfSxEZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWVbMV0uZGltcyxvPXIubGVuZ3RoLGk9ay5ub3JtYWxpemVBeGlzKHQuYXhpcyxvKSxhPXIuc2xpY2UoMCk7YS5zcGxpY2UoaSwxLC4uLm4pO2xldCBkPXJbaV0sbD1lWzBdLmRhdGFUeXBlPT09OT80OjEscD1NYXRoLmNlaWwoay5zaXplKGEpL2wpLG09W3t0eXBlOjEyLGRhdGE6cH0se3R5cGU6NixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6aX0sLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zLGEpXSx1PWg9PntsZXQgXz1FKFwiZGF0YVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCxsKSx5PUUoXCJpbnB1dEluZGljZXNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLGc9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsYS5sZW5ndGgsbCkseD12PT57bGV0IFM9bi5sZW5ndGgsVD1gdmFyIGluZGljZXNJbmRpY2VzJHt2fSAgPSAke3kudHlwZS5pbmRpY2VzfSgwKTtgO2ZvcihsZXQgQT0wO0E8UztBKyspVCs9YCR7Uz4xP2BpbmRpY2VzSW5kaWNlcyR7dn1bJHtBfV1gOmBpbmRpY2VzSW5kaWNlcyR7dn1gfSA9ICR7YS5sZW5ndGg+MT9gb3V0cHV0SW5kaWNlcyR7dn1bdW5pZm9ybXMuYXhpcyArICR7QX1dYDpgb3V0cHV0SW5kaWNlcyR7dn1gfTtgO1QrPWBcbiAgICAgICAgICB2YXIgaWR4JHt2fSA9ICR7eS5nZXRCeUluZGljZXMoYGluZGljZXNJbmRpY2VzJHt2fWApfTtcbiAgICAgICAgICBpZiAoaWR4JHt2fSA8IDApIHtcbiAgICAgICAgICAgIGlkeCR7dn0gPSBpZHgke3Z9ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YUluZGljZXMke3Z9IDogJHtfLnR5cGUuaW5kaWNlc307XG4gICAgICAgIGA7Zm9yKGxldCBBPTAsQz0wO0E8bztBKyspQT09PWk/KFQrPWAke28+MT9gZGF0YUluZGljZXMke3Z9WyR7QX1dYDpgZGF0YUluZGljZXMke3Z9YH0gPSB1MzIoaWR4JHt2fSk7YCxDKz1TKTooVCs9YCR7bz4xP2BkYXRhSW5kaWNlcyR7dn1bJHtBfV1gOmBkYXRhSW5kaWNlcyR7dn1gfSA9ICR7YS5sZW5ndGg+MT9gb3V0cHV0SW5kaWNlcyR7dn1bJHtDfV1gOmBvdXRwdXRJbmRpY2VzJHt2fWB9O2AsQysrKTtyZXR1cm4gVH0sJDtpZihlWzBdLmRhdGFUeXBlPT09OSl7bGV0IHY9KFMsVCxBPVwiXCIpPT5gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke1R9ID0gJHtnLm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHtUfXVgKX07XG4gICAgICAgICAgJHt4KFQpfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHtUfSA9ICR7Xy5pbmRpY2VzVG9PZmZzZXQoYGRhdGFJbmRpY2VzJHtUfWApfTtcbiAgICAgICAgICBsZXQgaW5kZXgke1R9ID0gb2Zmc2V0JHtUfSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQke1R9ID0gb2Zmc2V0JHtUfSAlIDR1O1xuICAgICAgICAgICR7U31bJHtUfV0gPSAke0F9KCR7Xy5nZXRCeU9mZnNldChgaW5kZXgke1R9YCl9W2NvbXBvbmVudCR7VH1dKTtcbiAgICAgICAgYDskPWBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2x9O1xuICAgICAgICB2YXIgdmFsdWUgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7dihcInZhbHVlXCIsMCxcInUzMlwiKX1cbiAgICAgICAgJHt2KFwidmFsdWVcIiwxLFwidTMyXCIpfVxuICAgICAgICAke3YoXCJ2YWx1ZVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICR7dihcInZhbHVlXCIsMyxcInUzMlwiKX1cbiAgICAgICAgJHtnLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gICAgICBgfWVsc2UgJD1gXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Zy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICR7eChcIlwiKX07XG4gICAgICBsZXQgdmFsdWUgPSAke18uZ2V0QnlJbmRpY2VzKFwiZGF0YUluZGljZXNcIil9O1xuICAgICAgJHtnLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICAgICAgYDtyZXR1cm5gXG4gICAgICAke2gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNEaW1MaW1pdFwiLFwiaTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKF8seSxnKX1cbiAgICAgICR7aC5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAkeyR9XG4gICAgICB9YH07cmV0dXJue25hbWU6XCJHYXRoZXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOnV9fSx3ZD1lPT5lZSh7YXhpczplLmF4aXN9KSx2ZD0oZSx0KT0+e2xldCByPWUuaW5wdXRzO09mKHIpLGUuY29tcHV0ZShEZihlLmlucHV0cyx0KSl9fSk7dmFyIEJmLHhkLFNkLFRkPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO0JmPShlLHQscixuLG8saSxhLGQsbCk9PntsZXQgcD1be3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfV0sbT1baV07cC5wdXNoKC4uLk4odC5kaW1zLG0pKTtsZXQgdT1oPT57bGV0IF89RShcImluZGljZXNfZGF0YVwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCkseT1NKFwiaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhXCIsMTIsMSwxKSxnPVtfLHldLHg9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmF0Y2hfZGltc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJpbnB1dF9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6ci5sZW5ndGh9LHtuYW1lOlwibnVtX3NsaWNlc19wZXJfYmF0Y2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaW5wdXRfYmF0Y2hfc3RyaWRlXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9zbGljZV9kaW1zXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke2gucmVnaXN0ZXJVbmlmb3Jtcyh4KS5kZWNsYXJlVmFyaWFibGVzKC4uLmcpfVxuICAke2gubWFpblN0YXJ0KCl9XG4gICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgYmF0Y2hfaWR4ID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLm51bV9zbGljZXNfcGVyX2JhdGNoO1xuICAgIGxldCBiYXNlX29mZnNldCA9IGJhdGNoX2lkeCAqIHVuaWZvcm1zLmlucHV0X2JhdGNoX3N0cmlkZTtcblxuICAgIGxldCBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm51bV9zbGljZV9kaW1zO1xuICAgIHZhciByZWxhdGl2ZV9zbGljZV9vZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGRpbV9pZHggPSAwdTsgZGltX2lkeCA8IHVuaWZvcm1zLm51bV9zbGljZV9kaW1zOyBkaW1faWR4ICsrKSB7XG4gICAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc19kYXRhW2RpbV9pZHggKyBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0XS54KTtcbiAgICAgIGxldCBpbnB1dF9kaW1faWR4ID0gdW5pZm9ybXMuYmF0Y2hfZGltcyArIGRpbV9pZHg7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICR7by5sZW5ndGg9PT0xP1wiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXMpO1wiOlwiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXNbaW5wdXRfZGltX2lkeF0pO1wifVxuICAgICAgfVxuICAgICAgJHtyLmxlbmd0aD09PTE/XCJyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGEpO1wiOlwicmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ICs9IGluZGV4ICogaTMyKHVuaWZvcm1zLnNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhW2RpbV9pZHhdKTtcIn1cbiAgICB9XG5cbiAgICBpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFbZ2xvYmFsX2lkeF0gPSAgYmFzZV9vZmZzZXQgKyB1MzIocmVsYXRpdmVfc2xpY2Vfb2Zmc2V0KTtcbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJjb21wdXRlU2xpY2VPZmZzZXRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7by5sZW5ndGh9XyR7ci5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6ZS5pbnB1dHNbMV0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6dX0se2lucHV0czpbdF0sb3V0cHV0czpbLTFdfSlbMF19LHhkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHMsbj1yWzBdLmRpbXMsbz1yWzBdLmRhdGFUeXBlLGk9clsxXS5kaW1zLGE9aVtpLmxlbmd0aC0xXSxkPWsuc2l6ZVRvRGltZW5zaW9uKGksaS5sZW5ndGgtMSksbD1rLnNpemVGcm9tRGltZW5zaW9uKG4sdC5iYXRjaERpbXMrYSkscD1rLnNpemVUb0RpbWVuc2lvbihuLHQuYmF0Y2hEaW1zKSxtPWsuc2l6ZUZyb21EaW1lbnNpb24obix0LmJhdGNoRGltcyksdT1kL3AsaD1uZXcgQXJyYXkoYSksXz1sO2ZvcihsZXQgVD0wO1Q8YTsrK1QpaFthLTEtVF09XyxfKj1uW3QuYmF0Y2hEaW1zK2EtMS1UXTtsZXQgeT1CZihlLHJbMV0saCx0LmJhdGNoRGltcyxuLGQsdSxtLGEpLGc9dC5iYXRjaERpbXMrYTtpZihnPm4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGluZGljZXMgbXVzdCBub3QgYmUgbGFyZ2VyIHRoYW4gcmFuayBvZiBpbnB1dCB0ZW5zb3JcIik7bGV0IHg9aS5zbGljZSgwLC0xKS5jb25jYXQobi5zbGljZShnKSksJD1rLnNpemUoeCksdj1be3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOmx9LC4uLk4oclswXS5kaW1zLHkuZGltcyx4KV0sUz1UPT57bGV0IEE9RShcImRhdGFcIixyWzBdLmRhdGFUeXBlLHJbMF0uZGltcy5sZW5ndGgpLEM9RShcInNsaWNlX29mZnNldHNcIiwxMix5LmRpbXMubGVuZ3RoKSxQPU0oXCJvdXRwdXRcIixyWzBdLmRhdGFUeXBlLHgubGVuZ3RoKTtyZXR1cm5gXG4gICAgICAgICAgJHtULnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2xpY2Vfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoQSxDLFApfVxuICAgICAgICAgICAgJHtULm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtULmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICBsZXQgc2xpY2Vfb2Zmc2V0ID0gc2xpY2Vfb2Zmc2V0c1tnbG9iYWxfaWR4IC8gdW5pZm9ybXMuc2xpY2Vfc2l6ZV07XG4gICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZGF0YVt1MzIoc2xpY2Vfb2Zmc2V0KSArIGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkdhdGhlck5EXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOngsZGF0YVR5cGU6b31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKCQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dn0pLGdldFNoYWRlclNvdXJjZTpTfSx7aW5wdXRzOltyWzBdLHldfSl9LFNkPWU9Pih7YmF0Y2hEaW1zOmUuYmF0Y2hfZGltcyxjYWNoZUtleTpcIlwifSl9KTt2YXIgTWYsUmYsSWQsQ2QsQWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtNZj0oZSx0KT0+e2lmKGUubGVuZ3RoPDN8fGUubGVuZ3RoPjQpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyQmxvY2tRdWFudGl6ZWQgcmVxdWlyZXMgMyBvciA0IGlucHV0cy5cIik7bGV0IHI9ay5ub3JtYWxpemVBeGlzKHQucXVhbnRpemVBeGlzLGVbMF0uZGltcy5sZW5ndGgpLG49dC5ibG9ja1NpemUsbz1lWzBdLGk9ZVsyXSxhPWUubGVuZ3RoPT09ND9lWzNdOnZvaWQgMDtpZihpLmRpbXMubGVuZ3RoIT09by5kaW1zLmxlbmd0aHx8IW8uZGltcy5tYXAoKGQsbCk9Pmw9PT1yP01hdGguY2VpbChkL24pPT09aS5kaW1zW2xdOmQ9PT1pLmRpbXNbbF0pLnJlZHVjZSgoZCxsKT0+ZCYmbCwhMCkpdGhyb3cgbmV3IEVycm9yKFwiU2NhbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gZ2F0aGVyQXhpcy5cIik7aWYoYSl7aWYoYS5kYXRhVHlwZSE9PW8uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlIGFzIHRoZSBpbnB1dCB0ZW5zb3IuXCIpO2lmKGEuZGltcy5sZW5ndGghPT1pLmRpbXMubGVuZ3RofHwhYS5kaW1zLm1hcCgoZCxsKT0+ZD09PWkuZGltc1tsXSkucmVkdWNlKChkLGwpPT5kJiZsLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gcXVhbnRpemVBeGlzLlwiKX19LFJmPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVsxXS5kaW1zLG89ci5sZW5ndGgsaT1rLm5vcm1hbGl6ZUF4aXModC5nYXRoZXJBeGlzLG8pLGE9ay5ub3JtYWxpemVBeGlzKHQucXVhbnRpemVBeGlzLG8pLGQ9ci5zbGljZSgwKTtkLnNwbGljZShpLDEsLi4ubik7bGV0IGw9ay5zaXplKGQpLHA9ZVsyXS5kYXRhVHlwZSx1PWVbMF0uZGF0YVR5cGU9PT0yMixoPVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOnQuYmxvY2tTaXplfSwuLi5OKC4uLmUubWFwKCh5LGcpPT55LmRpbXMpLGQpXSxfPXk9PntsZXQgZz1FKFwiZGF0YVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCkseD1FKFwiaW5wdXRJbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSwkPUUoXCJzY2FsZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLHY9ZS5sZW5ndGg+Mz9FKFwiemVyb1BvaW50XCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDAsUz1NKFwib3V0cHV0XCIscCxkLmxlbmd0aCksVD1bZyx4LCRdO3YmJlQucHVzaCh2KTtsZXQgQT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJxdWFudGl6ZV9heGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImdhdGhlcl9heGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJsb2NrX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICAgICAgICR7eS5yZWdpc3RlclVuaWZvcm1zKEEpLmRlY2xhcmVWYXJpYWJsZXMoLi4uVCxTKX1cbiAgICAgICAgJHt5Lm1haW5TdGFydCgpfVxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgIHZhciBpbmRpY2VzX2luZGljZXMgPSAke3gudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgJHsoKCk9Pm4ubGVuZ3RoPjE/YFxuICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke24ubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAke1MuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIGlcIil9O1xuICAgICAgICAgICAgJHt4LmluZGljZXNTZXQoXCJpbmRpY2VzX2luZGljZXNcIixcImlcIixcImluZGV4XCIpfTtcbiAgICAgICAgICB9YDpgaW5kaWNlc19pbmRpY2VzID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXNcIil9O2ApKCl9O1xuICAgICAgICB2YXIgZGF0YV9pbmRpY2VzID0gJHtnLnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5nYXRoZXJfYXhpczsgaSsrKSB7XG4gICAgICAgICAgbGV0IGluZGV4ID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgICAgJHtnLmluZGljZXNTZXQoXCJkYXRhX2luZGljZXNcIixcImlcIixcImluZGV4XCIpfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXhfZnJvbV9pbmRpY2VzID0gJHt4LmdldEJ5SW5kaWNlcyhcImluZGljZXNfaW5kaWNlc1wiKX07XG4gICAgICAgIGlmIChpbmRleF9mcm9tX2luZGljZXMgPCAwKSB7XG4gICAgICAgICAgaW5kZXhfZnJvbV9pbmRpY2VzICs9ICR7cltpXX07XG4gICAgICAgIH1cbiAgICAgICAgJHtnLmluZGljZXNTZXQoXCJkYXRhX2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzXCIsXCJ1MzIoaW5kZXhfZnJvbV9pbmRpY2VzKVwiKX07XG4gICAgICAgIGZvciAodmFyIGkgPSB1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIDE7IGkgPCAke2QubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgICAgbGV0IGluZGV4ID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLGBpICsgJHtuLmxlbmd0aH0gLSAxYCl9O1xuICAgICAgICAgICR7Zy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFfb2Zmc2V0ID0gJHtnLmluZGljZXNUb09mZnNldChcImRhdGFfaW5kaWNlc1wiKX07XG4gICAgICAgIGxldCBkYXRhX2luZGV4ID0gZGF0YV9vZmZzZXQgJSA4O1xuICAgICAgICAvLyBDb252ZXJ0IDQtYml0IHBhY2tlZCBkYXRhIHRvIDgtYml0IHBhY2tlZCBkYXRhLlxuICAgICAgICBsZXQgcGFja2VkXzRiaXRfcXVhbnRpemVkX2RhdGEgPSAke2cuZ2V0QnlPZmZzZXQoXCJkYXRhX29mZnNldCAvIDhcIil9O1xuICAgICAgICBsZXQgcGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEgPSAocGFja2VkXzRiaXRfcXVhbnRpemVkX2RhdGEgPj4gKDQgKiAoZGF0YV9pbmRleCAlIDIpKSkgJiAweDBmMGYwZjBmO1xuICAgICAgICBsZXQgcXVhbnRpemVkX2RhdGFfdmVjID0gJHt1P1widW5wYWNrNHhJOFwiOlwidW5wYWNrNHhVOFwifSh1MzIocGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEpKTtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhID0gcXVhbnRpemVkX2RhdGFfdmVjW2RhdGFfaW5kZXggLyAyXTtcbiAgICAgICAgdmFyIHNjYWxlX2luZGljZXMgPSBkYXRhX2luZGljZXM7XG4gICAgICAgIGxldCBxdWFudGl6ZV9heGlzX2luZGV4ID0gJHskLmluZGljZXNHZXQoXCJkYXRhX2luZGljZXNcIixcInVuaWZvcm1zLnF1YW50aXplX2F4aXNcIil9IC8gdW5pZm9ybXMuYmxvY2tfc2l6ZTtcbiAgICAgICAgJHskLmluZGljZXNTZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5xdWFudGl6ZV9heGlzXCIsXCJxdWFudGl6ZV9heGlzX2luZGV4XCIpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHskLmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O1xuICAgICAgICAkeygoKT0+dj9gXG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGljZXMgPSBzY2FsZV9pbmRpY2VzO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke3YuaW5kaWNlc1RvT2Zmc2V0KFwiemVyb19wb2ludF9pbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSB6ZXJvX3BvaW50X29mZnNldCAlIDg7XG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA9ICR7di5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfb2Zmc2V0IC8gOFwiKX07XG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfOGJpdF96ZXJvX3BvaW50cyA9IChwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA+PiAoNCAqICh6ZXJvX3BvaW50X2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7dT9cInVucGFjazR4SThcIjpcInVucGFjazR4VThcIn0odTMyKHBhY2tlZF84Yml0X3plcm9fcG9pbnRzKSk7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAvIDJdO2A6XCJ2YXIgemVyb19wb2ludCA9IDBcIikoKX07XG4gICAgICAgIGxldCBkZXF1YW50aXplZF9kYXRhID0gJHtFZShwKX0ocXVhbnRpemVkX2RhdGEgLSB6ZXJvX3BvaW50KSAqIHNjYWxlO1xuICAgICAgICAke1Muc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkZXF1YW50aXplZF9kYXRhXCIpfTtcbiAgICB9YH07cmV0dXJue25hbWU6XCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7ZS5maWx0ZXIoKHksZyk9PmchPT0xKS5tYXAoeT0+eS5kaW1zLmpvaW4oXCJfXCIpKS5qb2luKFwiO1wiKX1gLGlucHV0RGVwZW5kZW5jaWVzOkFycmF5LmZyb20oe2xlbmd0aDplLmxlbmd0aH0sKHksZyk9PlwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOnB9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmh9KSxnZXRTaGFkZXJTb3VyY2U6X319LElkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7TWYocix0KSxlLmNvbXB1dGUoUmYoZS5pbnB1dHMsdCkpfSxDZD1lPT5lZSh7YmxvY2tTaXplOmUuYmxvY2tTaXplLGdhdGhlckF4aXM6ZS5nYXRoZXJBeGlzLHF1YW50aXplQXhpczplLnF1YW50aXplQXhpc30pfSk7dmFyIFVmLE5mLGtkLEVkLFBkPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7VWY9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGJlIHJhbmsgPj0gMS5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKX0sTmY9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1lWzBdLmRhdGFUeXBlLG89ci5sZW5ndGgsaT1lWzFdLmRpbXMsYT1lWzFdLmRhdGFUeXBlLGQ9ay5ub3JtYWxpemVBeGlzKHQuYXhpcyxvKSxsPXJbZF0scD1pLnNsaWNlKDApLG09ay5zaXplKHApLHU9RShcImlucHV0XCIsbixvKSxoPUUoXCJpbmRpY2VzSW5wdXRcIixhLGkubGVuZ3RoKSxfPU0oXCJvdXRwdXRcIixuLHAubGVuZ3RoKSx5PVt7dHlwZToxMixkYXRhOm19LHt0eXBlOjYsZGF0YTpsfSx7dHlwZToxMixkYXRhOmR9XTtyZXR1cm4geS5wdXNoKC4uLk4ocixpLHApKSx7bmFtZTpcIkdhdGhlckVsZW1lbnRzXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobS82NCl9LHByb2dyYW1Vbmlmb3Jtczp5fSksZ2V0U2hhZGVyU291cmNlOiQ9PmBcbiAgICAgICR7JC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModSxoLF8pfVxuICAgICAgJHskLm1haW5TdGFydCgpfVxuICAgICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Xy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgdmFyIGlkeCA9ICR7aC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgaWR4ID0gaWR4ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xuICAgICAgfVxuICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7dS50eXBlLmluZGljZXN9KG91dHB1dEluZGljZXMpO1xuICAgICAgJHt1LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpZHgpXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7dS5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIil9O1xuXG4gICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gIH1gfX0sa2Q9ZT0+ZWUoe2F4aXM6ZS5heGlzfSksRWQ9KGUsdCk9PntsZXQgcj1lLmlucHV0cztVZihyKSxlLmNvbXB1dGUoTmYoZS5pbnB1dHMsdCkpfX0pO3ZhciBWZixXZix6ZCxPZCxEZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7YWUoKTtWZj1lPT57aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBudW1iZXIuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsyXS5kaW1zLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZihlWzBdLmRhdGFUeXBlIT09ZVsxXS5kYXRhVHlwZXx8ZS5sZW5ndGg9PT0zJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX0sV2Y9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMuc2xpY2UoKSxuPWVbMV0uZGltcy5zbGljZSgpLFtvLGksYV09TnIuZ2V0U2hhcGVPZkdlbW1SZXN1bHQocix0LnRyYW5zQSxuLHQudHJhbnNCLGUubGVuZ3RoPT09Mz9lWzJdLmRpbXM6dm9pZCAwKSxkPVtvLGldO2lmKCFkKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBsPTE2LHA9TWF0aC5jZWlsKGkvbCksbT1NYXRoLmNlaWwoby9sKSx1PSEwLGg9ay5zaXplKGQpLF89W3t0eXBlOjEyLGRhdGE6dT9wOmh9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEsZGF0YTp0LmFscGhhfSx7dHlwZToxLGRhdGE6dC5iZXRhfV0seT1bXCJ0eXBlXCIsXCJ0eXBlXCJdO2UubGVuZ3RoPT09MyYmKF8ucHVzaCguLi5OKGVbMl0uZGltcykpLHkucHVzaChcInJhbmtcIikpLF8ucHVzaCguLi5OKGQpKTtsZXQgZz0kPT57bGV0IHY9XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/dj1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTtcIjp0LnRyYW5zQSYmIXQudHJhbnNCP3Y9XCJ2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07XCI6IXQudHJhbnNBJiZ0LnRyYW5zQj92PVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYodj1cInZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIik7bGV0IFM9dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IHVuaWZvcm1zLmFscGhhO1wiLFQ9RShcImFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksQT1FKFwiYlwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSxDPVQudHlwZS52YWx1ZSxQPW51bGwsRD1bVCxBXTtlLmxlbmd0aD09PTMmJihQPUUoXCJjXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxELnB1c2goUCkpO2xldCBSPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQubGVuZ3RoKTtELnB1c2goUik7bGV0IEg9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dO3JldHVybmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoSCkuZGVjbGFyZVZhcmlhYmxlcyguLi5EKX1cblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7Q30oMCk7XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICR7dn1cbiAgICB9XG5cbiAgICAke1N9XG4gICAgJHsoKCk9PlAhPW51bGw/YGxldCBjT2Zmc2V0ID0gJHtQLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwidmVjMihtLCBuKVwiLFIpfTsgdmFsdWUgKz0gJHtDfSh1bmlmb3Jtcy5iZXRhKSAqICR7UC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O2A6XCJcIikoKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgfWB9LHg9JD0+e2xldCB2PUUoXCJhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMpLFM9RShcImJcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksVD1udWxsLEE9W3YsU107ZS5sZW5ndGg9PT0zJiYoVD1FKFwiY1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksQS5wdXNoKFQpKTtsZXQgQz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLmxlbmd0aCk7QS5wdXNoKEMpO2xldCBQPVt7bmFtZTpcIm51bV90aWxlX25cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dLEQ9XCJcIixSPVwiXCI7dC50cmFuc0EmJnQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTp0LnRyYW5zQSYmIXQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO1wiKTohdC50cmFuc0EmJnQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5NKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2xvY2FsX2lkLnldW2tdICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTohdC50cmFuc0EmJiF0LnRyYW5zQiYmKFI9YFxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuTiArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1MudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEQ9XCJ2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07XCIpO2xldCBIPXQuYWxwaGE9PT0xP1wiXCI6XCJ2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTtcIjtyZXR1cm5gXG4gICR7JC5yZWdpc3RlclVuaWZvcm1zKFApLmRlY2xhcmVWYXJpYWJsZXMoLi4uQSl9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYTogYXJyYXk8YXJyYXk8JHt2LnR5cGUuc3RvcmFnZX0sICR7bH0+LCAke2x9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZV9iOiBhcnJheTxhcnJheTwke1MudHlwZS5zdG9yYWdlfSwgJHtsfT4sICR7bH0+O1xuICAkeyQubWFpblN0YXJ0KFtsLGwsMV0pfVxuICAgIGxldCB0aWxlX2NvbF9zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7bH07XG4gICAgbGV0IHRpbGVfcm93X3N0YXJ0ID0gKHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLm51bV90aWxlX24pICogJHtsfTtcbiAgICBsZXQgbnVtX3RpbGVzID0gKHVuaWZvcm1zLksgLSAxKSAvICR7bH0gKyAxO1xuICAgIHZhciBrX3N0YXJ0ID0gMHU7XG4gICAgdmFyIHZhbHVlID0gJHtDLnR5cGUudmFsdWV9KDApO1xuICAgIGZvciAodmFyIHQ6IHUzMiA9IDB1OyB0IDwgbnVtX3RpbGVzOyB0KyspIHtcbiAgICAgICR7Un1cbiAgICAgIGtfc3RhcnQgPSBrX3N0YXJ0ICsgJHtsfTtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCAke2x9OyBrKyspIHtcbiAgICAgICAgJHtEfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgICR7SH1cbiAgICBsZXQgbSA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICBsZXQgbiA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAkeygoKT0+VCE9bnVsbD9gbGV0IGNPZmZzZXQgPSAke1QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJ2ZWMyKG0sIG4pXCIsQyl9OyB2YWx1ZSArPSAke0MudHlwZS52YWx1ZX0odW5pZm9ybXMuYmV0YSkgKiAke1QuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtgOlwiXCIpKCl9XG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBvdXRwdXRbbSAqIHVuaWZvcm1zLk4gKyBuXSA9IHZhbHVlO1xuICAgIH1cbiAgfWB9O3JldHVybiB1P3tuYW1lOlwiR2VtbVNoYXJlZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczp5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6cCptfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTp4fTp7bmFtZTpcIkdlbW1cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6eX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChoLzY0KX0scHJvZ3JhbVVuaWZvcm1zOl99KSxnZXRTaGFkZXJTb3VyY2U6Z319LHpkPWU9PntsZXQgdD1lLnRyYW5zQSxyPWUudHJhbnNCLG49ZS5hbHBoYSxvPWUuYmV0YTtyZXR1cm57dHJhbnNBOnQsdHJhbnNCOnIsYWxwaGE6bixiZXRhOm8sY2FjaGVLZXk6YCR7ZS50cmFuc0F9OyR7ZS50cmFuc0J9OyR7ZS5hbHBoYT09PTF9YH19LE9kPShlLHQpPT57VmYoZS5pbnB1dHMpLGUuY29tcHV0ZShXZihlLmlucHV0cyx0KSl9fSk7dmFyIGx0LF90LE50LFZ0LExmLEdmLEhmLEZmLHFmLEtmLGpmLFlmLEJkLE1kLFJkPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7W2x0LF90LE50LFZ0XT1bMCwxLDIsM10sTGY9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcIm9ubHkgNC1EIHRlbnNvciBpcyBzdXBwb3J0ZWQuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImlucHV0IGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCB0byBncmlkIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zLmxlbmd0aC0yIT09ZVsxXS5kaW1zW2VbMV0uZGltcy5sZW5ndGgtMV0pdGhyb3cgbmV3IEVycm9yKGBsYXN0IGRpbWVuc2lvbiBvZiBncmlkIG11c3QgYmUgZXF1YWwgdG8gJHtlWzBdLmRpbXMubGVuZ3RoLTJ9YCk7aWYoZVswXS5kaW1zWzBdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImdyaWQgYmF0Y2ggc2l6ZSBtdXN0IG1hdGNoIGlucHV0IGJhdGNoIHNpemVcIil9LEdmPWBcbiAgZm4gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4OiBmMzIpIC0+IHZlYzQ8ZjMyPiB7XG4gICAgbGV0IGN1YmljX2FscGhhID0gLTAuNzVmO1xuICAgIGxldCB4X2FicyA9IGFicyh4KTtcbiAgICB2YXIgY29lZmZzOiB2ZWM0PGYzMj47XG4gICAgY29lZmZzWzBdID0gKCgoY3ViaWNfYWxwaGEgKiAoeF9hYnMgKyAxKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoeF9hYnMgKyAxKSArIDggKiBjdWJpY19hbHBoYSkgKiAoeF9hYnMgKyAxKSAtIDQgKiBjdWJpY19hbHBoYSk7XG4gICAgY29lZmZzWzFdID0gKCgoY3ViaWNfYWxwaGEgKyAyKSAqIHhfYWJzIC0gKGN1YmljX2FscGhhICsgMykpICogeF9hYnMgKiB4X2FicyArIDEpO1xuICAgIGNvZWZmc1syXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiAoMSAtIHhfYWJzKSAtIChjdWJpY19hbHBoYSArIDMpKSAqICgxIC0geF9hYnMpICogKDEgLSB4X2FicykgKyAxKTtcbiAgICBjb2VmZnNbM10gPSAoKChjdWJpY19hbHBoYSAqICgyIC0geF9hYnMpIC0gNSAqIGN1YmljX2FscGhhKSAqICgyIC0geF9hYnMpICsgOCAqIGN1YmljX2FscGhhKSAqICgyIC0geF9hYnMpIC0gNCAqIGN1YmljX2FscGhhKTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5gLEhmPWU9PmBcbiAgZm4gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwOiBtYXQ0eDQ8JHtlfT4sIHg6IGYzMiwgeTogZjMyKSAtPiAke2V9IHtcbiAgICB2YXIgdjogdmVjNDxmMzI+O1xuICAgIHZhciBjb2VmZnMgPSBnc19nZXRfY3ViaWNfY29lZmZzKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICB2W2ldID0gY29lZmZzWzBdICogcFtpXVswXSArIGNvZWZmc1sxXSAqIHBbaV1bMV0gKyBjb2VmZnNbMl0gKiBwW2ldWzJdICsgY29lZmZzWzNdICogcFtpXVszXTtcbiAgICB9XG4gICAgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh5KTtcbiAgICBsZXQgcGl4ZWwgPSAke2V9KGNvZWZmc1swXSAqIHZbMF0gKyBjb2VmZnNbMV0gKiB2WzFdICsgY29lZmZzWzJdICogdlsyXSArIGNvZWZmc1szXSAqIHZbM10pO1xuICAgIHJldHVybiBwaXhlbDtcbiAgfVxuYCxGZj1lPT5gXG4gIGZuIGdzX2Rlbm9ybWFsaXplKG46IGYzMiwgbGVuZ3RoOiBpMzIpIC0+IGYzMiB7XG4gICAgJHtlLmFsaWduQ29ybmVycz09PTA/YFxuICAgIC8vIGFsaWduQ29ybmVyczogZmFsc2UgPT4gWy0xLCAxXSB0byBbLTAuNSwgbGVuZ3RoIC0gMC41XVxuICAgIHJldHVybiAoKG4gKyAxLjApICogZjMyKGxlbmd0aCkgLSAxLjApIC8gMi4wO1xuICAgIGA6YFxuICAgIC8vIGFsaWduQ29ybmVyczogdHJ1ZSA9PiBbLTEsIDFdIHRvIFswLCBsZW5ndGggLSAxXVxuICAgIHJldHVybiAobiArIDEuMCkgLyAyLjAgKiAoZjMyKGxlbmd0aCAtIDEpKTtcbiAgICBgfVxuICB9XG5gLHFmPWU9PmBcbiAgJHtlLnBhZGRpbmdNb2RlPT09XCJyZWZsZWN0aW9uXCI/YFxuICAgICAgZm4gZ3NfcmVmbGVjdCh4OiBpMzIsIHhfbWluOiBmMzIsIHhfbWF4OiBmMzIpIC0+IHUzMiB7XG4gICAgICAgIHZhciBkeCA9IDAuMDtcbiAgICAgICAgdmFyIGZ4ID0gZjMyKHgpO1xuICAgICAgICBsZXQgcmFuZ2UgPSB4X21heCAtIHhfbWluO1xuICAgICAgICBpZiAoZnggPCB4X21pbikge1xuICAgICAgICAgIGR4ID0geF9taW4gLSBmeDtcbiAgICAgICAgICBsZXQgbiA9IHUzMihkeCAvIHJhbmdlKTtcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcbiAgICAgICAgICAgIGZ4ID0geF9taW4gKyByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnggPiB4X21heCkge1xuICAgICAgICAgIGR4ID0gZnggLSB4X21heDtcbiAgICAgICAgICBsZXQgbiA9IHUzMihkeCAvIHJhbmdlKTtcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcbiAgICAgICAgICAgIGZ4ID0geF9tYXggLSByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUzMihmeCk7XG4gICAgICB9YDpcIlwifVxuYCxLZj0oZSx0LHIpPT5gXG4gIGZuIHBpeGVsX2F0X2dyaWQocjogaTMyLCBjOiBpMzIsIEg6IGkzMiwgVzogaTMyLCBiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGJvcmRlcjogdmVjNDxmMzI+KSAtPiAke3R9IHtcbiAgICAgdmFyIHBpeGVsID0gJHt0fSgwKTtcbiAgICAgdmFyIGluZGljZXMgPSB2ZWM0PHUzMj4oMCk7XG4gICAgIGluZGljZXNbJHtsdH1dID0gYmF0Y2g7XG4gICAgIGluZGljZXNbJHtfdH1dID0gY2hhbm5lbDtgKygoKT0+e3N3aXRjaChyLnBhZGRpbmdNb2RlKXtjYXNlXCJ6ZXJvc1wiOnJldHVybmBcbiAgICAgICAgICBpZiAociA+PSAwICYmIHIgPCBIICYmIGMgPj0wICYmIGMgPCBXKSB7XG4gICAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IHUzMihyKTtcbiAgICAgICAgICAgIGluZGljZXNbJHtWdH1dID0gdTMyKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtjYXNlXCJib3JkZXJcIjpyZXR1cm5gXG4gICAgICAgICAgaW5kaWNlc1ske050fV0gPSB1MzIoY2xhbXAociwgMCwgSCAtIDEpKTtcbiAgICAgICAgICBpbmRpY2VzWyR7VnR9XSA9IHUzMihjbGFtcChjLCAwLCBXIC0gMSkpO1xuICAgICAgICBgO2Nhc2VcInJlZmxlY3Rpb25cIjpyZXR1cm5gXG4gICAgICAgICAgaW5kaWNlc1ske050fV0gPSBnc19yZWZsZWN0KHIsIGJvcmRlclsxXSwgYm9yZGVyWzNdKTtcbiAgICAgICAgICBpbmRpY2VzWyR7VnR9XSA9IGdzX3JlZmxlY3QoYywgYm9yZGVyWzBdLCBib3JkZXJbMl0pO1xuICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nIG1vZGUgJHtyLnBhZGRpbmdNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStgXG4gICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpfTtcbiAgfVxuYCxqZj0oZSx0LHIpPT4oKCk9Pntzd2l0Y2goci5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxuICAgICAgICAgIGxldCByZXN1bHQgPSBwaXhlbF9hdF9ncmlkKGkzMihyb3VuZCh5KSksIGkzMihyb3VuZCh4KSksIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgYDtjYXNlXCJiaWxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICBsZXQgeDEgPSBpMzIoZmxvb3IoeCkpO1xuICAgICAgICAgIGxldCB5MSA9IGkzMihmbG9vcih5KSk7XG4gICAgICAgICAgbGV0IHgyID0geDEgKyAxO1xuICAgICAgICAgIGxldCB5MiA9IHkxICsgMTtcblxuICAgICAgICAgIGxldCBwMTEgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtfdH1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMTIgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtfdH1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMjEgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtfdH1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMjIgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtfdH1dLCBib3JkZXIpO1xuXG4gICAgICAgICAgbGV0IGR4MiA9ICR7dH0oZjMyKHgyKSAtIHgpO1xuICAgICAgICAgIGxldCBkeDEgPSAke3R9KHggLSBmMzIoeDEpKTtcbiAgICAgICAgICBsZXQgZHkyID0gJHt0fShmMzIoeTIpIC0geSk7XG4gICAgICAgICAgbGV0IGR5MSA9ICR7dH0oeSAtIGYzMih5MSkpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBkeTIgKiAoZHgyICogcDExICsgZHgxICogcDEyKSArIGR5MSAqIChkeDIgKiBwMjEgKyBkeDEgKiBwMjIpO1xuICAgICAgICBgO2Nhc2VcImJpY3ViaWNcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHgwID0gaTMyKGZsb29yKHgpKSAtIDE7XG4gICAgICAgICAgbGV0IHkwID0gaTMyKGZsb29yKHkpKSAtIDE7XG4gICAgICAgICAgdmFyIHA6IG1hdDR4NDwke3R9PjtcbiAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IDQ7IGgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCA0OyB3KyspIHtcbiAgICAgICAgICAgICAgcFtoXVt3XSA9IHBpeGVsX2F0X2dyaWQoaCArIHkwLCB3ICsgeDAsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgZHggPSB4IC0gZjMyKHgwICsgMSk7XG4gICAgICAgICAgbGV0IGR5ID0geSAtIGYzMih5MCArIDEpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBnc19iaWN1YmljX2ludGVycG9sYXRlKHAsIGR4LCBkeSk7XG4gICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG1vZGUgJHtyLm1vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK2Ake2Uuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJyZXN1bHRcIil9YCxZZj0oZSx0KT0+e2xldCByPUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSxuPVtlWzFdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXV0sbz1FKFwiZ3JpZFwiLGVbMV0uZGF0YVR5cGUsbi5sZW5ndGgsMiksaT1bZVswXS5kaW1zWzBdLGVbMF0uZGltc1sxXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdXTt0LmZvcm1hdD09PVwiTkhXQ1wiJiYoaT1bZVswXS5kaW1zWzBdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl0sZVswXS5kaW1zWzNdXSxbbHQsX3QsTnQsVnRdPVswLDMsMSwyXSk7bGV0IGE9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsaS5sZW5ndGgpLGQ9ci50eXBlLnZhbHVlLGw9ay5zaXplKGkpLHA9W3t0eXBlOjEyLGRhdGE6bH0sLi4uTihlWzBdLmRpbXMsbixpKV0sbT11PT5gXG4gICR7dS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMocixvLGEpfVxuICAke0dmfVxuICAke0hmKGQpfVxuICAke0ZmKHQpfVxuICAke3FmKHQpfVxuICAke0tmKHIsZCx0KX1cblxuICAke3UubWFpblN0YXJ0KCl9XG4gICAgJHt1Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBIX2luID0gaTMyKHVuaWZvcm1zLnhfc2hhcGVbJHtOdH1dKTtcbiAgICAgIGxldCBXX2luID0gaTMyKHVuaWZvcm1zLnhfc2hhcGVbJHtWdH1dKTtcblxuICAgICAgJHt0LmFsaWduQ29ybmVycz09PTA/YFxuICAgICAgbGV0IHhfbWluID0gLTAuNTtcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDAuNTtcbiAgICAgIGxldCB5X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAwLjU7XG4gICAgICBgOmBcbiAgICAgIGxldCB4X21pbiA9IDAuMDtcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDEuMDtcbiAgICAgIGxldCB5X21pbiA9IDAuMDtcbiAgICAgIGxldCB5X21heCA9IGYzMihIX2luKSAtIDEuMDtcbiAgICAgIGB9O1xuICAgICAgbGV0IGJvcmRlciA9IHZlYzQ8ZjMyPih4X21pbiwgeV9taW4sIHhfbWF4LCB5X21heCk7XG5cbiAgICAgIGxldCBpbmRpY2VzID0gJHthLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgdmFyIGdyaWRfaW5kaWNlcyA9IHZlYzM8dTMyPihpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske050fV0sIGluZGljZXNbJHtWdH1dKTtcbiAgICAgIGxldCBueHkgPSAke28uZ2V0QnlJbmRpY2VzKFwiZ3JpZF9pbmRpY2VzXCIpfTtcbiAgICAgIHZhciB4ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVswXSksIFdfaW4pO1xuICAgICAgdmFyIHkgPSBnc19kZW5vcm1hbGl6ZShmMzIobnh5WzFdKSwgSF9pbik7XG5cbiAgICAgICR7amYoYSxkLHQpfVxuICB9YDtyZXR1cm57bmFtZTpcIkdyaWRTYW1wbGVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTp1PT57bGV0IGg9ay5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOnVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChoLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9fSxnZXRTaGFkZXJTb3VyY2U6bX19LEJkPShlLHQpPT57TGYoZS5pbnB1dHMpLGUuY29tcHV0ZShZZihlLmlucHV0cyx0KSl9LE1kPWU9PmVlKHthbGlnbkNvcm5lcnM6ZS5hbGlnbl9jb3JuZXJzLG1vZGU6ZS5tb2RlLHBhZGRpbmdNb2RlOmUucGFkZGluZ19tb2RlLGZvcm1hdDplLmZvcm1hdH0pfSk7dmFyIE1lLFhmLE5kLFVkLEpmLGVyLFZkLHhvPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO1VyKCk7SHIoKTthZSgpO2R0KCk7TWU9KGUsdCk9PmUubGVuZ3RoPnQmJmVbdF0uZGltcy5sZW5ndGg+MD9lW3RdOnZvaWQgMCxYZj0oZSx0KT0+e2xldCByPWVbMF0sbj1NZShlLDEpLG89TWUoZSwyKSxpPU1lKGUsMyksYT1NZShlLDQpLGQ9TWUoZSw1KSxsPU1lKGUsNikscD1NZShlLDcpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zXCIpO2xldCBtPXIuZGltc1swXSx1PXIuZGltc1sxXSxoPXIuZGltcy5sZW5ndGg9PT0zP3IuZGltc1syXTp0Lm51bUhlYWRzKnIuZGltc1s0XSxfPXUseT0wLGc9MCx4PU1hdGguZmxvb3IoaC90Lm51bUhlYWRzKTtpZihsJiZwJiZrLnNpemUobC5kaW1zKSYmay5zaXplKHAuZGltcykpe2lmKGwuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYobC5kaW1zWzBdIT09bXx8bC5kaW1zWzFdIT09dC5udW1IZWFkc3x8bC5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO2lmKHAuZGltc1swXSE9PW18fHAuZGltc1sxXSE9PXQubnVtSGVhZHN8fHAuZGltc1szXSE9PXgpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO2lmKGwuZGltc1syXSE9PXAuZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChwYXN0X3NlcXVlbmNlX2xlbmd0aCknKTtpZihwLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7eT1sLmRpbXNbMl0sZz1sLmRpbXNbMl19ZWxzZSBpZihsJiZrLnNpemUobC5kaW1zKXx8cCYmay5zaXplKHAuZGltcykpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO2xldCAkO2lmKG4mJmsuc2l6ZShuLmRpbXMpPjApe2lmKHIuZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7aWYobi5kaW1zLmxlbmd0aDwzfHxuLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7aWYoci5kaW1zWzBdIT09bi5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtpZihuLmRpbXMubGVuZ3RoPT09Myl7aWYobi5kaW1zWzJdIT09ci5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAoaGlkZGVuX3NpemUpJyk7JD0yLF89bi5kaW1zWzFdfWVsc2UgaWYobi5kaW1zLmxlbmd0aD09PTUpe2lmKG4uZGltc1syXSE9PXQubnVtSGVhZHN8fG4uZGltc1szXSE9PTJ8fG4uZGltc1s0XSE9PXgpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO2lmKG8pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpOyQ9NSxfPW4uZGltc1sxXX1lbHNle2lmKG4uZGltc1sxXSE9PXQubnVtSGVhZHN8fG4uZGltc1szXSE9PXgpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7JD0wLF89bi5kaW1zWzJdfX1lbHNle2lmKHIuZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNSBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGVtcHR5Jyk7aWYoci5kaW1zWzJdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTskPTN9aWYoaSYmay5zaXplKGkuZGltcyk+MCl7aWYoaS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uJyk7aWYobiYmbi5kaW1zLmxlbmd0aD09PTUmJm4uZGltc1szXT09PTIpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBub3QgYWxsb3dlZCBmb3IgcGFja2VkIGt2LlwiKX1sZXQgdj15K18sUz0wO2lmKGEmJmsuc2l6ZShhLmRpbXMpPjApe1M9ODtsZXQgUD1hLmRpbXM7dGhyb3cgUC5sZW5ndGg9PT0xP1BbMF09PT1tP1M9MTpQWzBdPT09MyptKzImJihTPTMpOlAubGVuZ3RoPT09MiYmUFswXT09PW0mJlBbMV09PT12JiYoUz01KSxTPT09OD9uZXcgRXJyb3IoJ0lucHV0IFwia2V5X3BhZGRpbmdfbWFza1wiIHNoYXBlIHNoYWxsIGJlIChiYXRjaF9zaXplKSBvciAoYmF0Y2hfc2l6ZSwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpOm5ldyBFcnJvcihcIk1hc2sgbm90IHN1cHBvcnRlZFwiKX1sZXQgVD0hMSxBPWg7aWYobyYmay5zaXplKG8uZGltcyk+MCl7aWYoby5kaW1zLmxlbmd0aCE9PTMmJm8uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1vLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7aWYoby5kaW1zLmxlbmd0aD09PTMpe2lmKF8hPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzJdfWVsc2V7aWYoXyE9PW8uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMV0qby5kaW1zWzNdLFQ9ITB9fWxldCBDPSExO2lmKGEmJmsuc2l6ZShhLmRpbXMpPjApdGhyb3cgbmV3IEVycm9yKFwiS2V5IHBhZGRpbmcgbWFzayBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGQmJmsuc2l6ZShkLmRpbXMpPjApe2lmKGQuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJhdHRlbnRpb25fYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoZC5kaW1zWzBdIT09bXx8ZC5kaW1zWzFdIT09dC5udW1IZWFkc3x8ZC5kaW1zWzJdIT09dXx8ZC5kaW1zWzNdIT09dil0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyl9cmV0dXJue2JhdGNoU2l6ZTptLHNlcXVlbmNlTGVuZ3RoOnUscGFzdFNlcXVlbmNlTGVuZ3RoOnksa3ZTZXF1ZW5jZUxlbmd0aDpfLHRvdGFsU2VxdWVuY2VMZW5ndGg6dixtYXhTZXF1ZW5jZUxlbmd0aDpnLGlucHV0SGlkZGVuU2l6ZTowLGhpZGRlblNpemU6aCx2SGlkZGVuU2l6ZTpBLGhlYWRTaXplOngsdkhlYWRTaXplOk1hdGguZmxvb3IoQS90Lm51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGlzVW5pZGlyZWN0aW9uYWw6ITEscGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohMSxtYXNrRmlsdGVyVmFsdWU6dC5tYXNrRmlsdGVyVmFsdWUsbWFza1R5cGU6UyxzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6QyxwYXNzUGFzdEluS3Y6VCxxa3ZGb3JtYXQ6JH19LE5kPWU9PmVlKHsuLi5lfSksVWQ9ZWUoe3Blcm06WzAsMiwxLDNdfSksSmY9KGUsdCxyLG4sbyxpLGEpPT57bGV0IGQ9W24sbyxpXSxsPWsuc2l6ZShkKSxwPVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTppfV0sbT11PT57bGV0IGg9TShcInFrdl93aXRoX2JpYXNcIix0LmRhdGFUeXBlLGQpLF89RShcInFrdlwiLHQuZGF0YVR5cGUsZCkseT1FKFwiYmlhc1wiLHIuZGF0YVR5cGUsZCksZz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJiaWFzX29mZnNldFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgJHt1LnJlZ2lzdGVyVW5pZm9ybXMoZykuZGVjbGFyZVZhcmlhYmxlcyhfLHksaCl9XG4gICR7dS5tYWluU3RhcnQoKX1cbiAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBiaWFzX29mZnNldF9pZHggPSAoZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLmhpZGRlbl9zaXplKSArIHVuaWZvcm1zLmJpYXNfb2Zmc2V0O1xuXG4gICAgcWt2X3dpdGhfYmlhc1tnbG9iYWxfaWR4XSA9IHFrdltnbG9iYWxfaWR4XSArIGJpYXNbYmlhc19vZmZzZXRfaWR4XTtcbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJNdWx0aUhlYWRBdHRlbnRpb25BZGRCaWFzXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6bX0se2lucHV0czpbdCxyXSxvdXRwdXRzOlstMV19KVswXX0sZXI9KGUsdCxyLG4sbyxpLGEsZCk9PntsZXQgbD1pO2lmKGEmJmsuc2l6ZShhLmRpbXMpPjApe2lmKG49PT0xKXRocm93IG5ldyBFcnJvcihcIkFkZEJpYXNSZXNoYXBlIGlzIG5vdCBpbXBsZW1lbnRlZC4gUGxlYXNlIGV4cG9ydCB5b3VyIG1vZGVsIHdpdGggcGFja2VkIFFLViBvciBLVlwiKTtyZXR1cm4gbD1KZihlLGksYSx0LG4scipvLGQpLGw9bC5yZXNoYXBlKFt0LG4scixvXSkscj09PTF8fG49PT0xP2w6ZS5jb21wdXRlKFBlKGwsVWQucGVybSkse2lucHV0czpbbF0sb3V0cHV0czpbLTFdfSlbMF19ZWxzZSByZXR1cm4gaS5kaW1zLmxlbmd0aD09PTMmJihsPWkucmVzaGFwZShbdCxuLHIsb10pKSxyPT09MXx8bj09PTE/bDplLmNvbXB1dGUoUGUobCxVZC5wZXJtKSx7aW5wdXRzOltsXSxvdXRwdXRzOlstMV19KVswXX0sVmQ9KGUsdCk9PntsZXQgcj1YZihlLmlucHV0cyx0KSxuPWUuaW5wdXRzWzBdLG89TWUoZS5pbnB1dHMsMSksaT1NZShlLmlucHV0cywyKSxhPU1lKGUuaW5wdXRzLDMpLGQ9TWUoZS5pbnB1dHMsNCksbD1NZShlLmlucHV0cyw1KSxwPU1lKGUuaW5wdXRzLDYpLG09TWUoZS5pbnB1dHMsNyk7aWYobi5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIFFLViBpcyBub3QgaW1wbGVtZW50ZWRcIik7aWYobz8uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBLViBpcyBub3QgaW1wbGVtZW50ZWRcIik7bGV0IHU9byYmaSYmby5kaW1zLmxlbmd0aD09PTQmJmkuZGltcy5sZW5ndGg9PT00LGg9ZXIoZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIuc2VxdWVuY2VMZW5ndGgsci5oZWFkU2l6ZSxuLGEsMCk7aWYodSlyZXR1cm4gVXQoZSxoLG8saSxkLHZvaWQgMCxwLG0sbCxyKTtpZighb3x8IWkpdGhyb3cgbmV3IEVycm9yKFwia2V5IGFuZCB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkXCIpO2xldCBfPWVyKGUsci5iYXRjaFNpemUsci5udW1IZWFkcyxyLmt2U2VxdWVuY2VMZW5ndGgsci5oZWFkU2l6ZSxvLGEsci5oaWRkZW5TaXplKSx5PWVyKGUsci5iYXRjaFNpemUsci5udW1IZWFkcyxyLmt2U2VxdWVuY2VMZW5ndGgsci52SGVhZFNpemUsaSxhLDIqci5oaWRkZW5TaXplKTtVdChlLGgsXyx5LGQsdm9pZCAwLHAsbSxsLHIpfX0pO3ZhciBlaCx0aCxyaCxuaCxTbyxXZCxMZCxUbz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTthZSgpO2VoPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKX0sdGg9KGUsdCk9PntsZXQgcj1bXSxuPXQubnVtT3V0cHV0cztyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJihlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG89PnIucHVzaChOdW1iZXIobykpKSxuPXIubGVuZ3RoKSxlZSh7bnVtT3V0cHV0czpuLGF4aXM6dC5heGlzLHNwbGl0U2l6ZXM6cn0pfSxyaD1lPT5gXG5mbiBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfXU7IGkgKz0gMXUgKSB7XG4gICAgaWYgKGluZGV4IDwgJHtxKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJpXCIsZSl9KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7ZX11O1xufWAsbmg9ZT0+e2xldCB0PWUubGVuZ3RoLHI9W107Zm9yKGxldCBuPTA7bjx0Oysrbil7bGV0IG89ZVtuXS5zZXRCeUluZGljZXMoXCJpbmRpY2VzXCIsXCJpbnB1dFtnbG9iYWxfaWR4XVwiKTt0PT09MT9yLnB1c2gobyk6bj09PTA/ci5wdXNoKGBpZiAob3V0cHV0X251bWJlciA9PSAke259dSkgeyAke299IH1gKTpuPT09dC0xP3IucHVzaChgZWxzZSB7ICR7b30gfWApOnIucHVzaChgZWxzZSBpZiAob3V0cHV0X251bWJlciA9PSAke259KSB7ICR7b30gfWApfXJldHVybmBcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyOiB1MzIsIGluZGljZXM6ICR7ZVswXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcbiAgICAgICAgJHtyLmpvaW4oYFxuYCl9XG4gICAgICB9YH0sU289KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1rLnNpemUociksbz1lWzBdLmRhdGFUeXBlLGk9ay5ub3JtYWxpemVBeGlzKHQuYXhpcyxyLmxlbmd0aCksYT1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxkPUUoXCJpbnB1dFwiLG8sci5sZW5ndGgpLGw9bmV3IEFycmF5KHQubnVtT3V0cHV0cykscD1bXSxtPVtdLHU9MCxoPVt7dHlwZToxMixkYXRhOm59XTtmb3IobGV0IHk9MDt5PHQubnVtT3V0cHV0czt5Kyspe3UrPXQuc3BsaXRTaXplc1t5XSxsW3ldPXU7bGV0IGc9ci5zbGljZSgpO2dbaV09dC5zcGxpdFNpemVzW3ldLG0ucHVzaChnKSxhW3ldPU0oYG91dHB1dCR7eX1gLG8sZy5sZW5ndGgpLHAucHVzaCh7ZGltczptW3ldLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KX1oLnB1c2goe3R5cGU6MTIsZGF0YTpsfSwuLi5OKHIsLi4ubSkpO2xldCBfPXk9PmBcbiAgJHt5LnJlZ2lzdGVyVW5pZm9ybShcImlucHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzaXplX2luX3NwbGl0X2F4aXNcIixcInUzMlwiLGwubGVuZ3RoKS5kZWNsYXJlVmFyaWFibGVzKGQsLi4uYSl9XG4gICR7cmgobC5sZW5ndGgpfVxuICAke25oKGEpfVxuXG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLmlucHV0X3NpemVcIil9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICB2YXIgaW5kZXggPSAke2QuaW5kaWNlc0dldChcImluZGljZXNcIixpKX07XG4gICAgbGV0IG91dHB1dF9udW1iZXIgPSBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleCk7XG4gICAgaWYgKG91dHB1dF9udW1iZXIgIT0gMCkge1xuICAgICAgaW5kZXggLT0gJHtxKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJvdXRwdXRfbnVtYmVyIC0gMXVcIixsLmxlbmd0aCl9O1xuICAgICAgJHtkLmluZGljZXNTZXQoXCJpbmRpY2VzXCIsaSxcImluZGV4XCIpfTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xuICB9YDtyZXR1cm57bmFtZTpcIlNwbGl0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6XyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6cCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmh9KX19LFdkPShlLHQpPT57ZWgoZS5pbnB1dHMpO2xldCByPWUuaW5wdXRzLmxlbmd0aD09PTE/dDp0aChlLmlucHV0cyx0KTtlLmNvbXB1dGUoU28oZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sTGQ9ZT0+e2xldCB0PWUuYXhpcyxyPWUuc3BsaXRTaXplcyxuPWUubnVtT3V0cHV0czwwP3IubGVuZ3RoOmUubnVtT3V0cHV0cztpZihuIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5naCBtdXN0IGJlIGVxdWFsXCIpO3JldHVybiBlZSh7YXhpczp0LG51bU91dHB1dHM6bixzcGxpdFNpemVzOnJ9KX19KTt2YXIgb2gsaWgsR2QsSGQsRmQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3hlKCk7SHIoKTt4bygpO1RvKCk7ZHQoKTtvaD0oZSx0KT0+e2lmKHQuZG9Sb3RhcnkpdGhyb3cgbmV3IEVycm9yKFwiR3JvdXBRdWVycnlBdHRlbnRpb24gZG9fcm90YXJ5IGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuZG9Sb3RhcnkmJmUubGVuZ3RoPD03KXRocm93IG5ldyBFcnJvcihcImNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGlucHV0cyBhcmUgcmVxdWlyZWQgaWYgZG9fcm90YXJ5IGlzIHNwZWNpZmllZFwiKTtsZXQgcj1lWzBdLG49ZVsxXSxvPWVbMl0saT1lWzNdLGE9ZVs0XTtpZih0LmxvY2FsV2luZG93U2l6ZSE9PS0xKXRocm93IG5ldyBFcnJvcihcIkxvY2FsIGF0dGVudGlvbiBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc29mdGNhcCE9PTApdGhyb3cgbmV3IEVycm9yKFwiU29mdGNhcCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQucm90YXJ5SW50ZXJsZWF2ZWQhPT0wKXRocm93IG5ldyBFcnJvcihcIlJvdGFyeSBpbnRlcmxlYXZlZCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc21vb3RoU29mdG1heCl0aHJvdyBuZXcgRXJyb3IoXCJTbW9vdGggc29mdG1heCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zXCIpO2xldCBkPSExLGw9ci5kaW1zWzBdLHA9ci5kaW1zWzFdLG09ci5kaW1zLmxlbmd0aD09PTM/ZD9yLmRpbXNbMl0vMzpyLmRpbXNbMl06dC5udW1IZWFkcypyLmRpbXNbNF0sdT1wLGg9MCxfPSFufHxuLmRpbXMubGVuZ3RoPT09MCx5PU1hdGguZmxvb3IoXz9tLyh0Lm51bUhlYWRzKzIqdC5rdk51bUhlYWRzKTptL3QubnVtSGVhZHMpO18mJihtPXkqdC5udW1IZWFkcyk7bGV0IGc9aSYmaS5kaW1zLmxlbmd0aCE9PTAseD1hJiZhLmRpbXMubGVuZ3RoIT09MDtpZihnJiZpLmRpbXMubGVuZ3RoPT09NCYmaS5kaW1zWzBdPT09bCYmaS5kaW1zWzFdIT09dC5rdk51bUhlYWRzJiZpLmRpbXNbMl09PT10Lmt2TnVtSGVhZHMmJmkuZGltc1szXT09PXkpdGhyb3cgbmV3IEVycm9yKFwiQlNOSCBwYXN0S2V5L3Bhc3RWYWx1ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGcmJngpe2lmKGkuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoYS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2g9aS5kaW1zWzJdfWVsc2UgaWYoZ3x8eCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0IHY9MTtpZihuJiZuLmRpbXMubGVuZ3RoPjApe2lmKHIuZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7aWYobi5kaW1zLmxlbmd0aDwzfHxuLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7aWYoci5kaW1zWzBdIT09bi5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtpZihuLmRpbXMubGVuZ3RoPT09Myl7aWYoci5kaW1zWzJdJW4uZGltc1syXSE9PTApdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gMiBvZiBcInF1ZXJ5XCIgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgXCJrZXlcIicpO3U9bi5kaW1zWzFdfWVsc2UgaWYobi5kaW1zLmxlbmd0aD09PTUpe2lmKG4uZGltc1syXSE9PXQubnVtSGVhZHN8fG4uZGltc1szXSE9PTJ8fG4uZGltc1s0XSE9PXkpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO2lmKG8pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO3U9bi5kaW1zWzFdfWVsc2V7aWYobi5kaW1zWzFdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09eSl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTt1PW4uZGltc1syXX19ZWxzZXtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO2lmKHIuZGltcy5sZW5ndGg9PT01JiYoci5kaW1zWzJdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09MykpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7dj0zfWxldCBTPTAsVD0hMSxBPXQua3ZOdW1IZWFkcz95KnQua3ZOdW1IZWFkczptO2lmKG8mJm8uZGltcy5sZW5ndGg+MCl7aWYoby5kaW1zLmxlbmd0aCE9PTMmJm8uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1vLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7aWYoby5kaW1zLmxlbmd0aD09PTMpe2lmKHUhPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzJdfWVsc2V7aWYodSE9PW8uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzFdKm8uZGltc1szXSxUPSEwfX1sZXQgQz1lLmxlbmd0aD40P2VbNV06dm9pZCAwO2lmKEMmJkMuZGltcy5sZW5ndGghPT0xJiZDLmRpbXNbMF0hPT1sKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJzZXFsZW5zXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbiBhbmQgdGhlIHNhbWUgZGltIDAgYXMgYmF0Y2hfc2l6ZScpO2xldCBQPS0xLEQ9LTEsUj0hMTtyZXR1cm57YmF0Y2hTaXplOmwsc2VxdWVuY2VMZW5ndGg6cCxwYXN0U2VxdWVuY2VMZW5ndGg6aCxrdlNlcXVlbmNlTGVuZ3RoOnUsdG90YWxTZXF1ZW5jZUxlbmd0aDpQLG1heFNlcXVlbmNlTGVuZ3RoOkQsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTptLHZIaWRkZW5TaXplOkEsaGVhZFNpemU6eSx2SGVhZFNpemU6TWF0aC5mbG9vcihBL3Qua3ZOdW1IZWFkcyksbnVtSGVhZHM6dC5udW1IZWFkcyxrdk51bUhlYWRzOnQua3ZOdW1IZWFkcyxuUmVwczp0Lm51bUhlYWRzL3Qua3ZOdW1IZWFkcyxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tUeXBlOlMsc2NhbGU6dC5zY2FsZSxicm9hZGNhc3RSZXNQb3NCaWFzOlIscGFzc1Bhc3RJbkt2OlQscWt2Rm9ybWF0OnZ9fSxpaD1lZSh7cGVybTpbMCwyLDEsM119KSxHZD0oZSx0LHIpPT57bGV0IG49dCxvPXIua3ZOdW1IZWFkcztyZXR1cm4gdC5kaW1zLmxlbmd0aD09PTMmJnIua3ZTZXF1ZW5jZUxlbmd0aCE9PTAmJihuPXQucmVzaGFwZShbci5iYXRjaFNpemUsci5rdlNlcXVlbmNlTGVuZ3RoLG8sci5oZWFkU2l6ZV0pLG49ZS5jb21wdXRlKFBlKG4saWgucGVybSkse2lucHV0czpbbl0sb3V0cHV0czpbLTFdfSlbMF0pLG59LEhkPShlLHQpPT57bGV0IHI9b2goZS5pbnB1dHMsdCk7aWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2lmKGUuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgbj1lLmlucHV0c1swXSxvPWUuaW5wdXRzWzFdJiZlLmlucHV0c1sxXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzFdOnZvaWQgMCxpPWUuaW5wdXRzWzJdJiZlLmlucHV0c1syXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzJdOnZvaWQgMCxhPWUuaW5wdXRzWzNdJiZlLmlucHV0c1szXS5kaW1zLmxlbmd0aCE9PTA/ZS5pbnB1dHNbM106dm9pZCAwLGQ9ZS5pbnB1dHNbNF0mJmUuaW5wdXRzWzRdLmRpbXMubGVuZ3RoIT09MD9lLmlucHV0c1s0XTp2b2lkIDAsbD1lLmlucHV0cy5sZW5ndGg+ND9lLmlucHV0c1s1XTp2b2lkIDAscD1lLmlucHV0cy5sZW5ndGg+NT9lLmlucHV0c1s2XTp2b2lkIDAsbT1yLmt2TnVtSGVhZHM/ci5rdk51bUhlYWRzOnIubnVtSGVhZHMsdT1lZSh7YXhpczoyLG51bU91dHB1dHM6MyxzcGxpdFNpemVzOltyLm51bUhlYWRzKnIuaGVhZFNpemUsbSpyLmhlYWRTaXplLG0qci5oZWFkU2l6ZV19KSxbaCxfLHldPSFvJiYhaT9lLmNvbXB1dGUoU28oW25dLHUpLHtpbnB1dHM6W25dLG91dHB1dHM6Wy0xLC0xLC0xXX0pOltuLG8saV0sZz1lcihlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5zZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLGgsdm9pZCAwLDApO1V0KGUsZyxHZChlLF8sciksR2QoZSx5LHIpLHZvaWQgMCx2b2lkIDAsYSxkLHZvaWQgMCxyLGwscCl9fSk7dmFyIHFkLGFoLHNoLEtkLGpkPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTtkdCgpO2FlKCk7cWQ9KGUsdCxyLG4sbyxpLGEsZCk9PntsZXQgbD1tZShpKSxwPWw9PT0xP1wiZjMyXCI6YHZlYyR7bH1mYCxtPWw9PT0xP1widmVjMmZcIjpgbWF0Mngke2x9ZmAsdT1vKmEsaD02NDt1PT09MSYmKGg9MjU2KTtsZXQgXz1bbyxhLGkvbF0seT1bbyxhLDJdLGc9W1wicmFua1wiLFwidHlwZVwiLFwidHlwZVwiXSx4PVtdO3gucHVzaCguLi5OKF8seSkpO2xldCAkPXY9PntsZXQgUz1FKFwieFwiLHQuZGF0YVR5cGUsMyxsKSxUPUUoXCJzY2FsZVwiLHIuZGF0YVR5cGUsci5kaW1zKSxBPUUoXCJiaWFzXCIsbi5kYXRhVHlwZSxuLmRpbXMpLEM9TShcIm91dHB1dFwiLDEsMywyKSxQPVtTLFQsQSxDXTtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQgOiBhcnJheTwke219LCAke2h9PjtcbiAgY29uc3Qgd29ya2dyb3VwX3NpemUgPSAke2h9dTtcbiAgJHt2LmRlY2xhcmVWYXJpYWJsZXMoLi4uUCl9XG4gICR7di5tYWluU3RhcnQoaCl9XG4gICAgbGV0IGJhdGNoID0gd29ya2dyb3VwX2luZGV4IC8gdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgY2hhbm5lbCA9IHdvcmtncm91cF9pbmRleCAlIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGhpZ2h0ID0gdW5pZm9ybXMueF9zaGFwZVsyXTtcbiAgICAvLyBpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnlcbiAgICB2YXIgc3VtID0gJHtwfSgwKTtcbiAgICB2YXIgc3F1YXJlZF9zdW0gPSAke3B9KDApO1xuICAgIGZvciAodmFyIGggPSBsb2NhbF9pZHg7IGggPCBoaWdodDsgaCArPSB3b3JrZ3JvdXBfc2l6ZSkge1xuICAgICAgbGV0IHZhbHVlID0gJHtwfSgke1MuZ2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIil9KTtcbiAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIHNxdWFyZWRfc3VtICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSA9ICR7bX0oc3VtLCBzcXVhcmVkX3N1bSk7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBfc2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gKyB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsX2lkeCA9PSAwKSB7XG4gICAgICBsZXQgc3VtX2ZpbmFsID0gJHtxZShcIndvcmtncm91cF9zaGFyZWRbMF1bMF1cIixsKX0gLyBmMzIoaGlnaHQgKiAke2x9KTtcbiAgICAgIGxldCBzcXVhcmVkX3N1bV9maW5hbCA9ICR7cWUoXCJ3b3JrZ3JvdXBfc2hhcmVkWzBdWzFdXCIsbCl9IC8gZjMyKGhpZ2h0ICogJHtsfSk7XG5cbiAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KHNxdWFyZWRfc3VtX2ZpbmFsIC0gc3VtX2ZpbmFsICogc3VtX2ZpbmFsICsgZjMyKCR7ZH0pKTtcbiAgICAgIGxldCBjaGFubmVsX3NjYWxlID0gaW52X3N0ZF9kZXYgKiBmMzIoc2NhbGVbY2hhbm5lbF0pO1xuICAgICAgbGV0IGNoYW5uZWxfc2hpZnQgPSBmMzIoYmlhc1tjaGFubmVsXSkgLSBzdW1fZmluYWwgKiBjaGFubmVsX3NjYWxlO1xuICAgICAgb3V0cHV0W3dvcmtncm91cF9pbmRleF0gPSB2ZWMyZihjaGFubmVsX3NjYWxlLCBjaGFubmVsX3NoaWZ0KTtcbiAgICB9XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtQ29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bH07JHtkfTske2h9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnksZGF0YVR5cGU6MX1dLGRpc3BhdGNoR3JvdXA6e3g6dX0scHJvZ3JhbVVuaWZvcm1zOnh9KSxnZXRTaGFkZXJTb3VyY2U6JH0se2lucHV0czpbdCxyLG5dLG91dHB1dHM6Wy0xXX0pWzBdfSxhaD0oZSx0LHIpPT57bGV0IG49dFswXS5kaW1zLG89bixpPTIsYT1uWzBdLGQ9blsxXSxsPWsuc2l6ZUZyb21EaW1lbnNpb24obixpKSxwPW1lKGwpLG09ay5zaXplKG8pL3AsdT1xZChlLHRbMF0sdFsxXSx0WzJdLGEsbCxkLHIuZXBzaWxvbiksaD1bYSxkLGwvcF0sXz1bYSxkXSx5PVtcInR5cGVcIixcIm5vbmVcIl0sZz14PT57bGV0ICQ9RShcInhcIix0WzBdLmRhdGFUeXBlLGgubGVuZ3RoLHApLHY9RShcInNjYWxlX3NoaWZ0XCIsMSxfLmxlbmd0aCwyKSxTPU0oXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLGgubGVuZ3RoLHApLFQ9WyQsdixTXTtyZXR1cm5gXG4gICR7eC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoLi4uVCl9XG4gICR7eC5tYWluU3RhcnQoKX1cbiAgJHt4Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgbGV0IGJhdGNoID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICAgIGxldCBjaGFubmVsID0gb3V0cHV0SW5kaWNlc1sxXTtcbiAgICAgIGxldCBzY2FsZV9zaGlmdCA9ICR7di5nZXRCeUluZGljZXMoXCJ2ZWMyPHUzMj4oYmF0Y2gsIGNoYW5uZWwpXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7JC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9ICogJHtTLnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LngpICsgJHtTLnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LnkpO1xuICAgICAgJHtTLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cH1gLGlucHV0RGVwZW5kZW5jaWVzOnl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTp0WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobS82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTptfSwuLi5OKGgsXyxoKV19KSxnZXRTaGFkZXJTb3VyY2U6Z30se2lucHV0czpbdFswXSx1XX0pfSxzaD0oZSx0LHIpPT57bGV0IG49dFswXS5kaW1zLG89bixpPW5bMF0sYT1uW24ubGVuZ3RoLTFdLGQ9ay5zaXplRnJvbURpbWVuc2lvbihuLDEpL2EsbD1tZShhKSxwPWsuc2l6ZShvKS9sLG09W3t0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpNYXRoLmZsb29yKGEvbCl9XSx1PVtcInR5cGVcIixcInR5cGVcIl0saD0hMSxfPVswLG4ubGVuZ3RoLTFdO2ZvcihsZXQgJD0wOyQ8bi5sZW5ndGgtMjskKyspaD1ofHxuWyQrMV0hPT0xLF8ucHVzaCgkKzEpO2g9aCYmbltuLmxlbmd0aC0xXSE9PTE7bGV0IHk9aD9lLmNvbXB1dGUoUGUoZS5pbnB1dHNbMF0sXykse2lucHV0czpbZS5pbnB1dHNbMF1dLG91dHB1dHM6Wy0xXX0pWzBdOmUuaW5wdXRzWzBdLnJlc2hhcGUoQXJyYXkuZnJvbSh7bGVuZ3RoOm4ubGVuZ3RofSwoJCx2KT0+bltfW3ZdXSkpLGc9cWQoZSx5LHRbMV0sdFsyXSxpLGQsYSxyLmVwc2lsb24pLHg9JD0+e2xldCB2PXllKHRbMF0uZGF0YVR5cGUpLFM9bD09PTE/XCJ2ZWMyZlwiOmBtYXQke2x9eDJmYCxUPVA9PntsZXQgRD1QPT09MD9cInhcIjpcInlcIixSPWw9PT0xP1wiZjMyXCI6YHZlYyR7bH1mYDtzd2l0Y2gobCl7Y2FzZSAxOnJldHVybmAke3Z9KCR7Un0oc2NhbGUuJHtEfSkpYDtjYXNlIDI6cmV0dXJuYHZlYzI8JHt2fT4oJHtSfShzY2FsZVswXS4ke0R9LCBzY2FsZVsxXS4ke0R9KSlgO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3Z9Pigke1J9KHNjYWxlWzBdLiR7RH0sIHNjYWxlWzFdLiR7RH0sIHNjYWxlWzJdLiR7RH0sIHNjYWxlWzNdLiR7RH0pKWA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgY29tcG9lbnRzICR7bH1gKX19LEE9RShcImlucHV0XCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMsbCksQz1NKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxvLGwpO3JldHVybmBcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7QS50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZV9pbnB1dCA6IGFycmF5PCR7U30+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7Qy50eXBlLnN0b3JhZ2V9PjtcbiAgc3RydWN0IFVuaWZvcm1zIHtIOiB1MzIsIEMgOiB1MzJ9O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgbGV0IGN1cnJlbnRfaW1hZ2VfbnVtYmVyID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5DICogdW5pZm9ybXMuSCk7XG4gICAgbGV0IGN1cnJlbnRfY2hhbm5lbF9udW1iZXIgPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuQztcblxuICAgIGxldCBzY2FsZV9vZmZzZXQgPSBjdXJyZW50X2ltYWdlX251bWJlciAqIHVuaWZvcm1zLkMgKyBjdXJyZW50X2NoYW5uZWxfbnVtYmVyO1xuICAgIGxldCBzY2FsZSA9IHNjYWxlX2lucHV0W3NjYWxlX29mZnNldF07XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZm1hKGlucHV0W2dsb2JhbF9pZHhdLCAke1QoMCl9LCAke1QoMSl9KTtcbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbk5IV0NcIixzaGFkZXJDYWNoZTp7aGludDpgJHtsfWAsaW5wdXREZXBlbmRlbmNpZXM6dX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOnRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6eH0se2lucHV0czpbdFswXSxnXX0pfSxLZD0oZSx0KT0+e3QuZm9ybWF0PT09XCJOSFdDXCI/c2goZSxlLmlucHV0cyx0KTphaChlLGUuaW5wdXRzLHQpfX0pO3ZhciB1aCxkaCxZZCxaZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7YWUoKTt1aD1lPT57aWYoIWV8fGUubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDIgaW5wdXRzLlwiKX0sZGg9KGUsdCxyKT0+e2xldCBuPXQuc2ltcGxpZmllZCxvPWVbMF0uZGltcyxpPWVbMV0sYT0hbiYmZVsyXSxkPW8sbD1rLm5vcm1hbGl6ZUF4aXModC5heGlzLG8ubGVuZ3RoKSxwPWsuc2l6ZVRvRGltZW5zaW9uKG8sbCksbT1rLnNpemVGcm9tRGltZW5zaW9uKG8sbCksdT1rLnNpemUoaS5kaW1zKSxoPWE/ay5zaXplKGEuZGltcyk6MDtpZih1IT09bXx8YSYmaCE9PW0pdGhyb3cgbmV3IEVycm9yKGBTaXplIG9mIFguc2hhcGUoKVtheGlzOl0gPT0gJHttfS5cbiAgICAgICBTaXplIG9mIHNjYWxlIGFuZCBiaWFzIChpZiBwcm92aWRlZCkgbXVzdCBtYXRjaCB0aGlzLlxuICAgICAgIEdvdCBzY2FsZSBzaXplIG9mICR7dX0gYW5kIGJpYXMgc2l6ZSBvZiAke2h9YCk7bGV0IF89W107Zm9yKGxldCBBPTA7QTxvLmxlbmd0aDsrK0EpQTxsP18ucHVzaChvW0FdKTpfLnB1c2goMSk7bGV0IHk9bWUobSksZz1bXCJ0eXBlXCIsXCJ0eXBlXCJdLHg9W3t0eXBlOjEyLGRhdGE6cH0se3R5cGU6MSxkYXRhOm19LHt0eXBlOjEyLGRhdGE6TWF0aC5mbG9vcihtL3kpfSx7dHlwZToxLGRhdGE6dC5lcHNpbG9ufV07YSYmZy5wdXNoKFwidHlwZVwiKTtsZXQgJD1yPjEsdj1yPjIsUz1BPT57bGV0IEM9eWUoZVswXS5kYXRhVHlwZSksUD1bRShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyx5KSxFKFwic2NhbGVcIixpLmRhdGFUeXBlLGkuZGltcyx5KV07YSYmUC5wdXNoKEUoXCJiaWFzXCIsYS5kYXRhVHlwZSxhLmRpbXMseSkpLFAucHVzaChNKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLHkpKSwkJiZQLnB1c2goTShcIm1lYW5fZGF0YV9vdXRwdXRcIiwxLF8pKSx2JiZQLnB1c2goTShcImludl9zdGRfb3V0cHV0XCIsMSxfKSk7bGV0IEQ9W3tuYW1lOlwibm9ybV9jb3VudFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJub3JtX3NpemVcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwibm9ybV9zaXplX3ZlY3Rvcml6ZWRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJmMzJcIn1dO3JldHVybmBcbiAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoRCkuZGVjbGFyZVZhcmlhYmxlcyguLi5QKX1cbiAgJHtBLm1haW5TdGFydCgpfVxuICAgICR7QS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMubm9ybV9jb3VudFwiKX1cbiAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkO1xuICAgIHZhciBtZWFuX3ZlY3RvciA9ICR7c28oXCJmMzJcIix5KX07XG4gICAgdmFyIG1lYW5fc3F1YXJlX3ZlY3RvciA9ICR7c28oXCJmMzJcIix5KX07XG5cbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBoKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7UHQoQyx5LFwieFtoICsgb2Zmc2V0XVwiKX07XG4gICAgICBtZWFuX3ZlY3RvciArPSB2YWx1ZTtcbiAgICAgIG1lYW5fc3F1YXJlX3ZlY3RvciArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgbWVhbiA9ICR7cWUoXCJtZWFuX3ZlY3RvclwiLHkpfSAvIHVuaWZvcm1zLm5vcm1fc2l6ZTtcbiAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydCgke3FlKFwibWVhbl9zcXVhcmVfdmVjdG9yXCIseSl9IC8gdW5pZm9ybXMubm9ybV9zaXplICR7bj9cIlwiOlwiLSBtZWFuICogbWVhblwifSArIHVuaWZvcm1zLmVwc2lsb24pO1xuXG4gICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBqKyspIHtcbiAgICAgIGxldCBmMzJpbnB1dCA9ICR7UHQoQyx5LFwieFtqICsgb2Zmc2V0XVwiKX07XG4gICAgICBsZXQgZjMyc2NhbGUgPSAke1B0KEMseSxcInNjYWxlW2pdXCIpfTtcbiAgICAgIG91dHB1dFtqICsgb2Zmc2V0XSA9ICR7UFswXS50eXBlLnZhbHVlfSgoZjMyaW5wdXQgJHtuP1wiXCI6XCItIG1lYW5cIn0pICogaW52X3N0ZF9kZXYgKiBmMzJzY2FsZVxuICAgICAgICAke2E/YCsgJHtQdChDLHksXCJiaWFzW2pdXCIpfWA6XCJcIn1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgJHskP1wibWVhbl9kYXRhX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW5cIjpcIlwifTtcbiAgICAke3Y/XCJpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2XCI6XCJcIn07XG4gIH1gfSxUPVt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4gJCYmVC5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6MX0pLHYmJlQucHVzaCh7ZGltczpfLGRhdGFUeXBlOjF9KSx7bmFtZTpcIkxheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3l9OyR7cn07JHtufWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlQsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3Jtczp4fSksZ2V0U2hhZGVyU291cmNlOlN9fSxZZD0oZSx0KT0+e3VoKGUuaW5wdXRzKSxlLmNvbXB1dGUoZGgoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50KSl9fSk7dmFyIGxoLFFkLFhkPVUoKCk9PntcInVzZSBzdHJpY3RcIjtuZSgpO1pyKCk7UXIoKTtsaD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJNYXRNdWwgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGltc1tlWzBdLmRpbXMubGVuZ3RoLTFdIT09ZVsxXS5kaW1zW2VbMV0uZGltcy5sZW5ndGgtMl0pdGhyb3cgbmV3IEVycm9yKFwic2hhcmVkIGRpbWVuc2lvbiBkb2VzIG5vdCBtYXRjaC5cIil9LFFkPWU9PntsaChlLmlucHV0cyk7bGV0IHQ9dHQuY2FsY1NoYXBlKGUuaW5wdXRzWzBdLmRpbXMsZS5pbnB1dHNbMV0uZGltcywhMCk7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgcj10W3QubGVuZ3RoLTFdLG49ZS5pbnB1dHNbMF0uZGltc1tlLmlucHV0c1swXS5kaW1zLmxlbmd0aC0xXTtpZihyPDgmJm48OCllLmNvbXB1dGUoWXIoZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIn0sdCkpO2Vsc2V7bGV0IG89dFt0Lmxlbmd0aC0yXSxpPWsuc2l6ZShlLmlucHV0c1swXS5kaW1zLnNsaWNlKDAsLTIpKSxhPWsuc2l6ZShlLmlucHV0c1sxXS5kaW1zLnNsaWNlKDAsLTIpKTtpZihpIT09MSYmbz09PTEmJmE9PT0xKXtsZXQgZD1lLmlucHV0c1swXS5yZXNoYXBlKFsxLGksbl0pLGw9ZS5pbnB1dHNbMV0ucmVzaGFwZShbMSxuLHJdKSxwPVsxLGkscl0sbT1bZCxsXTtlLmNvbXB1dGUoSnQobSx7YWN0aXZhdGlvbjpcIlwifSx0LHApLHtpbnB1dHM6bX0pfWVsc2UgZS5jb21wdXRlKEp0KGUuaW5wdXRzLHthY3RpdmF0aW9uOlwiXCJ9LHQpKX19fSk7dmFyIGNoLHBoLG1oLEpkLGVsLHRsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7Y2g9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIk1hdE11bE5CaXRzIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHNcIik7bGV0IHI9ZVswXSxuPXIuZGltcy5sZW5ndGg7aWYoci5kaW1zW24tMV0hPT10LmspdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxhc3QgZGltIG9mIGlucHV0IHNoYXBlIGRvZXMgbm90IG1hdGNoIHRoZSBrIHZhbHVlXCIpO2xldCBvPU1hdGguZmxvb3IoKHQuayt0LmJsb2NrU2l6ZS0xKS90LmJsb2NrU2l6ZSksaT10LmJsb2NrU2l6ZS84KnQuYml0cyxhPWVbMV07aWYoIWsuYXJlRXF1YWwoYS5kaW1zLFt0Lm4sbyxpXSkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlY29uZCBpbnB1dHMgbXVzdCBiZSAzRCB0ZW5zb3Igd2l0aCBzaGFwZSBOIFggbkJsb2Nrc1BlckNvbCBYIGJsb2JTaXplXCIpO2xldCBsPWVbMl0uZGltcztpZihrLnNpemUobCkhPT10Lm4qbyl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZXMgaW5wdXQgc2l6ZSBlcnJvci5cIik7aWYoZS5sZW5ndGg9PT00KXtsZXQgbT1lWzNdLmRpbXMsdT10LmJpdHM+ND90Lm4qbzp0Lm4qTWF0aC5mbG9vcigobysxKS8yKTtpZihrLnNpemUobSkhPT11KXRocm93IG5ldyBFcnJvcihcInplcm9Qb2ludHMgaW5wdXQgc2l6ZSBlcnJvci5cIil9fSxwaD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPXIubGVuZ3RoLG89cltuLTJdLGk9dC5rLGE9dC5uLGQ9ci5zbGljZSgwLG4tMiksbD1rLnNpemUoZCksbT1lWzFdLmRpbXNbMl0vNCx1PWVbMF0uZGF0YVR5cGUsaD1tZSh0LmspLF89bWUobSkseT1tZShhKSxnPWQuY29uY2F0KFtvLGFdKSx4PW8+MSYmYS95JTI9PT0wPzI6MSwkPWsuc2l6ZShnKS95L3gsdj02NCxTPVtdLFQ9W2wsbyxpL2hdLEE9ay5jb252ZXJ0U2hhcGUoZVsxXS5kaW1zKS5zbGljZSgpO0Euc3BsaWNlKC0xLDEsbS9fKSxTLnB1c2goLi4uTihUKSksUy5wdXNoKC4uLk4oQSkpLFMucHVzaCguLi5OKGVbMl0uZGltcykpLGUubGVuZ3RoPT09NCYmUy5wdXNoKC4uLk4oay5jb252ZXJ0U2hhcGUoZVszXS5kaW1zKSkpO2xldCBDPVtsLG8sYS95XTtTLnB1c2goLi4uTihDKSk7bGV0IFA9RD0+e2xldCBSPVQubGVuZ3RoLEg9RShcImFcIixlWzBdLmRhdGFUeXBlLFIsaCksTD1FKFwiYlwiLDEyLEEubGVuZ3RoLF8pLHJlPUUoXCJzY2FsZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLFY9W0gsTCxyZV0sSz1lLmxlbmd0aD09PTQ/RShcInplcm9fcG9pbnRzXCIsMTIsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwO0smJlYucHVzaChLKTtsZXQgd2U9Qy5sZW5ndGgsaj1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx3ZSx5KSxRPXllKGVbMF0uZGF0YVR5cGUpLGllPSgoKT0+e3N3aXRjaChoKXtjYXNlIDE6cmV0dXJuYGFycmF5PCR7UX0sIDg+YDtjYXNlIDI6cmV0dXJuYG1hdDR4Mjwke1F9PmA7Y2FzZSA0OnJldHVybmBtYXQyeDQ8JHtRfT5gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2h9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0pKCksdGU9KCk9PntsZXQgdmU9YFxuICAgICAgICAgIC8vIHJldXNlIGEgZGF0YVxuICAgICAgICAgICAgdmFyIGlucHV0X29mZnNldCA9ICR7SC5pbmRpY2VzVG9PZmZzZXQoYCR7SC50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIHdvcmRfb2Zmc2V0KWApfTtcbiAgICAgICAgICAgIHZhciBhX2RhdGE6ICR7aWV9O1xuICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8ICR7OC9ofTsgaisrKSB7XG4gICAgICAgICAgICAgIGFfZGF0YVtqXSA9ICR7SC5nZXRCeU9mZnNldChcImlucHV0X29mZnNldFwiKX07XG4gICAgICAgICAgICAgIGlucHV0X29mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7Zm9yKGxldCBkZT0wO2RlPHkqeDtkZSsrKXZlKz1gXG4gICAgICAgICAgICBiX3ZhbHVlID0gJHtfPT09MT9gYiR7ZGV9X2RhdGFgOmBiJHtkZX1fZGF0YVtpXWB9O1xuICAgICAgICAgICAgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3F1YW50aXplZF92YWx1ZXMgPSAke2llfSgke0FycmF5LmZyb20oe2xlbmd0aDo0fSwoVyxZKT0+YCR7UX0oYl92YWx1ZV9sb3dlclske1l9XSksICR7UX0oYl92YWx1ZV91cHBlclske1l9XSlgKS5qb2luKFwiLCBcIil9KTtcbiAgICAgICAgICAgIGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gJHsoKCk9Pmg9PT0xP2Ake2llfSgke0FycmF5LmZyb20oe2xlbmd0aDo4fSwoVyxZKT0+YChiX3F1YW50aXplZF92YWx1ZXNbJHtZfV0gLSAke0s/YHplcm9fcG9pbnQke2RlfWA6XCJ6ZXJvX3BvaW50XCJ9KSAqIHNjYWxlJHtkZX1gKS5qb2luKFwiLCBcIil9KTtgOmAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtpZX0oJHtBcnJheSg4KS5maWxsKGAke0s/YHplcm9fcG9pbnQke2RlfWA6XCJ6ZXJvX3BvaW50XCJ9YCkuam9pbihcIixcIil9KSkgKiBzY2FsZSR7ZGV9O2ApKCl9O1xuICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZC54ICogJHt4fSArICR7TWF0aC5mbG9vcihkZS95KX1dJHt5PjE/YFske2RlJXl9XWA6XCJcIn0gKz0gJHtBcnJheS5mcm9tKHtsZW5ndGg6OC9ofSwoVyxZKT0+YCR7aD09PTE/YGFfZGF0YVske1l9XSAqIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7WX1dYDpgZG90KGFfZGF0YVske1l9XSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtZfV0pYH1gKS5qb2luKFwiICsgXCIpfTtcbiAgICAgICAgICBgO3JldHVybiB2ZX0sYmU9KCk9PntsZXQgdmU9YFxuICAgICAgICAgICAgdmFyIGNvbF9pbmRleCA9IGNvbCAqICR7eX07XG4gICAgICAgICAgICAke0s/YFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuQmxvY2tzUGVyQ29sICsgMSkgLyAyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9jb3VudDogdTMyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZF9pbmRleDogdTMyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkOiB1MzI7YDpgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtRfSg4KTtgfVxuICAgICAgICAgICAgYDtmb3IobGV0IGRlPTA7ZGU8eSp4O2RlKyspdmUrPWBcbiAgICAgICAgICAgIGxldCBzY2FsZSR7ZGV9ID0gJHtyZS5nZXRCeU9mZnNldChcImNvbF9pbmRleCAqIG5CbG9ja3NQZXJDb2wgKyBibG9ja1wiKX07XG4gICAgICAgICAgICAke0s/YFxuICAgICAgICAgICAgemVyb19wb2ludF9ieXRlX2NvdW50ID0gY29sX2luZGV4ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xuICAgICAgICAgICAgemVyb19wb2ludF93b3JkX2luZGV4ID0gemVyb19wb2ludF9ieXRlX2NvdW50ID4+IDB4MnU7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0ID0gemVyb19wb2ludF9ieXRlX2NvdW50ICYgMHgzdTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmQgPSAke0suZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X3dvcmRfaW5kZXhcIil9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCR7ZGV9ID0gJHtRfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2A6XCJcIn1cbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7cmV0dXJuIHZlfSxPZT0oKT0+e2xldCB2ZT1gY29sX2luZGV4ID0gY29sICogJHt5fTtgO2ZvcihsZXQgZGU9MDtkZTx5Kng7ZGUrKyl2ZSs9YFxuICAgICAgICAgICAgbGV0IGIke2RlfV9kYXRhID0gJHtMLmdldEJ5SW5kaWNlcyhgJHtMLnR5cGUuaW5kaWNlc30oY29sX2luZGV4LCBibG9jaywgd29yZClgKX07XG4gICAgICAgICAgICBjb2xfaW5kZXggKz0gMTtgO3JldHVybiB2ZSs9YFxuICAgICAgICAgICAgdmFyIGJfdmFsdWU6IHUzMjtcbiAgICAgICAgICAgIGxldCBiX21hc2s6IHUzMiA9IDB4MEYwRjBGMEZ1O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfbG93ZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX3VwcGVyOiB2ZWM0PHUzMj47XG4gICAgICAgICAgICB2YXIgYl9xdWFudGl6ZWRfdmFsdWVzOiAke2llfTtcbiAgICAgICAgICAgIHZhciBiX2RlcXVhbnRpemVkX3ZhbHVlczogJHtpZX07YCx2ZX07cmV0dXJuYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkOiBhcnJheTwke2oudHlwZS52YWx1ZX0sICR7eCp2fT47XG4gICAgICAgICR7RC5kZWNsYXJlVmFyaWFibGVzKC4uLlYsail9XG4gICAgICAgICR7RC5tYWluU3RhcnQoW3YsMSwxXSl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtqLm9mZnNldFRvSW5kaWNlcyhgKGdsb2JhbF9pZHggLyAke3Z9KSAqICR7eH1gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbkJsb2Nrc1BlckNvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG5cbiAgICAgICAgICBmb3IgKHZhciBibG9jayA9IGxvY2FsX2lkLng7IGJsb2NrIDwgbkJsb2Nrc1BlckNvbDsgYmxvY2sgKz0gJHt2fSkge1xuICAgICAgICAgICAgLy9wcm9jZXNzIG9uZSBibG9ja1xuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0OiB1MzIgPSBibG9jayAqICR7dC5ibG9ja1NpemUvaH07XG4gICAgICAgICAgICAke2JlKCl9XG4gICAgICAgICAgICBmb3IgKHZhciB3b3JkOiB1MzIgPSAwOyB3b3JkIDwgJHttfTsgd29yZCArPSAke199KSB7XG4gICAgICAgICAgICAgICR7T2UoKX1cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7X307IGkrKykge1xuICAgICAgICAgICAgICAgICR7dGUoKX1cbiAgICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezgvaH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkLnggPCAke3h9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke2oudHlwZS52YWx1ZX0gPSAke2oudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICB2YXIgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQ6IHUzMiA9IGxvY2FsX2lkLng7XG4gICAgICAgICAgICBmb3IgKHZhciBiOiB1MzIgPSAwdTsgYiA8ICR7dn11OyBiKyspIHtcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IHdvcmtncm91cF9zaGFyZWRbd29ya2dyb3VwX3NoYXJlZF9vZmZzZXRdO1xuICAgICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldCArPSAke3h9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtqLnNldEJ5SW5kaWNlcyhgJHtqLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWQueClgLFwib3V0cHV0X3ZhbHVlXCIpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIk1hdE11bE5CaXRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5ibG9ja1NpemV9OyR7dC5iaXRzfTske2h9OyR7X307JHt5fTske3h9OyR7dn1gLGlucHV0RGVwZW5kZW5jaWVzOkFycmF5KGUubGVuZ3RoKS5maWxsKFwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpnLGRhdGFUeXBlOnV9XSxkaXNwYXRjaEdyb3VwOnt4OiR9LHByb2dyYW1Vbmlmb3JtczpTfSksZ2V0U2hhZGVyU291cmNlOlB9fSxtaD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPXIubGVuZ3RoLG89cltuLTJdLGk9dC5rLGE9dC5uLGQ9ci5zbGljZSgwLG4tMiksbD1rLnNpemUoZCksbT1lWzFdLmRpbXNbMl0vNCx1PWVbMF0uZGF0YVR5cGUsaD1tZSh0LmspLF89bWUobSkseT1kLmNvbmNhdChbbyxhXSksZz0xMjgseD1hJTg9PT0wPzg6YSU0PT09MD80OjEsJD1nL3gsdj0kKl8qOCxTPXYvaCxUPXYvdC5ibG9ja1NpemUsQT1rLnNpemUoeSkveCxDPVtdLFA9W2wsbyxpL2hdLEQ9ay5jb252ZXJ0U2hhcGUoZVsxXS5kaW1zKS5zbGljZSgpO0Quc3BsaWNlKC0xLDEsbS9fKSxDLnB1c2goLi4uTihQKSksQy5wdXNoKC4uLk4oRCkpLEMucHVzaCguLi5OKGVbMl0uZGltcykpLGUubGVuZ3RoPT09NCYmQy5wdXNoKC4uLk4oay5jb252ZXJ0U2hhcGUoZVszXS5kaW1zKSkpO2xldCBSPVtsLG8sYV07Qy5wdXNoKC4uLk4oUikpO2xldCBIPUw9PntsZXQgcmU9UC5sZW5ndGgsVj1FKFwiYVwiLGVbMF0uZGF0YVR5cGUscmUsaCksSz1FKFwiYlwiLDEyLEQubGVuZ3RoLF8pLHdlPUUoXCJzY2FsZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLGo9W1YsSyx3ZV0sUT1lLmxlbmd0aD09PTQ/RShcInplcm9fcG9pbnRzXCIsMTIsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwO1EmJmoucHVzaChRKTtsZXQgaWU9Ui5sZW5ndGgsdGU9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsaWUpLGJlPXllKGVbMF0uZGF0YVR5cGUpLE9lPSgpPT57c3dpdGNoKGgpe2Nhc2UgMTpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7YmV9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke2JlfT4oc3ViX2Fbd29yZF9vZmZzZXQgKyA0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA1XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA2XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA3XSk7YDtjYXNlIDI6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gdmVjNDwke2JlfT4oc3ViX2Fbd29yZF9vZmZzZXRdLCBzdWJfYVt3b3JkX29mZnNldCArIDFdKTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHZlYzQ8JHtiZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO2A7Y2FzZSA0OnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHN1Yl9hW3dvcmRfb2Zmc2V0XTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV07YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtofS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19O3JldHVybmBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gc3ViX2E6IGFycmF5PCR7Vi50eXBlLnZhbHVlfSwgJHtTfT47XG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IGludGVyX3Jlc3VsdHM6IGFycmF5PGFycmF5PCR7dGUudHlwZS52YWx1ZX0sICR7JH0+LCAke3h9PjtcbiAgICAgICAgJHtMLmRlY2xhcmVWYXJpYWJsZXMoLi4uaix0ZSl9XG4gICAgICAgICR7TC5tYWluU3RhcnQoWyQseCwxXSl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHt0ZS5vZmZzZXRUb0luZGljZXMoYHdvcmtncm91cF9pbmRleCAqICR7eH1gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbl9ibG9ja3NfcGVyX2NvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG4gICAgICAgICAgbGV0IG51bV90aWxlcyA9ICAobl9ibG9ja3NfcGVyX2NvbCAtIDEpIC8gJHtUfSArIDE7XG5cbiAgICAgICAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICAgICAgICBmb3IgKHZhciB0aWxlOiB1MzIgPSAwOyB0aWxlIDwgbnVtX3RpbGVzOyB0aWxlICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBhX2NvbF9zdGFydCA9IHRpbGUgKiAke1N9O1xuICAgICAgICAgICAgLy8gbG9hZCBvbmUgdGlsZSBBIGRhdGEgaW50byBzaGFyZWQgbWVtb3J5LlxuICAgICAgICAgICAgZm9yICh2YXIgYV9vZmZzZXQgPSBsb2NhbF9pZHg7IGFfb2Zmc2V0IDwgJHtTfTsgYV9vZmZzZXQgKz0gJHtnfSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGV0IGFfY29sID0gYV9jb2xfc3RhcnQgKyBhX29mZnNldDtcbiAgICAgICAgICAgICAgaWYgKGFfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsyXSlcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1Yl9hW2Ffb2Zmc2V0XSA9ICR7Vi5nZXRCeUluZGljZXMoYCR7Vi50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGFfY29sKWApfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke1YudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgICAgLy8gZWFjaCB0aHJlYWQgcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIGxldCBiX3JvdyA9IGNvbCArIGxvY2FsX2lkLnk7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aWxlICogJHtUfSArIGxvY2FsX2lkLng7XG4gICAgICAgICAgICAke1E/YFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuX2Jsb2Nrc19wZXJfY29sICsgMSkgLyAyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGJfcm93ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkID0gJHtRLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF93b3JkX2luZGV4XCIpfSA+PiB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke2JlfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2A6YFxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyA4IGZvciB1bnNpZ25lZCA0LWJpdCBxdWFudGl6YXRpb24uXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7YmV9KDgpO2B9XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSAke3dlLmdldEJ5T2Zmc2V0KFwiYl9yb3cgKiBuX2Jsb2Nrc19wZXJfY29sICsgYmxvY2tcIil9O1xuICAgICAgICAgICAgbGV0IGJfZGF0YSA9ICR7Sy5nZXRCeUluZGljZXMoYCR7Sy50eXBlLmluZGljZXN9KGJfcm93LCBibG9jaywgMClgKX07XG4gICAgICAgICAgICB2YXIgd29yZF9vZmZzZXQgPSBsb2NhbF9pZC54ICogJHt0LmJsb2NrU2l6ZS9ofTtcbiAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke199OyBpKyspIHtcbiAgICAgICAgICAgICAgJHtPZSgpfVxuICAgICAgICAgICAgICBsZXQgYl92YWx1ZSA9ICR7Xz09PTE/XCJiX2RhdGFcIjpcImJfZGF0YVtpXVwifTtcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfbG93ZXIgPSB1bnBhY2s0eFU4KGJfdmFsdWUgJiAweDBGMEYwRjBGdSk7XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIDB4MEYwRjBGMEZ1KTtcbiAgICAgICAgICAgICAgbGV0IGJfcXVhbnRpemVkX3ZhbHVlcyA9IG1hdDJ4NDwke2JlfT4oJHtBcnJheS5mcm9tKHtsZW5ndGg6NH0sKHZlLGRlKT0+YCR7YmV9KGJfdmFsdWVfbG93ZXJbJHtkZX1dKSwgJHtiZX0oYl92YWx1ZV91cHBlclske2RlfV0pYCkuam9pbihcIiwgXCIpfSk7XG4gICAgICAgICAgICAgIGxldCBiX2RlcXVhbnRpemVkX3ZhbHVlcyA9IChiX3F1YW50aXplZF92YWx1ZXMgLSBtYXQyeDQ8JHtiZX0+KCR7QXJyYXkoOCkuZmlsbChcInplcm9fcG9pbnRcIikuam9pbihcIixcIil9KSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgaW50ZXJfcmVzdWx0c1tsb2NhbF9pZC55XVtsb2NhbF9pZC54XSArPSAke0FycmF5LmZyb20oe2xlbmd0aDoyfSwodmUsZGUpPT5gJHtgZG90KGFfZGF0YSR7ZGV9LCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske2RlfV0pYH1gKS5qb2luKFwiICsgXCIpfTtcbiAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4L2h9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsb2NhbF9pZHggPCAke3h9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke3RlLnR5cGUudmFsdWV9ID0gJHt0ZS50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwdTsgYiA8ICR7JH07IGIrKykge1xuICAgICAgICAgICAgICBvdXRwdXRfdmFsdWUgKz0gaW50ZXJfcmVzdWx0c1tsb2NhbF9pZHhdW2JdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbCArIGxvY2FsX2lkeCA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsyXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgJHt0ZS5zZXRCeUluZGljZXMoYCR7dGUudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBjb2wgKyBsb2NhbF9pZHgpYCxcIm91dHB1dF92YWx1ZVwiKX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkJsb2Nrd2lzZU1hdE11bE5CaXRzMzJcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmJsb2NrU2l6ZX07JHtofTske199OyR7JH07JHt4fWAsaW5wdXREZXBlbmRlbmNpZXM6QXJyYXkoZS5sZW5ndGgpLmZpbGwoXCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnksZGF0YVR5cGU6dX1dLGRpc3BhdGNoR3JvdXA6e3g6QX0scHJvZ3JhbVVuaWZvcm1zOkN9KSxnZXRTaGFkZXJTb3VyY2U6SH19LEpkPShlLHQpPT57Y2goZS5pbnB1dHMsdCksdC5ibG9ja1NpemU9PT0zMiYmZS5hZGFwdGVySW5mby5pc1ZlbmRvcihcImludGVsXCIpJiZlLmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKFwiZ2VuLTEybHBcIik/ZS5jb21wdXRlKG1oKGUuaW5wdXRzLHQpKTplLmNvbXB1dGUocGgoZS5pbnB1dHMsdCkpfSxlbD1lPT5lZShlKX0pO3ZhciBmaCxoaCxnaCxiaCx5aCxfaCx3aCx2aCxybCxubD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7YWUoKTtmaD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGZldyBpbnB1dHNcIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT0xMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQgb3IgZmxvYXQxNi5cIik7aWYoZS5sZW5ndGg+PTIpe2xldCB0PWVbMF0uZGltcy5sZW5ndGgqMj09PWVbMV0uZGltc1swXTtpZihlLmxlbmd0aD09PTQmJih0PWVbM10uZGltc1swXSoyPT09ZVsxXS5kaW1zWzBdKSwhdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS5cIil9fSxoaD0oZSx0LHIpPT57bGV0IG49XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKW4rPWBcbiAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7cShcInVuaWZvcm1zLnBhZHNcIixvLHIpfTtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID49IGkzMigke3EoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtxKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICB2YWx1ZSA9ICR7ZS50eXBlLnZhbHVlfSh1bmlmb3Jtcy5jb25zdGFudF92YWx1ZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgJHtufVxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgYH0sZ2g9KGUsdCxyKT0+e2xldCBuPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbyluKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtxKFwidW5pZm9ybXMucGFkc1wiLG8scil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IC1rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke3EoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pIC0gMSk7XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtxKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gXzJuXzEgLSBrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke3EoXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtufVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSxiaD0oZSx0LHIpPT57bGV0IG49XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKW4rPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke3EoXCJ1bmlmb3Jtcy5wYWRzXCIsbyxyKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7cShcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtxKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7cShcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke259XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LHloPShlLHQscik9PntsZXQgbj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pbis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7cShcInVuaWZvcm1zLnBhZHNcIixvLHIpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XG4gICAgICAgICAgICAgICAgICBrICs9IGkzMigke3EoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7cShcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgLT0gaTMyKCR7cShcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7cShcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke259XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LF9oPShlLHQscik9Pntzd2l0Y2goci5tb2RlKXtjYXNlIDA6cmV0dXJuIGhoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDE6cmV0dXJuIGdoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDI6cmV0dXJuIGJoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDM6cmV0dXJuIHloKGUsdCxyLnBhZHMubGVuZ3RoKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZVwiKX19LHdoPShlLHQpPT57bGV0IHI9ay5wYWRTaGFwZShlWzBdLmRpbXMuc2xpY2UoKSx0LnBhZHMpLG49ZVswXS5kaW1zLG89ay5zaXplKHIpLGk9W3t0eXBlOjEyLGRhdGE6b30se3R5cGU6NixkYXRhOnQucGFkc31dLGE9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YTt0Lm1vZGU9PT0wJiZpLnB1c2goe3R5cGU6YT9lWzJdLmRhdGFUeXBlOjEsZGF0YTp0LnZhbHVlfSksaS5wdXNoKC4uLk4oZVswXS5kaW1zLHIpKTtsZXQgZD1bXCJyYW5rXCJdLGw9cD0+e2xldCBtPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoKSx1PUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCksaD11LnR5cGUudmFsdWUsXz1faChtLG4ubGVuZ3RoLHQpLHk9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH1dO3JldHVybiB0Lm1vZGU9PT0wJiZ5LnB1c2goe25hbWU6XCJjb25zdGFudF92YWx1ZVwiLHR5cGU6YT9oOlwiZjMyXCJ9KSxgXG4gICAgICAgICAgICAke3AucmVnaXN0ZXJVbmlmb3Jtcyh5KS5kZWNsYXJlVmFyaWFibGVzKHUsbSl9XG4gICAgICAgICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtofSgwKTtcbiAgICAgICAgICAgICR7X31cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJQYWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0Lm1vZGV9JHthfWAsaW5wdXREZXBlbmRlbmNpZXM6ZH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChrLnNpemUocikvNjQpfSxwcm9ncmFtVW5pZm9ybXM6aX0pLGdldFNoYWRlclNvdXJjZTpsfX0sdmg9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1lWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxuPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGE/ZVsyXS5kYXRhVHlwZT09PTEwP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTplWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjAsbz1lWzBdLmRpbXMubGVuZ3RoLGk9bmV3IEludDMyQXJyYXkoMipvKS5maWxsKDApO2lmKGUubGVuZ3RoPj00KXtsZXQgZD1lWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtmb3IobGV0IGw9MDtsPGQubGVuZ3RoO2wrKylpW051bWJlcihkW2xdKV09TnVtYmVyKHJbbF0pLGlbTnVtYmVyKGRbbF0pK29dPU51bWJlcihyW2wrZC5sZW5ndGhdKX1lbHNlIHIuZm9yRWFjaCgoZCxsKT0+aVtOdW1iZXIobCldPU51bWJlcihkKSk7bGV0IGE9W107cmV0dXJuIGkuZm9yRWFjaChkPT5hLnB1c2goZCkpLHttb2RlOnQubW9kZSx2YWx1ZTpuLHBhZHM6YX19ZWxzZSByZXR1cm4gdH0scmw9KGUsdCk9PntmaChlLmlucHV0cyk7bGV0IHI9dmgoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKHdoKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIGVuLG9sLGlsLGFsLHNsLCRoLHhoLHVsLGRsLGxsLGNsLHBsLG1sLGZsLGhsLGdsLGJsLHlsLF9sLHdsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtMZSgpO0ooKTtuZSgpO2FlKCk7ZW49ZT0+e2lmKF9lLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmKCFlfHxlLmxlbmd0aCE9PTEpKXRocm93IG5ldyBFcnJvcihcIlBvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxvbD0oZSx0LHIpPT57bGV0IG49dC5mb3JtYXQ9PT1cIk5IV0NcIixvPWUuZGltcy5zbGljZSgpO24mJm8uc3BsaWNlKDEsMCxvLnBvcCgpKTtsZXQgaT1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwiZGlsYXRpb25zXCIpLGE9dC5rZXJuZWxTaGFwZS5zbGljZSgpLGQ9dC5zdHJpZGVzLnNsaWNlKCksbD1pP3QuZGlsYXRpb25zLnNsaWNlKCk6W10scD10LnBhZHMuc2xpY2UoKTtrdC5hZGp1c3RQb29sQXR0cmlidXRlcyhyLG8sYSxkLGwscCk7bGV0IG09a3QuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShyLG8sZCxsLGEscCx0LmF1dG9QYWQpLHU9T2JqZWN0LmFzc2lnbih7fSx0KTtpP09iamVjdC5hc3NpZ24odSx7a2VybmVsU2hhcGU6YSxzdHJpZGVzOmQscGFkczpwLGRpbGF0aW9uczpsLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTpPYmplY3QuYXNzaWduKHUse2tlcm5lbFNoYXBlOmEsc3RyaWRlczpkLHBhZHM6cCxjYWNoZUtleTp0LmNhY2hlS2V5fSk7bGV0IGg9bS5zbGljZSgpO3JldHVybiBoLnB1c2goaC5zcGxpY2UoMSwxKVswXSksW3Usbj9oOm1dfSxpbD0oZSx0KT0+e2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCIsbj1rLnNpemUoZSksbz1rLnNpemUodC5rZXJuZWxTaGFwZSksaT1be3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99XSxhPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgZD10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTFdLGw9dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMV0scD10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTFdLG09dC5wYWRzW3QucGFkcy5sZW5ndGgtMV0sdT0hIShwK20pO2kucHVzaCh7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxMixkYXRhOm19KSxhLnB1c2goe25hbWU6XCJrd1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzd1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwd1N0YXJ0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInB3RW5kXCIsdHlwZTpcInUzMlwifSk7bGV0IGg9ITE7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgXz10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTJdLHk9dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMl0sZz10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTJdLHg9dC5wYWRzW3QucGFkcy5sZW5ndGgtMl07aD0hIShnK3gpLGkucHVzaCh7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6eX0se3R5cGU6MTIsZGF0YTpnfSx7dHlwZToxMixkYXRhOnh9KSxhLnB1c2goe25hbWU6XCJraFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzaFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaFN0YXJ0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBoRW5kXCIsdHlwZTpcInUzMlwifSl9cmV0dXJuW2ksYSwhMCx1LGhdfWVsc2V7aWYocil0aHJvdyBuZXcgRXJyb3IoXCJQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC5cIik7bGV0IGQ9ay5jb21wdXRlU3RyaWRlcyh0Lmtlcm5lbFNoYXBlKTtpLnB1c2goe3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOnQucGFkc30se3R5cGU6MTIsZGF0YTp0LnN0cmlkZXN9KSxhLnB1c2goe25hbWU6XCJrZXJuZWxTdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpkLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnBhZHMubGVuZ3RofSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuc3RyaWRlcy5sZW5ndGh9KTtsZXQgbD10LnBhZHMucmVkdWNlKChwLG0pPT5wK20pO3JldHVybltpLGEsISFsLCExLCExXX19LGFsPShlLHQscixuLG8saSxhLGQsbCxwLG0sdSk9PntsZXQgaD1vLmZvcm1hdD09PVwiTkhXQ1wiLF89dC50eXBlLnZhbHVlLHk9TShcIm91dHB1dFwiLHQudHlwZS50ZW5zb3Isbik7aWYoby5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2xldCBnPVwiXCIseD1cIlwiLCQ9XCJcIix2PXItKGg/MjoxKTtpZihtP2c9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHt2fV0gPSBpbmRpY2VzWyR7dn1dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske3Z9XSA8IDAgfHwgeEluZGljZXNbJHt2fV1cbiAgICAgICAgICAgICAgICAgICAgICA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7dn1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgICAgfWA6Zz1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske3Z9XSA9IGluZGljZXNbJHt2fV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgICAgICB9YCxvLmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCBUPXItKGg/MzoyKTt1P3g9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtUfV0gPSBpbmRpY2VzWyR7VH1dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske1R9XSA8IDAgfHwgeEluZGljZXNbJHtUfV0gPj0gdW5pZm9ybXMueF9zaGFwZVske1R9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQgKz0gaTMyKHVuaWZvcm1zLmt3KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGA6eD1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske1R9XSA9IGluZGljZXNbJHtUfV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xuICAgICAgICAgICAgICAgIGAsJD1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMobCkuZGVjbGFyZVZhcmlhYmxlcyh0LHkpfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7X30oJHtkfSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICAke3h9XG4gICAgICAgICAgICAgICR7Z31cbiAgICAgICAgICAgICAgJHskfVxuICAgICAgICAgICAgICAke2F9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YH1lbHNle2lmKGgpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCBnPW8ua2VybmVsU2hhcGUubGVuZ3RoLHg9by5wYWRzLmxlbmd0aCwkPVwiXCI7cmV0dXJuIHA/JD1gXG4gICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzW2pdID49IHVuaWZvcm1zLnhfc2hhcGVbal0pIHtcbiAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNQYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgICAgfWA6JD1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgJHtpfVxuICAgICAgICAgICAgYCxgXG4gICAgICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtcyhsKS5kZWNsYXJlVmFyaWFibGVzKHQseSl9XG5cbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7Z30+O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7X30oJHtkfSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICB2YXIgaXNQYWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmtlcm5lbFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7Zy0xfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IG9mZnNldCAvICR7cShcInVuaWZvcm1zLmtlcm5lbFN0cmlkZXNcIixcImpcIixnKX07XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gb2Zmc2V0c1tqXSAqICR7cShcInVuaWZvcm1zLmtlcm5lbFN0cmlkZXNcIixcImpcIixnKX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHtnLTF9XSA9IG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7ci1nfXU7IGogPCAke3J9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiAke3EoXCJ1bmlmb3Jtcy5zdHJpZGVzXCIsYGogLSAke3ItZ311YCxnKX1cbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke3ItZ311XSAtICR7cShcInVuaWZvcm1zLnBhZHNcIixcImogLSAydVwiLHgpfTtcbiAgICAgICAgICAgICAgICAgICR7JH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke2F9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YH19LHNsPWU9PmAke2UuZm9ybWF0fTske2UuY2VpbE1vZGV9OyR7ZS5hdXRvUGFkfTske2Uua2VybmVsU2hhcGUubGVuZ3RofWAsJGg9ZT0+YCR7c2woZSl9OyR7ZS5jb3VudEluY2x1ZGVQYWR9YCx4aD1lPT5gJHtzbChlKX07JHtlLnN0b3JhZ2VPcmRlcn07JHtlLmRpbGF0aW9uc31gLHVsPWU9Pih7Zm9ybWF0OmUuZm9ybWF0LGF1dG9QYWQ6W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxjZWlsTW9kZTplLmNlaWxfbW9kZSxrZXJuZWxTaGFwZTplLmtlcm5lbF9zaGFwZSxzdHJpZGVzOmUuc3RyaWRlcyxwYWRzOmUucGFkc30pLGRsPShlLHQscixuKT0+e2xldFtvLGldPW9sKHQsbixyKSxhPUUoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxkPWEudHlwZS52YWx1ZSxsPVwidmFsdWUgKz0geF92YWw7XCIscD1cIlwiO28uY291bnRJbmNsdWRlUGFkP3ArPWB2YWx1ZSAvPSAke2R9KHVuaWZvcm1zLmtlcm5lbFNpemUpO2A6cCs9YHZhbHVlIC89ICR7ZH0oaTMyKHVuaWZvcm1zLmtlcm5lbFNpemUpIC0gcGFkKTtgO2xldFttLHUsaCxfLHldPWlsKGksbyk7bS5wdXNoKC4uLk4odC5kaW1zLGkpKTtsZXQgZz1bXCJyYW5rXCJdO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bi5jYWNoZUtleX07JHtofTske199OyR7eX1gLGlucHV0RGVwZW5kZW5jaWVzOmd9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoay5zaXplKGkpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6eD0+YWwoeCxhLHQuZGltcy5sZW5ndGgsaS5sZW5ndGgsbyxsLHAsMCx1LGgsXyx5KX19LGxsPWU9PntsZXQgdD1lLmNvdW50X2luY2x1ZGVfcGFkIT09MCxyPXVsKGUpO2lmKHIuY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2xcIik7bGV0IG49e2NvdW50SW5jbHVkZVBhZDp0LC4uLnIsY2FjaGVLZXk6XCJcIn07cmV0dXJuey4uLm4sY2FjaGVLZXk6JGgobil9fSxjbD0oZSx0KT0+e2VuKGUuaW5wdXRzKSxlLmNvbXB1dGUoZGwoXCJBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCExLHQpKX0scGw9e2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W10sc3RvcmFnZU9yZGVyOjAsZGlsYXRpb25zOltdfSxtbD1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLnBsLGNhY2hlS2V5OnR9fSxmbD0oZSx0KT0+e2VuKGUuaW5wdXRzKSxlLmNvbXB1dGUoZGwoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCEwLHQpKX0saGw9KGUsdCxyLG4pPT57bGV0W28saV09b2wodCxuLHIpLGE9YFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcbiAgICBgLGQ9XCJcIixsPUUoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxwPVtcInJhbmtcIl0sW20sdSxoLF8seV09aWwoaSxvKTtyZXR1cm4gbS5wdXNoKC4uLk4odC5kaW1zLGkpKSx7bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke24uY2FjaGVLZXl9OyR7aH07JHtffTske3l9YCxpbnB1dERlcGVuZGVuY2llczpwfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGsuc2l6ZShpKS82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOmc9PmFsKGcsbCx0LmRpbXMubGVuZ3RoLGkubGVuZ3RoLG8sYSxkLHQuZGF0YVR5cGU9PT0xMD8tNjU1MDQ6LTFlNSx1LGgsXyx5KX19LGdsPShlLHQpPT57ZW4oZS5pbnB1dHMpLGUuY29tcHV0ZShobChcIk1heFBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LGJsPWU9PntsZXQgdD1lLnN0b3JhZ2Vfb3JkZXIscj1lLmRpbGF0aW9ucyxuPXVsKGUpO2lmKHQhPT0wKXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKG4uY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtsZXQgbz17c3RvcmFnZU9yZGVyOnQsZGlsYXRpb25zOnIsLi4ubixjYWNoZUtleTpcIlwifTtyZXR1cm57Li4ubyxjYWNoZUtleTp4aChvKX19LHlsPWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4ucGwsY2FjaGVLZXk6dH19LF9sPShlLHQpPT57ZW4oZS5pbnB1dHMpLGUuY29tcHV0ZShobChcIkdsb2JhbE1heFBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9fSk7dmFyIFRoLEloLHZsLCRsLHhsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7VGg9KGUsdCk9PntpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkRlcXVhbnRpemVMaW5lYXIgcmVxdWlyZXMgMiBvciAzIGlucHV0cy5cIik7aWYoZS5sZW5ndGg9PT0zJiZlWzFdLmRpbXM9PT1lWzJdLmRpbXMpdGhyb3cgbmV3IEVycm9yKFwieC1zY2FsZSBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZS5cIik7aWYoZS5sZW5ndGg9PT0zJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJ4IGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZS5cIik7aWYoZVswXS5kYXRhVHlwZT09PTYmJmUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiSW4gdGhlIGNhc2Ugb2YgZGVxdWFudGl6aW5nIGludDMyIHRoZXJlIGlzIG5vIHplcm8gcG9pbnQuXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0wJiZlWzFdLmRpbXMubGVuZ3RoIT09MSYmZVsxXS5kaW1zLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2NhbGUgaW5wdXQgbXVzdCBiZSBhIHNjYWxhciwgYSAxRCB0ZW5zb3IsIG9yIGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yLlwiKTtpZihlLmxlbmd0aD4yKXtpZihlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJ4IGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZS5cIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PWVbMl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rLlwiKTtpZighZVsxXS5kaW1zLm1hcCgocixuKT0+cj09PWVbMl0uZGltc1tuXSkucmVkdWNlKChyLG4pPT5yJiZuLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLlwiKX1pZih0LmJsb2NrU2l6ZT4wKXtpZihlWzFdLmRpbXMubGVuZ3RoPT09MHx8ZVsxXS5kaW1zLmxlbmd0aD09PTEmJmVbMV0uZGltc1swXT09PTEpdGhyb3cgbmV3IEVycm9yKFwiYmxvY2tTaXplIG11c3QgYmUgc2V0IG9ubHkgZm9yIGJsb2NrIHF1YW50aXphdGlvbi5cIik7aWYoIWVbMV0uZGltcy5tYXAoKG8saSk9Pmk9PT10LmF4aXN8fG89PT1lWzBdLmRpbXNbaV0pLnJlZHVjZSgobyxpKT0+byYmaSwhMCkpdGhyb3cgbmV3IEVycm9yKFwiRm9yIGJsb2NrIHF1bmF0aXphdGlvbiwgc2NhbGUgaW5wdXQgc2hhcGUgdG8gbWF0Y2ggdGhlIGlucHV0IHNoYXBlIGV4Y2VwdCBmb3IgdGhlIGF4aXNcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRm9yIGJsb2NrIHF1bmF0aXphdGlvbiB0aGUgc2NhbGUgaW5wdXQgcmFuayBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSB4IHJhbmsuXCIpO2xldCByPWVbMF0uZGltc1t0LmF4aXNdLG49ZVsxXS5kaW1zW3QuYXhpc107aWYodC5ibG9ja1NpemU8TWF0aC5jZWlsKHIvbil8fHQuYmxvY2tTaXplPk1hdGguY2VpbChyLyhuLTEpLTEpKXRocm93IG5ldyBFcnJvcihcImJsb2NrU2l6ZSBtdXN0IGJlIHdpdGggaW4gdGhlIHJhbmdlIFtjZWlsKGRJIC8gU2kpLCBjZWlsKGRJIC8gKFNpIC0gMSkgLSAxKV0uXCIpfX0sSWg9KGUsdCk9PntsZXQgcj1rLm5vcm1hbGl6ZUF4aXModC5heGlzLGVbMF0uZGltcy5sZW5ndGgpLG49ZVswXS5kYXRhVHlwZSxvPW49PT0zLGk9ZVswXS5kaW1zLGE9ZVsxXS5kYXRhVHlwZSxkPWsuc2l6ZShpKSxsPW49PT0zfHxuPT09MixwPWw/W01hdGguY2VpbChrLnNpemUoZVswXS5kaW1zKS80KV06ZVswXS5kaW1zLG09ZVsxXS5kaW1zLHU9ZS5sZW5ndGg+Mj9lWzJdOnZvaWQgMCxoPXU/bD9bTWF0aC5jZWlsKGsuc2l6ZSh1LmRpbXMpLzQpXTp1LmRpbXM6dm9pZCAwLF89bS5sZW5ndGg9PT0wfHxtLmxlbmd0aD09PTEmJm1bMF09PT0xLHk9Xz09PSExJiZtLmxlbmd0aD09PTEsZz1tZShkKSx4PV8mJighbHx8Zz09PTQpLCQ9eD9nOjEsdj14JiYhbD9nOjEsUz1FKFwiaW5wdXRcIixsPzEyOm4scC5sZW5ndGgsdiksVD1FKFwic2NhbGVcIixhLG0ubGVuZ3RoKSxBPXU/RShcInplcm9fcG9pbnRcIixsPzEyOm4saC5sZW5ndGgpOnZvaWQgMCxDPU0oXCJvdXRwdXRcIixhLGkubGVuZ3RoLCQpLFA9W1MsVF07QSYmUC5wdXNoKEEpO2xldCBEPVtwLG1dO3UmJkQucHVzaChoKTtsZXQgUj1be3R5cGU6MTIsZGF0YTpkLyR9LHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTp0LmJsb2NrU2l6ZX0sLi4uTiguLi5ELGkpXSxIPUw9PntsZXQgcmU9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJibG9ja19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAgICAgJHtMLnJlZ2lzdGVyVW5pZm9ybXMocmUpLmRlY2xhcmVWYXJpYWJsZXMoLi4uUCxDKX1cbiAgICAgICR7TC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke0wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7Qy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgIC8vIFNldCBpbnB1dCB4XG4gICAgICAgICAgJHsoKCk9Pmw/YFxuICAgICAgICAgICAgbGV0IGlucHV0ID0gJHtTLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAvIDRcIil9O1xuICAgICAgICAgICAgbGV0IHhfdmVjID0gJHtvP1widW5wYWNrNHhJOChpbnB1dClcIjpcInVucGFjazR4VTgoaW5wdXQpXCJ9O1xuICAgICAgICAgICAgbGV0IHhfdmFsdWUgPSAkeyQ9PT0xP1wieF92ZWNbZ2xvYmFsX2lkeCAlIDRdXCI6XCJ4X3ZlY1wifTtgOmBsZXQgeF92YWx1ZSA9ICR7Uy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O2ApKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHNjYWxlIGlucHV0XG4gICAgICAgICAgJHsoKCk9Pl8/YGxldCBzY2FsZV92YWx1ZT0gJHtULmdldEJ5T2Zmc2V0KFwiMFwiKX1gOnk/YFxuICAgICAgICAgICAgbGV0IHNjYWxlX2luZGV4ID0gJHtDLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7VC5nZXRCeU9mZnNldChcInNjYWxlX2luZGV4XCIpfTtgOmBcbiAgICAgICAgICAgIHZhciBzY2FsZV9pbmRpY2VzOiAke1QudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtULmluZGljZXNHZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICAgICAke1QuaW5kaWNlc1NldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcImluZGV4XCIpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtULmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O2ApKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHplcm8tcG9pbnQgaW5wdXRcbiAgICAgICAgICAkeygoKT0+QT9fP2w/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiMFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWU9IHplcm9fcG9pbnRfdmVjWzBdYDpgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke0EuZ2V0QnlPZmZzZXQoXCIwXCIpfWA6eT9sP2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7Qy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9pbmRleCAvIDRcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAlIDRdYDpgXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSAke0MuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfaW5kZXhcIil9O2A6bD9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHtULmluZGljZXNUb09mZnNldChcInNjYWxlX2luZGljZXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9vZmZzZXQgLyA0XCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9vZmZzZXQgJSA0XTtgOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtgOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7bD9vP1wiaTMyXCI6XCJ1MzJcIjpTLnR5cGUudmFsdWV9KDApO2ApKCl9O1xuICAgICAgLy8gQ29tcHV0ZSBhbmQgd3JpdGUgb3V0cHV0XG4gICAgICAke0Muc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsYCR7Qy50eXBlLnZhbHVlfSh4X3ZhbHVlIC0gemVyb19wb2ludF92YWx1ZSkgKiBzY2FsZV92YWx1ZWApfTtcbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkRlcXVhbnRpemVMaW5lYXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOkE/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6SCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvJC82NCkseToxLHo6MX0scHJvZ3JhbVVuaWZvcm1zOlJ9KX19LHZsPShlLHQpPT57VGgoZS5pbnB1dHMsdCksZS5jb21wdXRlKEloKGUuaW5wdXRzLHQpKX0sJGw9ZT0+ZWUoe2F4aXM6ZS5heGlzLGJsb2NrU2l6ZTplLmJsb2NrU2l6ZX0pfSk7dmFyIENoLEFoLFNsLFRsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtMZSgpO0ooKTthZSgpO0NoPShlLHQscik9PntsZXQgbj1lPT09dCxvPWU8dCYmcjwwLGk9ZT50JiZyPjA7aWYobnx8b3x8aSl0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSB0aGVzZSBpbnB1dHMnIGNvbnRlbnRzIGFyZSBpbnZhbGlkLlwiKX0sQWg9KGUsdCxyLG4pPT57bGV0IG89TWF0aC5hYnMoTWF0aC5jZWlsKCh0LWUpL3IpKSxpPVtvXSxhPW8sZD1be3R5cGU6MTIsZGF0YTphfSx7dHlwZTpuLGRhdGE6ZX0se3R5cGU6bixkYXRhOnJ9LC4uLk4oaSldLGw9cD0+e2xldCBtPU0oXCJvdXRwdXRcIixuLGkubGVuZ3RoKSx1PW0udHlwZS52YWx1ZSxoPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RhcnRcIix0eXBlOnV9LHtuYW1lOlwiZGVsdGFcIix0eXBlOnV9XTtyZXR1cm5gXG4gICAgICAgICR7cC5yZWdpc3RlclVuaWZvcm1zKGgpLmRlY2xhcmVWYXJpYWJsZXMobSl9XG4gICAgICAgICR7cC5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtwLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB1bmlmb3Jtcy5zdGFydCArICR7dX0oZ2xvYmFsX2lkeCkgKiB1bmlmb3Jtcy5kZWx0YTtcbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlJhbmdlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bn1gfSxnZXRTaGFkZXJTb3VyY2U6bCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6bn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6ZH0pfX0sU2w9ZT0+e2xldCB0PTAscj0wLG49MDtlLmlucHV0c1swXS5kYXRhVHlwZT09PTY/KHQ9ZS5pbnB1dHNbMF0uZ2V0SW50MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMV0uZ2V0SW50MzJBcnJheSgpWzBdLG49ZS5pbnB1dHNbMl0uZ2V0SW50MzJBcnJheSgpWzBdKTplLmlucHV0c1swXS5kYXRhVHlwZT09PTEmJih0PWUuaW5wdXRzWzBdLmdldEZsb2F0MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF0sbj1lLmlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXSksX2Uud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiZDaCh0LHIsbiksZS5jb21wdXRlKEFoKHQscixuLGUuaW5wdXRzWzBdLmRhdGFUeXBlKSx7aW5wdXRzOltdfSl9fSk7dmFyIGtoLEVoLElsLENsLEFsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7a2g9KGUsdCxyLG4pPT57aWYoZSE9PVwibm9uZVwiJiZuIT09XCJpMzJcIiYmbiE9PVwidTMyXCImJm4hPT1cImYzMlwiKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtufSBpcyBub3Qgc3VwcG9ydGVkIHdpdGggcmVkdWN0aW9uICR7ZX0uYCk7bGV0IG89YHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGxvb3Age1xuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlRjMyID1gLGk9YDtcbiAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IGJpdGNhc3Q8aTMyPihuZXdWYWx1ZUYzMik7XG4gICAgICAgICAgICAgICAgICBsZXQgcmVzID0gYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhaygmJHt0fSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIHJlcy5leGNoYW5nZWQge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzLm9sZF92YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1gO3N3aXRjaChlKXtjYXNlXCJub25lXCI6cmV0dXJuYCR7dH09JHtyfTtgO2Nhc2VcImFkZFwiOnJldHVybiBuPT09XCJpMzJcInx8bj09PVwidTMyXCI/YGF0b21pY0FkZCgmJHt0fSwgYml0Y2FzdDwke259Pigke3J9KSk7YDpgXG4gICAgICAgICAgICAgICR7b31iaXRjYXN0PCR7bn0+KG9sZFZhbHVlKSArICgke3J9KSR7aX1gO2Nhc2VcIm1heFwiOnJldHVybiBuPT09XCJpMzJcInx8bj09PVwidTMyXCI/YGF0b21pY01heCgmJHt0fSwgYml0Y2FzdDwke259Pigke3J9KSk7YDpgXG4gICAgICAgICAgICAgICAgJHtvfW1heChiaXRjYXN0PGYzMj4ob2xkVmFsdWUpLCAoJHtyfSkpJHtpfWA7Y2FzZVwibWluXCI6cmV0dXJuIG49PT1cImkzMlwifHxuPT09XCJ1MzJcIj9gYXRvbWljTWluKCYke3R9LCBiaXRjYXN0PCR7bn0+KCR7cn0pKTtgOmAke299bWluKGJpdGNhc3Q8JHtufT4ob2xkVmFsdWUpLCAoJHtyfSkpJHtpfWA7Y2FzZVwibXVsXCI6cmV0dXJuYCR7b30oYml0Y2FzdDwke259PihvbGRWYWx1ZSkgKiAoJHtyfSkpJHtpfWA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFJlZHVjdGlvbiAke2V9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxFaD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWVbMV0uZGltcyxvPXIsaT0xLGE9TWF0aC5jZWlsKGsuc2l6ZShuKS9pKSxkPW5bbi5sZW5ndGgtMV0sbD1rLnNpemVGcm9tRGltZW5zaW9uKHIsZCkscD1be3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6bH0sLi4uTihlWzFdLmRpbXMsZVsyXS5kaW1zLG8pXSxtPXU9PntsZXQgaD1FKFwiaW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksXz1FKFwidXBkYXRlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxpKSx5PXQucmVkdWN0aW9uIT09XCJub25lXCImJnQucmVkdWN0aW9uIT09XCJcIj90cyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgpOk0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoLGkpO3JldHVybmBcbiAgICAgICR7dS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImxhc3RfaW5kZXhfZGltZW5zaW9uXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwibnVtX3VwZGF0ZXNfZWxlbWVudHNcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGgsXyx5KX1cbiAgICAgICR7dS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHt1Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgdmFyIGRhdGFfb2Zmc2V0ID0gMHU7XG4gIGxldCBpbmRpY2VzX3N0YXJ0ID0gdW5pZm9ybXMubGFzdF9pbmRleF9kaW1lbnNpb24gKiBnbG9iYWxfaWR4O1xuICBsZXQgaW5kaWNlc19lbmQgPSBpbmRpY2VzX3N0YXJ0ICsgdW5pZm9ybXMubGFzdF9pbmRleF9kaW1lbnNpb247XG4gIGZvciAodmFyIGkgPSBpbmRpY2VzX3N0YXJ0OyBpIDwgaW5kaWNlc19lbmQ7IGkrKykge1xuICAgIHZhciBpbmRleCA9IGkzMihpbmRpY2VzW2ldLngpO1xuICAgICR7ZVswXS5kaW1zLmxlbmd0aD09PTE/YFxuICAgIGxldCBlbGVtZW50X2NvdW50X2RpbSA9IHVuaWZvcm1zLm91dHB1dF9zdHJpZGVzO1xuICAgIGxldCBkaW1fdmFsdWUgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGU7YDpgXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXNbaSAtIGluZGljZXNfc3RhcnRdO1xuICAgIGxldCBkaW1fdmFsdWUgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbaSAtIGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbl07YH1cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgaWYgKGluZGV4ID49IGkzMihkaW1fdmFsdWUpKSB7XG4gICAgICAgIGluZGV4ID0gaTMyKGRpbV92YWx1ZSAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5kZXggPCAtaTMyKGRpbV92YWx1ZSkpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggKz0gaTMyKGRpbV92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRhdGFfb2Zmc2V0ICs9IHUzMigodTMyKGluZGV4KSAqIGVsZW1lbnRfY291bnRfZGltKSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMHU7IGkgPCB1bmlmb3Jtcy5udW1fdXBkYXRlc19lbGVtZW50czsgaSsrKSB7XG4gICAgbGV0IHZhbHVlID0gdXBkYXRlc1t1bmlmb3Jtcy5udW1fdXBkYXRlc19lbGVtZW50cyAqIGdsb2JhbF9pZHggKyBpXTtcbiAgICAke2toKHQucmVkdWN0aW9uLFwib3V0cHV0W2RhdGFfb2Zmc2V0ICsgaV1cIixcInZhbHVlXCIseS50eXBlLnZhbHVlKX1cbiAgfVxuXG4gICAgICB9YH07cmV0dXJue25hbWU6XCJTY2F0dGVyTkRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fV8ke3QucmVkdWN0aW9ufWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6bX19LElsPWU9PmVlKHtyZWR1Y3Rpb246ZS5yZWR1Y3Rpb259KSxDbD0oZSx0KT0+e2UuY29tcHV0ZShFaChlLmlucHV0cyx0KSx7aW5wdXRzOltlLmlucHV0c1sxXSxlLmlucHV0c1syXV0sb3V0cHV0czpbXX0pfX0pO3ZhciBQaCx6aCxPaCxrbCxEaCxCaCxNaCxSaCxVaCxOaCxWaCxXaCxFbCxMaCxHaCxIaCxGaCxxaCxQbCx6bCxPbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTthZSgpO1BoPShlLHQpPT57aWYoZS5ldmVyeShyPT5yPjB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlXCIpfSkpLGUubGVuZ3RoPjApe2lmKHQubW9kZT09PVwibGluZWFyXCIpe2lmKCEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTN8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MXx8ZS5sZW5ndGg9PT01JiZlWzBdPT09MSYmZVsxXT09PTEpKXRocm93IG5ldyBFcnJvcihgRm9yIGxpbmVhciBtb2RlLCBSZXNpemUgcmVxdWlyZXMgc2NhbGVzIHRvIGJlIDJELCAzRCwgNEQgd2l0aCBlaXRoZXIgdHdvIG91dGVybW9zdCBvciBvbmUgaW5uZXJtb3N0IGFuZFxuICAgICAgICAgICAgb25lIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMSwgb3IgNUQgd2l0aCB0d28gb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxYCl9ZWxzZSBpZih0Lm1vZGU9PT1cImN1YmljXCImJiEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGVcIil9fSx6aD0oZSx0LHIpPT57dC5ldmVyeShvPT5vPj0wJiZvPHJ8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmtcIil9KSk7bGV0IG49bmV3IEFycmF5KHIpLmZpbGwoMSk7cmV0dXJuIHQuZm9yRWFjaCgobyxpKT0+bltvXT1lW2ldKSxufSxPaD0oZSx0LHIsbixvLGkpPT57bGV0W2EsZCxsXT1yPjEwP1sxLDIsM106Wy0xLGUubGVuZ3RoPjE/MTotMSwtMV0scD1lWzBdLmRpbXMubGVuZ3RoO2lmKGE+MCYmZS5sZW5ndGg+YSYmZVthXS5kaW1zLmxlbmd0aD4wKWVbYV0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChtPT5pLnB1c2gobSkpO2Vsc2UgaWYodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemVcIik7aWYoZD4wJiZlLmxlbmd0aD5kJiZlW2RdLmRpbXMubGVuZ3RoPT09MSYmZVtkXS5kaW1zWzBdPjApe2lmKGVbZF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChtPT5uLnB1c2gobSkpLG4ubGVuZ3RoIT09MCYmbi5sZW5ndGghPT1wJiZyPj0xOCYmbi5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7UGgobix0KSx0LmF4ZXMubGVuZ3RoPjAmJnpoKG4sdC5heGVzLHApLmZvckVhY2goKG0sdSk9Pm5bdV09bSl9aWYobD4wJiZlLmxlbmd0aD5sJiZlW2xdLmRpbXMubGVuZ3RoPT09MSYmZVtsXS5kaW1zWzBdPjAmJihlW2xdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG09Pm8ucHVzaChOdW1iZXIobSkpKSxvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09cCYmcj49MTgmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO2lmKHQuYXhlcy5sZW5ndGg+MCl7aWYobi5sZW5ndGghPT0wJiZuLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtpZihvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKX1pZih0eXBlb2YgbjxcInVcIiYmdHlwZW9mIG88XCJ1XCImJm4ubGVuZ3RoPjAmJm8ubGVuZ3RoPnApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIG9ubHkgb2Ygc2NhbGVzIG9yIHNpemVzIHRvIGJlIHNwZWNpZmllZFwiKX0sa2w9KGUsdCxyLG4pPT5gXG4gIC8vIFRoZSB3aG9sZSBwYXJ0IGFuZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IGFyZSBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZHVlIHRvIGluYWNjdXJhY3kgb2YgZmxvYXRpbmdcbiAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXG4gIC8vIG9mZnNldC1ieS1vbmUgZXJyb3IgbGF0ZXIgaW4gZmxvb3IoKS5cbiAgbGV0IGJpZyA9ICgke2V9KSAqICgke3R9KTtcbiAgbGV0IHdob2xlID0gJHtufShiaWcgLyAoJHtyfSkpO1xuICBsZXQgZnJhY3QgPSAke259KGJpZyAlICgke3J9KSkgLyAke259KCR7cn0pO1xuICByZXR1cm4gd2hvbGUgKyBmcmFjdDtcbmAsRGg9KGUsdCk9PmBmbiBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoeFJlc2l6ZWQ6IHUzMiwgeFNjYWxlOiBmMzIsIGxlbmd0aFJlc2l6ZWQ6IHUzMixcbiAgICAgbGVuZ3RoT3JpZ2luYWw6IHUzMiwgcm9pU3RhcnQ6IGYzMiwgcm9pRW5kOiBmMzIpIC0+ICR7dH0geyBgKygoKT0+e3N3aXRjaChlKXtjYXNlXCJhc3ltbWV0cmljXCI6cmV0dXJuYFxuICAgICAgICAgIGlmICh4U2NhbGUgPCAxLjAgfHwgZmxvb3IoeFNjYWxlKSAhPSB4U2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiAke3R9KHhSZXNpemVkKSAvICR7dH0oeFNjYWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHtrbChcInhSZXNpemVkXCIsXCJsZW5ndGhPcmlnaW5hbFwiLFwibGVuZ3RoUmVzaXplZFwiLHQpfVxuICAgICAgICAgIH1cbiAgICAgICAgYDtjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjpyZXR1cm5gaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpIC0gMC41O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCI6cmV0dXJuYHJldHVybiAoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpO2A7Y2FzZVwiYWxpZ25fY29ybmVyc1wiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAke2tsKFwieFJlc2l6ZWRcIixcImxlbmd0aE9yaWdpbmFsIC0gMVwiLFwibGVuZ3RoUmVzaXplZCAtIDFcIix0KX1cbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR7dH0ocm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgke3R9KHhSZXNpemVkKSAqICR7dH0ocm9pRW5kIC0gcm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAke3R9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAke3R9KHJvaVN0YXJ0ICsgcm9pRW5kKSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcImhhbGZfcGl4ZWxfc3ltbWV0cmljXCI6cmV0dXJuYGNvbnN0IG91dHB1dFdpZHRoID0gJHt0fXhTY2FsZSAqICR7dH0obGVuZ3RoUmVzaXplZCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gJHt0fShsZW5ndGhSZXNpemVkKSAvIG91dHB1dFdpZHRoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gJHt0fShsZW5ndGhPcmlnaW5hbCkgLyAyO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtjYXNlXCJoYWxmX3BpeGVsXCI6cmV0dXJuYHJldHVybiAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLEJoPShlLHQscik9PmBmbiBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoeE9yaWdpbmFsOiAke3J9LCBpc0Rvd25TYW1wbGU6IGJvb2wpIC0+ICR7cn0ge2ArKCgpPT57c3dpdGNoKGUpe2Nhc2VcInJvdW5kX3ByZWZlcl9jZWlsXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgfVwiO2Nhc2VcImZsb29yXCI6cmV0dXJuXCJyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTtcIjtjYXNlXCJjZWlsXCI6cmV0dXJuXCJyZXR1cm4gY2VpbCh4T3JpZ2luYWwpO1wiO2Nhc2VcInJvdW5kX3ByZWZlcl9mbG9vclwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJzaW1wbGVcIjpkZWZhdWx0OmlmKHQ8MTEpcmV0dXJuXCJpZiAoaXNEb3duU2FtcGxlKSAgICAgICAgICAgICAgICAgICAgIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7ICAgICAgICAgICAgICAgICAgICAgfVwiO3Rocm93IG5ldyBFcnJvcihgTmVhcmVzdCBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsTWg9KGUsdCxyKT0+e2xldCBuPW5ldyBBcnJheShyKS5maWxsKDApLmNvbmNhdChuZXcgQXJyYXkocikuZmlsbCgxKSksbz1lLmxlbmd0aD09PTA/bjplLnNsaWNlKCk7cmV0dXJuIHQubGVuZ3RoPjA/KHQuZm9yRWFjaCgoaSxhKT0+e25baV09b1thXSxuW2Ercl09b1t0Lmxlbmd0aCthXX0pLG4pOm99LFJoPShlLHQscixuKT0+e2xldCBvPVtdO2lmKHIubGVuZ3RoPjApaWYobi5sZW5ndGg+MCl7aWYoZS5mb3JFYWNoKGk9Pm8ucHVzaChpKSksTWF0aC5tYXgoLi4ubik+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcyBpcyBvdXQgb2YgYm91bmRcIik7bi5mb3JFYWNoKChpLGEpPT5vW2ldPXJbYV0pfWVsc2Ugci5mb3JFYWNoKGk9Pm8ucHVzaChpKSk7ZWxzZXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGVpdGhlciBzY2FsZXMgb3Igc2l6ZXMuXCIpO289ZS5tYXAoKGksYSk9Pk1hdGgucm91bmQoaSp0W2FdKSl9cmV0dXJuIG99LFVoPShlLHQscik9PntsZXQgbj0oKCk9Pntzd2l0Y2goci5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpe2Nhc2VcIm5vdF9sYXJnZXJcIjpyZXR1cm4gci5heGVzLmxlbmd0aD4wP01hdGgubWluKC4uLnIuYXhlcy5tYXAoaT0+dFtpXSksTnVtYmVyLk1BWF9WQUxVRSk6TWF0aC5taW4oLi4udCxOdW1iZXIuTUFYX1ZBTFVFKTtjYXNlXCJub3Rfc21hbGxlclwiOnJldHVybiByLmF4ZXMubGVuZ3RoPjA/TWF0aC5tYXgoLi4uci5heGVzLm1hcChpPT50W2ldKSxOdW1iZXIuTUlOX1ZBTFVFKTpNYXRoLm1heCguLi50LE51bWJlci5NSU5fVkFMVUUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHtyLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCk7dC5maWxsKDEsMCx0Lmxlbmd0aCk7bGV0IG89ZS5zbGljZSgpO3JldHVybiByLmF4ZXMubGVuZ3RoPjA/KHIuYXhlcy5mb3JFYWNoKGk9PnRbaV09biksci5heGVzLmZvckVhY2goaT0+b1tpXT1NYXRoLnJvdW5kKGVbaV0qdFtpXSkpKToodC5maWxsKG4sMCx0Lmxlbmd0aCksby5mb3JFYWNoKChpLGEpPT5vW2FdPU1hdGgucm91bmQoaSp0W2FdKSkpLG99LE5oPShlLHQscixuLG8pPT5gXG4gICAgZm4gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBhcnJheTwke2UudHlwZS52YWx1ZX0sICR7ci5sZW5ndGh9PiB7XG4gICAgICB2YXIgb3JpZ2luYWxfaW5kaWNlczogYXJyYXk8JHtlLnR5cGUudmFsdWV9LCAke3IubGVuZ3RofT47XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtxKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIsbil9O1xuICAgICAgICB2YXIgcm9pX2xvdyA9ICR7cShcInVuaWZvcm1zLnJvaVwiLFwiaVwiLG8pfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7cShcInVuaWZvcm1zLnJvaVwiLGBpICsgJHt0Lmxlbmd0aH1gLG8pfTtcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSAke2UudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7cShcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke3EoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxfaW5kaWNlcztcbiAgICB9YCxWaD0oZSx0LHIsbixvLGksYSk9PmBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7bi5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtxKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIsbyl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvaV9sb3cgPSAke3EoXCJ1bmlmb3Jtcy5yb2lcIixcImlcIixpKX07XG4gICAgICAgICAgdmFyIHJvaV9oaSA9ICR7cShcInVuaWZvcm1zLnJvaVwiLGBpICsgJHtyLmxlbmd0aH1gLGkpfTtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7cShcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke3EoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICAgIGlmICghJHthfSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHt0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSAtIDEpKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwob3JpZ2luYWxfaWR4LCBzY2FsZSA8IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIob3JpZ2luYWxfaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9pbmRleFwiKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgIH1gLFdoPShlLHQpPT5gXG4gICAgZm4gY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcImlucHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICBpZiAoaW5wdXRfaW5kZXggPCAwIHx8IGlucHV0X2luZGV4ID49ICR7cShcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfWAsRWw9KGUsdCxyLG4pPT5lLnJhbms+bj9gXG4gICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsdCxcImNoYW5uZWxcIil9O1xuICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHIsXCJiYXRjaFwiKX07XG5gOlwiXCIsTGg9KGUsdCxyLG4sbyk9PntsZXRbYSxkLGwscF09ci5sZW5ndGg9PT0yP1stMSwwLDEsLTFdOlswLDIsMywxXSxtPWUudHlwZS52YWx1ZTtyZXR1cm5gXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIHJvdzogdTMyLCBjb2w6IHUzMikgLT4gJHttfSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLGBtYXgoMCwgbWluKHJvdywgJHtyW2RdfSAtIDEpKWApfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGwsYG1heCgwLCBtaW4oY29sLCAke3JbbF19IC0gMSkpYCl9O1xuICAgICAgJHtFbChlLHAsYSwyKX1cbiAgICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgfVxuXG4gICAgZm4gYmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHttfSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIHJvdzoke219ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZH1dO1xuICAgICAgdmFyIGNvbDoke219ID0gb3JpZ2luYWxJbmRpY2VzWyR7bH1dO1xuICAgICAgJHtuP2BpZiAocm93IDwgMCB8fCByb3cgPiAoJHtyW2RdfSAtIDEpIHx8IGNvbCA8IDAgfHwgY29sID4gKCR7cltsXX0gLSAxKSkge1xuICAgICAgICByZXR1cm4gJHtvfTtcbiAgICAgIH1gOlwiXCJ9O1xuICAgICAgcm93ID0gbWF4KDAsIG1pbihyb3csICR7cltkXX0gLSAxKSk7XG4gICAgICBjb2wgPSBtYXgoMCwgbWluKGNvbCwgJHtyW2xdfSAtIDEpKTtcbiAgICAgIHZhciByb3cxOiB1MzIgPSB1MzIocm93KTtcbiAgICAgIHZhciBjb2wxOiB1MzIgPSB1MzIoY29sKTtcbiAgICAgIHZhciByb3cyOiB1MzIgPSB1MzIocm93ICsgMSk7XG4gICAgICB2YXIgY29sMjogdTMyID0gdTMyKGNvbCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7ci5sZW5ndGg+Mj9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske3B9XSlgOlwiMFwifTtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7ci5sZW5ndGg+Mj9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske2F9XSlgOlwiMFwifTtcbiAgICAgIHZhciB4MTE6ICR7bX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wxKTtcbiAgICAgIHZhciB4MTI6ICR7bX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wyKTtcbiAgICAgIHZhciB4MjE6ICR7bX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wxKTtcbiAgICAgIHZhciB4MjI6ICR7bX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wyKTtcbiAgICAgIHZhciBkeDE6ICR7bX0gPSBhYnMocm93IC0gJHttfShyb3cxKSk7XG4gICAgICB2YXIgZHgyOiAke219ID0gYWJzKCR7bX0ocm93MikgLSByb3cpO1xuICAgICAgdmFyIGR5MTogJHttfSA9IGFicyhjb2wgLSAke219KGNvbDEpKTtcbiAgICAgIHZhciBkeTI6ICR7bX0gPSBhYnMoJHttfShjb2wyKSAtIGNvbCk7XG4gICAgICBpZiAocm93MSA9PSByb3cyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGNvbDEgPT0gY29sMikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExICogZHgyICogZHkyICsgeDEyICogZHgyICogZHkxICsgeDIxICogZHgxICogZHkyICsgeDIyICogZHgxICogZHkxKTtcbiAgICB9YH0sR2g9KGUsdCxyLG4sbyxpLGEsZCxsLHApPT57bGV0IG09ci5sZW5ndGg9PT0yLHU9ITAsW2gsX109bT9bMCwxXTp1P1syLDNdOlsxLDJdLHk9ZS50eXBlLnZhbHVlLGc9eD0+e2xldCAkPXg9PT1oP1wicm93XCI6XCJjb2xcIjtyZXR1cm5gXG4gICAgICBmbiAkeyR9Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9LCBvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7eX0ge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLHgpfTtcbiAgICAgICAgdmFyIG9yaWdpbmFsSWR4OiAke3l9ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgJHtvW3hdfSxcbiAgICAgICAgJHtuW3hdfSwgJHtyW3hdfSwgJHtpW3hdfSwgJHtpW3hdfSArICR7ci5sZW5ndGh9KTtcbiAgICAgICAgdmFyIGZyYWN0T3JpZ2luYWxJZHg6ICR7eX0gPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcbiAgICAgICAgdmFyIGNvZWZzID0gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoZnJhY3RPcmlnaW5hbElkeCk7XG5cbiAgICAgICAgaWYgKCR7ZH0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke3JbeF19IC0gMSkpKSB7XG4gICAgICAgICAgcmV0dXJuICR7bH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PCR7eX0sIDQ+ID0gYXJyYXk8JHt5fSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgZm9yICh2YXIgaTogaTMyID0gLTE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB2YXIgJHskfTogJHt5fSA9IG9yaWdpbmFsSWR4ICsgJHt5fShpKTtcbiAgICAgICAgICBpZiAoJHskfSA8IDAgfHwgJHskfSA+PSAke3JbeF19KSB7XG4gICAgICAgICAgICAkeygoKT0+cD9gY29lZnNbaSArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7YDpkP2ByZXR1cm4gJHtsfTtgOmAkeyR9ID0gbWF4KDAsIG1pbigkeyR9LCAke3JbeF19IC0gMSkpO2ApKCl9O1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0X2luZGljZXNfY29weTogJHtlLnR5cGUuaW5kaWNlc30gPSBpbnB1dF9pbmRpY2VzO1xuICAgICAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc19jb3B5XCIseCxgdTMyKCR7JH0pYCl9O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gJHt4PT09aD9lLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNfY29weVwiKTpcInJvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzX2NvcHksIG91dHB1dF9pbmRpY2VzKVwifTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoZGF0YSwgY29lZnMpO1xuICAgICAgfWB9O3JldHVybmBcbiAgICAke2coaCl9O1xuICAgICR7ZyhfKX07XG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6ICR7eX0pIC0+IGFycmF5PCR7eX0sIDQ+IHtcbiAgICB2YXIgYWJzUyA9IGFicyhzKTtcbiAgICB2YXIgY29lZmZzOiBhcnJheTwke3l9LCA0PiA9IGFycmF5PCR7eX0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgdmFyIG9uZU1pbnVzQWJzUzogJHt5fSA9IDEuMCAtIGFic1M7XG4gICAgdmFyIHR3b01pbnVzQWJzUzogJHt5fSA9IDIuMCAtIGFic1M7XG4gICAgdmFyIG9uZVBsdXNBYnNTOiAke3l9ID0gMS4wICsgYWJzUztcbiAgICBjb2VmZnNbMF0gPSAoKCR7YX0gKiBvbmVQbHVzQWJzUyAtIDUgKiAke2F9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7YX0pICogb25lUGx1c0Fic1MgLSA0ICogJHthfTtcbiAgICBjb2VmZnNbMV0gPSAoKCR7YX0gKyAyKSAqIGFic1MgLSAoJHthfSArIDMpKSAqIGFic1MgKiBhYnNTICsgMTtcbiAgICBjb2VmZnNbMl0gPSAoKCR7YX0gKyAyKSAqIG9uZU1pbnVzQWJzUyAtICgke2F9ICsgMykpICogb25lTWludXNBYnNTICogb25lTWludXNBYnNTICsgMTtcbiAgICBjb2VmZnNbM10gPSAoKCR7YX0gKiB0d29NaW51c0Fic1MgLSA1ICogJHthfSkgKiB0d29NaW51c0Fic1MgKyA4ICogJHthfSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHthfTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5cbiAgZm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoeDogYXJyYXk8JHt5fSwgND4sIGNvZWZzOiBhcnJheTwke3l9LCA0PikgLT4gJHt5fSB7XG4gICAgdmFyIGNvZWZzU3VtOiAke3l9ID0gY29lZnNbMF0gKyBjb2Vmc1sxXSArIGNvZWZzWzJdICsgY29lZnNbM107XG4gICAgcmV0dXJuICh4WzBdICogY29lZnNbMF0gKyB4WzFdICogY29lZnNbMV0rIHhbMl0gKiBjb2Vmc1syXSsgeFszXSAqIGNvZWZzWzNdKSAvIGNvZWZzU3VtO1xuICB9XG5cbiAgZm4gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke3l9IHtcbiAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXMsIG91dHB1dF9pbmRpY2VzKTtcbiAgfVxuICAgIGB9LEhoPShlLHQscixuLG8pPT57bGV0W2EsZCxsLHAsbV09ci5sZW5ndGg9PT0zP1stMSwwLDEsMiwtMV06WzAsMiwzLDQsMV0sdT1lLnR5cGUudmFsdWU7cmV0dXJuYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBkZXB0aDp1MzIsIGhlaWdodDogdTMyLCB3aWR0aDogdTMyKSAtPiAke3V9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGQsYG1heCgwLCBtaW4oZGVwdGgsICR7cltkXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixsLGBtYXgoMCwgbWluKGhlaWdodCwgJHtyW2xdfSAtIDEpKWApfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHAsYG1heCgwLCBtaW4od2lkdGgsICR7cltwXX0gLSAxKSlgKX07XG4gICAgICAke0VsKGUsbSxhLDMpfVxuICAgICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICB9XG5cbiAgICBmbiB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHt1fSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIGRlcHRoOiR7dX0gPSBvcmlnaW5hbEluZGljZXNbJHtkfV07XG4gICAgICB2YXIgaGVpZ2h0OiR7dX0gPSBvcmlnaW5hbEluZGljZXNbJHtsfV07XG4gICAgICB2YXIgd2lkdGg6JHt1fSA9IG9yaWdpbmFsSW5kaWNlc1ske3B9XTtcbiAgICAgICR7bj9gaWYgKGRlcHRoIDwgMCB8fCBkZXB0aCA+ICgke3JbZF19IC0gMSkgfHwgaGVpZ2h0IDwgMCB8fCBoZWlnaHQgPiAoJHtyW2xdfSAtIDEpIHx8IHdpZHRoIDwgMCB8fCAod2lkdGggPiAke3JbcF19IC0gMSkpIHtcbiAgICAgIHJldHVybiAke299O1xuICAgICAgICB9YDpcIlwifTtcblxuICAgIGRlcHRoID0gbWF4KDAsIG1pbihkZXB0aCwgJHtyW2RdfSAtIDEpKTtcbiAgICAgIGhlaWdodCA9IG1heCgwLCBtaW4oaGVpZ2h0LCAke3JbbF19IC0gMSkpO1xuICAgICAgd2lkdGggPSBtYXgoMCwgbWluKHdpZHRoLCAke3JbcF19IC0gMSkpO1xuICAgICAgdmFyIGRlcHRoMTogdTMyID0gdTMyKGRlcHRoKTtcbiAgICAgIHZhciBoZWlnaHQxOiB1MzIgPSB1MzIoaGVpZ2h0KTtcbiAgICAgIHZhciB3aWR0aDE6IHUzMiA9IHUzMih3aWR0aCk7XG4gICAgICB2YXIgZGVwdGgyOiB1MzIgPSB1MzIoZGVwdGggKyAxKTtcbiAgICAgIHZhciBoZWlnaHQyOiB1MzIgPSB1MzIoaGVpZ2h0ICsgMSk7XG4gICAgICB2YXIgd2lkdGgyOiB1MzIgPSB1MzIod2lkdGggKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke3IubGVuZ3RoPjM/YHUzMihvcmlnaW5hbEluZGljZXNbJHttfV0pYDpcIjBcIn07XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke3IubGVuZ3RoPjM/YHUzMihvcmlnaW5hbEluZGljZXNbJHthfV0pYDpcIjBcIn07XG5cbiAgICAgIHZhciB4MTExOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgxMTI6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDEyMTogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTIyOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIHgyMTE6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMSk7XG4gICAgICB2YXIgeDIxMjogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjIxOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMjI6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMik7XG4gICAgICB2YXIgZHgxOiAke3V9ID0gYWJzKGRlcHRoIC0gJHt1fShkZXB0aDEpKTtcbiAgICAgIHZhciBkeDI6ICR7dX0gPSBhYnMoJHt1fShkZXB0aDIpIC0gZGVwdGgpO1xuICAgICAgdmFyIGR5MTogJHt1fSA9IGFicyhoZWlnaHQgLSAke3V9KGhlaWdodDEpKTtcbiAgICAgIHZhciBkeTI6ICR7dX0gPSBhYnMoJHt1fShoZWlnaHQyKSAtIGhlaWdodCk7XG4gICAgICB2YXIgZHoxOiAke3V9ID0gYWJzKHdpZHRoIC0gJHt1fSh3aWR0aDEpKTtcbiAgICAgIHZhciBkejI6ICR7dX0gPSBhYnMoJHt1fSh3aWR0aDIpIC0gd2lkdGgpO1xuICAgICAgaWYgKGRlcHRoMSA9PSBkZXB0aDIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0MSA9PSBoZWlnaHQyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoMSA9PSB3aWR0aDIpIHtcbiAgICAgICAgZHoxID0gMC41O1xuICAgICAgICBkejIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMTEgKiBkeDIgKiBkeTIgKiBkejIgKyB4MTEyICogZHgyICogZHkyICogZHoxICsgeDEyMSAqIGR4MiAqIGR5MSAqZHoyICsgeDEyMiAqIGR4MiAqIGR5MSAqIGR6MSArXG4gICAgICAgICAgICAgIHgyMTEgKiBkeDEgKiBkeTIgKiBkejIgKyB4MjEyICogZHgxICogZHkyICogZHoxICsgeDIyMSAqIGR4MSAqIGR5MSAqZHoyICsgeDIyMiAqIGR4MSAqIGR5MSAqIGR6MSk7XG4gICAgfWB9LEZoPShlLHQscixuLG8saSk9PntsZXQgYT1lLmRpbXMsZD1NaChpLHQuYXhlcyxhLmxlbmd0aCksbD1SaChhLG4sbyx0LmF4ZXMpLHA9bi5zbGljZSgpO24ubGVuZ3RoPT09MCYmKHA9YS5tYXAoKHYsUyk9PnY9PT0wPzE6bFtTXS92KSx0LmtlZXBBc3BlY3RSYXRpb1BvbGljeSE9PVwic3RyZXRjaFwiJiYobD1VaChhLHAsdCkpKTtsZXQgbT1NKFwib3V0cHV0XCIsZS5kYXRhVHlwZSxsLmxlbmd0aCksdT1FKFwiaW5wdXRcIixlLmRhdGFUeXBlLGEubGVuZ3RoKSxoPWsuc2l6ZShsKSxfPWEubGVuZ3RoPT09bC5sZW5ndGgmJmEuZXZlcnkoKHYsUyk9PnY9PT1sW1NdKSx5PXQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiLGc9dC5leHRyYXBvbGF0aW9uVmFsdWUseD11LnR5cGUudmFsdWUsJD12PT5gXG4gICAgICAke18/XCJcIjpgXG4gICAgICAke0RoKHQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUseCl9O1xuICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxuICAgICAgICAgICAgICAke1doKHUsYSl9O1xuICAgICAgICAgICAgICAke0JoKHQubmVhcmVzdE1vZGUscix4KX07XG4gICAgICAgICAgICAgICR7VmgodSxtLGEsbCxwLmxlbmd0aCxkLmxlbmd0aCx5KX07XG4gICAgICAgICAgICAgIGA7Y2FzZVwibGluZWFyXCI6cmV0dXJuYFxuICAgICAgICAgICAgICAke05oKG0sYSxsLHAubGVuZ3RoLGQubGVuZ3RoKX07XG4gICAgICAgICAgICAgICR7KCgpPT57aWYoYS5sZW5ndGg9PT0yfHxhLmxlbmd0aD09PTQpcmV0dXJuYCR7TGgodSxtLGEseSxnKX1gO2lmKGEubGVuZ3RoPT09M3x8YS5sZW5ndGg9PT01KXJldHVybmAke0hoKHUsbSxhLHksZyl9YDt0aHJvdyBFcnJvcihcIkxpbmVhciBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyLCAzLCA0IGFuZCA1IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XG4gICAgICAgICAgICBgO2Nhc2VcImN1YmljXCI6cmV0dXJuYFxuICAgICAgICAgICAgJHsoKCk9PntpZihhLmxlbmd0aD09PTJ8fGEubGVuZ3RoPT09NClyZXR1cm5gJHtHaCh1LG0sYSxsLHAsZCx0LmN1YmljQ29lZmZBLHksdC5leHRyYXBvbGF0aW9uVmFsdWUsdC5leGNsdWRlT3V0c2lkZSl9YDt0aHJvdyBFcnJvcihcIkN1YmljIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIgYW5kIDQgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS5cIil9KSgpfTtcbiAgICAgICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIkludmFsaWQgcmVzaXplIG1vZGVcIil9fSkoKX07XG4gICAgICBgfVxuICAgICAgJHt2LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2NhbGVzXCIsXCJmMzJcIixwLmxlbmd0aCkucmVnaXN0ZXJVbmlmb3JtKFwicm9pXCIsXCJmMzJcIixkLmxlbmd0aCkuZGVjbGFyZVZhcmlhYmxlcyh1LG0pfVxuICAgICAgJHt2Lm1haW5TdGFydCgpfVxuICAgICAgICAke3YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAke18/XCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcIjpgXG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7dS50eXBlLmluZGljZXN9O1xuICAgICAgICAkeygoKT0+e3N3aXRjaCh0Lm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlcykpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7dS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt0LmV4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgICAgICAgICAgfWA7Y2FzZVwibGluZWFyXCI6cmV0dXJuYG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7YS5sZW5ndGg9PT0yfHxhLmxlbmd0aD09PTQ/XCJiaWxpbmVhckludGVycG9sYXRpb25cIjpcInRyaWxpbmVhckludGVycG9sYXRpb25cIn0ob3V0cHV0X2luZGljZXMpO2A7Y2FzZVwiY3ViaWNcIjpyZXR1cm5cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzKTtcIjtkZWZhdWx0OnRocm93IEVycm9yKGBVbnN1cHBvcnRlZCByZXNpemUgbW9kZTogJHt0Lm1vZGV9YCl9fSkoKX07XG5gfVxuICAgICAgfWA7cmV0dXJue25hbWU6XCJSZXNpemVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke3J9fCR7cC5sZW5ndGg+MD90Lm1vZGU9PT1cImN1YmljXCI/cDpwLmxlbmd0aDpcIlwifXwke28ubGVuZ3RoPjA/bzpcIlwifXwke2QubGVuZ3RoPjA/ZDpcIlwifXwke199fCR7dC5tb2RlPT09XCJuZWFyZXN0XCI/YS5sZW5ndGg6YX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTokLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bCxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpofSx7dHlwZToxLGRhdGE6cH0se3R5cGU6MSxkYXRhOmR9LC4uLk4oYSxsKV19KX19LHFoPWU9PntsZXQgdD1lLmN1c3RvbURhdGFCdWZmZXI7cmV0dXJuIG5ldyBVaW50MzJBcnJheSh0LHQuYnl0ZU9mZnNldCwxKVswXX0sUGw9KGUsdCk9PntsZXQgcj1bXSxuPVtdLG89W10saT1xaChlKTtpZih0LmFudGlhbGlhcyE9PTApdGhyb3cgRXJyb3IoXCJPbmx5IGRlZmF1bHQgdmFsdWUgKDApIGZvciBBbnRpYWxpYXMgYXR0cmlidXRlIGlzIHN1cHBvcnRlZFwiKTtPaChlLmlucHV0cyx0LGkscixuLG8pLGUuY29tcHV0ZShGaChlLmlucHV0c1swXSx0LGkscixuLG8pLHtpbnB1dHM6WzBdfSl9LHpsPWU9PntsZXQgdD1lLmFudGlhbGlhcyxyPWUuYXhlcyxuPWUuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsbz1lLmN1YmljQ29lZmZBLGk9ZS5leGNsdWRlT3V0c2lkZSE9PTAsYT1lLmV4dHJhcG9sYXRpb25WYWx1ZSxkPWUua2VlcEFzcGVjdFJhdGlvUG9saWN5LGw9ZS5tb2RlLHA9ZS5uZWFyZXN0TW9kZT09PVwiXCI/XCJzaW1wbGVcIjplLm5lYXJlc3RNb2RlO3JldHVybiBlZSh7YW50aWFsaWFzOnQsYXhlczpyLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOm4sY3ViaWNDb2VmZkE6byxleGNsdWRlT3V0c2lkZTppLGV4dHJhcG9sYXRpb25WYWx1ZTphLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpkLG1vZGU6bCxuZWFyZXN0TW9kZTpwfSl9fSk7dmFyIEtoLGpoLERsLEJsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTt4ZSgpO2FlKCk7S2g9KGUsdCk9PntsZXRbcixuLG8saV09ZSx7bnVtSGVhZHM6YSxyb3RhcnlFbWJlZGRpbmdEaW06ZH09dDtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAneCcgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucywgZ290ICR7ci5kaW1zLmxlbmd0aH1gKTtpZighay5hcmVFcXVhbChuLmRpbXMsW10pJiYhay5hcmVFcXVhbChuLmRpbXMsWzFdKSYmbi5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBpcyBleHBlY3RlZCB0byBoYXZlIDAsIDEsIG9yIDIgZGltZW5zaW9ucywgZ290ICR7bi5kaW1zLmxlbmd0aH1gKTtpZihvLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdjb3NfY2FjaGUnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zLCBnb3QgJHtvLmRpbXMubGVuZ3RofWApO2lmKGkuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Npbl9jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke2kuZGltcy5sZW5ndGh9YCk7aWYoIWsuYXJlRXF1YWwoby5kaW1zLGkuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXRzICdjb3NfY2FjaGUnIGFuZCAnc2luX2NhY2hlJyBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKTtpZihkPjAmJmE9PT0wKXRocm93IG5ldyBFcnJvcihcIm51bV9oZWFkcyBtdXN0IGJlIHByb3ZpZGVkIGlmIHJvdGFyeV9lbWJlZGRpbmdfZGltIGlzIHNwZWNpZmllZFwiKTtsZXQgbD1yLmRpbXNbMF0scD1yLmRpbXNbci5kaW1zLmxlbmd0aC0yXSxtPW8uZGltc1swXSx1PWsuc2l6ZUZyb21EaW1lbnNpb24oci5kaW1zLDEpL3AsaD1kPT09MD9vLmRpbXNbMV0qMjp1L2E7aWYoZD5oKXRocm93IG5ldyBFcnJvcihcInJvdGFyeV9lbWJlZGRpbmdfZGltIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGhlYWRfc2l6ZVwiKTtpZihuLmRpbXMubGVuZ3RoPT09Mil7aWYobCE9PW4uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAwIHNob3VsZCBiZSBvZiBzaXplIGJhdGNoX3NpemUsIGdvdCAke24uZGltc1swXX1gKTtpZihwIT09bi5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDEgc2hvdWxkIGJlIG9mIHNpemUgc2VxdWVuY2VfbGVuZ3RoLCBnb3QgJHtuLmRpbXNbMV19YCl9aWYoaC8yIT09by5kaW1zWzFdJiZkLzIhPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBkaW1lbnNpb24gMSBzaG91bGQgYmUgc2FtZSBhcyBoZWFkX3NpemUgLyAyIG9yIHJvdGFyeV9lbWJlZGRpbmdfZGltIC8gMiwgZ290ICR7by5kaW1zWzFdfWApO2lmKHA+bSl0aHJvdyBuZXcgRXJyb3IoXCJVcGRhdGluZyBjb3NfY2FjaGUgYW5kIHNpbl9jYWNoZSBpbiBSb3RhcnlFbWJlZGRpbmcgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWRcIil9LGpoPShlLHQpPT57bGV0e2ludGVybGVhdmVkOnIsbnVtSGVhZHM6bixyb3RhcnlFbWJlZGRpbmdEaW06byxzY2FsZTppfT10LGE9ZVswXS5kaW1zWzBdLGQ9ay5zaXplRnJvbURpbWVuc2lvbihlWzBdLmRpbXMsMSksbD1lWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0yXSxwPWQvbCxtPWVbMl0uZGltc1sxXSx1PW89PT0wP20qMjpwL24saD1uZXcgQXJyYXkoYSxsLHAvdSx1LW0pLF89ay5jb21wdXRlU3RyaWRlcyhoKSx5PVt7dHlwZToxLGRhdGE6aX0se3R5cGU6MTIsZGF0YTpofSx7dHlwZToxMixkYXRhOl99LC4uLmVbMF0uZGltcy5sZW5ndGg9PT0zP25ldyBBcnJheSh7dHlwZToxMixkYXRhOltkLHAsdSwxXX0pOltdLC4uLmVbMF0uZGltcy5sZW5ndGg9PT00P25ldyBBcnJheSh7dHlwZToxMixkYXRhOltkLHUsbCp1LDFdfSk6W10sLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zLGVbMl0uZGltcyxlWzNdLmRpbXMsZVswXS5kaW1zKV0sZz14PT57bGV0ICQ9RShcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSx2PUUoXCJwb3NpdGlvbl9pZHNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLFM9RShcImNvc19jYWNoZVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksVD1FKFwic2luX2NhY2hlXCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMubGVuZ3RoKSxBPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpO3JldHVybiB4LnJlZ2lzdGVyVW5pZm9ybXMoW3tuYW1lOlwic2NhbGVcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiZ2xvYmFsX3NoYXBlXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpoLmxlbmd0aH0se25hbWU6XCJnbG9iYWxfc3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Xy5sZW5ndGh9LHtuYW1lOlwiaW5wdXRfb3V0cHV0X3N0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOl8ubGVuZ3RofV0pLGBcbiAgICAgICAgJHt4LmRlY2xhcmVWYXJpYWJsZXMoJCx2LFMsVCxBKX1cblxuICAgICAgICAke3gubWFpblN0YXJ0KEV0KX1cbiAgICAgICAgICBsZXQgaGFsZl9yb3RhcnlfZW1iX2RpbSA9IHVuaWZvcm1zLiR7Uy5uYW1lfV9zaGFwZVsxXTtcbiAgICAgICAgICBsZXQgYnNuaCA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlcyAlIHVuaWZvcm1zLmdsb2JhbF9zaGFwZTtcbiAgICAgICAgICBsZXQgc2l6ZSA9IHVuaWZvcm1zLmdsb2JhbF9zaGFwZVswXSAqIHVuaWZvcm1zLmdsb2JhbF9zdHJpZGVzWzBdO1xuICAgICAgICAgICR7eC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwic2l6ZVwiKX1cblxuICAgICAgICAgIGlmIChic25oWzNdIDwgaGFsZl9yb3RhcnlfZW1iX2RpbSkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkc19pZHggPVxuICAgICAgICAgICAgICAgICR7di5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcImJzbmgueHlcIixNKFwiXCIsdi50eXBlLnRlbnNvciwyKSl9O1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkID1cbiAgICAgICAgICAgICAgICB1MzIoJHt2LmdldEJ5T2Zmc2V0KFwicG9zaXRpb25faWRzX2lkeFwiKX0pICsgc2VsZWN0KDAsIGJzbmhbMV0sIHBvc2l0aW9uX2lkc19pZHggPT0gMCk7XG4gICAgICAgICAgICBsZXQgaSA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBzZWxlY3QoMCwgYnNuaFszXSwgJHtyfSk7XG4gICAgICAgICAgICBsZXQgaiA9IGkgKyBzZWxlY3QoaGFsZl9yb3RhcnlfZW1iX2RpbSwgMSwgJHtyfSk7XG4gICAgICAgICAgICBsZXQgcmUgPSAkeyQuZ2V0QnlPZmZzZXQoXCJpXCIpfSAqICR7Uy5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX0gLVxuICAgICAgICAgICAgICAgICR7JC5nZXRCeU9mZnNldChcImpcIil9ICogJHtULmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfTtcbiAgICAgICAgICAgICR7QS5zZXRCeU9mZnNldChcImlcIixcInJlXCIpfVxuICAgICAgICAgICAgbGV0IGltID0gJHskLmdldEJ5T2Zmc2V0KFwiaVwiKX0gKiAke1QuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9ICtcbiAgICAgICAgICAgICAgICAkeyQuZ2V0QnlPZmZzZXQoXCJqXCIpfSAqICR7Uy5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJqXCIsXCJpbVwiKX1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGsgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgaGFsZl9yb3RhcnlfZW1iX2RpbTtcbiAgICAgICAgICAgICR7QS5zZXRCeU9mZnNldChcImtcIiwkLmdldEJ5T2Zmc2V0KFwia1wiKSl9XG4gICAgICAgICAgfVxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJSb3RhcnlFbWJlZGRpbmdcIixzaGFkZXJDYWNoZTp7aGludDplZSh7aW50ZXJsZWF2ZWQ6cn0pLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpnLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZVswXS5kaW1zLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChrLnNpemUoaCkvRXQpfSxwcm9ncmFtVW5pZm9ybXM6eX0pfX0sRGw9KGUsdCk9PntLaChlLmlucHV0cyx0KSxlLmNvbXB1dGUoamgoZS5pbnB1dHMsdCkpfX0pO3ZhciBZaCxaaCxNbCxSbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7YWUoKTtZaD1lPT57aWYoIWV8fGUubGVuZ3RoPDMpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLlwiKTtsZXQgdD1lWzBdLHI9ZVsxXSxuPWVbMl07aWYodC5kYXRhVHlwZSE9PXIuZGF0YVR5cGV8fHQuZGF0YVR5cGUhPT1uLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIkFsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZVwiKTtpZih0LmRpbXMubGVuZ3RoIT09MyYmdC5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSAyRCBvciAzRFwiKTtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGJlIDJEIG9yIDNEXCIpO2xldCBvPXQuZGltc1t0LmRpbXMubGVuZ3RoLTFdLGk9dC5kaW1zW3QuZGltcy5sZW5ndGgtMl07aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKHIuZGltc1tyLmRpbXMubGVuZ3RoLTJdIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBzZXF1ZW5jZSBsZW5ndGggYXMgaW5wdXRcIik7aWYobi5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBiZSAxRFwiKTtpZihuLmRpbXNbbi5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKGUubGVuZ3RoPjMpe2xldCBhPWVbM107aWYoYS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGJlIDFEXCIpO2lmKGEuZGltc1thLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX1pZihlLmxlbmd0aD40KXtsZXQgYT1lWzRdO2lmKGEuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBiZSAxRFwiKTtpZihhLmRpbXNbYS5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9fSxaaD0oZSx0LHIsbik9PntsZXQgbz10LnNpbXBsaWZpZWQsaT1lWzBdLmRpbXMsYT1rLnNpemUoaSksZD1pLGw9YSxwPWkuc2xpY2UoLTEpWzBdLG09bj9pLnNsaWNlKDAsLTEpLmNvbmNhdCgxKTpbXSx1PSFvJiZlLmxlbmd0aD4zLGg9ZS5sZW5ndGg+NCxfPW4mJnI+MSx5PW4mJnI+MixnPXI+Myx4PTY0LCQ9bWUocCksdj1be3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOiR9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MSxkYXRhOnQuZXBzaWxvbn1dLFM9QT0+e2xldCBDPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImNvbXBvbmVudHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJmMzJcIn1dLFA9W0UoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsJCksRShcInNraXBcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcywkKSxFKFwiZ2FtbWFcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcywkKV07dSYmUC5wdXNoKEUoXCJiZXRhXCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMsJCkpLGgmJlAucHVzaChFKFwiYmlhc1wiLGVbNF0uZGF0YVR5cGUsZVs0XS5kaW1zLCQpKSxQLnB1c2goTShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZCwkKSksXyYmUC5wdXNoKE0oXCJtZWFuX291dHB1dFwiLDEsbSkpLHkmJlAucHVzaChNKFwiaW52X3N0ZF9vdXRwdXRcIiwxLG0pKSxnJiZQLnB1c2goTShcImlucHV0X3NraXBfYmlhc19zdW1cIixlWzBdLmRhdGFUeXBlLGQsJCkpO2xldCBEPXllKGVbMF0uZGF0YVR5cGUpLFI9eWUoMSwkKTtyZXR1cm5gXG5cbiAgICAgICR7QS5yZWdpc3RlclVuaWZvcm1zKEMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uUCl9XG4gICAgICB2YXI8d29ya2dyb3VwPiBzdW1fc2hhcmVkIDogYXJyYXk8JHtSfSwgJHt4fT47XG4gICAgICB2YXI8d29ya2dyb3VwPiBzdW1fc3F1YXJlZF9zaGFyZWQgOiBhcnJheTwke1J9LCAke3h9PjtcblxuICAgICAgJHtBLm1haW5TdGFydChbeCwxLDFdKX1cbiAgICAgICAgbGV0IGl4ID0gbG9jYWxfaWQueDtcbiAgICAgICAgbGV0IGl5ID0gZ2xvYmFsX2lkLnggLyAke3h9O1xuXG4gICAgICAgIGxldCBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkOiB1MzIgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSAvIHVuaWZvcm1zLmNvbXBvbmVudHM7XG4gICAgICAgIHZhciBzdHJpZGUgPSBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkIC8gJHt4fTtcbiAgICAgICAgbGV0IG9mZnNldCA9IGl4ICogc3RyaWRlICsgaXkgKiBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkO1xuICAgICAgICBsZXQgb2Zmc2V0MWQgPSBzdHJpZGUgKiBpeDtcbiAgICAgICAgaWYgKGl4ID09ICR7eC0xfSkge1xuICAgICAgICAgIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLSBzdHJpZGUgKiBpeDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2tpcF92YWx1ZSA9IHNraXBbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IGJpYXNfdmFsdWUgPSAke2g/XCJiaWFzW29mZnNldDFkICsgaV1cIjpEK1wiKDAuMClcIn07XG4gICAgICAgICAgbGV0IGlucHV0X3ZhbHVlID0geFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dF92YWx1ZSArIHNraXBfdmFsdWUgKyBiaWFzX3ZhbHVlO1xuICAgICAgICAgICR7Zz9cImlucHV0X3NraXBfYmlhc19zdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcIjpcIlwifVxuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHZhbHVlO1xuICAgICAgICAgIGxldCBmMzJfdmFsdWUgPSAke1B0KEQsJCxcInZhbHVlXCIpfTtcbiAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBmMzJfdmFsdWU7XG4gICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBmMzJfdmFsdWUgKiBmMzJfdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIHZhciByZWR1Y2Vfc2l6ZSA6IHUzMiA9ICR7eH07XG4gICAgICAgIGZvciAodmFyIGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDE7ICBjdXJyX3NpemUgPiAwOyBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxKSB7XG4gICAgICAgICAgcmVkdWNlX3NpemUgPSBjdXJyX3NpemUgKyAocmVkdWNlX3NpemUgJiAxKTtcbiAgICAgICAgICBpZiAoaXggPCBjdXJyX3NpemUpIHtcbiAgICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IHN1bV9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XG4gICAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IHN1bV9zcXVhcmVkX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN1bSA9IHN1bV9zaGFyZWRbMF07XG4gICAgICAgIGxldCBzcXVhcmVfc3VtID0gc3VtX3NxdWFyZWRfc2hhcmVkWzBdO1xuICAgICAgICBsZXQgbWVhbiA9ICR7cWUoXCJzdW1cIiwkKX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpO1xuICAgICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydCgke3FlKFwic3F1YXJlX3N1bVwiLCQpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgJHtvP1wiXCI6XCItIG1lYW4gKiBtZWFuXCJ9ICsgdW5pZm9ybXMuZXBzaWxvbik7XG4gICAgICAgICR7Xz9cIm1lYW5fb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbjtcIjpcIlwifVxuICAgICAgICAke3k/XCJpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2O1wiOlwiXCJ9XG5cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHN0cmlkZTsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gKG91dHB1dFtvZmZzZXQgKyBpXSAke28/XCJcIjpgLSAke0R9KG1lYW4pYH0pICpcbiAgICAgICAgICAgICR7RH0oaW52X3N0ZF9kZXYpICogZ2FtbWFbb2Zmc2V0MWQgKyBpXVxuICAgICAgICAgICAgJHt1P1wiKyBiZXRhW29mZnNldDFkICsgaV1cIjpcIlwifTtcbiAgICAgICAgfVxuICAgICAgfWB9LFQ9W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiByPjEmJlQucHVzaCh7ZGltczptLGRhdGFUeXBlOjF9KSxyPjImJlQucHVzaCh7ZGltczptLGRhdGFUeXBlOjF9KSxyPjMmJlQucHVzaCh7ZGltczppLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KSx7bmFtZTpcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHskfTske199OyR7eX07JHtnfWAsaW5wdXREZXBlbmRlbmNpZXM6ZS5tYXAoKEEsQyk9PlwidHlwZVwiKX0sZ2V0U2hhZGVyU291cmNlOlMsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlQsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC9wKX0scHJvZ3JhbVVuaWZvcm1zOnZ9KX19LE1sPShlLHQpPT57WWgoZS5pbnB1dHMpO2xldCBuPVswXTtlLm91dHB1dENvdW50PjEmJm4ucHVzaCgtMyksZS5vdXRwdXRDb3VudD4yJiZuLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MyYmbi5wdXNoKDMpLGUuY29tcHV0ZShaaChlLmlucHV0cyx0LGUub3V0cHV0Q291bnQsITEpLHtvdXRwdXRzOm59KX19KTt2YXIgUWgsdG4sWGgsVWwsSmgsZWcsTmwsVmwsV2w9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtuZSgpO3hlKCk7YWUoKTtRaD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2lmKHQuYXhlcy5sZW5ndGghPT0wKXtpZih0LmF4ZXMubGVuZ3RoIT09dC5zdGFydHMubGVuZ3RofHx0LmF4ZXMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKX1lbHNlIGlmKHQuc3RhcnRzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7ZS5zbGljZSgxKS5mb3JFYWNoKChyLG4pPT57aWYoZVtuKzFdLmRhdGFUeXBlIT09NiYmZVtuKzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7bn0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApfSl9LHRuPShlLHQpPT57bGV0IHI9W107aWYoZS5sZW5ndGg+dClpZihlW3RdLmRhdGFUeXBlPT09NyllW3RdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG49PnIucHVzaChOdW1iZXIobikpKTtlbHNlIGlmKGVbdF0uZGF0YVR5cGU9PT02KWVbdF0uZ2V0SW50MzJBcnJheSgpLmZvckVhY2gobj0+ci5wdXNoKE51bWJlcihuKSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3R9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtyZXR1cm4gcn0sWGg9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj10bihlLDEpLG49dG4oZSwyKSxvPXRuKGUsMyk7cmV0dXJuIG8ubGVuZ3RoPT09MCYmKG89Wy4uLkFycmF5KGVbMF0uZGltcy5sZW5ndGgpLmtleXMoKV0pLGVlKHtzdGFydHM6cixlbmRzOm4sYXhlczpvfSl9ZWxzZSByZXR1cm4gdH0sVWw9KGUsdCxyLG4sbyk9PntsZXQgaT1lO3JldHVybiBlPDAmJihpKz1yW25bdF1dKSxvW3RdPDA/TWF0aC5tYXgoMCxNYXRoLm1pbihpLHJbblt0XV0tMSkpOk1hdGgubWF4KDAsTWF0aC5taW4oaSxyW25bdF1dKSl9LEpoPShlLHQscik9PmBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAke3IubGVuZ3RofTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9zaGFwZV9pID0gJHtxKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0ZXBzX2kgPSAke3EoXCJ1bmlmb3Jtcy5zdGVwc1wiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7cShcInVuaWZvcm1zLnNpZ25zXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGFydHNfaSA9ICR7cShcInVuaWZvcm1zLnN0YXJ0c1wiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXggKiBzdGVwc19pICsgc3RhcnRzX2kgKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gaW5wdXRfaW5kZXggLyBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9pbmRleCAlIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpZiAoc2lnbnNfaSA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gaW5wdXRfaW5kZXggLSAxdSArIHN0YXJ0c19pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9pbmRleFwiKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgICAgfWAsZWc9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1rLnNpemUociksbz10LmF4ZXMubGVuZ3RoPjA/ay5ub3JtYWxpemVBeGVzKHQuYXhlcyxyLmxlbmd0aCk6Wy4uLkFycmF5KHIubGVuZ3RoKS5rZXlzKCldLGk9dG4oZSw0KTtpLmZvckVhY2goJD0+JCE9PTB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcInN0ZXAgY2Fubm90IGJlIDBcIil9KSksaS5sZW5ndGg9PT0wJiYoaT1BcnJheShvLmxlbmd0aCkuZmlsbCgxKSk7bGV0IGE9dC5zdGFydHMubWFwKCgkLHYpPT5VbCgkLHYscixvLGkpKSxkPXQuZW5kcy5tYXAoKCQsdik9PlVsKCQsdixyLG8saSkpO2lmKG8ubGVuZ3RoIT09YS5sZW5ndGh8fG8ubGVuZ3RoIT09ZC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnQsIGVuZHMgYW5kIGF4ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXCIpO2lmKG8ubGVuZ3RoIT09ci5sZW5ndGgpZm9yKGxldCAkPTA7JDxyLmxlbmd0aDsrKyQpby5pbmNsdWRlcygkKXx8KGEuc3BsaWNlKCQsMCwwKSxkLnNwbGljZSgkLDAsclskXSksaS5zcGxpY2UoJCwwLDEpKTtsZXQgbD1pLm1hcCgkPT5NYXRoLnNpZ24oJCkpO2kuZm9yRWFjaCgoJCx2LFMpPT57aWYoJDwwKXtsZXQgVD0oZFt2XS1hW3ZdKS8kLEE9YVt2XSxDPUErVCppW3ZdO2Fbdl09QyxkW3ZdPUEsU1t2XT0tJH19KTtsZXQgcD1yLnNsaWNlKDApO28uZm9yRWFjaCgoJCx2KT0+e3BbJF09TWF0aC5jZWlsKChkWyRdLWFbJF0pL2lbJF0pfSk7bGV0IG09e2RpbXM6cCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSx1PU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHAubGVuZ3RoKSxoPUUoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksXz1rLnNpemUocCkseT1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0YXJ0c1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6YS5sZW5ndGh9LHtuYW1lOlwic2lnbnNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOmwubGVuZ3RofSx7bmFtZTpcInN0ZXBzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDppLmxlbmd0aH1dLGc9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTphfSx7dHlwZTo2LGRhdGE6bH0se3R5cGU6MTIsZGF0YTppfSwuLi5OKGVbMF0uZGltcyxwKV0seD0kPT5gXG4gICAgICAkeyQucmVnaXN0ZXJVbmlmb3Jtcyh5KS5kZWNsYXJlVmFyaWFibGVzKGgsdSl9XG4gICAgICAgICR7SmgoaCx1LHIpfVxuICAgICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7dS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICBsZXQgaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgJHt1LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGguZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKSl9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlNsaWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bC5sZW5ndGh9XyR7YS5sZW5ndGh9XyR7aS5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6eCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W21dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfSxwcm9ncmFtVW5pZm9ybXM6Z30pfX0sTmw9KGUsdCk9PntRaChlLmlucHV0cyx0KTtsZXQgcj1YaChlLmlucHV0cyx0KTtlLmNvbXB1dGUoZWcoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sVmw9ZT0+e2xldCB0PWUuc3RhcnRzLHI9ZS5lbmRzLG49ZS5heGVzO3JldHVybiBlZSh7c3RhcnRzOnQsZW5kczpyLGF4ZXM6bn0pfX0pO3ZhciB0ZyxyZyxMbCxHbCxIbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7eGUoKTtkdCgpO2FlKCk7dGc9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LlwiKX0scmc9KGUsdCk9PntsZXQgcj1lLmlucHV0c1swXSxuPXIuZGltcyxvPWsuc2l6ZShuKSxpPW4ubGVuZ3RoLGE9ay5ub3JtYWxpemVBeGlzKHQuYXhpcyxpKSxkPWE8bi5sZW5ndGgtMSxsLHA9W107ZD8ocD1BcnJheS5mcm9tKHtsZW5ndGg6aX0sKFAsRCk9PkQpLHBbYV09aS0xLHBbaS0xXT1hLGw9ZS5jb21wdXRlKFBlKHIscCkse2lucHV0czpbcl0sb3V0cHV0czpbLTFdfSlbMF0pOmw9cjtsZXQgbT1sLmRpbXMsdT1tW2ktMV0saD1vL3UsXz1tZSh1KSx5PXUvXyxnPTY0O2g9PT0xJiYoZz0yNTYpO2xldCB4PShQLEQpPT5EPT09ND9gbWF4KG1heCgke1B9LngsICR7UH0ueSksIG1heCgke1B9LnosICR7UH0udykpYDpEPT09Mj9gbWF4KCR7UH0ueCwgJHtQfS55KWA6RD09PTM/YG1heChtYXgoJHtQfS54LCAke1B9LnkpLCAke1B9LnopYDpQLCQ9RShcInhcIixsLmRhdGFUeXBlLGwuZGltcyxfKSx2PU0oXCJyZXN1bHRcIixsLmRhdGFUeXBlLGwuZGltcyxfKSxTPSQudHlwZS52YWx1ZSxUPXllKGwuZGF0YVR5cGUpPT09XCJmMzJcIj9gdmFyIHRocmVhZE1heCA9ICR7U30oLTMuNDAyODIzZSszOGYpO2A6YHZhciB0aHJlYWRNYXggPSAke1N9KC02NTUwNC4waCk7YCxBPVA9PmBcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7U307XG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dTdW1TaGFyZWQgOiAke1N9O1xuICAgICAgdmFyPHdvcmtncm91cD4gdGhyZWFkU2hhcmVkIDogYXJyYXk8JHtTfSwgJHtnfT47XG5cbiAgICAgIGZuIGdldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyKSAtPiAke1N9IHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7U30pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgJHtQLnJlZ2lzdGVyVW5pZm9ybShcInBhY2tlZENvbHNcIixcImkzMlwiKS5kZWNsYXJlVmFyaWFibGVzKCQsdil9XG4gICAgICAke1AubWFpblN0YXJ0KGcpfVxuICAgICAgICBsZXQgZ2luZGV4ID0gaTMyKGdsb2JhbF9pZHgpO1xuICAgICAgICBsZXQgbGluZGV4ID0gaTMyKGxvY2FsX2lkeCk7XG4gICAgICAgIGNvbnN0IHdnID0gJHtnfTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAke1R9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7U30oJHt4KFwidGhyZWFkU2hhcmVkWzBdXCIsXyl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7U30oMC4wKTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgc3ViRXhwID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCk7XG4gICAgICAgICAgdGhyZWFkU3VtICs9IHN1YkV4cDtcbiAgICAgICAgfVxuICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFN1bTtcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gd2cgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFNoYXJlZFtsaW5kZXhdICsgdGhyZWFkU2hhcmVkW2xpbmRleCArIGN1cnJTaXplXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd1N1bVNoYXJlZCA9ICR7U30oJHtxZShcInRocmVhZFNoYXJlZFswXVwiLF8pfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKSAvIHJvd1N1bVNoYXJlZDtcbiAgICAgICAgICBzZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9YCxDPWUuY29tcHV0ZSh7bmFtZTpcIlNvZnRtYXhcIixzaGFkZXJDYWNoZTp7aGludDpgJHtffTske2d9YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6bC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6aH0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTo2LGRhdGE6eX1dfSksZ2V0U2hhZGVyU291cmNlOkF9LHtpbnB1dHM6W2xdLG91dHB1dHM6W2Q/LTE6MF19KVswXTtkJiZlLmNvbXB1dGUoUGUoQyxwKSx7aW5wdXRzOltDXX0pfSxMbD0oZSx0KT0+e3RnKGUuaW5wdXRzKSxyZyhlLHQpfSxHbD1lPT5lZSh7YXhpczplLmF4aXN9KX0pO3ZhciBGbCxuZyxvZyxpZyxxbCxLbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO25lKCk7YWUoKTtGbD1lPT5BcnJheS5mcm9tKGUuZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksbmc9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT0xMCYmZVswXS5kYXRhVHlwZSE9PTYmJmVbMF0uZGF0YVR5cGUhPT0xMil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIG9ubHkgc3VwcG9ydCBmbG9hdCwgZmxvYXQxNiwgaW50MzIsIGFuZCB1aW50MzIgZGF0YSB0eXBlc1wiKTtpZihlWzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgb2YgaW50NjQgZGF0YSB0eXBlXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSAxLURcIik7aWYoRmwoZVsxXSkubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgaGF2ZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyByYW5rIG9mIGlucHV0IGRhdGEgdGVuc29yXCIpfSxvZz0oZSx0KT0+e2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKXIucHVzaChlW25dKnRbbl0pO3JldHVybiByfSxpZz0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPXQ/P0ZsKGVbMV0pLG89b2cocixuKSxpPWsuc2l6ZShvKSxhPWVbMF0uZGF0YVR5cGUsZD1FKFwiaW5wdXRcIixhLHIubGVuZ3RoKSxsPU0oXCJvdXRwdXRcIixhLG8ubGVuZ3RoKSxwPW09PmBcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSAke2QuaW5kaWNlcyguLi5yKX07XG4gICAgICAke20ucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGQsbCl9XG4gICAgICAke20ubWFpblN0YXJ0KCl9XG4gICAgICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtsLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZC50eXBlLmluZGljZXN9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIGxldCBpbnB1dF9kaW1faSA9ICR7ZC5pbmRpY2VzR2V0KFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIil9O1xuICAgICAgICBsZXQgaW5wdXRfZGltX3ZhbHVlID0gJHtsLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX0gICUgaW5wdXRfZGltX2k7XG5cbiAgICAgICAgJHtkLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9kaW1fdmFsdWVcIil9XG4gICAgICB9XG4gICAgICAke2wuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZC5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpKX1cbiAgICB9YDtyZXR1cm57bmFtZTpcIlRpbGVcIixzaGFkZXJDYWNoZTp7aGludDpgJHtufWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOml9LC4uLk4oZVswXS5kaW1zLG8pXX0pLGdldFNoYWRlclNvdXJjZTpwfX0scWw9ZT0+e25nKGUuaW5wdXRzKSxlLmNvbXB1dGUoaWcoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIGFnLHNnLGpsLFlsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKKCk7bmUoKTthZSgpO2FnPShlLHQscixuLG8pPT57bGV0IGk9TShcIm91dHB1dF9kYXRhXCIsbyxyLmxlbmd0aCw0KSxhPUUoXCJhX2RhdGFcIix0WzFdLmRhdGFUeXBlLHRbMV0uZGltcy5sZW5ndGgsNCksZD1FKFwiYl9kYXRhXCIsdFsyXS5kYXRhVHlwZSx0WzJdLmRpbXMubGVuZ3RoLDQpLGw9RShcImNfZGF0YVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLmxlbmd0aCw0KSxwLG09KHUsaCxfKT0+YHNlbGVjdCgke2h9LCAke3V9LCAke199KWA7aWYoIW4pcD1pLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLG0oYS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksbC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2xldCB1PShoLF8seT1cIlwiKT0+e2xldCBnPWBhX2RhdGFbaW5kZXhfYSR7X31dW2NvbXBvbmVudF9hJHtffV1gLHg9YGJfZGF0YVtpbmRleF9iJHtffV1bY29tcG9uZW50X2Ike199XWAsJD1gYm9vbChjX2RhdGFbaW5kZXhfYyR7X31dICYgKDB4ZmZ1IDw8IChjb21wb25lbnRfYyR7X30gKiA4KSkpYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke199ID0gJHtpLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtffXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Eke199ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7X31gLGkpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYiR7X30gPSAke2QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtffWAsaSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9jJHtffSA9ICR7bC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCxpKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhfYSR7X30gPSBvZmZzZXRfYSR7X30gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9iJHtffSA9IG9mZnNldF9iJHtffSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Mke199ID0gb2Zmc2V0X2Mke199IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Eke199ID0gb2Zmc2V0X2Eke199ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Ike199ID0gb2Zmc2V0X2Ike199ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Mke199ID0gb2Zmc2V0X2Mke199ICUgNHU7XG4gICAgICAgICAgICAke2h9WyR7X31dID0gJHt5fSgke20oZyx4LCQpfSk7XG4gICAgICAgICAgYH07bz09PTk/cD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7dShcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt1KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3UoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7dShcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDpwPWBcbiAgICAgICAgICAgICR7dShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke3UoXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHt1KFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7dShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobCxhLGQsaSl9XG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAgICAgJHtwfVxuICAgICAgfWB9LHNnPWU9PntsZXQgdD1lWzFdLmRpbXMscj1lWzJdLmRpbXMsbj1lWzBdLmRpbXMsbz1lWzFdLmRhdGFUeXBlLGk9IShrLmFyZUVxdWFsKHQscikmJmsuYXJlRXF1YWwocixuKSksYT10LGQ9ay5zaXplKHQpO2lmKGkpe2xldCBwPXR0LmNhbGNTaGFwZSh0dC5jYWxjU2hhcGUodCxyLCExKSxuLCExKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2E9cCxkPWsuc2l6ZShhKX1sZXQgbD1NYXRoLmNlaWwoZC80KTtyZXR1cm57bmFtZTpcIldoZXJlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpwPT5hZyhwLGUsYSxpLG8pLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmx9LC4uLk4obix0LHIsYSldfSl9fSxqbD1lPT57ZS5jb21wdXRlKHNnKGUuaW5wdXRzKSl9fSk7dmFyIFpsLFFsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtFcygpO0hyKCk7T3MoKTtCcygpO3d1KCk7UHUoKTtEdSgpO1p1KCk7bmQoKTthZCgpO2RkKCk7ZmQoKTtiZCgpO19kKCk7JGQoKTtUZCgpO0FkKCk7UGQoKTtEZCgpO1JkKCk7RmQoKTtqZCgpO1pkKCk7WGQoKTt0bCgpO3hvKCk7bmwoKTt3bCgpO3hsKCk7VGwoKTtBbCgpO0xyKCk7T2woKTtCbCgpO1JsKCk7V2woKTtIbCgpO1RvKCk7S2woKTtkdCgpO3FyKCk7WWwoKTtabD1uZXcgTWFwKFtbXCJBYnNcIixbTXNdXSxbXCJBY29zXCIsW1JzXV0sW1wiQWNvc2hcIixbVXNdXSxbXCJBZGRcIixbdnVdXSxbXCJBcmdNYXhcIixba3MsbG9dXSxbXCJBcmdNaW5cIixbQXMsbG9dXSxbXCJBc2luXCIsW05zXV0sW1wiQXNpbmhcIixbVnNdXSxbXCJBdGFuXCIsW1dzXV0sW1wiQXRhbmhcIixbTHNdXSxbXCJBdHRlbnRpb25cIixbUHNdXSxbXCJBdmVyYWdlUG9vbFwiLFtjbCxsbF1dLFtcIkJhdGNoTm9ybWFsaXphdGlvblwiLFt6c11dLFtcIkJpYXNBZGRcIixbRHNdXSxbXCJCaWFzU3BsaXRHZWx1XCIsW191XV0sW1wiQ2FzdFwiLFtIcyxHc11dLFtcIkNlaWxcIixbcXNdXSxbXCJDbGlwXCIsW0ZzXV0sW1wiQ29uY2F0XCIsW3p1LE91XV0sW1wiQ29udlwiLFtfbyx5b11dLFtcIkNvbnZUcmFuc3Bvc2VcIixbcmQsZWRdXSxbXCJDb3NcIixbS3NdXSxbXCJDb3NoXCIsW2pzXV0sW1wiQ3VtU3VtXCIsW29kLGlkXV0sW1wiRGVwdGhUb1NwYWNlXCIsW3NkLHVkXV0sW1wiRGVxdWFudGl6ZUxpbmVhclwiLFt2bCwkbF1dLFtcIkRpdlwiLFskdV1dLFtcIkVpbnN1bVwiLFtwZCxtZF1dLFtcIkVsdVwiLFtZcyxRdF1dLFtcIkVxdWFsXCIsW3h1XV0sW1wiRXJmXCIsW1pzXV0sW1wiRXhwXCIsW1FzXV0sW1wiRXhwYW5kXCIsW2dkXV0sW1wiRmFzdEdlbHVcIixbeWRdXSxbXCJGbG9vclwiLFtYc11dLFtcIkZ1c2VkQ29udlwiLFtfbyx5b11dLFtcIkdhdGhlclwiLFt2ZCx3ZF1dLFtcIkdhdGhlckVsZW1lbnRzXCIsW0VkLGtkXV0sW1wiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixbSWQsQ2RdXSxbXCJHYXRoZXJORFwiLFt4ZCxTZF1dLFtcIkdlbHVcIixbSnNdXSxbXCJHZW1tXCIsW09kLHpkXV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixbZmwsbWxdXSxbXCJHbG9iYWxNYXhQb29sXCIsW19sLHlsXV0sW1wiR3JlYXRlclwiLFtDdV1dLFtcIkdyZWF0ZXJPckVxdWFsXCIsW2t1XV0sW1wiR3JpZFNhbXBsZVwiLFtCZCxNZF1dLFtcIkdyb3VwUXVlcnlBdHRlbnRpb25cIixbSGRdXSxbXCJIYXJkU2lnbW9pZFwiLFtzdSxhdV1dLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFtLZF1dLFtcIkxheWVyTm9ybWFsaXphdGlvblwiLFtZZF1dLFtcIkxlYWt5UmVsdVwiLFtldSxRdF1dLFtcIkxlc3NcIixbQXVdXSxbXCJMZXNzT3JFcXVhbFwiLFtFdV1dLFtcIkxvZ1wiLFtndV1dLFtcIk1hdE11bFwiLFtRZF1dLFtcIk1hdE11bE5CaXRzXCIsW0pkLGVsXV0sW1wiTWF4UG9vbFwiLFtnbCxibF1dLFtcIk11bFwiLFtTdV1dLFtcIk11bHRpSGVhZEF0dGVudGlvblwiLFtWZCxOZF1dLFtcIk5lZ1wiLFtydV1dLFtcIk5vdFwiLFt0dV1dLFtcIlBhZFwiLFtybF1dLFtcIlBvd1wiLFtUdV1dLFtcIlF1aWNrR2VsdVwiLFtidSxRdF1dLFtcIlJhbmdlXCIsW1NsXV0sW1wiUmVjaXByb2NhbFwiLFtudV1dLFtcIlJlZHVjZU1pblwiLFskc11dLFtcIlJlZHVjZU1lYW5cIixbYnNdXSxbXCJSZWR1Y2VNYXhcIixbdnNdXSxbXCJSZWR1Y2VTdW1cIixbU3NdXSxbXCJSZWR1Y2VQcm9kXCIsW3hzXV0sW1wiUmVkdWNlTDFcIixbeXNdXSxbXCJSZWR1Y2VMMlwiLFtfc11dLFtcIlJlZHVjZUxvZ1N1bVwiLFtJc11dLFtcIlJlZHVjZUxvZ1N1bUV4cFwiLFt3c11dLFtcIlJlZHVjZVN1bVNxdWFyZVwiLFtUc11dLFtcIlJlbHVcIixbb3VdXSxbXCJSZXNpemVcIixbUGwsemxdXSxbXCJSb3RhcnlFbWJlZGRpbmdcIixbRGxdXSxbXCJTY2F0dGVyTkRcIixbQ2wsSWxdXSxbXCJTaWdtb2lkXCIsW2l1XV0sW1wiU2luXCIsW3V1XV0sW1wiU2luaFwiLFtkdV1dLFtcIlNsaWNlXCIsW05sLFZsXV0sW1wiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLFtNbF1dLFtcIlNwbGl0XCIsW1dkLExkXV0sW1wiU3FydFwiLFtsdV1dLFtcIlNvZnRtYXhcIixbTGwsR2xdXSxbXCJTdWJcIixbSXVdXSxbXCJUYW5cIixbY3VdXSxbXCJUYW5oXCIsW211XV0sW1wiVGhyZXNob2xkZWRSZWx1XCIsW2h1LFF0XV0sW1wiVGlsZVwiLFtxbF1dLFtcIlRyYW5zcG9zZVwiLFtvcyxpc11dLFtcIldoZXJlXCIsW2psXV1dKX0pO3ZhciBybixYbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7TGUoKTtldCgpO2FlKCk7cm49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxyKXt0aGlzLnJlcG8uc2V0KHQscil9cnVuKHQscixuLG8saSl7TmUodC5wcm9ncmFtSW5mby5uYW1lKTtsZXQgYT10aGlzLmJhY2tlbmQuZGV2aWNlLGQ9dGhpcy5iYWNrZW5kLmdldENvbXB1dGVQYXNzRW5jb2RlcigpO3RoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIpO2xldCBsPVtdO2ZvcihsZXQgbSBvZiByKWwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOm0uYnVmZmVyfX0pO2ZvcihsZXQgbSBvZiBuKWwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOm0uYnVmZmVyfX0pO2kmJmwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTppfSk7bGV0IHA9YS5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDp0LmNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksZW50cmllczpsLGxhYmVsOnQucHJvZ3JhbUluZm8ubmFtZX0pO2lmKHRoaXMuYmFja2VuZC5zZXNzaW9uU3RhdHVzPT09XCJjYXB0dXJpbmdcIil7bGV0IG09e2tlcm5lbElkOnRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQsY29tcHV0ZVBpcGVsaW5lOnQuY29tcHV0ZVBpcGVsaW5lLGJpbmRHcm91cDpwLGRpc3BhdGNoR3JvdXA6b307dGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKS5wdXNoKG0pfWQuc2V0UGlwZWxpbmUodC5jb21wdXRlUGlwZWxpbmUpLGQuc2V0QmluZEdyb3VwKDAscCksZC5kaXNwYXRjaFdvcmtncm91cHMoLi4ubyksdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlcnx8dGhpcy5iYWNrZW5kLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCIpJiZ0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXImJnRoaXMuYmFja2VuZC5mbHVzaCgpLEJlKHQucHJvZ3JhbUluZm8ubmFtZSl9ZGlzcG9zZSgpe31idWlsZCh0LHIpe05lKHQubmFtZSk7bGV0IG49dGhpcy5iYWNrZW5kLmRldmljZSxvPVtdO1t7ZmVhdHVyZTpcInNoYWRlci1mMTZcIixleHRlbnNpb246XCJmMTZcIn0se2ZlYXR1cmU6XCJzdWJncm91cHNcIixleHRlbnNpb246XCJzdWJncm91cHNcIn0se2ZlYXR1cmU6XCJzdWJncm91cHMtZjE2XCIsZXh0ZW5zaW9uOlwic3ViZ3JvdXBzX2YxNlwifV0uZm9yRWFjaCh1PT57bi5mZWF0dXJlcy5oYXModS5mZWF0dXJlKSYmby5wdXNoKGBlbmFibGUgJHt1LmV4dGVuc2lvbn07YCl9KTtsZXQgYT1ycyhyLHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzKSxkPXQuZ2V0U2hhZGVyU291cmNlKGEpLGw9YCR7by5qb2luKGBcbmApfVxuJHthLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XG4ke2R9YCxwPW4uY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOmwsbGFiZWw6dC5uYW1lfSk7c2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSAke3QubmFtZX0gc2hhZGVyIGNvZGU6ICR7bH1gKTtsZXQgbT1uLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7Y29tcHV0ZTp7bW9kdWxlOnAsZW50cnlQb2ludDpcIm1haW5cIn0sbGF5b3V0OlwiYXV0b1wiLGxhYmVsOnQubmFtZX0pO3JldHVybiBCZSh0Lm5hbWUpLHtwcm9ncmFtSW5mbzp0LGNvbXB1dGVQaXBlbGluZTptLHVuaWZvcm1WYXJpYWJsZXNJbmZvOmEudmFyaWFibGVzSW5mb319bm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUodCl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0Lngsbj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQueXx8MSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC56fHwxLGk9dGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247aWYocjw9aSYmbjw9aSYmbzw9aSlyZXR1cm5bcixuLG9dO2xldCBhPXIqbipvLGQ9TWF0aC5jZWlsKE1hdGguc3FydChhKSk7aWYoZD5pKXtpZihkPU1hdGguY2VpbChNYXRoLmNicnQoYSkpLGQ+aSl0aHJvdyBuZXcgRXJyb3IoXCJUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uXCIpO3JldHVybltkLGQsZF19ZWxzZSByZXR1cm5bZCxkLDFdfX19KTt2YXIgdWcsZGcsSW8sQ28sbm4sSmw9VSgoKT0+e1widXNlIHN0cmljdFwiO0xlKCk7SigpO2V0KCk7WG4oKTtYYSgpO1FsKCk7WGwoKTt1Zz0oZSx0KT0+e2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnB1dERlcGVuZGVuY2llcyBsZW5ndGggJHt0Lmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtlLmxlbmd0aH0uYCk7bGV0IHI9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pe2xldCBvPWVbbl0uZGF0YVR5cGU7c3dpdGNoKHRbbl0pe2Nhc2VcIm5vbmVcIjp7ci5wdXNoKFwiXCIpO2JyZWFrfWNhc2VcInR5cGVcIjp7ci5wdXNoKGAke299YCk7YnJlYWt9Y2FzZVwicmFua1wiOntsZXQgaT1lW25dLmRpbXMubGVuZ3RoO3IucHVzaChgJHtvfTske2l9YCk7YnJlYWt9Y2FzZVwiZGltc1wiOntsZXQgaT1lW25dLmRpbXMuam9pbihcIixcIik7ci5wdXNoKGAke299OyR7aX1gKTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgaW5wdXQgZGVwZW5kZW5jeTogJHt0W25dfWApfX1yZXR1cm4gci5qb2luKFwifFwiKX0sZGc9KGUsdCxyKT0+e2xldCBuPWUubmFtZTtyZXR1cm4gZS5zaGFkZXJDYWNoZT8uaGludCYmKG4rPVwiW1wiK2Uuc2hhZGVyQ2FjaGUuaGludCtcIl1cIiksbis9XCI6XCIrcitgOiR7dWcodCxlLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcz8/bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKFwiZGltc1wiKSl9YCxufSxJbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0JiYodGhpcy5hcmNoaXRlY3R1cmU9dC5hcmNoaXRlY3R1cmUsdGhpcy52ZW5kb3I9dC52ZW5kb3IpfWlzQXJjaGl0ZWN0dXJlKHQpe3JldHVybiB0aGlzLmFyY2hpdGVjdHVyZT09PXR9aXNWZW5kb3IodCl7cmV0dXJuIHRoaXMudmVuZG9yPT09dH19LENvPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc3ViZ3JvdXBzU3VwcG9ydGVkPXQuZmVhdHVyZXMuaGFzKFwic3ViZ3JvdXBzXCIpLHRoaXMuc3ViZ3JvdXBzRjE2U3VwcG9ydGVkPXQuZmVhdHVyZXMuaGFzKFwic3ViZ3JvdXBzXCIpO2xldCByPXQubGltaXRzOyF0aGlzLnN1Ymdyb3Vwc1N1cHBvcnRlZHx8IXIubWluU3ViZ3JvdXBTaXplfHwhci5tYXhTdWJncm91cFNpemU/dGhpcy5zdWJncm91cFNpemVSYW5nZT12b2lkIDA6dGhpcy5zdWJncm91cFNpemVSYW5nZT1bci5taW5TdWJncm91cFNpemUsci5tYXhTdWJncm91cFNpemVdfX0sbm49Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmN1cnJlbnRTZXNzaW9uSWQ9bnVsbDt0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsO3RoaXMuY29tbWFuZEVuY29kZXI9bnVsbDt0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsO3RoaXMubWF4RGlzcGF0Y2hOdW1iZXI9MTY7dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MDt0aGlzLnBlbmRpbmdLZXJuZWxzPVtdO3RoaXMucGVuZGluZ1F1ZXJpZXM9bmV3IE1hcDt0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCI7dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0PW5ldyBNYXA7dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzPW5ldyBNYXA7dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZz1uZXcgTWFwfWdldCBjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpe2lmKHRoaXMuY3VycmVudEtlcm5lbElkPT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiBjdXJyZW50S2VybmVsSWQgaXMgbnVsbC4gKHNob3VsZCBub3QgaGFwcGVuKVwiKTtsZXQgdD10aGlzLmtlcm5lbEN1c3RvbURhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtyZXR1cm4gdHx8KHQ9e30sdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCx0KSksdH1hc3luYyBpbml0aWFsaXplKHQscil7dGhpcy5lbnY9dDtsZXQgbj1bXSxvPXtyZXF1aXJlZExpbWl0czp7bWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6ci5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplLG1heEJ1ZmZlclNpemU6ci5saW1pdHMubWF4QnVmZmVyU2l6ZSxtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXA6ci5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVo6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafSxyZXF1aXJlZEZlYXR1cmVzOm59LGk9YT0+ci5mZWF0dXJlcy5oYXMoYSkmJm4ucHVzaChhKSYmITA7aShcImNocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKXx8aShcInRpbWVzdGFtcC1xdWVyeVwiKSxpKFwic2hhZGVyLWYxNlwiKSxpKFwic3ViZ3JvdXBzXCIpJiZpKFwic3ViZ3JvdXBzLWYxNlwiKSx0aGlzLmRldmljZT1hd2FpdCByLnJlcXVlc3REZXZpY2UobyksdGhpcy5kZXZpY2VJbmZvPW5ldyBDbyh0aGlzLmRldmljZSksdGhpcy5hZGFwdGVySW5mbz1uZXcgSW8oci5pbmZvfHxhd2FpdCByLnJlcXVlc3RBZGFwdGVySW5mbygpKSx0aGlzLmdwdURhdGFNYW5hZ2VyPVFhKHRoaXMpLHRoaXMucHJvZ3JhbU1hbmFnZXI9bmV3IHJuKHRoaXMpLHRoaXMua2VybmVscz1uZXcgTWFwLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGE9bmV3IE1hcCx0aGlzLmtlcm5lbEN1c3RvbURhdGE9bmV3IE1hcCxNcih0LmxvZ0xldmVsLCEhdC5kZWJ1ZyksdGhpcy5kZXZpY2Uub251bmNhcHR1cmVkZXJyb3I9YT0+e2EuZXJyb3IgaW5zdGFuY2VvZiBHUFVWYWxpZGF0aW9uRXJyb3ImJmNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7YS5lcnJvci5tZXNzYWdlfWApfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LFwiZGV2aWNlXCIse3ZhbHVlOnRoaXMuZGV2aWNlLHdyaXRhYmxlOiExLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImFkYXB0ZXJcIix7dmFsdWU6cix3cml0YWJsZTohMSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMX0pLHRoaXMuc2V0UXVlcnlUeXBlKCl9ZGlzcG9zZSgpe3R5cGVvZiB0aGlzLnF1ZXJ5U2V0PFwidVwiJiZ0aGlzLnF1ZXJ5U2V0LmRlc3Ryb3koKSx0aGlzLmdwdURhdGFNYW5hZ2VyLmRpc3Bvc2UoKX1nZXRDb21tYW5kRW5jb2Rlcigpe3JldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyfHwodGhpcy5jb21tYW5kRW5jb2Rlcj10aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpKSx0aGlzLmNvbW1hbmRFbmNvZGVyfWdldENvbXB1dGVQYXNzRW5jb2Rlcigpe2lmKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcil7bGV0IHQ9dGhpcy5nZXRDb21tYW5kRW5jb2RlcigpLHI9e307dGhpcy5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiJiYoci50aW1lc3RhbXBXcml0ZXM9e3F1ZXJ5U2V0OnRoaXMucXVlcnlTZXQsYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleDp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyLGVuZE9mUGFzc1dyaXRlSW5kZXg6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxfSksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9dC5iZWdpbkNvbXB1dGVQYXNzKHIpfXJldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcn1lbmRDb21wdXRlUGFzcygpe3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyJiYodGhpcy5jb21wdXRlUGFzc0VuY29kZXIuZW5kKCksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbCl9Zmx1c2goKXtpZighdGhpcy5jb21tYW5kRW5jb2RlcilyZXR1cm47TmUoKSx0aGlzLmVuZENvbXB1dGVQYXNzKCk7bGV0IHQ7dGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmKHRoaXMuY29tbWFuZEVuY29kZXIucmVzb2x2ZVF1ZXJ5U2V0KHRoaXMucXVlcnlTZXQsMCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyLHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyLDApLHQ9dGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIqOCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRHxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVH0pLHRoaXMucGVuZGluZ1F1ZXJpZXMuc2V0KHQsdGhpcy5wZW5kaW5nS2VybmVscyksdGhpcy5wZW5kaW5nS2VybmVscz1bXSx0aGlzLmNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcih0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciwwLHQsMCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKjgpKSx0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpLHRoaXMuY29tbWFuZEVuY29kZXI9bnVsbCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnQubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpPT57bGV0IHI9bmV3IEJpZ1VpbnQ2NEFycmF5KHQuZ2V0TWFwcGVkUmFuZ2UoKSksbj10aGlzLnBlbmRpbmdRdWVyaWVzLmdldCh0KTtmb3IobGV0IG89MDtvPHIubGVuZ3RoLzI7bysrKXtsZXQgaT1uW29dLGE9aS5rZXJuZWxJZCxkPXRoaXMua2VybmVscy5nZXQoYSksbD1kLmtlcm5lbFR5cGUscD1kLmtlcm5lbE5hbWUsbT1pLnByb2dyYW1OYW1lLHU9aS5pbnB1dFRlbnNvclZpZXdzLGg9aS5vdXRwdXRUZW5zb3JWaWV3cyxfPXJbbyoyXSx5PXJbbyoyKzFdO3R5cGVvZiB0aGlzLnF1ZXJ5VGltZUJhc2U+XCJ1XCImJih0aGlzLnF1ZXJ5VGltZUJhc2U9Xyk7bGV0IGc9TnVtYmVyKF8tdGhpcy5xdWVyeVRpbWVCYXNlKSx4PU51bWJlcih5LXRoaXMucXVlcnlUaW1lQmFzZSk7aWYoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGcpfHwhTnVtYmVyLmlzU2FmZUludGVnZXIoeCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbmNvcnJlY3QgdGltZXN0YW1wIHJhbmdlXCIpO2lmKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm9uZGF0YSl0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nLm9uZGF0YSh7dmVyc2lvbjoxLGlucHV0c01ldGFkYXRhOnUubWFwKCQ9Pih7ZGltczokLmRpbXMsZGF0YVR5cGU6YnQoJC5kYXRhVHlwZSl9KSksb3V0cHV0c01ldGFkYXRhOmgubWFwKCQ9Pih7ZGltczokLmRpbXMsZGF0YVR5cGU6YnQoJC5kYXRhVHlwZSl9KSksa2VybmVsSWQ6YSxrZXJuZWxUeXBlOmwsa2VybmVsTmFtZTpwLHByb2dyYW1OYW1lOm0sc3RhcnRUaW1lOmcsZW5kVGltZTp4fSk7ZWxzZXtsZXQgJD1cIlwiO3UuZm9yRWFjaCgoUyxUKT0+eyQrPWBpbnB1dFske1R9XTogWyR7Uy5kaW1zfV0gfCAke2J0KFMuZGF0YVR5cGUpfSwgYH0pO2xldCB2PVwiXCI7aC5mb3JFYWNoKChTLFQpPT57dis9YG91dHB1dFske1R9XTogWyR7Uy5kaW1zfV0gfCAke2J0KFMuZGF0YVR5cGUpfSwgYH0pLGNvbnNvbGUubG9nKGBbcHJvZmlsaW5nXSBrZXJuZWwgXCIke2F9fCR7bH18JHtwfXwke219XCIgJHskfSR7dn1leGVjdXRpb24gdGltZTogJHt4LWd9IG5zYCl9X3IoXCJHUFVcIixgJHttfTo6JHtffTo6JHt5fWApfXQudW5tYXAoKSx0aGlzLnBlbmRpbmdRdWVyaWVzLmRlbGV0ZSh0KX0pLEJlKCl9cnVuKHQscixuLG8saSxhKXtOZSh0Lm5hbWUpO2xldCBkPVtdO2ZvcihsZXQgUz0wO1M8ci5sZW5ndGg7KytTKXtsZXQgVD1yW1NdLmRhdGE7aWYoVD09PTApY29udGludWU7bGV0IEE9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoVCk7aWYoIUEpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgaW5wdXQ6ICR7VH1gKTtkLnB1c2goQSl9bGV0e291dHB1dHM6bCxkaXNwYXRjaEdyb3VwOnAscHJvZ3JhbVVuaWZvcm1zOm19PXQuZ2V0UnVuRGF0YShyKSx1PW4ubGVuZ3RoPT09MD9sLm1hcCgoUyxUKT0+VCk6bjtpZih1Lmxlbmd0aCE9PWwubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgT3V0cHV0IHNpemUgJHt1Lmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byAke2wubGVuZ3RofS5gKTtsZXQgaD1bXSxfPVtdO2ZvcihsZXQgUz0wO1M8bC5sZW5ndGg7KytTKXtpZighTnVtYmVyLmlzSW50ZWdlcih1W1NdKXx8dVtTXTwtM3x8dVtTXT49YSl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3V0cHV0IGluZGV4OiAke3VbU119YCk7aWYodVtTXT09PS0zKWNvbnRpbnVlO2xldCBUPXVbU109PT0tMSxBPXVbU109PT0tMixDPVR8fEE/aShsW1NdLmRhdGFUeXBlLGxbU10uZGltcyk6byh1W1NdLGxbU10uZGF0YVR5cGUsbFtTXS5kaW1zKTtpZihoLnB1c2goQyksQy5kYXRhPT09MCljb250aW51ZTtsZXQgUD10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChDLmRhdGEpO2lmKCFQKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHtDLmRhdGF9YCk7aWYoVCYmdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goUCksQSl7bGV0IEQ9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO0R8fChEPVtdLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLEQpKSxELnB1c2goUCl9Xy5wdXNoKFApfWlmKGQubGVuZ3RoIT09ci5sZW5ndGh8fF8ubGVuZ3RoIT09aC5sZW5ndGgpe2lmKF8ubGVuZ3RoPT09MClyZXR1cm4gQmUodC5uYW1lKSxoO3Rocm93IG5ldyBFcnJvcihgUHJvZ3JhbSAke3QubmFtZX0gaGFzIHplcm8tc2l6ZWQgdGVuc29yKHMpIGluIGlucHV0cyBvciBvdXRwdXRzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgbm93LmApfWxldCB5O2lmKG0pe2xldCBTPTAsVD1bXTttLmZvckVhY2goRD0+e2xldCBSPXR5cGVvZiBELmRhdGE9PVwibnVtYmVyXCI/W0QuZGF0YV06RC5kYXRhO2lmKFIubGVuZ3RoPT09MClyZXR1cm47bGV0IEg9RC50eXBlPT09MTA/Mjo0LEwscmU7RC50eXBlPT09MTA/KHJlPVIubGVuZ3RoPjQ/MTY6Ui5sZW5ndGg+Mj84OlIubGVuZ3RoKkgsTD1SLmxlbmd0aD40PzE2OkgqUi5sZW5ndGgpOihyZT1SLmxlbmd0aDw9Mj9SLmxlbmd0aCpIOjE2LEw9MTYpLFM9TWF0aC5jZWlsKFMvcmUpKnJlLFQucHVzaChTKTtsZXQgVj1ELnR5cGU9PT0xMD84OjQ7Uys9Ui5sZW5ndGg+ND9NYXRoLmNlaWwoUi5sZW5ndGgvVikqTDpSLmxlbmd0aCpIfSk7bGV0IEE9MTY7Uz1NYXRoLmNlaWwoUy9BKSpBO2xldCBDPW5ldyBBcnJheUJ1ZmZlcihTKTttLmZvckVhY2goKEQsUik9PntsZXQgSD1UW1JdLEw9dHlwZW9mIEQuZGF0YT09XCJudW1iZXJcIj9bRC5kYXRhXTpELmRhdGE7aWYoRC50eXBlPT09NiluZXcgSW50MzJBcnJheShDLEgsTC5sZW5ndGgpLnNldChMKTtlbHNlIGlmKEQudHlwZT09PTEyKW5ldyBVaW50MzJBcnJheShDLEgsTC5sZW5ndGgpLnNldChMKTtlbHNlIGlmKEQudHlwZT09PTEwKW5ldyBVaW50MTZBcnJheShDLEgsTC5sZW5ndGgpLnNldChMKTtlbHNlIGlmKEQudHlwZT09PTEpbmV3IEZsb2F0MzJBcnJheShDLEgsTC5sZW5ndGgpLnNldChMKTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdW5pZm9ybSB0eXBlOiAke2J0KEQudHlwZSl9YCl9KTtsZXQgUD10aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShTLEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pO3RoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFAuYnVmZmVyLDAsQywwLFMpLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShQLmlkKSx5PXtvZmZzZXQ6MCxzaXplOlMsYnVmZmVyOlAuYnVmZmVyfX1sZXQgZz10aGlzLnByb2dyYW1NYW5hZ2VyLm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKHApLHg9Z1sxXT09PTEmJmdbMl09PT0xLCQ9ZGcodCxyLHgpLHY9dGhpcy5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdCgkKTtpZih2fHwodj10aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHQsZyksdGhpcy5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdCgkLHYpLHNlKFwiaW5mb1wiLCgpPT5gW2FydGlmYWN0XSBrZXk6ICR7JH0sIHByb2dyYW1OYW1lOiAke3QubmFtZX1gKSksbSYmdi51bmlmb3JtVmFyaWFibGVzSW5mbyl7aWYobS5sZW5ndGghPT12LnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gdmFyaWFibGVzIGNvdW50IG1pc21hdGNoOiBleHBlY3QgJHt2LnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aH0sIGdvdCAke20ubGVuZ3RofSBpbiBwcm9ncmFtIFwiJHt2LnByb2dyYW1JbmZvLm5hbWV9XCIuYCk7Zm9yKGxldCBTPTA7UzxtLmxlbmd0aDtTKyspe2xldCBUPW1bU10sQT1ULnR5cGUsQz10eXBlb2YgVC5kYXRhPT1cIm51bWJlclwiPzE6VC5kYXRhLmxlbmd0aCxbUCxEXT12LnVuaWZvcm1WYXJpYWJsZXNJbmZvW1NdO2lmKEEhPT1QfHxDIT09RCl0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gdmFyaWFibGUgJHtTfSBtaXNtYXRjaDogZXhwZWN0IHR5cGUgJHtQfSB3aXRoIHNpemUgJHtEfSwgZ290IHR5cGUgJHtBfSB3aXRoIHNpemUgJHtDfSBpbiBwcm9ncmFtIFwiJHt2LnByb2dyYW1JbmZvLm5hbWV9XCIuYCl9fWlmKHNlKFwiaW5mb1wiLCgpPT5gW1Byb2dyYW1NYW5hZ2VyXSBydW4gXCIke3QubmFtZX1cIiAoa2V5PSR7JH0pIHdpdGggJHtnWzBdfXgke2dbMV19eCR7Z1syXX1gKSx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwifHx0aGlzLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiKXtsZXQgUz17a2VybmVsSWQ6dGhpcy5jdXJyZW50S2VybmVsSWQscHJvZ3JhbU5hbWU6di5wcm9ncmFtSW5mby5uYW1lLGlucHV0VGVuc29yVmlld3M6cixvdXRwdXRUZW5zb3JWaWV3czpofTt0aGlzLnBlbmRpbmdLZXJuZWxzLnB1c2goUyksdGhpcy5zZXNzaW9uU3RhdHVzPT09XCJjYXB0dXJpbmdcIiYmdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLnB1c2goUyl9cmV0dXJuIHRoaXMucHJvZ3JhbU1hbmFnZXIucnVuKHYsZCxfLGcseSksQmUodC5uYW1lKSxofXVwbG9hZCh0LHIpe3RoaXMuZ3B1RGF0YU1hbmFnZXIudXBsb2FkKHQscil9bWVtY3B5KHQscil7dGhpcy5ncHVEYXRhTWFuYWdlci5tZW1jcHkodCxyKX1hc3luYyBkb3dubG9hZCh0LHIpe2F3YWl0IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZG93bmxvYWQodCxyKX1hbGxvYyh0KXtyZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUodCkuaWR9ZnJlZSh0KXtyZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHQpfWNyZWF0ZUtlcm5lbCh0LHIsbixvKXtsZXQgaT1abC5nZXQodCk7aWYoIWkpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGltcGxlbWVudGVkOiAke3R9YCk7bGV0IGE9e2tlcm5lbFR5cGU6dCxrZXJuZWxOYW1lOm8sa2VybmVsRW50cnk6aVswXSxhdHRyaWJ1dGVzOltpWzFdLG5dfTt0aGlzLmtlcm5lbHMuc2V0KHIsYSl9cmVsZWFzZUtlcm5lbCh0KXtsZXQgcj10aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0KTtpZihyKXtmb3IobGV0IG4gb2Ygcil0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2Uobi5pZCk7dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5kZWxldGUodCl9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmRlbGV0ZSh0KSx0aGlzLmtlcm5lbHMuZGVsZXRlKHQpfWNvbXB1dGVLZXJuZWwodCxyLG4pe2xldCBvPXRoaXMua2VybmVscy5nZXQodCk7aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGNyZWF0ZWQ6ICR7dH1gKTtsZXQgaT1vLmtlcm5lbFR5cGUsYT1vLmtlcm5lbE5hbWUsZD1vLmtlcm5lbEVudHJ5LGw9by5hdHRyaWJ1dGVzO2lmKHRoaXMuY3VycmVudEtlcm5lbElkIT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBcIlske2l9XSAke2F9XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5YCk7dGhpcy5jdXJyZW50S2VybmVsSWQ9dCxsWzBdJiYobFsxXT1sWzBdKGxbMV0pLGxbMF09dm9pZCAwKSxzZShcImluZm9cIiwoKT0+YFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCJbJHtpfV0gJHthfVwiLi4uYCk7bGV0IHA9dGhpcy5lbnYuZGVidWc7dGhpcy50ZW1wb3JhcnlEYXRhPVtdO3RyeXtyZXR1cm4gcCYmdGhpcy5kZXZpY2UucHVzaEVycm9yU2NvcGUoXCJ2YWxpZGF0aW9uXCIpLGQocixsWzFdKSwwfWNhdGNoKG0pe3JldHVybiBuLnB1c2goUHJvbWlzZS5yZXNvbHZlKGBbV2ViR1BVXSBLZXJuZWwgXCJbJHtpfV0gJHthfVwiIGZhaWxlZC4gJHttfWApKSwxfWZpbmFsbHl7cCYmbi5wdXNoKHRoaXMuZGV2aWNlLnBvcEVycm9yU2NvcGUoKS50aGVuKG09Pm0/YEdQVSB2YWxpZGF0aW9uIGVycm9yIGZvciBrZXJuZWwgXCJbJHtpfV0gJHthfVwiOiAke20ubWVzc2FnZX1gOm51bGwpKTtmb3IobGV0IG0gb2YgdGhpcy50ZW1wb3JhcnlEYXRhKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShtLmlkKTt0aGlzLnRlbXBvcmFyeURhdGE9W10sdGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbH19cmVnaXN0ZXJCdWZmZXIodCxyLG4sbyl7bGV0IGk9dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7aXx8KGk9bmV3IE1hcCx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLnNldCh0LGkpKTtsZXQgYT1pLmdldChyKSxkPXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihuLG8sYSk7cmV0dXJuIGkuc2V0KHIsW2Qsbl0pLGR9dW5yZWdpc3RlckJ1ZmZlcnModCl7bGV0IHI9dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7ciYmKHIuZm9yRWFjaChuPT50aGlzLmdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihuWzBdKSksdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5kZWxldGUodCkpfWdldEJ1ZmZlcih0KXtsZXQgcj10aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBidWZmZXI6ICR7dH1gKTtyZXR1cm4gci5idWZmZXJ9Y3JlYXRlRG93bmxvYWRlcih0LHIsbil7cmV0dXJuIGFzeW5jKCk9PntsZXQgbz1hd2FpdCBybyh0aGlzLHQscik7cmV0dXJuIFJyKG8uYnVmZmVyLG4pfX13cml0ZVRpbWVzdGFtcCh0KXt0aGlzLnF1ZXJ5VHlwZT09PVwiaW5zaWRlLXBhc3Nlc1wiJiZ0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci53cml0ZVRpbWVzdGFtcCh0aGlzLnF1ZXJ5U2V0LHQpfXNldFF1ZXJ5VHlwZSgpe3RoaXMucXVlcnlUeXBlPVwibm9uZVwiLCh0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5tb2RlPT09XCJkZWZhdWx0XCJ8fCh0eXBlb2YgdGhpcy5lbnYudHJhY2U+XCJ1XCI/dGhpcy5lbnYud2FzbS50cmFjZTp0aGlzLmVudi50cmFjZSkpJiYodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwiY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzXCIpP3RoaXMucXVlcnlUeXBlPVwiaW5zaWRlLXBhc3Nlc1wiOnRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKSYmKHRoaXMucXVlcnlUeXBlPVwiYXQtcGFzc2VzXCIpLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnR5cGVvZiB0aGlzLnF1ZXJ5U2V0PlwidVwiJiYodGhpcy5xdWVyeVNldD10aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7dHlwZTpcInRpbWVzdGFtcFwiLGNvdW50OnRoaXMubWF4RGlzcGF0Y2hOdW1iZXIqMn0pLHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyPXRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0aGlzLm1heERpc3BhdGNoTnVtYmVyKjIqOCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFfSkpKX1jYXB0dXJlQmVnaW4oKXtzZShcImluZm9cIixcImNhcHR1cmVCZWdpblwiKSx0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCl8fHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5zZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkLFtdKSx0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCl8fHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5zZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkLFtdKSx0aGlzLmZsdXNoKCksdGhpcy5zZXNzaW9uU3RhdHVzPVwiY2FwdHVyaW5nXCJ9Y2FwdHVyZUVuZCgpe3NlKFwiaW5mb1wiLFwiY2FwdHVyZUVuZFwiKSx0aGlzLmZsdXNoKCksdGhpcy5zZXNzaW9uU3RhdHVzPVwiZGVmYXVsdFwifXJlcGxheSgpe3NlKFwiaW5mb1wiLFwicmVwbGF5XCIpLHRoaXMuc2Vzc2lvblN0YXR1cz1cInJlcGxheWluZ1wiO2xldCB0PXRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKSxyPXRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKSxuPXQubGVuZ3RoO3RoaXMucGVuZGluZ0tlcm5lbHM9W107Zm9yKGxldCBvPTA7bzxuO28rKyl7bGV0IGk9dGhpcy5nZXRDb21wdXRlUGFzc0VuY29kZXIoKSxhPXRbb107dGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKSxpLnNldFBpcGVsaW5lKGEuY29tcHV0ZVBpcGVsaW5lKSxpLnNldEJpbmRHcm91cCgwLGEuYmluZEdyb3VwKSxpLmRpc3BhdGNoV29ya2dyb3VwcyguLi5hLmRpc3BhdGNoR3JvdXApLHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxKSx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnRoaXMucGVuZGluZ0tlcm5lbHMucHVzaChyW29dKSwodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMubWF4RGlzcGF0Y2hOdW1iZXJ8fHRoaXMucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIikmJnRoaXMuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5tYXhEaXNwYXRjaE51bWJlciYmdGhpcy5mbHVzaCgpfXRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCJ9b25DcmVhdGVTZXNzaW9uKCl7dGhpcy5ncHVEYXRhTWFuYWdlci5vbkNyZWF0ZVNlc3Npb24oKX1vblJlbGVhc2VTZXNzaW9uKHQpe3RoaXMudW5yZWdpc3RlckJ1ZmZlcnModCksdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0Lmhhcyh0KSYmdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmRlbGV0ZSh0KSx0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuaGFzKHQpJiZ0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZGVsZXRlKHQpLHRoaXMuZ3B1RGF0YU1hbmFnZXIub25SZWxlYXNlU2Vzc2lvbih0KX1vblJ1blN0YXJ0KHQpe3RoaXMuY3VycmVudFNlc3Npb25JZD10LHRoaXMuc2V0UXVlcnlUeXBlKCl9fX0pO3ZhciBsZyxlYyxjZyx0YyxvbixhbixBbyxyYyxuYz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZXQoKTtsZz0xLGVjPSgpPT5sZysrLGNnPW5ldyBNYXAoW1tcImZsb2F0MzJcIiwzMl0sW1wiZmxvYXQxNlwiLDE2XSxbXCJpbnQzMlwiLDMyXSxbXCJ1aW50MzJcIiwzMl0sW1wiaW50NjRcIiw2NF0sW1widWludDY0XCIsNjRdLFtcImludDhcIiw4XSxbXCJ1aW50OFwiLDhdLFtcImludDRcIiw0XSxbXCJ1aW50NFwiLDRdXSksdGM9KGUsdCk9PntsZXQgcj1jZy5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlLlwiKTtyZXR1cm4gdC5sZW5ndGg+MD9NYXRoLmNlaWwodC5yZWR1Y2UoKG4sbyk9Pm4qbykqci84KTowfSxvbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlc3Npb25JZD10LnNlc3Npb25JZCx0aGlzLm1sQ29udGV4dD10LmNvbnRleHQsdGhpcy5tbFRlbnNvcj10LnRlbnNvcix0aGlzLmRhdGFUeXBlPXQuZGF0YVR5cGUsdGhpcy50ZW5zb3JTaGFwZT10LnNoYXBlfWdldCB0ZW5zb3IoKXtyZXR1cm4gdGhpcy5tbFRlbnNvcn1nZXQgdHlwZSgpe3JldHVybiB0aGlzLmRhdGFUeXBlfWdldCBzaGFwZSgpe3JldHVybiB0aGlzLnRlbnNvclNoYXBlfWdldCBieXRlTGVuZ3RoKCl7cmV0dXJuIHRjKHRoaXMuZGF0YVR5cGUsdGhpcy50ZW5zb3JTaGFwZSl9ZGVzdHJveSgpe3NlKFwidmVyYm9zZVwiLCgpPT5cIltXZWJOTl0gVGVuc29yV3JhcHBlci5kZXN0cm95XCIpLHRoaXMubWxUZW5zb3IuZGVzdHJveSgpfXdyaXRlKHQpe3RoaXMubWxDb250ZXh0LndyaXRlVGVuc29yKHRoaXMubWxUZW5zb3IsdCl9YXN5bmMgcmVhZCh0KXtyZXR1cm4gdD90aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IsdCk6dGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yKX1jYW5SZXVzZVRlbnNvcih0LHIsbil7cmV0dXJuIHRoaXMubWxDb250ZXh0PT09dCYmdGhpcy5kYXRhVHlwZT09PXImJnRoaXMudGVuc29yU2hhcGUubGVuZ3RoPT09bi5sZW5ndGgmJnRoaXMudGVuc29yU2hhcGUuZXZlcnkoKG8saSk9Pm89PT1uW2ldKX19LGFuPWNsYXNze2NvbnN0cnVjdG9yKHQscil7dGhpcy50ZW5zb3JNYW5hZ2VyPXQ7dGhpcy53cmFwcGVyPXJ9Z2V0IHRlbnNvcldyYXBwZXIoKXtyZXR1cm4gdGhpcy53cmFwcGVyfXJlbGVhc2VUZW5zb3IoKXt0aGlzLnRlbnNvcldyYXBwZXImJih0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcih0aGlzLnRlbnNvcldyYXBwZXIpLHRoaXMud3JhcHBlcj12b2lkIDApfWFzeW5jIGVuc3VyZVRlbnNvcih0LHIsbixvKXtpZih0aGlzLndyYXBwZXIpe2lmKHRoaXMud3JhcHBlci5jYW5SZXVzZVRlbnNvcih0LHIsbikpcmV0dXJuIHRoaXMud3JhcHBlci50ZW5zb3I7aWYobyl7aWYodGhpcy53cmFwcGVyLmJ5dGVMZW5ndGghPT10YyhyLG4pKXRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb3B5IGRhdGEgdG8gdGVuc29yIHdpdGggZGlmZmVyZW50IHNpemUuXCIpO3RoaXMuYWN0aXZlVXBsb2FkPW5ldyBVaW50OEFycmF5KGF3YWl0IHRoaXMud3JhcHBlci5yZWFkKCkpfXRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMud3JhcHBlcil9bGV0IGk9dHlwZW9mIE1MVGVuc29yVXNhZ2U+XCJ1XCI/dm9pZCAwOk1MVGVuc29yVXNhZ2UuUkVBRHxNTFRlbnNvclVzYWdlLldSSVRFO3JldHVybiB0aGlzLndyYXBwZXI9YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmdldENhY2hlZFRlbnNvcihyLG4saSwhMCwhMCksbyYmdGhpcy5hY3RpdmVVcGxvYWQmJih0aGlzLndyYXBwZXIud3JpdGUodGhpcy5hY3RpdmVVcGxvYWQpLHRoaXMuYWN0aXZlVXBsb2FkPXZvaWQgMCksdGhpcy53cmFwcGVyLnRlbnNvcn11cGxvYWQodCl7aWYodGhpcy53cmFwcGVyKWlmKHQuYnl0ZUxlbmd0aD09PXRoaXMud3JhcHBlci5ieXRlTGVuZ3RoKXt0aGlzLndyYXBwZXIud3JpdGUodCk7cmV0dXJufWVsc2Ugc2UoXCJ2ZXJib3NlXCIsKCk9PlwiRGF0YSBzaXplIGRvZXMgbm90IG1hdGNoIHRlbnNvciBzaXplLiBSZWxlYXNpbmcgdGVuc29yLlwiKSx0aGlzLnJlbGVhc2VUZW5zb3IoKTt0aGlzLmFjdGl2ZVVwbG9hZD90aGlzLmFjdGl2ZVVwbG9hZC5zZXQodCk6dGhpcy5hY3RpdmVVcGxvYWQ9bmV3IFVpbnQ4QXJyYXkodCl9YXN5bmMgZG93bmxvYWQodCl7aWYodGhpcy5hY3RpdmVVcGxvYWQpaWYodCl7dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP25ldyBVaW50OEFycmF5KHQpLnNldCh0aGlzLmFjdGl2ZVVwbG9hZCk6bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkuc2V0KHRoaXMuYWN0aXZlVXBsb2FkKTtyZXR1cm59ZWxzZSByZXR1cm4gdGhpcy5hY3RpdmVVcGxvYWQuYnVmZmVyO2lmKCF0aGlzLndyYXBwZXIpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGhhcyBub3QgYmVlbiBjcmVhdGVkLlwiKTtyZXR1cm4gdD90aGlzLndyYXBwZXIucmVhZCh0KTp0aGlzLndyYXBwZXIucmVhZCgpfX0sQW89Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQ9bmV3IE1hcDt0aGlzLmZyZWVUZW5zb3JzPVtdO3RoaXMuZXh0ZXJuYWxUZW5zb3JzPW5ldyBTZXR9cmVzZXJ2ZVRlbnNvcklkKCl7bGV0IHQ9ZWMoKTtyZXR1cm4gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KHQsbmV3IGFuKHRoaXMpKSx0fXJlbGVhc2VUZW5zb3JJZCh0KXtsZXQgcj10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodCk7ciYmKHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmRlbGV0ZSh0KSxyLnRlbnNvcldyYXBwZXImJnRoaXMucmVsZWFzZVRlbnNvcihyLnRlbnNvcldyYXBwZXIpKX1hc3luYyBlbnN1cmVUZW5zb3IodCxyLG4sbyl7c2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIFRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yIHt0ZW5zb3JJZDogJHt0fSwgZGF0YVR5cGU6ICR7cn0sIHNoYXBlOiAke259LCBjb3B5T2xkOiAke299fWApO2xldCBpPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighaSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtyZXR1cm4gaS5lbnN1cmVUZW5zb3IodGhpcy5iYWNrZW5kLmN1cnJlbnRDb250ZXh0LHIsbixvKX11cGxvYWQodCxyKXtsZXQgbj10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIG5vdCBmb3VuZC5cIik7bi51cGxvYWQocil9YXN5bmMgZG93bmxvYWQodCxyKXtzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gVGVuc29yTWFuYWdlci5kb3dubG9hZCB7dGVuc29ySWQ6ICR7dH0sIGRzdEJ1ZmZlcjogJHtyPy5ieXRlTGVuZ3RofX1gKTtsZXQgbj10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIG5vdCBmb3VuZC5cIik7cmV0dXJuIG4uZG93bmxvYWQocil9cmVsZWFzZVRlbnNvcnNGb3JTZXNzaW9uKHQpe2ZvcihsZXQgciBvZiB0aGlzLmZyZWVUZW5zb3JzKXIuc2Vzc2lvbklkPT09dCYmci5kZXN0cm95KCk7dGhpcy5mcmVlVGVuc29ycz10aGlzLmZyZWVUZW5zb3JzLmZpbHRlcihyPT5yLnNlc3Npb25JZCE9PXQpfXJlZ2lzdGVyVGVuc29yKHQscixuLG8pe2xldCBpPWVjKCksYT1uZXcgb24oe3Nlc3Npb25JZDp0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCxjb250ZXh0OnQsdGVuc29yOnIsZGF0YVR5cGU6bixzaGFwZTpvfSk7cmV0dXJuIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldChpLG5ldyBhbih0aGlzLGEpKSx0aGlzLmV4dGVybmFsVGVuc29ycy5hZGQoYSksaX1hc3luYyBnZXRDYWNoZWRUZW5zb3IodCxyLG4sbyxpKXtsZXQgYT10aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCxkPXRoaXMuYmFja2VuZC5jdXJyZW50Q29udGV4dDtmb3IobGV0W3AsbV1vZiB0aGlzLmZyZWVUZW5zb3JzLmVudHJpZXMoKSlpZihtLmNhblJldXNlVGVuc29yKGQsdCxyKSl7c2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIFJldXNpbmcgdGVuc29yIHtkYXRhVHlwZTogJHt0fSwgc2hhcGU6ICR7cn19YCk7bGV0IHU9dGhpcy5mcmVlVGVuc29ycy5zcGxpY2UocCwxKVswXTtyZXR1cm4gdS5zZXNzaW9uSWQ9YSx1fXNlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBNTENvbnRleHQuY3JlYXRlVGVuc29yIHtkYXRhVHlwZTogJHt0fSwgc2hhcGU6ICR7cn19YCk7bGV0IGw9YXdhaXQgZC5jcmVhdGVUZW5zb3Ioe2RhdGFUeXBlOnQsc2hhcGU6cixkaW1lbnNpb25zOnIsdXNhZ2U6bix3cml0YWJsZTpvLHJlYWRhYmxlOml9KTtyZXR1cm4gbmV3IG9uKHtzZXNzaW9uSWQ6YSxjb250ZXh0OmQsdGVuc29yOmwsZGF0YVR5cGU6dCxzaGFwZTpyfSl9cmVsZWFzZVRlbnNvcih0KXt0aGlzLmV4dGVybmFsVGVuc29ycy5oYXModCkmJnRoaXMuZXh0ZXJuYWxUZW5zb3JzLmRlbGV0ZSh0KSx0aGlzLmZyZWVUZW5zb3JzLnB1c2godCl9fSxyYz0oLi4uZSk9Pm5ldyBBbyguLi5lKX0pO3ZhciBvYyxwZyxzbixpYz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SigpO2d0KCk7WG4oKTtuYygpO2V0KCk7b2M9bmV3IE1hcChbWzEsXCJmbG9hdDMyXCJdLFsxMCxcImZsb2F0MTZcIl0sWzYsXCJpbnQzMlwiXSxbMTIsXCJ1aW50MzJcIl0sWzcsXCJpbnQ2NFwiXSxbMTMsXCJ1aW50NjRcIl0sWzIyLFwiaW50NFwiXSxbMjEsXCJ1aW50NFwiXSxbMyxcImludDhcIl0sWzIsXCJ1aW50OFwiXSxbOSxcInVpbnQ4XCJdXSkscGc9KGUsdCk9PntpZihlPT09dClyZXR1cm4hMDtpZihlPT09dm9pZCAwfHx0PT09dm9pZCAwKXJldHVybiExO2xldCByPU9iamVjdC5rZXlzKGUpLnNvcnQoKSxuPU9iamVjdC5rZXlzKHQpLnNvcnQoKTtyZXR1cm4gci5sZW5ndGg9PT1uLmxlbmd0aCYmci5ldmVyeSgobyxpKT0+bz09PW5baV0mJmVbb109PT10W29dKX0sc249Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy50ZW5zb3JNYW5hZ2VyPXJjKHRoaXMpO3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQ9bmV3IE1hcDt0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dD1uZXcgTWFwO3RoaXMubWxDb250ZXh0Q2FjaGU9W107TXIodC5sb2dMZXZlbCwhIXQuZGVidWcpfWdldCBjdXJyZW50U2Vzc2lvbklkKCl7aWYodGhpcy5hY3RpdmVTZXNzaW9uSWQ9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiTm8gYWN0aXZlIHNlc3Npb25cIik7cmV0dXJuIHRoaXMuYWN0aXZlU2Vzc2lvbklkfW9uUnVuU3RhcnQodCl7dGhpcy5hY3RpdmVTZXNzaW9uSWQ9dH1hc3luYyBjcmVhdGVNTENvbnRleHQodCl7aWYodCBpbnN0YW5jZW9mIEdQVURldmljZSl7bGV0IG49dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5ncHVEZXZpY2U9PT10KTtpZihuIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbl0ubWxDb250ZXh0O3tsZXQgbz1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh0KTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHtncHVEZXZpY2U6dCxtbENvbnRleHQ6b30pLG99fWVsc2UgaWYodD09PXZvaWQgMCl7bGV0IG49dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5vcHRpb25zPT09dm9pZCAwJiZvLmdwdURldmljZT09PXZvaWQgMCk7aWYobiE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW25dLm1sQ29udGV4dDt7bGV0IG89YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoKTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHttbENvbnRleHQ6b30pLG99fWxldCByPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KG49PnBnKG4ub3B0aW9ucyx0KSk7aWYociE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW3JdLm1sQ29udGV4dDt7bGV0IG49YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQodCk7cmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7b3B0aW9uczp0LG1sQ29udGV4dDpufSksbn19Z2V0IGN1cnJlbnRDb250ZXh0KCl7bGV0IHQ9dGhpcy5nZXRNTENvbnRleHQodGhpcy5jdXJyZW50U2Vzc2lvbklkKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoYE5vIE1MQ29udGV4dCBmb3VuZCBmb3Igc2Vzc2lvbiAke3RoaXMuY3VycmVudFNlc3Npb25JZH1gKTtyZXR1cm4gdH1yZWdpc3Rlck1MQ29udGV4dCh0LHIpe3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuc2V0KHQscik7bGV0IG49dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KHIpO258fChuPW5ldyBTZXQsdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuc2V0KHIsbikpLG4uYWRkKHQpfW9uUmVsZWFzZVNlc3Npb24odCl7bGV0IHI9dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQodCk7aWYoIXIpcmV0dXJuO3RoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCksdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5kZWxldGUodCk7bGV0IG49dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KHIpO2lmKG4uZGVsZXRlKHQpLG4uc2l6ZT09PTApe3RoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmRlbGV0ZShyKTtsZXQgbz10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChpPT5pLm1sQ29udGV4dD09PXIpO28hPT0tMSYmdGhpcy5tbENvbnRleHRDYWNoZS5zcGxpY2UobywxKX19Z2V0TUxDb250ZXh0KHQpe3JldHVybiB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldCh0KX1yZXNlcnZlVGVuc29ySWQoKXtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpfXJlbGVhc2VUZW5zb3JJZCh0KXtzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVsZWFzZVRlbnNvcklkIHt0ZW5zb3JJZDogJHt0fX1gKSx0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHQpfWFzeW5jIGVuc3VyZVRlbnNvcih0LHIsbixvKXtsZXQgaT1vYy5nZXQocik7aWYoIWkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtyfWApO3JldHVybiB0aGlzLnRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yKHQsaSxuLG8pfXVwbG9hZFRlbnNvcih0LHIpe2lmKCFUZSgpLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcil0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gdXBsb2FkIHRvIGEgTUxUZW5zb3Igd2hpbGUgc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yIGlzIGZhbHNlXCIpO3NlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSB1cGxvYWRUZW5zb3Ige3RlbnNvcklkOiAke3R9LCBkYXRhOiAke3IuYnl0ZUxlbmd0aH19YCksdGhpcy50ZW5zb3JNYW5hZ2VyLnVwbG9hZCh0LHIpfWFzeW5jIGRvd25sb2FkVGVuc29yKHQscil7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5kb3dubG9hZCh0LHIpfWNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcih0LHIpe3JldHVybiBhc3luYygpPT57bGV0IG49YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHQpO3JldHVybiBScihuLHIpfX1yZWdpc3Rlck1MVGVuc29yKHQscixuKXtsZXQgbz1vYy5nZXQocik7aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtyfWApO2xldCBpPXRoaXMudGVuc29yTWFuYWdlci5yZWdpc3RlclRlbnNvcih0aGlzLmN1cnJlbnRDb250ZXh0LHQsbyxuKTtyZXR1cm4gc2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxUZW5zb3Ige3RlbnNvcjogJHt0fSwgZGF0YVR5cGU6ICR7b30sIGRpbWVuc2lvbnM6ICR7bn19IC0+IHt0ZW5zb3JJZDogJHtpfX1gKSxpfXJlZ2lzdGVyTUxDb25zdGFudCh0LHIsbixvLGksYSl7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiRXh0ZXJuYWwgbW91bnRlZCBmaWxlcyBhcmUgbm90IGF2YWlsYWJsZS5cIik7bGV0IGQ9dDt0LnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGQ9dC5zdWJzdHJpbmcoMikpO2xldCBsPWEuZ2V0KGQpO2lmKCFsKXRocm93IG5ldyBFcnJvcihgRmlsZSB3aXRoIG5hbWUgJHtkfSBub3QgZm91bmQgaW4gcHJlbG9hZGVkIGZpbGVzLmApO2lmKHIrbj5sLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT3V0IG9mIGJvdW5kczogZGF0YSBvZmZzZXQgYW5kIGxlbmd0aCBleGNlZWQgdGhlIGV4dGVybmFsIGZpbGUgZGF0YSBzaXplLlwiKTtsZXQgcD1sLnNsaWNlKHIscituKS5idWZmZXIsbTtzd2l0Y2goaS5kYXRhVHlwZSl7Y2FzZVwiZmxvYXQzMlwiOm09bmV3IEZsb2F0MzJBcnJheShwKTticmVhaztjYXNlXCJmbG9hdDE2XCI6bT1uZXcgVWludDE2QXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50MzJcIjptPW5ldyBJbnQzMkFycmF5KHApO2JyZWFrO2Nhc2VcInVpbnQzMlwiOm09bmV3IFVpbnQzMkFycmF5KHApO2JyZWFrO2Nhc2VcImludDY0XCI6bT1uZXcgQmlnSW50NjRBcnJheShwKTticmVhaztjYXNlXCJ1aW50NjRcIjptPW5ldyBCaWdVaW50NjRBcnJheShwKTticmVhaztjYXNlXCJpbnQ4XCI6bT1uZXcgSW50OEFycmF5KHApO2JyZWFrO2Nhc2VcImludDRcIjpjYXNlXCJ1aW50NFwiOmNhc2VcInVpbnQ4XCI6bT1uZXcgVWludDhBcnJheShwKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2kuZGF0YVR5cGV9IGluIGNyZWF0aW5nIFdlYk5OIENvbnN0YW50IGZyb20gZXh0ZXJuYWwgZGF0YS5gKX1yZXR1cm4gc2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxDb25zdGFudCB7ZGF0YVR5cGU6ICR7aS5kYXRhVHlwZX0sIHNoYXBlOiAke2kuc2hhcGV9fX1gKSxvLmNvbnN0YW50KGksbSl9Zmx1c2goKXt9fX0pO3ZhciBhYz17fTtIdChhYyx7aW5pdDooKT0+bWd9KTt2YXIgdHIsa28sbWcsc2M9VSgoKT0+e1widXNlIHN0cmljdFwiO0ooKTtKbCgpO2V0KCk7bmUoKTtpYygpO3RyPWNsYXNzIGV7Y29uc3RydWN0b3IodCxyLG4sbyl7dGhpcy5tb2R1bGU9dDt0aGlzLmRhdGFUeXBlPXI7dGhpcy5kYXRhPW47dGhpcy5kaW1zPW99Z2V0RmxvYXQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9ay5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBGbG9hdDMyQXJyYXk6bmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEJpZ0ludDY0QXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1rLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEJpZ0ludDY0QXJyYXk6bmV3IEJpZ0ludDY0QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRJbnQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTYpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9ay5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBJbnQzMkFycmF5Om5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0VWludDE2QXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09MTAmJnRoaXMuZGF0YVR5cGUhPT00KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PWsuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgVWludDE2QXJyYXk6bmV3IFVpbnQxNkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9cmVzaGFwZSh0KXtpZihrLnNpemUodCkhPT1rLnNpemUodGhpcy5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5ldyBzaGFwZVwiKTtyZXR1cm4gbmV3IGUodGhpcy5tb2R1bGUsdGhpcy5kYXRhVHlwZSx0aGlzLmRhdGEsdCl9fSxrbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIsbil7dGhpcy5tb2R1bGU9dDt0aGlzLmJhY2tlbmQ9cjt0aGlzLmN1c3RvbURhdGFPZmZzZXQ9MDt0aGlzLmN1c3RvbURhdGFTaXplPTA7dGhpcy5hZGFwdGVySW5mbz1yLmFkYXB0ZXJJbmZvLHRoaXMuZGV2aWNlSW5mbz1yLmRldmljZUluZm87bGV0IG89dC5QVFJfU0laRSxpPW4vdC5QVFJfU0laRSxhPW89PT00P1wiaTMyXCI6XCJpNjRcIjt0aGlzLm9wS2VybmVsQ29udGV4dD1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSk7bGV0IGQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpO3RoaXMub3V0cHV0Q291bnQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpLHRoaXMuY3VzdG9tRGF0YU9mZnNldD1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxcIipcIikpLHRoaXMuY3VzdG9tRGF0YVNpemU9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpO2xldCBsPVtdO2ZvcihsZXQgcD0wO3A8ZDtwKyspe2xldCBtPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKSx1PU51bWJlcih0LmdldFZhbHVlKG8qaSsrLFwiKlwiKSksaD1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSksXz1bXTtmb3IobGV0IHk9MDt5PGg7eSsrKV8ucHVzaChOdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSkpO2wucHVzaChuZXcgdHIodCxtLHUsXykpfXRoaXMuaW5wdXRzPWx9Z2V0IGtlcm5lbEN1c3RvbURhdGEoKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxDdXN0b21EYXRhfWdldCBjdXN0b21EYXRhQnVmZmVyKCl7cmV0dXJuIHRoaXMubW9kdWxlLkhFQVBVOC5zdWJhcnJheSh0aGlzLmN1c3RvbURhdGFPZmZzZXQsdGhpcy5jdXN0b21EYXRhT2Zmc2V0K3RoaXMuY3VzdG9tRGF0YVNpemUpfWNvbXB1dGUodCxyKXtsZXQgbj1yPy5pbnB1dHM/Lm1hcChkPT50eXBlb2YgZD09XCJudW1iZXJcIj90aGlzLmlucHV0c1tkXTpkKT8/dGhpcy5pbnB1dHMsbz1yPy5vdXRwdXRzPz9bXSxpPShkLGwscCk9Pm5ldyB0cih0aGlzLm1vZHVsZSxsLHRoaXMub3V0cHV0KGQscCkscCksYT0oZCxsKT0+e2xldCBwPUF0KGQsbCk7aWYoIXApdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZH1gKTtsZXQgbT1wPjA/dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShwKS5pZDowO3JldHVybiBuZXcgdHIodGhpcy5tb2R1bGUsZCxtLGwpfTtyZXR1cm4gdGhpcy5iYWNrZW5kLnJ1bih0LG4sbyxpLGEsdGhpcy5vdXRwdXRDb3VudCl9b3V0cHV0KHQscil7bGV0IG49dGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7dHJ5e2xldCBvPXRoaXMubW9kdWxlLlBUUl9TSVpFLGk9bz09PTQ/XCJpMzJcIjpcImk2NFwiLGE9dGhpcy5tb2R1bGUuc3RhY2tBbGxvYygoMStyLmxlbmd0aCkqbyk7dGhpcy5tb2R1bGUuc2V0VmFsdWUoYSxyLmxlbmd0aCxpKTtmb3IobGV0IGQ9MDtkPHIubGVuZ3RoO2QrKyl0aGlzLm1vZHVsZS5zZXRWYWx1ZShhK28qKGQrMSkscltkXSxpKTtyZXR1cm4gdGhpcy5tb2R1bGUuX0pzZXBPdXRwdXQodGhpcy5vcEtlcm5lbENvbnRleHQsdCxhKX1jYXRjaChvKXt0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBrZXJuZWwncyBvdXRwdXRbJHt0fV0gd2l0aCBkaW1zIFske3J9XS4gSWYgeW91IGFyZSBydW5uaW5nIHdpdGggcHJlLWFsbG9jYXRlZCBvdXRwdXQsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIG91dHB1dCB0eXBlL2RpbXMgYXJlIGNvcnJlY3QuIEVycm9yOiAke299YCl9ZmluYWxseXt0aGlzLm1vZHVsZS5zdGFja1Jlc3RvcmUobil9fX0sbWc9YXN5bmMoZSx0LHIsbik9PntsZXQgbz10LmpzZXBJbml0O2lmKCFvKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIEpTRVAuIFRoZSBXZWJBc3NlbWJseSBtb2R1bGUgaXMgbm90IGJ1aWx0IHdpdGggSlNFUCBzdXBwb3J0LlwiKTtpZihlPT09XCJ3ZWJncHVcIil7bGV0IGk9bmV3IG5uO2F3YWl0IGkuaW5pdGlhbGl6ZShyLG4pLG8oXCJ3ZWJncHVcIixbaSxhPT5pLmFsbG9jKE51bWJlcihhKSksYT0+aS5mcmVlKGEpLChhLGQsbCxwPSExKT0+e2lmKHApc2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvR3B1OiBzcmM9JHtOdW1iZXIoYSl9LCBkc3Q9JHtOdW1iZXIoZCl9LCBzaXplPSR7TnVtYmVyKGwpfWApLGkubWVtY3B5KE51bWJlcihhKSxOdW1iZXIoZCkpO2Vsc2V7c2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUNwdVRvR3B1OiBkYXRhT2Zmc2V0PSR7TnVtYmVyKGEpfSwgZ3B1RGF0YUlkPSR7TnVtYmVyKGQpfSwgc2l6ZT0ke051bWJlcihsKX1gKTtsZXQgbT10LkhFQVBVOC5zdWJhcnJheShOdW1iZXIoYT4+PjApLE51bWJlcihhPj4+MCkrTnVtYmVyKGwpKTtpLnVwbG9hZChOdW1iZXIoZCksbSl9fSxhc3luYyhhLGQsbCk9PntzZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9DcHU6IGdwdURhdGFJZD0ke2F9LCBkYXRhT2Zmc2V0PSR7ZH0sIHNpemU9JHtsfWApLGF3YWl0IGkuZG93bmxvYWQoTnVtYmVyKGEpLCgpPT50LkhFQVBVOC5zdWJhcnJheShOdW1iZXIoZCk+Pj4wLE51bWJlcihkK2wpPj4+MCkpfSwoYSxkLGwpPT5pLmNyZWF0ZUtlcm5lbChhLE51bWJlcihkKSxsLHQuVVRGOFRvU3RyaW5nKHQuX0pzZXBHZXROb2RlTmFtZShOdW1iZXIoZCkpKSksYT0+aS5yZWxlYXNlS2VybmVsKGEpLChhLGQsbCxwKT0+e3NlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcFJ1bjogc2Vzc2lvbkhhbmRsZT0ke2x9LCBrZXJuZWw9JHthfSwgY29udGV4dERhdGFPZmZzZXQ9JHtkfWApO2xldCBtPW5ldyBrbyh0LGksTnVtYmVyKGQpKTtyZXR1cm4gaS5jb21wdXRlS2VybmVsKE51bWJlcihhKSxtLHApfSwoKT0+aS5jYXB0dXJlQmVnaW4oKSwoKT0+aS5jYXB0dXJlRW5kKCksKCk9PmkucmVwbGF5KCldKX1lbHNle2xldCBpPW5ldyBzbihyKTtvKFwid2Vibm5cIixbaSwoKT0+aS5yZXNlcnZlVGVuc29ySWQoKSxhPT5pLnJlbGVhc2VUZW5zb3JJZChhKSxhc3luYyhhLGQsbCxwKT0+aS5lbnN1cmVUZW5zb3IoYSxkLGwscCksKGEsZCk9PntpLnVwbG9hZFRlbnNvcihhLGQpfSxhc3luYyhhLGQpPT5pLmRvd25sb2FkVGVuc29yKGEsZCldKX19fSk7dmFyIGZnLFNyLFRyLHp0LGhnLHF0LElyLENyLHVjLEFyLGtyLEVyLEZuPVUoKCk9PntcInVzZSBzdHJpY3RcIjtHYSgpO0ZhKCk7SigpO2d0KCk7enIoKTtRbigpO2ZnPShlLHQpPT57VGUoKS5fT3J0SW5pdChlLHQpIT09MCYmY2UoXCJDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKX0sU3I9YXN5bmMgZT0+e2ZnKGUud2FzbS5udW1UaHJlYWRzLFl0KGUubG9nTGV2ZWwpKX0sVHI9YXN5bmMoZSx0KT0+e3tsZXQgcj0oc2MoKSxncihhYykpLmluaXQ7aWYodD09PVwid2ViZ3B1XCIpe2lmKHR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCJ8fCFuYXZpZ2F0b3IuZ3B1KXRocm93IG5ldyBFcnJvcihcIldlYkdQVSBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnRcIik7bGV0IG49ZS53ZWJncHUuYWRhcHRlcjtpZihuKXtpZih0eXBlb2Ygbi5saW1pdHMhPVwib2JqZWN0XCJ8fHR5cGVvZiBuLmZlYXR1cmVzIT1cIm9iamVjdFwifHx0eXBlb2Ygbi5yZXF1ZXN0RGV2aWNlIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHUFUgYWRhcHRlciBzZXQgaW4gYGVudi53ZWJncHUuYWRhcHRlcmAuIEl0IG11c3QgYmUgYSBHUFVBZGFwdGVyIG9iamVjdC5cIil9ZWxzZXtsZXQgbz1lLndlYmdwdS5wb3dlclByZWZlcmVuY2U7aWYobyE9PXZvaWQgMCYmbyE9PVwibG93LXBvd2VyXCImJm8hPT1cImhpZ2gtcGVyZm9ybWFuY2VcIil0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcG93ZXJQcmVmZXJlbmNlIHNldHRpbmc6IFwiJHtvfVwiYCk7bGV0IGk9ZS53ZWJncHUuZm9yY2VGYWxsYmFja0FkYXB0ZXI7aWYoaSE9PXZvaWQgMCYmdHlwZW9mIGkhPVwiYm9vbGVhblwiKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb3JjZUZhbGxiYWNrQWRhcHRlciBzZXR0aW5nOiBcIiR7aX1cImApO2lmKG49YXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcih7cG93ZXJQcmVmZXJlbmNlOm8sZm9yY2VGYWxsYmFja0FkYXB0ZXI6aX0pLCFuKXRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLicpfWF3YWl0IHIoXCJ3ZWJncHVcIixUZSgpLGUsbil9aWYodD09PVwid2Vibm5cIil7aWYodHlwZW9mIG5hdmlnYXRvcj5cInVcInx8IW5hdmlnYXRvci5tbCl0aHJvdyBuZXcgRXJyb3IoXCJXZWJOTiBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnRcIik7YXdhaXQgcihcIndlYm5uXCIsVGUoKSxlKX19fSx6dD1uZXcgTWFwLGhnPWU9PntsZXQgdD1UZSgpLHI9dC5zdGFja1NhdmUoKTt0cnl7bGV0IG49dC5QVFJfU0laRSxvPXQuc3RhY2tBbGxvYygyKm4pO3QuX09ydEdldElucHV0T3V0cHV0Q291bnQoZSxvLG8rbikhPT0wJiZjZShcIkNhbid0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC5cIik7bGV0IGE9bj09PTQ/XCJpMzJcIjpcImk2NFwiO3JldHVybltOdW1iZXIodC5nZXRWYWx1ZShvLGEpKSxOdW1iZXIodC5nZXRWYWx1ZShvK24sYSkpXX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKHIpfX0scXQ9ZT0+e2xldCB0PVRlKCkscj10Ll9tYWxsb2MoZS5ieXRlTGVuZ3RoKTtpZihyPT09MCl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7ZS5ieXRlTGVuZ3RofS5gKTtyZXR1cm4gdC5IRUFQVTguc2V0KGUsciksW3IsZS5ieXRlTGVuZ3RoXX0sSXI9YXN5bmMoZSx0KT0+e2xldCByLG4sbz1UZSgpO0FycmF5LmlzQXJyYXkoZSk/W3Isbl09ZTplLmJ1ZmZlcj09PW8uSEVBUFU4LmJ1ZmZlcj9bcixuXT1bZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aF06W3Isbl09cXQoZSk7bGV0IGk9MCxhPTAsZD0wLGw9W10scD1bXSxtPVtdO3RyeXtpZihbYSxsXT1IYSh0KSx0Py5leHRlcm5hbERhdGEmJm8ubW91bnRFeHRlcm5hbERhdGEpe2xldCB2PVtdO2ZvcihsZXQgUyBvZiB0LmV4dGVybmFsRGF0YSl7bGV0IFQ9dHlwZW9mIFM9PVwic3RyaW5nXCI/UzpTLnBhdGg7di5wdXNoKFp0KHR5cGVvZiBTPT1cInN0cmluZ1wiP1M6Uy5kYXRhKS50aGVuKEE9PntvLm1vdW50RXh0ZXJuYWxEYXRhKFQsQSl9KSl9YXdhaXQgUHJvbWlzZS5hbGwodil9Zm9yKGxldCB2IG9mIHQ/LmV4ZWN1dGlvblByb3ZpZGVycz8/W10paWYoKHR5cGVvZiB2PT1cInN0cmluZ1wiP3Y6di5uYW1lKT09PVwid2Vibm5cIil7aWYoby5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3I9ITEsdHlwZW9mIHYhPVwic3RyaW5nXCIpe2xldCBUPXYsQT1UPy5jb250ZXh0LEM9VD8uZ3B1RGV2aWNlLFA9VD8uZGV2aWNlVHlwZSxEPVQ/LnBvd2VyUHJlZmVyZW5jZTtBP28uY3VycmVudENvbnRleHQ9QTpDP28uY3VycmVudENvbnRleHQ9YXdhaXQgby5qc2VwQ3JlYXRlTUxDb250ZXh0KEMpOm8uY3VycmVudENvbnRleHQ9YXdhaXQgby5qc2VwQ3JlYXRlTUxDb250ZXh0KHtkZXZpY2VUeXBlOlAscG93ZXJQcmVmZXJlbmNlOkR9KX1lbHNlIG8uY3VycmVudENvbnRleHQ9YXdhaXQgby5qc2VwQ3JlYXRlTUxDb250ZXh0KCk7YnJlYWt9aT1hd2FpdCBvLl9PcnRDcmVhdGVTZXNzaW9uKHIsbixhKSxpPT09MCYmY2UoXCJDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLlwiKSxvLmpzZXBPbkNyZWF0ZVNlc3Npb24/LigpLG8uY3VycmVudENvbnRleHQmJihvLmpzZXBSZWdpc3Rlck1MQ29udGV4dChpLG8uY3VycmVudENvbnRleHQpLG8uY3VycmVudENvbnRleHQ9dm9pZCAwLG8uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yPSEwKTtsZXRbdSxoXT1oZyhpKSxfPSEhdD8uZW5hYmxlR3JhcGhDYXB0dXJlLHk9W10sZz1bXSx4PVtdO2ZvcihsZXQgdj0wO3Y8dTt2Kyspe2xldCBTPW8uX09ydEdldElucHV0TmFtZShpLHYpO1M9PT0wJiZjZShcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lLlwiKSxwLnB1c2goUykseS5wdXNoKG8uVVRGOFRvU3RyaW5nKFMpKX1mb3IobGV0IHY9MDt2PGg7disrKXtsZXQgUz1vLl9PcnRHZXRPdXRwdXROYW1lKGksdik7Uz09PTAmJmNlKFwiQ2FuJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLlwiKSxtLnB1c2goUyk7bGV0IFQ9by5VVEY4VG9TdHJpbmcoUyk7Zy5wdXNoKFQpO3tpZihfJiZ0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09PXZvaWQgMCl7eC5wdXNoKFwiZ3B1LWJ1ZmZlclwiKTtjb250aW51ZX1sZXQgQT10eXBlb2YgdD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb249PVwic3RyaW5nXCI/dC5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbjp0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW1RdPz9cImNwdVwiO2lmKEEhPT1cImNwdVwiJiZBIT09XCJjcHUtcGlubmVkXCImJkEhPT1cImdwdS1idWZmZXJcIiYmQSE9PVwibWwtdGVuc29yXCIpdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7QX0uYCk7aWYoXyYmQSE9PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke0F9LiBPbmx5ICdncHUtYnVmZmVyJyBsb2NhdGlvbiBpcyBzdXBwb3J0ZWQgd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTt4LnB1c2goQSl9fWxldCAkPW51bGw7cmV0dXJuIHguc29tZSh2PT52PT09XCJncHUtYnVmZmVyXCJ8fHY9PT1cIm1sLXRlbnNvclwiKSYmKGQ9by5fT3J0Q3JlYXRlQmluZGluZyhpKSxkPT09MCYmY2UoXCJDYW4ndCBjcmVhdGUgSU8gYmluZGluZy5cIiksJD17aGFuZGxlOmQsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOngsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDp4Lm1hcCh2PT5abih2KSl9KSx6dC5zZXQoaSxbaSxwLG0sJCxfLCExXSksW2kseSxnXX1jYXRjaCh1KXt0aHJvdyBwLmZvckVhY2goaD0+by5fT3J0RnJlZShoKSksbS5mb3JFYWNoKGg9Pm8uX09ydEZyZWUoaCkpLGQhPT0wJiZvLl9PcnRSZWxlYXNlQmluZGluZyhkKSE9PTAmJmNlKFwiQ2FuJ3QgcmVsZWFzZSBJTyBiaW5kaW5nLlwiKSxpIT09MCYmby5fT3J0UmVsZWFzZVNlc3Npb24oaSkhPT0wJiZjZShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIiksdX1maW5hbGx5e28uX2ZyZWUociksYSE9PTAmJm8uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhhKSE9PTAmJmNlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpLGwuZm9yRWFjaCh1PT5vLl9mcmVlKHUpKSxvLnVubW91bnRFeHRlcm5hbERhdGE/LigpfX0sQ3I9ZT0+e2xldCB0PVRlKCkscj16dC5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVsZWFzZSBzZXNzaW9uLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXRbbixvLGksYSxkXT1yO2EmJihkJiZ0Ll9PcnRDbGVhckJvdW5kT3V0cHV0cyhhLmhhbmRsZSkhPT0wJiZjZShcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpLHQuX09ydFJlbGVhc2VCaW5kaW5nKGEuaGFuZGxlKSE9PTAmJmNlKFwiQ2FuJ3QgcmVsZWFzZSBJTyBiaW5kaW5nLlwiKSksdC5qc2VwT25SZWxlYXNlU2Vzc2lvbj8uKGUpLG8uZm9yRWFjaChsPT50Ll9PcnRGcmVlKGwpKSxpLmZvckVhY2gobD0+dC5fT3J0RnJlZShsKSksdC5fT3J0UmVsZWFzZVNlc3Npb24obikhPT0wJiZjZShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIiksenQuZGVsZXRlKGUpfSx1Yz0oZSx0LHIsbixvLGk9ITEpPT57aWYoIWUpe3QucHVzaCgwKTtyZXR1cm59bGV0IGE9VGUoKSxkPWEuUFRSX1NJWkUsbD1lWzBdLHA9ZVsxXSxtPWVbM10sdSxoO2lmKGw9PT1cInN0cmluZ1wiJiYobT09PVwiZ3B1LWJ1ZmZlclwifHxtPT09XCJtbC10ZW5zb3JcIikpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7aWYoaSYmbSE9PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihgRXh0ZXJuYWwgYnVmZmVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIGlucHV0L291dHB1dCBpbmRleCAke299IHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCk7aWYobT09PVwiZ3B1LWJ1ZmZlclwiKXtsZXQgZz1lWzJdLmdwdUJ1ZmZlcjtoPUF0KGp0KGwpLHApO2xldCB4PWEuanNlcFJlZ2lzdGVyQnVmZmVyO2lmKCF4KXRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7dT14KG4sbyxnLGgpfWVsc2UgaWYobT09PVwibWwtdGVuc29yXCIpe2xldCBnPWVbMl0ubWxUZW5zb3I7aD1BdChqdChsKSxwKTtsZXQgeD1hLmpzZXBSZWdpc3Rlck1MVGVuc29yO2lmKCF4KXRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO3U9eChnLGp0KGwpLHApfWVsc2V7bGV0IGc9ZVsyXTtpZihBcnJheS5pc0FycmF5KGcpKXtoPWQqZy5sZW5ndGgsdT1hLl9tYWxsb2MoaCksci5wdXNoKHUpO2ZvcihsZXQgeD0wO3g8Zy5sZW5ndGg7eCsrKXtpZih0eXBlb2YgZ1t4XSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke3h9IGlzIG5vdCBhIHN0cmluZ2ApO2Euc2V0VmFsdWUodSt4KmQsa2UoZ1t4XSxyKSxcIipcIil9fWVsc2UgaD1nLmJ5dGVMZW5ndGgsdT1hLl9tYWxsb2MoaCksci5wdXNoKHUpLGEuSEVBUFU4LnNldChuZXcgVWludDhBcnJheShnLmJ1ZmZlcixnLmJ5dGVPZmZzZXQsaCksdSl9bGV0IF89YS5zdGFja1NhdmUoKSx5PWEuc3RhY2tBbGxvYyg0KnAubGVuZ3RoKTt0cnl7cC5mb3JFYWNoKCh4LCQpPT5hLnNldFZhbHVlKHkrJCpkLHgsZD09PTQ/XCJpMzJcIjpcImk2NFwiKSk7bGV0IGc9YS5fT3J0Q3JlYXRlVGVuc29yKGp0KGwpLHUsaCx5LHAubGVuZ3RoLFpuKG0pKTtnPT09MCYmY2UoYENhbid0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke259LCBpbmRleD0ke299LmApLHQucHVzaChnKX1maW5hbGx5e2Euc3RhY2tSZXN0b3JlKF8pfX0sQXI9YXN5bmMoZSx0LHIsbixvLGkpPT57bGV0IGE9VGUoKSxkPWEuUFRSX1NJWkUsbD16dC5nZXQoZSk7aWYoIWwpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcnVuIGluZmVyZW5jZS4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0IHA9bFswXSxtPWxbMV0sdT1sWzJdLGg9bFszXSxfPWxbNF0seT1sWzVdLGc9dC5sZW5ndGgseD1uLmxlbmd0aCwkPTAsdj1bXSxTPVtdLFQ9W10sQT1bXSxDPWEuc3RhY2tTYXZlKCksUD1hLnN0YWNrQWxsb2MoZypkKSxEPWEuc3RhY2tBbGxvYyhnKmQpLFI9YS5zdGFja0FsbG9jKHgqZCksSD1hLnN0YWNrQWxsb2MoeCpkKTt0cnl7YS5qc2VwT25SdW5TdGFydD8uKHApLFskLHZdPUxhKGkpO2ZvcihsZXQgVj0wO1Y8ZztWKyspdWMocltWXSxTLEEsZSx0W1ZdLF8pO2ZvcihsZXQgVj0wO1Y8eDtWKyspdWMob1tWXSxULEEsZSxnK25bVl0sXyk7Zm9yKGxldCBWPTA7VjxnO1YrKylhLnNldFZhbHVlKFArVipkLFNbVl0sXCIqXCIpLGEuc2V0VmFsdWUoRCtWKmQsbVt0W1ZdXSxcIipcIik7Zm9yKGxldCBWPTA7Vjx4O1YrKylhLnNldFZhbHVlKFIrVipkLFRbVl0sXCIqXCIpLGEuc2V0VmFsdWUoSCtWKmQsdVtuW1ZdXSxcIipcIik7aWYoaCYmIXkpe2xldHtoYW5kbGU6VixvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6SyxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOndlfT1oO2lmKG0ubGVuZ3RoIT09Zyl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IGNvdW50IGZyb20gZmVlZHMgKCR7Z30pIGlzIGV4cGVjdGVkIHRvIGJlIGFsd2F5cyBlcXVhbCB0byBtb2RlbCdzIGlucHV0IGNvdW50ICgke20ubGVuZ3RofSkuYCk7Zm9yKGxldCBqPTA7ajxnO2orKyl7bGV0IFE9dFtqXTthd2FpdCBhLl9PcnRCaW5kSW5wdXQoVixtW1FdLFNbal0pIT09MCYmY2UoYENhbid0IGJpbmQgaW5wdXRbJHtqfV0gZm9yIHNlc3Npb249JHtlfS5gKX1mb3IobGV0IGo9MDtqPHg7aisrKXtsZXQgUT1uW2pdO29bal0/LlszXT9hLl9PcnRCaW5kT3V0cHV0KFYsdVtRXSxUW2pdLDApIT09MCYmY2UoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtqfV0gZm9yIHNlc3Npb249JHtlfS5gKTphLl9PcnRCaW5kT3V0cHV0KFYsdVtRXSwwLHdlW1FdKSE9PTAmJmNlKGBDYW4ndCBiaW5kIG91dHB1dFske2p9XSB0byAke0tbal19IGZvciBzZXNzaW9uPSR7ZX0uYCl9enQuc2V0KGUsW3AsbSx1LGgsXywhMF0pfWxldCBMO2g/TD1hd2FpdCBhLl9PcnRSdW5XaXRoQmluZGluZyhwLGguaGFuZGxlLHgsUiwkKTpMPWF3YWl0IGEuX09ydFJ1bihwLEQsUCxnLEgseCxSLCQpLEwhPT0wJiZjZShcImZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLlwiKTtsZXQgcmU9W107Zm9yKGxldCBWPTA7Vjx4O1YrKyl7bGV0IEs9TnVtYmVyKGEuZ2V0VmFsdWUoUitWKmQsXCIqXCIpKTtpZihLPT09VFtWXSl7cmUucHVzaChvW1ZdKTtjb250aW51ZX1sZXQgd2U9YS5zdGFja1NhdmUoKSxqPWEuc3RhY2tBbGxvYyg0KmQpLFE9ITEsaWUsdGU9MDt0cnl7YS5fT3J0R2V0VGVuc29yRGF0YShLLGosaitkLGorMipkLGorMypkKSE9PTAmJmNlKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7Vn0uYCk7bGV0IE9lPWQ9PT00P1wiaTMyXCI6XCJpNjRcIix2ZT1OdW1iZXIoYS5nZXRWYWx1ZShqLE9lKSk7dGU9YS5nZXRWYWx1ZShqK2QsXCIqXCIpO2xldCBkZT1hLmdldFZhbHVlKGorZCoyLFwiKlwiKSxXPU51bWJlcihhLmdldFZhbHVlKGorZCozLE9lKSksWT1bXTtmb3IobGV0IHBlPTA7cGU8VztwZSsrKVkucHVzaChOdW1iZXIoYS5nZXRWYWx1ZShkZStwZSpkLE9lKSkpO2EuX09ydEZyZWUoZGUpIT09MCYmY2UoXCJDYW4ndCBmcmVlIG1lbW9yeSBmb3IgdGVuc29yIGRpbXMuXCIpO2xldCBoZT1ZLnJlZHVjZSgocGUsSWUpPT5wZSpJZSwxKTtpZT1idCh2ZSk7bGV0IERlPWg/Lm91dHB1dFByZWZlcnJlZExvY2F0aW9uc1tuW1ZdXTtpZihpZT09PVwic3RyaW5nXCIpe2lmKERlPT09XCJncHUtYnVmZmVyXCJ8fERlPT09XCJtbC10ZW5zb3JcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtsZXQgcGU9W107Zm9yKGxldCBJZT0wO0llPGhlO0llKyspe2xldCBIZT1hLmdldFZhbHVlKHRlK0llKmQsXCIqXCIpLG1uPWEuZ2V0VmFsdWUodGUrKEllKzEpKmQsXCIqXCIpLHd0PUllPT09aGUtMT92b2lkIDA6bW4tSGU7cGUucHVzaChhLlVURjhUb1N0cmluZyhIZSx3dCkpfXJlLnB1c2goW2llLFkscGUsXCJjcHVcIl0pfWVsc2UgaWYoRGU9PT1cImdwdS1idWZmZXJcIiYmaGU+MCl7bGV0IHBlPWEuanNlcEdldEJ1ZmZlcjtpZighcGUpdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO2xldCBJZT1wZSh0ZSksSGU9QXQodmUsaGUpO2lmKEhlPT09dm9pZCAwfHwhRHIoaWUpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2llfWApO1E9ITAscmUucHVzaChbaWUsWSx7Z3B1QnVmZmVyOkllLGRvd25sb2FkOmEuanNlcENyZWF0ZURvd25sb2FkZXIoSWUsSGUsaWUpLGRpc3Bvc2U6KCk9PnthLl9PcnRSZWxlYXNlVGVuc29yKEspIT09MCYmY2UoXCJDYW4ndCByZWxlYXNlIHRlbnNvci5cIil9fSxcImdwdS1idWZmZXJcIl0pfWVsc2UgaWYoRGU9PT1cIm1sLXRlbnNvclwiJiZoZT4wKXtsZXQgcGU9YS5qc2VwRW5zdXJlVGVuc29yO2lmKCFwZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO2lmKEF0KHZlLGhlKT09PXZvaWQgMHx8IUJyKGllKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtpZX1gKTtsZXQgSGU9YXdhaXQgcGUodGUsdmUsWSwhMSk7UT0hMCxyZS5wdXNoKFtpZSxZLHttbFRlbnNvcjpIZSxkb3dubG9hZDphLmpzZXBDcmVhdGVNTFRlbnNvckRvd25sb2FkZXIodGUsaWUpLGRpc3Bvc2U6KCk9PnthLmpzZXBSZWxlYXNlVGVuc29ySWQodGUpLGEuX09ydFJlbGVhc2VUZW5zb3IoSyl9fSxcIm1sLXRlbnNvclwiXSl9ZWxzZXtsZXQgcGU9T3IoaWUpLEllPW5ldyBwZShoZSk7bmV3IFVpbnQ4QXJyYXkoSWUuYnVmZmVyLEllLmJ5dGVPZmZzZXQsSWUuYnl0ZUxlbmd0aCkuc2V0KGEuSEVBUFU4LnN1YmFycmF5KHRlLHRlK0llLmJ5dGVMZW5ndGgpKSxyZS5wdXNoKFtpZSxZLEllLFwiY3B1XCJdKX19ZmluYWxseXthLnN0YWNrUmVzdG9yZSh3ZSksaWU9PT1cInN0cmluZ1wiJiZ0ZSYmYS5fZnJlZSh0ZSksUXx8YS5fT3J0UmVsZWFzZVRlbnNvcihLKX19cmV0dXJuIGgmJiFfJiYoYS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoaC5oYW5kbGUpIT09MCYmY2UoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKSx6dC5zZXQoZSxbcCxtLHUsaCxfLCExXSkpLHJlfWZpbmFsbHl7YS5zdGFja1Jlc3RvcmUoQyksUy5mb3JFYWNoKEw9PmEuX09ydFJlbGVhc2VUZW5zb3IoTCkpLFQuZm9yRWFjaChMPT5hLl9PcnRSZWxlYXNlVGVuc29yKEwpKSxBLmZvckVhY2goTD0+YS5fZnJlZShMKSksJCE9PTAmJmEuX09ydFJlbGVhc2VSdW5PcHRpb25zKCQpLHYuZm9yRWFjaChMPT5hLl9mcmVlKEwpKX19LGtyPWU9PntsZXQgdD1UZSgpLHI9enQuZ2V0KGUpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtsZXQgbj1yWzBdLG89dC5fT3J0RW5kUHJvZmlsaW5nKG4pO289PT0wJiZjZShcIkNhbid0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZS5cIiksdC5fT3J0RnJlZShvKX0sRXI9ZT0+e2xldCB0PVtdO2ZvcihsZXQgciBvZiBlKXtsZXQgbj1yWzJdOyFBcnJheS5pc0FycmF5KG4pJiZcImJ1ZmZlclwiaW4gbiYmdC5wdXNoKG4uYnVmZmVyKX1yZXR1cm4gdH19KTt2YXIgT3QsR2UscnIsZG4sbG4sdW4sRW8sUG8sV3QsTHQsYmcsZGMsbGMsY2MscGMsbWMsZmMsaGMsem89VSgoKT0+e1widXNlIHN0cmljdFwiO0xlKCk7Rm4oKTtndCgpOyRyKCk7T3Q9KCk9PiEhX2Uud2FzbS5wcm94eSYmdHlwZW9mIGRvY3VtZW50PFwidVwiLHJyPSExLGRuPSExLGxuPSExLFBvPW5ldyBNYXAsV3Q9KGUsdCk9PntsZXQgcj1Qby5nZXQoZSk7cj9yLnB1c2godCk6UG8uc2V0KGUsW3RdKX0sTHQ9KCk9PntpZihycnx8IWRufHxsbnx8IUdlKXRocm93IG5ldyBFcnJvcihcIndvcmtlciBub3QgcmVhZHlcIil9LGJnPWU9Pntzd2l0Y2goZS5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOnJyPSExLGUuZGF0YS5lcnI/KGxuPSEwLEVvWzFdKGUuZGF0YS5lcnIpKTooZG49ITAsRW9bMF0oKSksdW4mJihVUkwucmV2b2tlT2JqZWN0VVJMKHVuKSx1bj12b2lkIDApO2JyZWFrO2Nhc2VcImluaXQtZXBcIjpjYXNlXCJjb3B5LWZyb21cIjpjYXNlXCJjcmVhdGVcIjpjYXNlXCJyZWxlYXNlXCI6Y2FzZVwicnVuXCI6Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOntsZXQgdD1Qby5nZXQoZS5kYXRhLnR5cGUpO2UuZGF0YS5lcnI/dC5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOnQuc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVha31kZWZhdWx0On19LGRjPWFzeW5jKCk9PntpZighZG4pe2lmKHJyKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0V2FzbSgpJyBkZXRlY3RlZC5cIik7aWYobG4pdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtpZihycj0hMCxPdCgpKXJldHVybiBuZXcgUHJvbWlzZSgoZSx0KT0+e0dlPy50ZXJtaW5hdGUoKSxOYSgpLnRoZW4oKFtyLG5dKT0+e3RyeXtHZT1uLEdlLm9uZXJyb3I9aT0+dChpKSxHZS5vbm1lc3NhZ2U9YmcsRW89W2UsdF07bGV0IG89e3R5cGU6XCJpbml0LXdhc21cIixpbjpfZX07IW8uaW4ud2FzbS53YXNtUGF0aHMmJihyfHxpbXBvcnQubWV0YS51cmw/LnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSkmJihvLmluLndhc20ud2FzbVBhdGhzPXt3YXNtOm5ldyBVUkwoXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiLGltcG9ydC5tZXRhLnVybCkuaHJlZn0pLEdlLnBvc3RNZXNzYWdlKG8pLHVuPXJ9Y2F0Y2gobyl7dChvKX19LHQpfSk7dHJ5e2F3YWl0IHhyKF9lLndhc20pLGF3YWl0IFNyKF9lKSxkbj0hMH1jYXRjaChlKXt0aHJvdyBsbj0hMCxlfWZpbmFsbHl7cnI9ITF9fX0sbGM9YXN5bmMgZT0+e2lmKE90KCkpcmV0dXJuIEx0KCksbmV3IFByb21pc2UoKHQscik9PntXdChcImluaXQtZXBcIixbdCxyXSk7bGV0IG49e3R5cGU6XCJpbml0LWVwXCIsaW46e2VwTmFtZTplLGVudjpfZX19O0dlLnBvc3RNZXNzYWdlKG4pfSk7YXdhaXQgVHIoX2UsZSl9LGNjPWFzeW5jIGU9Pk90KCk/KEx0KCksbmV3IFByb21pc2UoKHQscik9PntXdChcImNvcHktZnJvbVwiLFt0LHJdKTtsZXQgbj17dHlwZTpcImNvcHktZnJvbVwiLGluOntidWZmZXI6ZX19O0dlLnBvc3RNZXNzYWdlKG4sW2UuYnVmZmVyXSl9KSk6cXQoZSkscGM9YXN5bmMoZSx0KT0+e2lmKE90KCkpe2lmKHQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uKXRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO3JldHVybiBMdCgpLG5ldyBQcm9taXNlKChyLG4pPT57V3QoXCJjcmVhdGVcIixbcixuXSk7bGV0IG89e3R5cGU6XCJjcmVhdGVcIixpbjp7bW9kZWw6ZSxvcHRpb25zOnsuLi50fX19LGk9W107ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJmkucHVzaChlLmJ1ZmZlciksR2UucG9zdE1lc3NhZ2UobyxpKX0pfWVsc2UgcmV0dXJuIElyKGUsdCl9LG1jPWFzeW5jIGU9PntpZihPdCgpKXJldHVybiBMdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57V3QoXCJyZWxlYXNlXCIsW3Qscl0pO2xldCBuPXt0eXBlOlwicmVsZWFzZVwiLGluOmV9O0dlLnBvc3RNZXNzYWdlKG4pfSk7Q3IoZSl9LGZjPWFzeW5jKGUsdCxyLG4sbyxpKT0+e2lmKE90KCkpe2lmKHIuc29tZShhPT5hWzNdIT09XCJjcHVcIikpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS5cIik7aWYoby5zb21lKGE9PmEpKXRocm93IG5ldyBFcnJvcihcInByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS5cIik7cmV0dXJuIEx0KCksbmV3IFByb21pc2UoKGEsZCk9PntXdChcInJ1blwiLFthLGRdKTtsZXQgbD1yLHA9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOmUsaW5wdXRJbmRpY2VzOnQsaW5wdXRzOmwsb3V0cHV0SW5kaWNlczpuLG9wdGlvbnM6aX19O0dlLnBvc3RNZXNzYWdlKHAsRXIobCkpfSl9ZWxzZSByZXR1cm4gQXIoZSx0LHIsbixvLGkpfSxoYz1hc3luYyBlPT57aWYoT3QoKSlyZXR1cm4gTHQoKSxuZXcgUHJvbWlzZSgodCxyKT0+e1d0KFwiZW5kLXByb2ZpbGluZ1wiLFt0LHJdKTtsZXQgbj17dHlwZTpcImVuZC1wcm9maWxpbmdcIixpbjplfTtHZS5wb3N0TWVzc2FnZShuKX0pO2tyKGUpfX0pO3ZhciBnYyx5ZyxjbixiYz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7TGUoKTt6bygpO0ooKTt2cigpO1FuKCk7Z2M9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuW2UudHlwZSxlLmRpbXMsZS5kYXRhLFwiY3B1XCJdO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7Z3B1QnVmZmVyOmUuZ3B1QnVmZmVyfSxcImdwdS1idWZmZXJcIl07Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse21sVGVuc29yOmUubWxUZW5zb3J9LFwibWwtdGVuc29yXCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZS5sb2NhdGlvbn0gZm9yICR7dCgpfWApfX0seWc9ZT0+e3N3aXRjaChlWzNdKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IEZlKGVbMF0sZVsyXSxlWzFdKTtjYXNlXCJncHUtYnVmZmVyXCI6e2xldCB0PWVbMF07aWYoIURyKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO2xldHtncHVCdWZmZXI6cixkb3dubG9hZDpuLGRpc3Bvc2U6b309ZVsyXTtyZXR1cm4gRmUuZnJvbUdwdUJ1ZmZlcihyLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpuLGRpc3Bvc2U6b30pfWNhc2VcIm1sLXRlbnNvclwiOntsZXQgdD1lWzBdO2lmKCFCcih0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIE1MVGVuc29yIHRlbnNvcmApO2xldHttbFRlbnNvcjpyLGRvd25sb2FkOm4sZGlzcG9zZTpvfT1lWzJdO3JldHVybiBGZS5mcm9tTUxUZW5zb3Iocix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6bixkaXNwb3NlOm99KX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2VbM119YCl9fSxjbj1jbGFzc3thc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KXtyZXR1cm4gY2MoYXdhaXQgWnQodCkpfWFzeW5jIGxvYWRNb2RlbCh0LHIpe05lKCk7bGV0IG47dHlwZW9mIHQ9PVwic3RyaW5nXCI/ITE/bj1hd2FpdCBadCh0KTpuPWF3YWl0IHRoaXMuZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkodCk6bj10LFt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQgcGMobixyKSxCZSgpfWFzeW5jIGRpc3Bvc2UoKXtyZXR1cm4gbWModGhpcy5zZXNzaW9uSWQpfWFzeW5jIHJ1bih0LHIsbil7TmUoKTtsZXQgbz1bXSxpPVtdO09iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goaD0+e2xldCBfPWhbMF0seT1oWzFdLGc9dGhpcy5pbnB1dE5hbWVzLmluZGV4T2YoXyk7aWYoZz09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHtffSdgKTtvLnB1c2goeSksaS5wdXNoKGcpfSk7bGV0IGE9W10sZD1bXTtPYmplY3QuZW50cmllcyhyKS5mb3JFYWNoKGg9PntsZXQgXz1oWzBdLHk9aFsxXSxnPXRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihfKTtpZihnPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG91dHB1dCAnJHtffSdgKTthLnB1c2goeSksZC5wdXNoKGcpfSk7bGV0IGw9by5tYXAoKGgsXyk9PmdjKGgsKCk9PmBpbnB1dCBcIiR7dGhpcy5pbnB1dE5hbWVzW2lbX11dfVwiYCkpLHA9YS5tYXAoKGgsXyk9Pmg/Z2MoaCwoKT0+YG91dHB1dCBcIiR7dGhpcy5vdXRwdXROYW1lc1tkW19dXX1cImApOm51bGwpLG09YXdhaXQgZmModGhpcy5zZXNzaW9uSWQsaSxsLGQscCxuKSx1PXt9O2ZvcihsZXQgaD0wO2g8bS5sZW5ndGg7aCsrKXVbdGhpcy5vdXRwdXROYW1lc1tkW2hdXV09YVtoXT8/eWcobVtoXSk7cmV0dXJuIEJlKCksdX1zdGFydFByb2ZpbGluZygpe31lbmRQcm9maWxpbmcoKXtoYyh0aGlzLnNlc3Npb25JZCl9fX0pO3ZhciBfYz17fTtIdChfYyx7T25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQ6KCk9PnBuLGluaXRpYWxpemVGbGFnczooKT0+eWMsd2FzbUJhY2tlbmQ6KCk9Pl9nfSk7dmFyIHljLHBuLF9nLHdjPVUoKCk9PntcInVzZSBzdHJpY3RcIjtMZSgpO3pvKCk7YmMoKTt5Yz0oKT0+e2lmKCh0eXBlb2YgX2Uud2FzbS5pbml0VGltZW91dCE9XCJudW1iZXJcInx8X2Uud2FzbS5pbml0VGltZW91dDwwKSYmKF9lLndhc20uaW5pdFRpbWVvdXQ9MCksX2Uud2FzbS5zaW1kPT09ITEmJmNvbnNvbGUud2FybignRGVwcmVjYXRlZCBwcm9wZXJ0eSBcImVudi53YXNtLnNpbWRcIiBpcyBzZXQgdG8gZmFsc2UuIG5vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyksdHlwZW9mIF9lLndhc20ucHJveHkhPVwiYm9vbGVhblwiJiYoX2Uud2FzbS5wcm94eT0hMSksdHlwZW9mIF9lLndhc20udHJhY2UhPVwiYm9vbGVhblwiJiYoX2Uud2FzbS50cmFjZT0hMSksdHlwZW9mIF9lLndhc20ubnVtVGhyZWFkcyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoX2Uud2FzbS5udW1UaHJlYWRzKXx8X2Uud2FzbS5udW1UaHJlYWRzPD0wKWlmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKV9lLndhc20ubnVtVGhyZWFkcz0xO2Vsc2V7bGV0IGU9dHlwZW9mIG5hdmlnYXRvcj5cInVcIj9VbihcIm5vZGU6b3NcIikuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtfZS53YXNtLm51bVRocmVhZHM9TWF0aC5taW4oNCxNYXRoLmNlaWwoKGV8fDEpLzIpKX19LHBuPWNsYXNze2FzeW5jIGluaXQodCl7eWMoKSxhd2FpdCBkYygpLGF3YWl0IGxjKHQpfWFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHQscil7bGV0IG49bmV3IGNuO3JldHVybiBhd2FpdCBuLmxvYWRNb2RlbCh0LHIpLFByb21pc2UucmVzb2x2ZShuKX19LF9nPW5ldyBwbn0pO0xlKCk7TGUoKTtMZSgpO3ZhciBJYT1cIjEuMjEuMC1kZXYuMjAyNTAyMDYtZDk4MWIxNTNkM1wiO3ZhciAkMT1Ibjt7bGV0IGU9KHdjKCksZ3IoX2MpKS53YXNtQmFja2VuZDtUdChcIndlYmdwdVwiLGUsNSksVHQoXCJ3ZWJublwiLGUsNSksVHQoXCJjcHVcIixlLDEwKSxUdChcIndhc21cIixlLDEwKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoX2UudmVyc2lvbnMsXCJ3ZWJcIix7dmFsdWU6SWEsZW51bWVyYWJsZTohMH0pO2V4cG9ydHtGcCBhcyBJbmZlcmVuY2VTZXNzaW9uLF9yIGFzIFRSQUNFLE5lIGFzIFRSQUNFX0ZVTkNfQkVHSU4sQmUgYXMgVFJBQ0VfRlVOQ19FTkQsRmUgYXMgVGVuc29yLCQxIGFzIGRlZmF1bHQsX2UgYXMgZW52LFR0IGFzIHJlZ2lzdGVyQmFja2VuZH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/onnxruntime-web@1.21.0-dev.20250206-d981b153d3/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?eb77\n");

/***/ })

};
;